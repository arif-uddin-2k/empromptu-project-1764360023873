var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var __accessCheck = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateGet = (obj, member, getter) => {
  __accessCheck(obj, member, "read from private field");
  return getter ? getter.call(obj) : member.get(obj);
};
var __privateAdd = (obj, member, value) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};
var __privateSet = (obj, member, value, setter) => {
  __accessCheck(obj, member, "write to private field");
  setter ? setter.call(obj, value) : member.set(obj, value);
  return value;
};
var __privateWrapper = (obj, member, setter, getter) => ({
  set _(value) {
    __privateSet(obj, member, value, setter);
  },
  get _() {
    return __privateGet(obj, member, getter);
  }
});
var __privateMethod = (obj, member, method) => {
  __accessCheck(obj, member, "access private method");
  return method;
};
var _a2;
import { r as reactExports, a as reactDomExports, R as React, g as getAugmentedNamespace, c as commonjsGlobal, b as React$1 } from "./vendor-27b9359a.js";
(/* @__PURE__ */ __name(function polyfill() {
  const relList = document.createElement("link").relList;
  if (relList && relList.supports && relList.supports("modulepreload")) {
    return;
  }
  for (const link of document.querySelectorAll('link[rel="modulepreload"]')) {
    processPreload(link);
  }
  new MutationObserver((mutations) => {
    for (const mutation of mutations) {
      if (mutation.type !== "childList") {
        continue;
      }
      for (const node of mutation.addedNodes) {
        if (node.tagName === "LINK" && node.rel === "modulepreload")
          processPreload(node);
      }
    }
  }).observe(document, { childList: true, subtree: true });
  function getFetchOpts(link) {
    const fetchOpts = {};
    if (link.integrity)
      fetchOpts.integrity = link.integrity;
    if (link.referrerPolicy)
      fetchOpts.referrerPolicy = link.referrerPolicy;
    if (link.crossOrigin === "use-credentials")
      fetchOpts.credentials = "include";
    else if (link.crossOrigin === "anonymous")
      fetchOpts.credentials = "omit";
    else
      fetchOpts.credentials = "same-origin";
    return fetchOpts;
  }
  __name(getFetchOpts, "getFetchOpts");
  function processPreload(link) {
    if (link.ep)
      return;
    link.ep = true;
    const fetchOpts = getFetchOpts(link);
    fetch(link.href, fetchOpts);
  }
  __name(processPreload, "processPreload");
}, "polyfill"))();
var jsxRuntime = { exports: {} };
var reactJsxRuntime_production_min = {};
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var f$1 = reactExports, k$1 = Symbol.for("react.element"), l$1 = Symbol.for("react.fragment"), m$2 = Object.prototype.hasOwnProperty, n$1 = f$1.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, p$1 = { key: true, ref: true, __self: true, __source: true };
function q$1(c2, a2, g2) {
  var b2, d2 = {}, e = null, h3 = null;
  void 0 !== g2 && (e = "" + g2);
  void 0 !== a2.key && (e = "" + a2.key);
  void 0 !== a2.ref && (h3 = a2.ref);
  for (b2 in a2)
    m$2.call(a2, b2) && !p$1.hasOwnProperty(b2) && (d2[b2] = a2[b2]);
  if (c2 && c2.defaultProps)
    for (b2 in a2 = c2.defaultProps, a2)
      void 0 === d2[b2] && (d2[b2] = a2[b2]);
  return { $$typeof: k$1, type: c2, key: e, ref: h3, props: d2, _owner: n$1.current };
}
__name(q$1, "q$1");
reactJsxRuntime_production_min.Fragment = l$1;
reactJsxRuntime_production_min.jsx = q$1;
reactJsxRuntime_production_min.jsxs = q$1;
{
  jsxRuntime.exports = reactJsxRuntime_production_min;
}
var jsxRuntimeExports = jsxRuntime.exports;
var client = {};
var m$1 = reactDomExports;
{
  client.createRoot = m$1.createRoot;
  client.hydrateRoot = m$1.hydrateRoot;
}
/**
 * @remix-run/router v1.23.1
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
function _extends$2() {
  _extends$2 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$2.apply(this, arguments);
}
__name(_extends$2, "_extends$2");
var Action;
(function(Action2) {
  Action2["Pop"] = "POP";
  Action2["Push"] = "PUSH";
  Action2["Replace"] = "REPLACE";
})(Action || (Action = {}));
const PopStateEventType = "popstate";
function createBrowserHistory(options) {
  if (options === void 0) {
    options = {};
  }
  function createBrowserLocation(window2, globalHistory) {
    let {
      pathname,
      search,
      hash
    } = window2.location;
    return createLocation(
      "",
      {
        pathname,
        search,
        hash
      },
      // state defaults to `null` because `window.history.state` does
      globalHistory.state && globalHistory.state.usr || null,
      globalHistory.state && globalHistory.state.key || "default"
    );
  }
  __name(createBrowserLocation, "createBrowserLocation");
  function createBrowserHref(window2, to2) {
    return typeof to2 === "string" ? to2 : createPath(to2);
  }
  __name(createBrowserHref, "createBrowserHref");
  return getUrlBasedHistory(createBrowserLocation, createBrowserHref, null, options);
}
__name(createBrowserHistory, "createBrowserHistory");
function invariant(value, message) {
  if (value === false || value === null || typeof value === "undefined") {
    throw new Error(message);
  }
}
__name(invariant, "invariant");
function warning(cond, message) {
  if (!cond) {
    if (typeof console !== "undefined")
      console.warn(message);
    try {
      throw new Error(message);
    } catch (e) {
    }
  }
}
__name(warning, "warning");
function createKey() {
  return Math.random().toString(36).substr(2, 8);
}
__name(createKey, "createKey");
function getHistoryState(location2, index2) {
  return {
    usr: location2.state,
    key: location2.key,
    idx: index2
  };
}
__name(getHistoryState, "getHistoryState");
function createLocation(current, to2, state, key) {
  if (state === void 0) {
    state = null;
  }
  let location2 = _extends$2({
    pathname: typeof current === "string" ? current : current.pathname,
    search: "",
    hash: ""
  }, typeof to2 === "string" ? parsePath(to2) : to2, {
    state,
    // TODO: This could be cleaned up.  push/replace should probably just take
    // full Locations now and avoid the need to run through this flow at all
    // But that's a pretty big refactor to the current test suite so going to
    // keep as is for the time being and just let any incoming keys take precedence
    key: to2 && to2.key || key || createKey()
  });
  return location2;
}
__name(createLocation, "createLocation");
function createPath(_ref) {
  let {
    pathname = "/",
    search = "",
    hash = ""
  } = _ref;
  if (search && search !== "?")
    pathname += search.charAt(0) === "?" ? search : "?" + search;
  if (hash && hash !== "#")
    pathname += hash.charAt(0) === "#" ? hash : "#" + hash;
  return pathname;
}
__name(createPath, "createPath");
function parsePath(path) {
  let parsedPath = {};
  if (path) {
    let hashIndex = path.indexOf("#");
    if (hashIndex >= 0) {
      parsedPath.hash = path.substr(hashIndex);
      path = path.substr(0, hashIndex);
    }
    let searchIndex = path.indexOf("?");
    if (searchIndex >= 0) {
      parsedPath.search = path.substr(searchIndex);
      path = path.substr(0, searchIndex);
    }
    if (path) {
      parsedPath.pathname = path;
    }
  }
  return parsedPath;
}
__name(parsePath, "parsePath");
function getUrlBasedHistory(getLocation, createHref, validateLocation, options) {
  if (options === void 0) {
    options = {};
  }
  let {
    window: window2 = document.defaultView,
    v5Compat = false
  } = options;
  let globalHistory = window2.history;
  let action = Action.Pop;
  let listener = null;
  let index2 = getIndex();
  if (index2 == null) {
    index2 = 0;
    globalHistory.replaceState(_extends$2({}, globalHistory.state, {
      idx: index2
    }), "");
  }
  function getIndex() {
    let state = globalHistory.state || {
      idx: null
    };
    return state.idx;
  }
  __name(getIndex, "getIndex");
  function handlePop() {
    action = Action.Pop;
    let nextIndex = getIndex();
    let delta = nextIndex == null ? null : nextIndex - index2;
    index2 = nextIndex;
    if (listener) {
      listener({
        action,
        location: history.location,
        delta
      });
    }
  }
  __name(handlePop, "handlePop");
  function push(to2, state) {
    action = Action.Push;
    let location2 = createLocation(history.location, to2, state);
    if (validateLocation)
      validateLocation(location2, to2);
    index2 = getIndex() + 1;
    let historyState = getHistoryState(location2, index2);
    let url = history.createHref(location2);
    try {
      globalHistory.pushState(historyState, "", url);
    } catch (error) {
      if (error instanceof DOMException && error.name === "DataCloneError") {
        throw error;
      }
      window2.location.assign(url);
    }
    if (v5Compat && listener) {
      listener({
        action,
        location: history.location,
        delta: 1
      });
    }
  }
  __name(push, "push");
  function replace(to2, state) {
    action = Action.Replace;
    let location2 = createLocation(history.location, to2, state);
    if (validateLocation)
      validateLocation(location2, to2);
    index2 = getIndex();
    let historyState = getHistoryState(location2, index2);
    let url = history.createHref(location2);
    globalHistory.replaceState(historyState, "", url);
    if (v5Compat && listener) {
      listener({
        action,
        location: history.location,
        delta: 0
      });
    }
  }
  __name(replace, "replace");
  function createURL(to2) {
    let base = window2.location.origin !== "null" ? window2.location.origin : window2.location.href;
    let href = typeof to2 === "string" ? to2 : createPath(to2);
    href = href.replace(/ $/, "%20");
    invariant(base, "No window.location.(origin|href) available to create URL for href: " + href);
    return new URL(href, base);
  }
  __name(createURL, "createURL");
  let history = {
    get action() {
      return action;
    },
    get location() {
      return getLocation(window2, globalHistory);
    },
    listen(fn) {
      if (listener) {
        throw new Error("A history only accepts one active listener");
      }
      window2.addEventListener(PopStateEventType, handlePop);
      listener = fn;
      return () => {
        window2.removeEventListener(PopStateEventType, handlePop);
        listener = null;
      };
    },
    createHref(to2) {
      return createHref(window2, to2);
    },
    createURL,
    encodeLocation(to2) {
      let url = createURL(to2);
      return {
        pathname: url.pathname,
        search: url.search,
        hash: url.hash
      };
    },
    push,
    replace,
    go(n2) {
      return globalHistory.go(n2);
    }
  };
  return history;
}
__name(getUrlBasedHistory, "getUrlBasedHistory");
var ResultType;
(function(ResultType2) {
  ResultType2["data"] = "data";
  ResultType2["deferred"] = "deferred";
  ResultType2["redirect"] = "redirect";
  ResultType2["error"] = "error";
})(ResultType || (ResultType = {}));
function matchRoutes(routes, locationArg, basename) {
  if (basename === void 0) {
    basename = "/";
  }
  return matchRoutesImpl(routes, locationArg, basename, false);
}
__name(matchRoutes, "matchRoutes");
function matchRoutesImpl(routes, locationArg, basename, allowPartial) {
  let location2 = typeof locationArg === "string" ? parsePath(locationArg) : locationArg;
  let pathname = stripBasename(location2.pathname || "/", basename);
  if (pathname == null) {
    return null;
  }
  let branches = flattenRoutes(routes);
  rankRouteBranches(branches);
  let matches = null;
  for (let i2 = 0; matches == null && i2 < branches.length; ++i2) {
    let decoded = decodePath(pathname);
    matches = matchRouteBranch(branches[i2], decoded, allowPartial);
  }
  return matches;
}
__name(matchRoutesImpl, "matchRoutesImpl");
function flattenRoutes(routes, branches, parentsMeta, parentPath) {
  if (branches === void 0) {
    branches = [];
  }
  if (parentsMeta === void 0) {
    parentsMeta = [];
  }
  if (parentPath === void 0) {
    parentPath = "";
  }
  let flattenRoute = /* @__PURE__ */ __name((route, index2, relativePath) => {
    let meta = {
      relativePath: relativePath === void 0 ? route.path || "" : relativePath,
      caseSensitive: route.caseSensitive === true,
      childrenIndex: index2,
      route
    };
    if (meta.relativePath.startsWith("/")) {
      invariant(meta.relativePath.startsWith(parentPath), 'Absolute route path "' + meta.relativePath + '" nested under path ' + ('"' + parentPath + '" is not valid. An absolute child route path ') + "must start with the combined path of all its parent routes.");
      meta.relativePath = meta.relativePath.slice(parentPath.length);
    }
    let path = joinPaths([parentPath, meta.relativePath]);
    let routesMeta = parentsMeta.concat(meta);
    if (route.children && route.children.length > 0) {
      invariant(
        // Our types know better, but runtime JS may not!
        // @ts-expect-error
        route.index !== true,
        "Index routes must not have child routes. Please remove " + ('all child routes from route path "' + path + '".')
      );
      flattenRoutes(route.children, branches, routesMeta, path);
    }
    if (route.path == null && !route.index) {
      return;
    }
    branches.push({
      path,
      score: computeScore(path, route.index),
      routesMeta
    });
  }, "flattenRoute");
  routes.forEach((route, index2) => {
    var _route$path;
    if (route.path === "" || !((_route$path = route.path) != null && _route$path.includes("?"))) {
      flattenRoute(route, index2);
    } else {
      for (let exploded of explodeOptionalSegments(route.path)) {
        flattenRoute(route, index2, exploded);
      }
    }
  });
  return branches;
}
__name(flattenRoutes, "flattenRoutes");
function explodeOptionalSegments(path) {
  let segments = path.split("/");
  if (segments.length === 0)
    return [];
  let [first, ...rest] = segments;
  let isOptional = first.endsWith("?");
  let required = first.replace(/\?$/, "");
  if (rest.length === 0) {
    return isOptional ? [required, ""] : [required];
  }
  let restExploded = explodeOptionalSegments(rest.join("/"));
  let result = [];
  result.push(...restExploded.map((subpath) => subpath === "" ? required : [required, subpath].join("/")));
  if (isOptional) {
    result.push(...restExploded);
  }
  return result.map((exploded) => path.startsWith("/") && exploded === "" ? "/" : exploded);
}
__name(explodeOptionalSegments, "explodeOptionalSegments");
function rankRouteBranches(branches) {
  branches.sort((a2, b2) => a2.score !== b2.score ? b2.score - a2.score : compareIndexes(a2.routesMeta.map((meta) => meta.childrenIndex), b2.routesMeta.map((meta) => meta.childrenIndex)));
}
__name(rankRouteBranches, "rankRouteBranches");
const paramRe = /^:[\w-]+$/;
const dynamicSegmentValue = 3;
const indexRouteValue = 2;
const emptySegmentValue = 1;
const staticSegmentValue = 10;
const splatPenalty = -2;
const isSplat = /* @__PURE__ */ __name((s2) => s2 === "*", "isSplat");
function computeScore(path, index2) {
  let segments = path.split("/");
  let initialScore = segments.length;
  if (segments.some(isSplat)) {
    initialScore += splatPenalty;
  }
  if (index2) {
    initialScore += indexRouteValue;
  }
  return segments.filter((s2) => !isSplat(s2)).reduce((score, segment) => score + (paramRe.test(segment) ? dynamicSegmentValue : segment === "" ? emptySegmentValue : staticSegmentValue), initialScore);
}
__name(computeScore, "computeScore");
function compareIndexes(a2, b2) {
  let siblings = a2.length === b2.length && a2.slice(0, -1).every((n2, i2) => n2 === b2[i2]);
  return siblings ? (
    // If two routes are siblings, we should try to match the earlier sibling
    // first. This allows people to have fine-grained control over the matching
    // behavior by simply putting routes with identical paths in the order they
    // want them tried.
    a2[a2.length - 1] - b2[b2.length - 1]
  ) : (
    // Otherwise, it doesn't really make sense to rank non-siblings by index,
    // so they sort equally.
    0
  );
}
__name(compareIndexes, "compareIndexes");
function matchRouteBranch(branch, pathname, allowPartial) {
  if (allowPartial === void 0) {
    allowPartial = false;
  }
  let {
    routesMeta
  } = branch;
  let matchedParams = {};
  let matchedPathname = "/";
  let matches = [];
  for (let i2 = 0; i2 < routesMeta.length; ++i2) {
    let meta = routesMeta[i2];
    let end = i2 === routesMeta.length - 1;
    let remainingPathname = matchedPathname === "/" ? pathname : pathname.slice(matchedPathname.length) || "/";
    let match = matchPath({
      path: meta.relativePath,
      caseSensitive: meta.caseSensitive,
      end
    }, remainingPathname);
    let route = meta.route;
    if (!match && end && allowPartial && !routesMeta[routesMeta.length - 1].route.index) {
      match = matchPath({
        path: meta.relativePath,
        caseSensitive: meta.caseSensitive,
        end: false
      }, remainingPathname);
    }
    if (!match) {
      return null;
    }
    Object.assign(matchedParams, match.params);
    matches.push({
      // TODO: Can this as be avoided?
      params: matchedParams,
      pathname: joinPaths([matchedPathname, match.pathname]),
      pathnameBase: normalizePathname(joinPaths([matchedPathname, match.pathnameBase])),
      route
    });
    if (match.pathnameBase !== "/") {
      matchedPathname = joinPaths([matchedPathname, match.pathnameBase]);
    }
  }
  return matches;
}
__name(matchRouteBranch, "matchRouteBranch");
function matchPath(pattern, pathname) {
  if (typeof pattern === "string") {
    pattern = {
      path: pattern,
      caseSensitive: false,
      end: true
    };
  }
  let [matcher, compiledParams] = compilePath(pattern.path, pattern.caseSensitive, pattern.end);
  let match = pathname.match(matcher);
  if (!match)
    return null;
  let matchedPathname = match[0];
  let pathnameBase = matchedPathname.replace(/(.)\/+$/, "$1");
  let captureGroups = match.slice(1);
  let params = compiledParams.reduce((memo, _ref, index2) => {
    let {
      paramName,
      isOptional
    } = _ref;
    if (paramName === "*") {
      let splatValue = captureGroups[index2] || "";
      pathnameBase = matchedPathname.slice(0, matchedPathname.length - splatValue.length).replace(/(.)\/+$/, "$1");
    }
    const value = captureGroups[index2];
    if (isOptional && !value) {
      memo[paramName] = void 0;
    } else {
      memo[paramName] = (value || "").replace(/%2F/g, "/");
    }
    return memo;
  }, {});
  return {
    params,
    pathname: matchedPathname,
    pathnameBase,
    pattern
  };
}
__name(matchPath, "matchPath");
function compilePath(path, caseSensitive, end) {
  if (caseSensitive === void 0) {
    caseSensitive = false;
  }
  if (end === void 0) {
    end = true;
  }
  warning(path === "*" || !path.endsWith("*") || path.endsWith("/*"), 'Route path "' + path + '" will be treated as if it were ' + ('"' + path.replace(/\*$/, "/*") + '" because the `*` character must ') + "always follow a `/` in the pattern. To get rid of this warning, " + ('please change the route path to "' + path.replace(/\*$/, "/*") + '".'));
  let params = [];
  let regexpSource = "^" + path.replace(/\/*\*?$/, "").replace(/^\/*/, "/").replace(/[\\.*+^${}|()[\]]/g, "\\$&").replace(/\/:([\w-]+)(\?)?/g, (_2, paramName, isOptional) => {
    params.push({
      paramName,
      isOptional: isOptional != null
    });
    return isOptional ? "/?([^\\/]+)?" : "/([^\\/]+)";
  });
  if (path.endsWith("*")) {
    params.push({
      paramName: "*"
    });
    regexpSource += path === "*" || path === "/*" ? "(.*)$" : "(?:\\/(.+)|\\/*)$";
  } else if (end) {
    regexpSource += "\\/*$";
  } else if (path !== "" && path !== "/") {
    regexpSource += "(?:(?=\\/|$))";
  } else
    ;
  let matcher = new RegExp(regexpSource, caseSensitive ? void 0 : "i");
  return [matcher, params];
}
__name(compilePath, "compilePath");
function decodePath(value) {
  try {
    return value.split("/").map((v2) => decodeURIComponent(v2).replace(/\//g, "%2F")).join("/");
  } catch (error) {
    warning(false, 'The URL path "' + value + '" could not be decoded because it is is a malformed URL segment. This is probably due to a bad percent ' + ("encoding (" + error + ")."));
    return value;
  }
}
__name(decodePath, "decodePath");
function stripBasename(pathname, basename) {
  if (basename === "/")
    return pathname;
  if (!pathname.toLowerCase().startsWith(basename.toLowerCase())) {
    return null;
  }
  let startIndex = basename.endsWith("/") ? basename.length - 1 : basename.length;
  let nextChar = pathname.charAt(startIndex);
  if (nextChar && nextChar !== "/") {
    return null;
  }
  return pathname.slice(startIndex) || "/";
}
__name(stripBasename, "stripBasename");
const ABSOLUTE_URL_REGEX$1 = /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i;
const isAbsoluteUrl = /* @__PURE__ */ __name((url) => ABSOLUTE_URL_REGEX$1.test(url), "isAbsoluteUrl");
function resolvePath(to2, fromPathname) {
  if (fromPathname === void 0) {
    fromPathname = "/";
  }
  let {
    pathname: toPathname,
    search = "",
    hash = ""
  } = typeof to2 === "string" ? parsePath(to2) : to2;
  let pathname;
  if (toPathname) {
    if (isAbsoluteUrl(toPathname)) {
      pathname = toPathname;
    } else {
      if (toPathname.includes("//")) {
        let oldPathname = toPathname;
        toPathname = toPathname.replace(/\/\/+/g, "/");
        warning(false, "Pathnames cannot have embedded double slashes - normalizing " + (oldPathname + " -> " + toPathname));
      }
      if (toPathname.startsWith("/")) {
        pathname = resolvePathname(toPathname.substring(1), "/");
      } else {
        pathname = resolvePathname(toPathname, fromPathname);
      }
    }
  } else {
    pathname = fromPathname;
  }
  return {
    pathname,
    search: normalizeSearch(search),
    hash: normalizeHash(hash)
  };
}
__name(resolvePath, "resolvePath");
function resolvePathname(relativePath, fromPathname) {
  let segments = fromPathname.replace(/\/+$/, "").split("/");
  let relativeSegments = relativePath.split("/");
  relativeSegments.forEach((segment) => {
    if (segment === "..") {
      if (segments.length > 1)
        segments.pop();
    } else if (segment !== ".") {
      segments.push(segment);
    }
  });
  return segments.length > 1 ? segments.join("/") : "/";
}
__name(resolvePathname, "resolvePathname");
function getInvalidPathError(char, field, dest, path) {
  return "Cannot include a '" + char + "' character in a manually specified " + ("`to." + field + "` field [" + JSON.stringify(path) + "].  Please separate it out to the ") + ("`to." + dest + "` field. Alternatively you may provide the full path as ") + 'a string in <Link to="..."> and the router will parse it for you.';
}
__name(getInvalidPathError, "getInvalidPathError");
function getPathContributingMatches(matches) {
  return matches.filter((match, index2) => index2 === 0 || match.route.path && match.route.path.length > 0);
}
__name(getPathContributingMatches, "getPathContributingMatches");
function getResolveToMatches(matches, v7_relativeSplatPath) {
  let pathMatches = getPathContributingMatches(matches);
  if (v7_relativeSplatPath) {
    return pathMatches.map((match, idx) => idx === pathMatches.length - 1 ? match.pathname : match.pathnameBase);
  }
  return pathMatches.map((match) => match.pathnameBase);
}
__name(getResolveToMatches, "getResolveToMatches");
function resolveTo(toArg, routePathnames, locationPathname, isPathRelative) {
  if (isPathRelative === void 0) {
    isPathRelative = false;
  }
  let to2;
  if (typeof toArg === "string") {
    to2 = parsePath(toArg);
  } else {
    to2 = _extends$2({}, toArg);
    invariant(!to2.pathname || !to2.pathname.includes("?"), getInvalidPathError("?", "pathname", "search", to2));
    invariant(!to2.pathname || !to2.pathname.includes("#"), getInvalidPathError("#", "pathname", "hash", to2));
    invariant(!to2.search || !to2.search.includes("#"), getInvalidPathError("#", "search", "hash", to2));
  }
  let isEmptyPath = toArg === "" || to2.pathname === "";
  let toPathname = isEmptyPath ? "/" : to2.pathname;
  let from2;
  if (toPathname == null) {
    from2 = locationPathname;
  } else {
    let routePathnameIndex = routePathnames.length - 1;
    if (!isPathRelative && toPathname.startsWith("..")) {
      let toSegments = toPathname.split("/");
      while (toSegments[0] === "..") {
        toSegments.shift();
        routePathnameIndex -= 1;
      }
      to2.pathname = toSegments.join("/");
    }
    from2 = routePathnameIndex >= 0 ? routePathnames[routePathnameIndex] : "/";
  }
  let path = resolvePath(to2, from2);
  let hasExplicitTrailingSlash = toPathname && toPathname !== "/" && toPathname.endsWith("/");
  let hasCurrentTrailingSlash = (isEmptyPath || toPathname === ".") && locationPathname.endsWith("/");
  if (!path.pathname.endsWith("/") && (hasExplicitTrailingSlash || hasCurrentTrailingSlash)) {
    path.pathname += "/";
  }
  return path;
}
__name(resolveTo, "resolveTo");
const joinPaths = /* @__PURE__ */ __name((paths) => paths.join("/").replace(/\/\/+/g, "/"), "joinPaths");
const normalizePathname = /* @__PURE__ */ __name((pathname) => pathname.replace(/\/+$/, "").replace(/^\/*/, "/"), "normalizePathname");
const normalizeSearch = /* @__PURE__ */ __name((search) => !search || search === "?" ? "" : search.startsWith("?") ? search : "?" + search, "normalizeSearch");
const normalizeHash = /* @__PURE__ */ __name((hash) => !hash || hash === "#" ? "" : hash.startsWith("#") ? hash : "#" + hash, "normalizeHash");
function isRouteErrorResponse(error) {
  return error != null && typeof error.status === "number" && typeof error.statusText === "string" && typeof error.internal === "boolean" && "data" in error;
}
__name(isRouteErrorResponse, "isRouteErrorResponse");
const validMutationMethodsArr = ["post", "put", "patch", "delete"];
new Set(validMutationMethodsArr);
const validRequestMethodsArr = ["get", ...validMutationMethodsArr];
new Set(validRequestMethodsArr);
/**
 * React Router v6.30.2
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
function _extends$1() {
  _extends$1 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$1.apply(this, arguments);
}
__name(_extends$1, "_extends$1");
const DataRouterContext = /* @__PURE__ */ reactExports.createContext(null);
const DataRouterStateContext = /* @__PURE__ */ reactExports.createContext(null);
const NavigationContext = /* @__PURE__ */ reactExports.createContext(null);
const LocationContext = /* @__PURE__ */ reactExports.createContext(null);
const RouteContext = /* @__PURE__ */ reactExports.createContext({
  outlet: null,
  matches: [],
  isDataRoute: false
});
const RouteErrorContext = /* @__PURE__ */ reactExports.createContext(null);
function useHref(to2, _temp) {
  let {
    relative
  } = _temp === void 0 ? {} : _temp;
  !useInRouterContext() ? invariant(false) : void 0;
  let {
    basename,
    navigator: navigator2
  } = reactExports.useContext(NavigationContext);
  let {
    hash,
    pathname,
    search
  } = useResolvedPath(to2, {
    relative
  });
  let joinedPathname = pathname;
  if (basename !== "/") {
    joinedPathname = pathname === "/" ? basename : joinPaths([basename, pathname]);
  }
  return navigator2.createHref({
    pathname: joinedPathname,
    search,
    hash
  });
}
__name(useHref, "useHref");
function useInRouterContext() {
  return reactExports.useContext(LocationContext) != null;
}
__name(useInRouterContext, "useInRouterContext");
function useLocation() {
  !useInRouterContext() ? invariant(false) : void 0;
  return reactExports.useContext(LocationContext).location;
}
__name(useLocation, "useLocation");
function useIsomorphicLayoutEffect(cb) {
  let isStatic = reactExports.useContext(NavigationContext).static;
  if (!isStatic) {
    reactExports.useLayoutEffect(cb);
  }
}
__name(useIsomorphicLayoutEffect, "useIsomorphicLayoutEffect");
function useNavigate() {
  let {
    isDataRoute
  } = reactExports.useContext(RouteContext);
  return isDataRoute ? useNavigateStable() : useNavigateUnstable();
}
__name(useNavigate, "useNavigate");
function useNavigateUnstable() {
  !useInRouterContext() ? invariant(false) : void 0;
  let dataRouterContext = reactExports.useContext(DataRouterContext);
  let {
    basename,
    future,
    navigator: navigator2
  } = reactExports.useContext(NavigationContext);
  let {
    matches
  } = reactExports.useContext(RouteContext);
  let {
    pathname: locationPathname
  } = useLocation();
  let routePathnamesJson = JSON.stringify(getResolveToMatches(matches, future.v7_relativeSplatPath));
  let activeRef = reactExports.useRef(false);
  useIsomorphicLayoutEffect(() => {
    activeRef.current = true;
  });
  let navigate = reactExports.useCallback(function(to2, options) {
    if (options === void 0) {
      options = {};
    }
    if (!activeRef.current)
      return;
    if (typeof to2 === "number") {
      navigator2.go(to2);
      return;
    }
    let path = resolveTo(to2, JSON.parse(routePathnamesJson), locationPathname, options.relative === "path");
    if (dataRouterContext == null && basename !== "/") {
      path.pathname = path.pathname === "/" ? basename : joinPaths([basename, path.pathname]);
    }
    (!!options.replace ? navigator2.replace : navigator2.push)(path, options.state, options);
  }, [basename, navigator2, routePathnamesJson, locationPathname, dataRouterContext]);
  return navigate;
}
__name(useNavigateUnstable, "useNavigateUnstable");
function useResolvedPath(to2, _temp2) {
  let {
    relative
  } = _temp2 === void 0 ? {} : _temp2;
  let {
    future
  } = reactExports.useContext(NavigationContext);
  let {
    matches
  } = reactExports.useContext(RouteContext);
  let {
    pathname: locationPathname
  } = useLocation();
  let routePathnamesJson = JSON.stringify(getResolveToMatches(matches, future.v7_relativeSplatPath));
  return reactExports.useMemo(() => resolveTo(to2, JSON.parse(routePathnamesJson), locationPathname, relative === "path"), [to2, routePathnamesJson, locationPathname, relative]);
}
__name(useResolvedPath, "useResolvedPath");
function useRoutes(routes, locationArg) {
  return useRoutesImpl(routes, locationArg);
}
__name(useRoutes, "useRoutes");
function useRoutesImpl(routes, locationArg, dataRouterState, future) {
  !useInRouterContext() ? invariant(false) : void 0;
  let {
    navigator: navigator2
  } = reactExports.useContext(NavigationContext);
  let {
    matches: parentMatches
  } = reactExports.useContext(RouteContext);
  let routeMatch = parentMatches[parentMatches.length - 1];
  let parentParams = routeMatch ? routeMatch.params : {};
  routeMatch ? routeMatch.pathname : "/";
  let parentPathnameBase = routeMatch ? routeMatch.pathnameBase : "/";
  routeMatch && routeMatch.route;
  let locationFromContext = useLocation();
  let location2;
  if (locationArg) {
    var _parsedLocationArg$pa;
    let parsedLocationArg = typeof locationArg === "string" ? parsePath(locationArg) : locationArg;
    !(parentPathnameBase === "/" || ((_parsedLocationArg$pa = parsedLocationArg.pathname) == null ? void 0 : _parsedLocationArg$pa.startsWith(parentPathnameBase))) ? invariant(false) : void 0;
    location2 = parsedLocationArg;
  } else {
    location2 = locationFromContext;
  }
  let pathname = location2.pathname || "/";
  let remainingPathname = pathname;
  if (parentPathnameBase !== "/") {
    let parentSegments = parentPathnameBase.replace(/^\//, "").split("/");
    let segments = pathname.replace(/^\//, "").split("/");
    remainingPathname = "/" + segments.slice(parentSegments.length).join("/");
  }
  let matches = matchRoutes(routes, {
    pathname: remainingPathname
  });
  let renderedMatches = _renderMatches(matches && matches.map((match) => Object.assign({}, match, {
    params: Object.assign({}, parentParams, match.params),
    pathname: joinPaths([
      parentPathnameBase,
      // Re-encode pathnames that were decoded inside matchRoutes
      navigator2.encodeLocation ? navigator2.encodeLocation(match.pathname).pathname : match.pathname
    ]),
    pathnameBase: match.pathnameBase === "/" ? parentPathnameBase : joinPaths([
      parentPathnameBase,
      // Re-encode pathnames that were decoded inside matchRoutes
      navigator2.encodeLocation ? navigator2.encodeLocation(match.pathnameBase).pathname : match.pathnameBase
    ])
  })), parentMatches, dataRouterState, future);
  if (locationArg && renderedMatches) {
    return /* @__PURE__ */ reactExports.createElement(LocationContext.Provider, {
      value: {
        location: _extends$1({
          pathname: "/",
          search: "",
          hash: "",
          state: null,
          key: "default"
        }, location2),
        navigationType: Action.Pop
      }
    }, renderedMatches);
  }
  return renderedMatches;
}
__name(useRoutesImpl, "useRoutesImpl");
function DefaultErrorComponent() {
  let error = useRouteError();
  let message = isRouteErrorResponse(error) ? error.status + " " + error.statusText : error instanceof Error ? error.message : JSON.stringify(error);
  let stack = error instanceof Error ? error.stack : null;
  let lightgrey = "rgba(200,200,200, 0.5)";
  let preStyles = {
    padding: "0.5rem",
    backgroundColor: lightgrey
  };
  let devInfo = null;
  return /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, /* @__PURE__ */ reactExports.createElement("h2", null, "Unexpected Application Error!"), /* @__PURE__ */ reactExports.createElement("h3", {
    style: {
      fontStyle: "italic"
    }
  }, message), stack ? /* @__PURE__ */ reactExports.createElement("pre", {
    style: preStyles
  }, stack) : null, devInfo);
}
__name(DefaultErrorComponent, "DefaultErrorComponent");
const defaultErrorElement = /* @__PURE__ */ reactExports.createElement(DefaultErrorComponent, null);
const _RenderErrorBoundary = class _RenderErrorBoundary extends reactExports.Component {
  constructor(props) {
    super(props);
    this.state = {
      location: props.location,
      revalidation: props.revalidation,
      error: props.error
    };
  }
  static getDerivedStateFromError(error) {
    return {
      error
    };
  }
  static getDerivedStateFromProps(props, state) {
    if (state.location !== props.location || state.revalidation !== "idle" && props.revalidation === "idle") {
      return {
        error: props.error,
        location: props.location,
        revalidation: props.revalidation
      };
    }
    return {
      error: props.error !== void 0 ? props.error : state.error,
      location: state.location,
      revalidation: props.revalidation || state.revalidation
    };
  }
  componentDidCatch(error, errorInfo) {
    console.error("React Router caught the following error during render", error, errorInfo);
  }
  render() {
    return this.state.error !== void 0 ? /* @__PURE__ */ reactExports.createElement(RouteContext.Provider, {
      value: this.props.routeContext
    }, /* @__PURE__ */ reactExports.createElement(RouteErrorContext.Provider, {
      value: this.state.error,
      children: this.props.component
    })) : this.props.children;
  }
};
__name(_RenderErrorBoundary, "RenderErrorBoundary");
let RenderErrorBoundary = _RenderErrorBoundary;
function RenderedRoute(_ref) {
  let {
    routeContext,
    match,
    children
  } = _ref;
  let dataRouterContext = reactExports.useContext(DataRouterContext);
  if (dataRouterContext && dataRouterContext.static && dataRouterContext.staticContext && (match.route.errorElement || match.route.ErrorBoundary)) {
    dataRouterContext.staticContext._deepestRenderedBoundaryId = match.route.id;
  }
  return /* @__PURE__ */ reactExports.createElement(RouteContext.Provider, {
    value: routeContext
  }, children);
}
__name(RenderedRoute, "RenderedRoute");
function _renderMatches(matches, parentMatches, dataRouterState, future) {
  var _dataRouterState;
  if (parentMatches === void 0) {
    parentMatches = [];
  }
  if (dataRouterState === void 0) {
    dataRouterState = null;
  }
  if (future === void 0) {
    future = null;
  }
  if (matches == null) {
    var _future;
    if (!dataRouterState) {
      return null;
    }
    if (dataRouterState.errors) {
      matches = dataRouterState.matches;
    } else if ((_future = future) != null && _future.v7_partialHydration && parentMatches.length === 0 && !dataRouterState.initialized && dataRouterState.matches.length > 0) {
      matches = dataRouterState.matches;
    } else {
      return null;
    }
  }
  let renderedMatches = matches;
  let errors = (_dataRouterState = dataRouterState) == null ? void 0 : _dataRouterState.errors;
  if (errors != null) {
    let errorIndex = renderedMatches.findIndex((m2) => m2.route.id && (errors == null ? void 0 : errors[m2.route.id]) !== void 0);
    !(errorIndex >= 0) ? invariant(false) : void 0;
    renderedMatches = renderedMatches.slice(0, Math.min(renderedMatches.length, errorIndex + 1));
  }
  let renderFallback = false;
  let fallbackIndex = -1;
  if (dataRouterState && future && future.v7_partialHydration) {
    for (let i2 = 0; i2 < renderedMatches.length; i2++) {
      let match = renderedMatches[i2];
      if (match.route.HydrateFallback || match.route.hydrateFallbackElement) {
        fallbackIndex = i2;
      }
      if (match.route.id) {
        let {
          loaderData,
          errors: errors2
        } = dataRouterState;
        let needsToRunLoader = match.route.loader && loaderData[match.route.id] === void 0 && (!errors2 || errors2[match.route.id] === void 0);
        if (match.route.lazy || needsToRunLoader) {
          renderFallback = true;
          if (fallbackIndex >= 0) {
            renderedMatches = renderedMatches.slice(0, fallbackIndex + 1);
          } else {
            renderedMatches = [renderedMatches[0]];
          }
          break;
        }
      }
    }
  }
  return renderedMatches.reduceRight((outlet, match, index2) => {
    let error;
    let shouldRenderHydrateFallback = false;
    let errorElement = null;
    let hydrateFallbackElement = null;
    if (dataRouterState) {
      error = errors && match.route.id ? errors[match.route.id] : void 0;
      errorElement = match.route.errorElement || defaultErrorElement;
      if (renderFallback) {
        if (fallbackIndex < 0 && index2 === 0) {
          warningOnce("route-fallback", false);
          shouldRenderHydrateFallback = true;
          hydrateFallbackElement = null;
        } else if (fallbackIndex === index2) {
          shouldRenderHydrateFallback = true;
          hydrateFallbackElement = match.route.hydrateFallbackElement || null;
        }
      }
    }
    let matches2 = parentMatches.concat(renderedMatches.slice(0, index2 + 1));
    let getChildren = /* @__PURE__ */ __name(() => {
      let children;
      if (error) {
        children = errorElement;
      } else if (shouldRenderHydrateFallback) {
        children = hydrateFallbackElement;
      } else if (match.route.Component) {
        children = /* @__PURE__ */ reactExports.createElement(match.route.Component, null);
      } else if (match.route.element) {
        children = match.route.element;
      } else {
        children = outlet;
      }
      return /* @__PURE__ */ reactExports.createElement(RenderedRoute, {
        match,
        routeContext: {
          outlet,
          matches: matches2,
          isDataRoute: dataRouterState != null
        },
        children
      });
    }, "getChildren");
    return dataRouterState && (match.route.ErrorBoundary || match.route.errorElement || index2 === 0) ? /* @__PURE__ */ reactExports.createElement(RenderErrorBoundary, {
      location: dataRouterState.location,
      revalidation: dataRouterState.revalidation,
      component: errorElement,
      error,
      children: getChildren(),
      routeContext: {
        outlet: null,
        matches: matches2,
        isDataRoute: true
      }
    }) : getChildren();
  }, null);
}
__name(_renderMatches, "_renderMatches");
var DataRouterHook$1 = /* @__PURE__ */ function(DataRouterHook2) {
  DataRouterHook2["UseBlocker"] = "useBlocker";
  DataRouterHook2["UseRevalidator"] = "useRevalidator";
  DataRouterHook2["UseNavigateStable"] = "useNavigate";
  return DataRouterHook2;
}(DataRouterHook$1 || {});
var DataRouterStateHook$1 = /* @__PURE__ */ function(DataRouterStateHook2) {
  DataRouterStateHook2["UseBlocker"] = "useBlocker";
  DataRouterStateHook2["UseLoaderData"] = "useLoaderData";
  DataRouterStateHook2["UseActionData"] = "useActionData";
  DataRouterStateHook2["UseRouteError"] = "useRouteError";
  DataRouterStateHook2["UseNavigation"] = "useNavigation";
  DataRouterStateHook2["UseRouteLoaderData"] = "useRouteLoaderData";
  DataRouterStateHook2["UseMatches"] = "useMatches";
  DataRouterStateHook2["UseRevalidator"] = "useRevalidator";
  DataRouterStateHook2["UseNavigateStable"] = "useNavigate";
  DataRouterStateHook2["UseRouteId"] = "useRouteId";
  return DataRouterStateHook2;
}(DataRouterStateHook$1 || {});
function useDataRouterContext(hookName) {
  let ctx = reactExports.useContext(DataRouterContext);
  !ctx ? invariant(false) : void 0;
  return ctx;
}
__name(useDataRouterContext, "useDataRouterContext");
function useDataRouterState(hookName) {
  let state = reactExports.useContext(DataRouterStateContext);
  !state ? invariant(false) : void 0;
  return state;
}
__name(useDataRouterState, "useDataRouterState");
function useRouteContext(hookName) {
  let route = reactExports.useContext(RouteContext);
  !route ? invariant(false) : void 0;
  return route;
}
__name(useRouteContext, "useRouteContext");
function useCurrentRouteId(hookName) {
  let route = useRouteContext();
  let thisRoute = route.matches[route.matches.length - 1];
  !thisRoute.route.id ? invariant(false) : void 0;
  return thisRoute.route.id;
}
__name(useCurrentRouteId, "useCurrentRouteId");
function useRouteError() {
  var _state$errors;
  let error = reactExports.useContext(RouteErrorContext);
  let state = useDataRouterState(DataRouterStateHook$1.UseRouteError);
  let routeId = useCurrentRouteId(DataRouterStateHook$1.UseRouteError);
  if (error !== void 0) {
    return error;
  }
  return (_state$errors = state.errors) == null ? void 0 : _state$errors[routeId];
}
__name(useRouteError, "useRouteError");
function useNavigateStable() {
  let {
    router
  } = useDataRouterContext(DataRouterHook$1.UseNavigateStable);
  let id = useCurrentRouteId(DataRouterStateHook$1.UseNavigateStable);
  let activeRef = reactExports.useRef(false);
  useIsomorphicLayoutEffect(() => {
    activeRef.current = true;
  });
  let navigate = reactExports.useCallback(function(to2, options) {
    if (options === void 0) {
      options = {};
    }
    if (!activeRef.current)
      return;
    if (typeof to2 === "number") {
      router.navigate(to2);
    } else {
      router.navigate(to2, _extends$1({
        fromRouteId: id
      }, options));
    }
  }, [router, id]);
  return navigate;
}
__name(useNavigateStable, "useNavigateStable");
const alreadyWarned$1 = {};
function warningOnce(key, cond, message) {
  if (!cond && !alreadyWarned$1[key]) {
    alreadyWarned$1[key] = true;
  }
}
__name(warningOnce, "warningOnce");
function logV6DeprecationWarnings(renderFuture, routerFuture) {
  if ((renderFuture == null ? void 0 : renderFuture.v7_startTransition) === void 0)
    ;
  if ((renderFuture == null ? void 0 : renderFuture.v7_relativeSplatPath) === void 0 && (!routerFuture || routerFuture.v7_relativeSplatPath === void 0))
    ;
  if (routerFuture) {
    if (routerFuture.v7_fetcherPersist === void 0)
      ;
    if (routerFuture.v7_normalizeFormMethod === void 0)
      ;
    if (routerFuture.v7_partialHydration === void 0)
      ;
    if (routerFuture.v7_skipActionErrorRevalidation === void 0)
      ;
  }
}
__name(logV6DeprecationWarnings, "logV6DeprecationWarnings");
function Navigate(_ref4) {
  let {
    to: to2,
    replace,
    state,
    relative
  } = _ref4;
  !useInRouterContext() ? invariant(false) : void 0;
  let {
    future,
    static: isStatic
  } = reactExports.useContext(NavigationContext);
  let {
    matches
  } = reactExports.useContext(RouteContext);
  let {
    pathname: locationPathname
  } = useLocation();
  let navigate = useNavigate();
  let path = resolveTo(to2, getResolveToMatches(matches, future.v7_relativeSplatPath), locationPathname, relative === "path");
  let jsonPath = JSON.stringify(path);
  reactExports.useEffect(() => navigate(JSON.parse(jsonPath), {
    replace,
    state,
    relative
  }), [navigate, jsonPath, relative, replace, state]);
  return null;
}
__name(Navigate, "Navigate");
function Route(_props) {
  invariant(false);
}
__name(Route, "Route");
function Router(_ref5) {
  let {
    basename: basenameProp = "/",
    children = null,
    location: locationProp,
    navigationType = Action.Pop,
    navigator: navigator2,
    static: staticProp = false,
    future
  } = _ref5;
  !!useInRouterContext() ? invariant(false) : void 0;
  let basename = basenameProp.replace(/^\/*/, "/");
  let navigationContext = reactExports.useMemo(() => ({
    basename,
    navigator: navigator2,
    static: staticProp,
    future: _extends$1({
      v7_relativeSplatPath: false
    }, future)
  }), [basename, future, navigator2, staticProp]);
  if (typeof locationProp === "string") {
    locationProp = parsePath(locationProp);
  }
  let {
    pathname = "/",
    search = "",
    hash = "",
    state = null,
    key = "default"
  } = locationProp;
  let locationContext = reactExports.useMemo(() => {
    let trailingPathname = stripBasename(pathname, basename);
    if (trailingPathname == null) {
      return null;
    }
    return {
      location: {
        pathname: trailingPathname,
        search,
        hash,
        state,
        key
      },
      navigationType
    };
  }, [basename, pathname, search, hash, state, key, navigationType]);
  if (locationContext == null) {
    return null;
  }
  return /* @__PURE__ */ reactExports.createElement(NavigationContext.Provider, {
    value: navigationContext
  }, /* @__PURE__ */ reactExports.createElement(LocationContext.Provider, {
    children,
    value: locationContext
  }));
}
__name(Router, "Router");
function Routes(_ref6) {
  let {
    children,
    location: location2
  } = _ref6;
  return useRoutes(createRoutesFromChildren(children), location2);
}
__name(Routes, "Routes");
new Promise(() => {
});
function createRoutesFromChildren(children, parentPath) {
  if (parentPath === void 0) {
    parentPath = [];
  }
  let routes = [];
  reactExports.Children.forEach(children, (element, index2) => {
    if (!/* @__PURE__ */ reactExports.isValidElement(element)) {
      return;
    }
    let treePath = [...parentPath, index2];
    if (element.type === reactExports.Fragment) {
      routes.push.apply(routes, createRoutesFromChildren(element.props.children, treePath));
      return;
    }
    !(element.type === Route) ? invariant(false) : void 0;
    !(!element.props.index || !element.props.children) ? invariant(false) : void 0;
    let route = {
      id: element.props.id || treePath.join("-"),
      caseSensitive: element.props.caseSensitive,
      element: element.props.element,
      Component: element.props.Component,
      index: element.props.index,
      path: element.props.path,
      loader: element.props.loader,
      action: element.props.action,
      errorElement: element.props.errorElement,
      ErrorBoundary: element.props.ErrorBoundary,
      hasErrorBoundary: element.props.ErrorBoundary != null || element.props.errorElement != null,
      shouldRevalidate: element.props.shouldRevalidate,
      handle: element.props.handle,
      lazy: element.props.lazy
    };
    if (element.props.children) {
      route.children = createRoutesFromChildren(element.props.children, treePath);
    }
    routes.push(route);
  });
  return routes;
}
__name(createRoutesFromChildren, "createRoutesFromChildren");
/**
 * React Router DOM v6.30.2
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
function _extends() {
  _extends = Object.assign ? Object.assign.bind() : function(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}
__name(_extends, "_extends");
function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i2;
  for (i2 = 0; i2 < sourceKeys.length; i2++) {
    key = sourceKeys[i2];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source[key];
  }
  return target;
}
__name(_objectWithoutPropertiesLoose, "_objectWithoutPropertiesLoose");
function isModifiedEvent(event) {
  return !!(event.metaKey || event.altKey || event.ctrlKey || event.shiftKey);
}
__name(isModifiedEvent, "isModifiedEvent");
function shouldProcessLinkClick(event, target) {
  return event.button === 0 && // Ignore everything but left clicks
  (!target || target === "_self") && // Let browser handle "target=_blank" etc.
  !isModifiedEvent(event);
}
__name(shouldProcessLinkClick, "shouldProcessLinkClick");
const _excluded = ["onClick", "relative", "reloadDocument", "replace", "state", "target", "to", "preventScrollReset", "viewTransition"];
const REACT_ROUTER_VERSION = "6";
try {
  window.__reactRouterVersion = REACT_ROUTER_VERSION;
} catch (e) {
}
const START_TRANSITION = "startTransition";
const startTransitionImpl = React[START_TRANSITION];
function BrowserRouter(_ref4) {
  let {
    basename,
    children,
    future,
    window: window2
  } = _ref4;
  let historyRef = reactExports.useRef();
  if (historyRef.current == null) {
    historyRef.current = createBrowserHistory({
      window: window2,
      v5Compat: true
    });
  }
  let history = historyRef.current;
  let [state, setStateImpl] = reactExports.useState({
    action: history.action,
    location: history.location
  });
  let {
    v7_startTransition
  } = future || {};
  let setState = reactExports.useCallback((newState) => {
    v7_startTransition && startTransitionImpl ? startTransitionImpl(() => setStateImpl(newState)) : setStateImpl(newState);
  }, [setStateImpl, v7_startTransition]);
  reactExports.useLayoutEffect(() => history.listen(setState), [history, setState]);
  reactExports.useEffect(() => logV6DeprecationWarnings(future), [future]);
  return /* @__PURE__ */ reactExports.createElement(Router, {
    basename,
    children,
    location: state.location,
    navigationType: state.action,
    navigator: history,
    future
  });
}
__name(BrowserRouter, "BrowserRouter");
const isBrowser = typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined";
const ABSOLUTE_URL_REGEX = /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i;
const Link$1 = /* @__PURE__ */ reactExports.forwardRef(/* @__PURE__ */ __name(function LinkWithRef(_ref7, ref) {
  let {
    onClick,
    relative,
    reloadDocument,
    replace,
    state,
    target,
    to: to2,
    preventScrollReset,
    viewTransition
  } = _ref7, rest = _objectWithoutPropertiesLoose(_ref7, _excluded);
  let {
    basename
  } = reactExports.useContext(NavigationContext);
  let absoluteHref;
  let isExternal = false;
  if (typeof to2 === "string" && ABSOLUTE_URL_REGEX.test(to2)) {
    absoluteHref = to2;
    if (isBrowser) {
      try {
        let currentUrl = new URL(window.location.href);
        let targetUrl = to2.startsWith("//") ? new URL(currentUrl.protocol + to2) : new URL(to2);
        let path = stripBasename(targetUrl.pathname, basename);
        if (targetUrl.origin === currentUrl.origin && path != null) {
          to2 = path + targetUrl.search + targetUrl.hash;
        } else {
          isExternal = true;
        }
      } catch (e) {
      }
    }
  }
  let href = useHref(to2, {
    relative
  });
  let internalOnClick = useLinkClickHandler(to2, {
    replace,
    state,
    target,
    preventScrollReset,
    relative,
    viewTransition
  });
  function handleClick(event) {
    if (onClick)
      onClick(event);
    if (!event.defaultPrevented) {
      internalOnClick(event);
    }
  }
  __name(handleClick, "handleClick");
  return (
    // eslint-disable-next-line jsx-a11y/anchor-has-content
    /* @__PURE__ */ reactExports.createElement("a", _extends({}, rest, {
      href: absoluteHref || href,
      onClick: isExternal || reloadDocument ? onClick : handleClick,
      ref,
      target
    }))
  );
}, "LinkWithRef"));
var DataRouterHook;
(function(DataRouterHook2) {
  DataRouterHook2["UseScrollRestoration"] = "useScrollRestoration";
  DataRouterHook2["UseSubmit"] = "useSubmit";
  DataRouterHook2["UseSubmitFetcher"] = "useSubmitFetcher";
  DataRouterHook2["UseFetcher"] = "useFetcher";
  DataRouterHook2["useViewTransitionState"] = "useViewTransitionState";
})(DataRouterHook || (DataRouterHook = {}));
var DataRouterStateHook;
(function(DataRouterStateHook2) {
  DataRouterStateHook2["UseFetcher"] = "useFetcher";
  DataRouterStateHook2["UseFetchers"] = "useFetchers";
  DataRouterStateHook2["UseScrollRestoration"] = "useScrollRestoration";
})(DataRouterStateHook || (DataRouterStateHook = {}));
function useLinkClickHandler(to2, _temp) {
  let {
    target,
    replace: replaceProp,
    state,
    preventScrollReset,
    relative,
    viewTransition
  } = _temp === void 0 ? {} : _temp;
  let navigate = useNavigate();
  let location2 = useLocation();
  let path = useResolvedPath(to2, {
    relative
  });
  return reactExports.useCallback((event) => {
    if (shouldProcessLinkClick(event, target)) {
      event.preventDefault();
      let replace = replaceProp !== void 0 ? replaceProp : createPath(location2) === createPath(path);
      navigate(to2, {
        replace,
        state,
        preventScrollReset,
        relative,
        viewTransition
      });
    }
  }, [location2, navigate, path, replaceProp, state, target, to2, preventScrollReset, relative, viewTransition]);
}
__name(useLinkClickHandler, "useLinkClickHandler");
const AuthContext = reactExports.createContext();
function useAuth() {
  return reactExports.useContext(AuthContext);
}
__name(useAuth, "useAuth");
function AuthProvider({ children }) {
  const [user, setUser] = reactExports.useState(null);
  const [loading, setLoading] = reactExports.useState(true);
  reactExports.useEffect(() => {
    const token = localStorage.getItem("token");
    if (token) {
      fetch("/api/auth/verify", {
        headers: {
          "Authorization": `Bearer ${token}`
        }
      }).then((res) => res.json()).then((data) => {
        if (data.success) {
          setUser(data.user);
        } else {
          localStorage.removeItem("token");
        }
      }).catch(() => {
        localStorage.removeItem("token");
      }).finally(() => {
        setLoading(false);
      });
    } else {
      setLoading(false);
    }
  }, []);
  const login = /* @__PURE__ */ __name(async (email, password) => {
    try {
      const response = await fetch("/api/auth/login", {
        method: "POST",
        headers: {
          "Content-Type": "application/json"
        },
        body: JSON.stringify({ email, password })
      });
      const data = await response.json();
      if (data.success) {
        localStorage.setItem("token", data.token);
        setUser(data.user);
        return { success: true };
      } else {
        return { success: false, error: data.message };
      }
    } catch (error) {
      return { success: false, error: "Network error" };
    }
  }, "login");
  const logout = /* @__PURE__ */ __name(() => {
    localStorage.removeItem("token");
    setUser(null);
  }, "logout");
  const value = {
    user,
    login,
    logout,
    loading
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(AuthContext.Provider, { value, children });
}
__name(AuthProvider, "AuthProvider");
const DatabaseContext = reactExports.createContext();
function useDatabase() {
  return reactExports.useContext(DatabaseContext);
}
__name(useDatabase, "useDatabase");
function DatabaseProvider({ children }) {
  reactExports.useEffect(() => {
    initializeDatabase();
  }, []);
  const initializeDatabase = /* @__PURE__ */ __name(async () => {
    try {
      const schema = {
        tables: [
          {
            name: "users",
            columns: [
              { name: "id", type: "uuid", nullable: false, default: "gen_random_uuid()" },
              { name: "email", type: "text", nullable: false },
              { name: "password_hash", type: "text", nullable: false },
              { name: "role", type: "text", nullable: false, default: "'user'" },
              { name: "team_id", type: "uuid" },
              { name: "created_at", type: "timestamptz", default: "now()" },
              { name: "last_login", type: "timestamptz" }
            ]
          },
          {
            name: "teams",
            columns: [
              { name: "id", type: "uuid", nullable: false, default: "gen_random_uuid()" },
              { name: "name", type: "text", nullable: false },
              { name: "description", type: "text" },
              { name: "created_at", type: "timestamptz", default: "now()" }
            ]
          },
          {
            name: "user_permissions",
            columns: [
              { name: "id", type: "uuid", nullable: false, default: "gen_random_uuid()" },
              { name: "user_id", type: "uuid", nullable: false },
              { name: "permission_type", type: "text", nullable: false },
              { name: "resource_id", type: "uuid" }
            ]
          },
          {
            name: "audit_logs",
            columns: [
              { name: "id", type: "uuid", nullable: false, default: "gen_random_uuid()" },
              { name: "user_id", type: "uuid", nullable: false },
              { name: "action", type: "text", nullable: false },
              { name: "resource_type", type: "text", nullable: false },
              { name: "resource_id", type: "uuid" },
              { name: "timestamp", type: "timestamptz", default: "now()" },
              { name: "details", type: "text" }
            ]
          },
          {
            name: "companies",
            columns: [
              { name: "id", type: "uuid", nullable: false, default: "gen_random_uuid()" },
              { name: "name", type: "text", nullable: false },
              { name: "industry", type: "text" },
              { name: "created_at", type: "timestamptz", default: "now()" },
              { name: "team_id", type: "uuid" }
            ]
          },
          {
            name: "financial_statements",
            columns: [
              { name: "id", type: "uuid", nullable: false, default: "gen_random_uuid()" },
              { name: "company_id", type: "uuid", nullable: false },
              { name: "statement_type", type: "text", nullable: false },
              { name: "period", type: "text", nullable: false },
              { name: "year", type: "bigint", nullable: false },
              { name: "quarter", type: "bigint" },
              { name: "file_path", type: "text" },
              { name: "processed_at", type: "timestamptz" },
              { name: "uploaded_by", type: "uuid", nullable: false }
            ]
          },
          {
            name: "financial_metrics",
            columns: [
              { name: "id", type: "uuid", nullable: false, default: "gen_random_uuid()" },
              { name: "statement_id", type: "uuid", nullable: false },
              { name: "metric_name", type: "text", nullable: false },
              { name: "metric_value", type: "numeric" },
              { name: "metric_category", type: "text", nullable: false }
            ]
          },
          {
            name: "inconsistencies",
            columns: [
              { name: "id", type: "uuid", nullable: false, default: "gen_random_uuid()" },
              { name: "statement_id", type: "uuid", nullable: false },
              { name: "inconsistency_type", type: "text", nullable: false },
              { name: "description", type: "text", nullable: false },
              { name: "severity", type: "text", nullable: false },
              { name: "detected_at", type: "timestamptz", default: "now()" }
            ]
          },
          {
            name: "reports",
            columns: [
              { name: "id", type: "uuid", nullable: false, default: "gen_random_uuid()" },
              { name: "name", type: "text", nullable: false },
              { name: "type", type: "text", nullable: false },
              { name: "parameters", type: "text" },
              { name: "created_by", type: "uuid", nullable: false },
              { name: "created_at", type: "timestamptz", default: "now()" }
            ]
          },
          {
            name: "dashboards",
            columns: [
              { name: "id", type: "uuid", nullable: false, default: "gen_random_uuid()" },
              { name: "name", type: "text", nullable: false },
              { name: "layout_config", type: "text" },
              { name: "created_by", type: "uuid", nullable: false },
              { name: "team_id", type: "uuid" },
              { name: "created_at", type: "timestamptz", default: "now()" }
            ]
          }
        ],
        indexes: [
          { table: "users", columns: ["email"], name: "users_email_uq", unique: true },
          { table: "companies", columns: ["name"], name: "companies_name_idx" },
          { table: "financial_statements", columns: ["company_id", "year", "quarter"], name: "statements_company_period_idx" },
          { table: "financial_metrics", columns: ["statement_id", "metric_name"], name: "metrics_statement_name_idx" },
          { table: "inconsistencies", columns: ["statement_id", "severity"], name: "inconsistencies_statement_severity_idx" }
        ]
      };
      const response = await fetch("https://builder.empromptu.ai/api_tools/database/schema", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          "Authorization": "Bearer 4b82f096e899fe27871d083ae66ddd01",
          "X-Generated-App-ID": "ae40c6ff-a693-48ae-ae9d-f44b3831f48e",
          "X-Usage-Key": "2b0185b0bd6d7d7ebe2369814e91bb81"
        },
        body: JSON.stringify(schema)
      });
      if (response.ok || response.status === 304) {
        console.log("Database schema initialized successfully");
      } else {
        console.error("Failed to initialize database schema");
      }
    } catch (error) {
      console.error("Database initialization error:", error);
    }
  }, "initializeDatabase");
  const query = /* @__PURE__ */ __name(async (sql, params = []) => {
    try {
      const response = await fetch("https://builder.empromptu.ai/api_tools/database/query", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          "Authorization": "Bearer 4b82f096e899fe27871d083ae66ddd01",
          "X-Generated-App-ID": "ae40c6ff-a693-48ae-ae9d-f44b3831f48e",
          "X-Usage-Key": "2b0185b0bd6d7d7ebe2369814e91bb81"
        },
        body: JSON.stringify({ query: sql, params })
      });
      return await response.json();
    } catch (error) {
      console.error("Database query error:", error);
      return { success: false, error: error.message };
    }
  }, "query");
  const value = {
    query
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(DatabaseContext.Provider, { value, children });
}
__name(DatabaseProvider, "DatabaseProvider");
var defaultAttributes = {
  xmlns: "http://www.w3.org/2000/svg",
  width: 24,
  height: 24,
  viewBox: "0 0 24 24",
  fill: "none",
  stroke: "currentColor",
  strokeWidth: 2,
  strokeLinecap: "round",
  strokeLinejoin: "round"
};
const toKebabCase = /* @__PURE__ */ __name((string) => string.replace(/([a-z0-9])([A-Z])/g, "$1-$2").toLowerCase(), "toKebabCase");
const createLucideIcon = /* @__PURE__ */ __name((iconName, iconNode) => {
  const Component = reactExports.forwardRef(
    ({ color: color2 = "currentColor", size = 24, strokeWidth = 2, absoluteStrokeWidth, children, ...rest }, ref) => reactExports.createElement(
      "svg",
      {
        ref,
        ...defaultAttributes,
        width: size,
        height: size,
        stroke: color2,
        strokeWidth: absoluteStrokeWidth ? Number(strokeWidth) * 24 / Number(size) : strokeWidth,
        className: `lucide lucide-${toKebabCase(iconName)}`,
        ...rest
      },
      [
        ...iconNode.map(([tag, attrs]) => reactExports.createElement(tag, attrs)),
        ...(Array.isArray(children) ? children : [children]) || []
      ]
    )
  );
  Component.displayName = `${iconName}`;
  return Component;
}, "createLucideIcon");
var createLucideIcon$1 = createLucideIcon;
const AlertTriangle = createLucideIcon$1("AlertTriangle", [
  [
    "path",
    {
      d: "m21.73 18-8-14a2 2 0 0 0-3.48 0l-8 14A2 2 0 0 0 4 21h16a2 2 0 0 0 1.73-3Z",
      key: "c3ski4"
    }
  ],
  ["path", { d: "M12 9v4", key: "juzpu7" }],
  ["path", { d: "M12 17h.01", key: "p32p05" }]
]);
const BarChart3 = createLucideIcon$1("BarChart3", [
  ["path", { d: "M3 3v18h18", key: "1s2lah" }],
  ["path", { d: "M18 17V9", key: "2bz60n" }],
  ["path", { d: "M13 17V5", key: "1frdt8" }],
  ["path", { d: "M8 17v-3", key: "17ska0" }]
]);
const Building2 = createLucideIcon$1("Building2", [
  ["path", { d: "M6 22V4a2 2 0 0 1 2-2h8a2 2 0 0 1 2 2v18Z", key: "1b4qmf" }],
  ["path", { d: "M6 12H4a2 2 0 0 0-2 2v6a2 2 0 0 0 2 2h2", key: "i71pzd" }],
  ["path", { d: "M18 9h2a2 2 0 0 1 2 2v9a2 2 0 0 1-2 2h-2", key: "10jefs" }],
  ["path", { d: "M10 6h4", key: "1itunk" }],
  ["path", { d: "M10 10h4", key: "tcdvrf" }],
  ["path", { d: "M10 14h4", key: "kelpxr" }],
  ["path", { d: "M10 18h4", key: "1ulq68" }]
]);
const CheckCircle = createLucideIcon$1("CheckCircle", [
  ["path", { d: "M22 11.08V12a10 10 0 1 1-5.93-9.14", key: "g774vq" }],
  ["polyline", { points: "22 4 12 14.01 9 11.01", key: "6xbx8j" }]
]);
const Clock = createLucideIcon$1("Clock", [
  ["circle", { cx: "12", cy: "12", r: "10", key: "1mglay" }],
  ["polyline", { points: "12 6 12 12 16 14", key: "68esgv" }]
]);
const DollarSign = createLucideIcon$1("DollarSign", [
  ["line", { x1: "12", x2: "12", y1: "2", y2: "22", key: "7eqyqh" }],
  [
    "path",
    { d: "M17 5H9.5a3.5 3.5 0 0 0 0 7h5a3.5 3.5 0 0 1 0 7H6", key: "1b0p4s" }
  ]
]);
const Download = createLucideIcon$1("Download", [
  ["path", { d: "M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4", key: "ih7n3h" }],
  ["polyline", { points: "7 10 12 15 17 10", key: "2ggqvy" }],
  ["line", { x1: "12", x2: "12", y1: "15", y2: "3", key: "1vk2je" }]
]);
const EyeOff = createLucideIcon$1("EyeOff", [
  ["path", { d: "M9.88 9.88a3 3 0 1 0 4.24 4.24", key: "1jxqfv" }],
  [
    "path",
    {
      d: "M10.73 5.08A10.43 10.43 0 0 1 12 5c7 0 10 7 10 7a13.16 13.16 0 0 1-1.67 2.68",
      key: "9wicm4"
    }
  ],
  [
    "path",
    {
      d: "M6.61 6.61A13.526 13.526 0 0 0 2 12s3 7 10 7a9.74 9.74 0 0 0 5.39-1.61",
      key: "1jreej"
    }
  ],
  ["line", { x1: "2", x2: "22", y1: "2", y2: "22", key: "a6p6uj" }]
]);
const Eye = createLucideIcon$1("Eye", [
  [
    "path",
    { d: "M2 12s3-7 10-7 10 7 10 7-3 7-10 7-10-7-10-7Z", key: "rwhkz3" }
  ],
  ["circle", { cx: "12", cy: "12", r: "3", key: "1v7zrd" }]
]);
const FileBarChart = createLucideIcon$1("FileBarChart", [
  [
    "path",
    {
      d: "M14.5 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7.5L14.5 2z",
      key: "1nnpy2"
    }
  ],
  ["polyline", { points: "14 2 14 8 20 8", key: "1ew0cm" }],
  ["path", { d: "M12 18v-4", key: "q1q25u" }],
  ["path", { d: "M8 18v-2", key: "qcmpov" }],
  ["path", { d: "M16 18v-6", key: "15y0np" }]
]);
const FileText = createLucideIcon$1("FileText", [
  [
    "path",
    {
      d: "M14.5 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7.5L14.5 2z",
      key: "1nnpy2"
    }
  ],
  ["polyline", { points: "14 2 14 8 20 8", key: "1ew0cm" }],
  ["line", { x1: "16", x2: "8", y1: "13", y2: "13", key: "14keom" }],
  ["line", { x1: "16", x2: "8", y1: "17", y2: "17", key: "17nazh" }],
  ["line", { x1: "10", x2: "8", y1: "9", y2: "9", key: "1a5vjj" }]
]);
const Link = createLucideIcon$1("Link", [
  [
    "path",
    {
      d: "M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71",
      key: "1cjeqo"
    }
  ],
  [
    "path",
    {
      d: "M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71",
      key: "19qd67"
    }
  ]
]);
const LogOut = createLucideIcon$1("LogOut", [
  ["path", { d: "M9 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h4", key: "1uf3rs" }],
  ["polyline", { points: "16 17 21 12 16 7", key: "1gabdz" }],
  ["line", { x1: "21", x2: "9", y1: "12", y2: "12", key: "1uyos4" }]
]);
const Menu = createLucideIcon$1("Menu", [
  ["line", { x1: "4", x2: "20", y1: "12", y2: "12", key: "1e0a9i" }],
  ["line", { x1: "4", x2: "20", y1: "6", y2: "6", key: "1owob3" }],
  ["line", { x1: "4", x2: "20", y1: "18", y2: "18", key: "yk5zj1" }]
]);
const PenSquare = createLucideIcon$1("PenSquare", [
  [
    "path",
    {
      d: "M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7",
      key: "1qinfi"
    }
  ],
  [
    "path",
    { d: "M18.5 2.5a2.12 2.12 0 0 1 3 3L12 15l-4 1 1-4Z", key: "w2jsv5" }
  ]
]);
const Plus = createLucideIcon$1("Plus", [
  ["path", { d: "M5 12h14", key: "1ays0h" }],
  ["path", { d: "M12 5v14", key: "s699le" }]
]);
const Search = createLucideIcon$1("Search", [
  ["circle", { cx: "11", cy: "11", r: "8", key: "4ej97u" }],
  ["path", { d: "m21 21-4.3-4.3", key: "1qie3q" }]
]);
const Shield = createLucideIcon$1("Shield", [
  ["path", { d: "M12 22s8-4 8-10V5l-8-3-8 3v7c0 6 8 10 8 10z", key: "3xmgem" }]
]);
const Trash2 = createLucideIcon$1("Trash2", [
  ["path", { d: "M3 6h18", key: "d0wm0j" }],
  ["path", { d: "M19 6v14c0 1-1 2-2 2H7c-1 0-2-1-2-2V6", key: "4alrt4" }],
  ["path", { d: "M8 6V4c0-1 1-2 2-2h4c1 0 2 1 2 2v2", key: "v07s0e" }],
  ["line", { x1: "10", x2: "10", y1: "11", y2: "17", key: "1uufr5" }],
  ["line", { x1: "14", x2: "14", y1: "11", y2: "17", key: "xtxkd" }]
]);
const TrendingUp = createLucideIcon$1("TrendingUp", [
  ["polyline", { points: "22 7 13.5 15.5 8.5 10.5 2 17", key: "126l90" }],
  ["polyline", { points: "16 7 22 7 22 13", key: "kwv8wd" }]
]);
const Upload = createLucideIcon$1("Upload", [
  ["path", { d: "M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4", key: "ih7n3h" }],
  ["polyline", { points: "17 8 12 3 7 8", key: "t8dd8p" }],
  ["line", { x1: "12", x2: "12", y1: "3", y2: "15", key: "widbto" }]
]);
const Users = createLucideIcon$1("Users", [
  ["path", { d: "M16 21v-2a4 4 0 0 0-4-4H6a4 4 0 0 0-4 4v2", key: "1yyitq" }],
  ["circle", { cx: "9", cy: "7", r: "4", key: "nufk8" }],
  ["path", { d: "M22 21v-2a4 4 0 0 0-3-3.87", key: "kshegd" }],
  ["path", { d: "M16 3.13a4 4 0 0 1 0 7.75", key: "1da9ce" }]
]);
const X$1 = createLucideIcon$1("X", [
  ["path", { d: "M18 6 6 18", key: "1bl5f8" }],
  ["path", { d: "m6 6 12 12", key: "d8bk6v" }]
]);
function Navbar() {
  const { user, logout } = useAuth();
  const location2 = useLocation();
  const [isMobileMenuOpen, setIsMobileMenuOpen] = reactExports.useState(false);
  const navigation = [
    { name: "Dashboard", href: "/", icon: BarChart3 },
    { name: "Companies", href: "/companies", icon: Building2 },
    { name: "Statements", href: "/statements", icon: FileText },
    { name: "Analytics", href: "/analytics", icon: TrendingUp },
    { name: "Reports", href: "/reports", icon: FileBarChart }
  ];
  if ((user == null ? void 0 : user.role) === "admin") {
    navigation.push({ name: "Users", href: "/users", icon: Users });
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx("nav", { className: "bg-white dark:bg-gray-800 shadow-sm border-b border-gray-200 dark:border-gray-700", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "container mx-auto px-4", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex justify-between items-center h-16", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex items-center", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Link$1, { to: "/", className: "flex items-center space-x-2", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(BarChart3, { className: "h-8 w-8 text-primary-600" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-xl font-bold text-gray-900 dark:text-white", children: "FinAnalyzer" })
      ] }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "hidden md:flex items-center space-x-8", children: navigation.map((item) => {
        const Icon = item.icon;
        const isActive = location2.pathname === item.href;
        return /* @__PURE__ */ jsxRuntimeExports.jsxs(
          Link$1,
          {
            to: item.href,
            className: `flex items-center space-x-1 px-3 py-2 rounded-md text-sm font-medium transition-colors ${isActive ? "text-primary-600 bg-primary-50 dark:bg-primary-900/20" : "text-gray-600 dark:text-gray-300 hover:text-gray-900 dark:hover:text-white hover:bg-gray-50 dark:hover:bg-gray-700"}`,
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { className: "h-4 w-4" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: item.name })
            ]
          },
          item.name
        );
      }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "hidden md:flex items-center space-x-4", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-sm text-gray-600 dark:text-gray-300", children: user == null ? void 0 : user.email }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(
          "button",
          {
            onClick: logout,
            className: "flex items-center space-x-1 px-3 py-2 text-sm text-gray-600 dark:text-gray-300 hover:text-gray-900 dark:hover:text-white",
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(LogOut, { className: "h-4 w-4" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "Logout" })
            ]
          }
        )
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "md:hidden", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        "button",
        {
          onClick: () => setIsMobileMenuOpen(!isMobileMenuOpen),
          className: "p-2 rounded-md text-gray-600 dark:text-gray-300 hover:text-gray-900 dark:hover:text-white",
          children: isMobileMenuOpen ? /* @__PURE__ */ jsxRuntimeExports.jsx(X$1, { className: "h-6 w-6" }) : /* @__PURE__ */ jsxRuntimeExports.jsx(Menu, { className: "h-6 w-6" })
        }
      ) })
    ] }),
    isMobileMenuOpen && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "md:hidden py-4 border-t border-gray-200 dark:border-gray-700", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-2", children: [
      navigation.map((item) => {
        const Icon = item.icon;
        const isActive = location2.pathname === item.href;
        return /* @__PURE__ */ jsxRuntimeExports.jsxs(
          Link$1,
          {
            to: item.href,
            onClick: () => setIsMobileMenuOpen(false),
            className: `flex items-center space-x-2 px-3 py-2 rounded-md text-sm font-medium ${isActive ? "text-primary-600 bg-primary-50 dark:bg-primary-900/20" : "text-gray-600 dark:text-gray-300 hover:text-gray-900 dark:hover:text-white hover:bg-gray-50 dark:hover:bg-gray-700"}`,
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { className: "h-4 w-4" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: item.name })
            ]
          },
          item.name
        );
      }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "border-t border-gray-200 dark:border-gray-700 pt-2 mt-2", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "px-3 py-2 text-sm text-gray-600 dark:text-gray-300", children: user == null ? void 0 : user.email }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(
          "button",
          {
            onClick: () => {
              logout();
              setIsMobileMenuOpen(false);
            },
            className: "flex items-center space-x-2 px-3 py-2 text-sm text-gray-600 dark:text-gray-300 hover:text-gray-900 dark:hover:text-white w-full text-left",
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(LogOut, { className: "h-4 w-4" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "Logout" })
            ]
          }
        )
      ] })
    ] }) })
  ] }) });
}
__name(Navbar, "Navbar");
function Login() {
  const { login } = useAuth();
  const [email, setEmail] = reactExports.useState("");
  const [password, setPassword] = reactExports.useState("");
  const [showPassword, setShowPassword] = reactExports.useState(false);
  const [loading, setLoading] = reactExports.useState(false);
  const [error, setError] = reactExports.useState("");
  const handleSubmit = /* @__PURE__ */ __name(async (e) => {
    e.preventDefault();
    setLoading(true);
    setError("");
    const result = await login(email, password);
    if (!result.success) {
      setError(result.error);
    }
    setLoading(false);
  }, "handleSubmit");
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "min-h-screen flex items-center justify-center bg-gray-50 dark:bg-gray-900 py-12 px-4 sm:px-6 lg:px-8", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "max-w-md w-full space-y-8", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex justify-center", children: /* @__PURE__ */ jsxRuntimeExports.jsx(BarChart3, { className: "h-12 w-12 text-primary-600" }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: "mt-6 text-center text-3xl font-extrabold text-gray-900 dark:text-white", children: "Sign in to FinAnalyzer" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "mt-2 text-center text-sm text-gray-600 dark:text-gray-400", children: "Financial Statement Analysis Platform" })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("form", { className: "mt-8 space-y-6", onSubmit: handleSubmit, children: [
      error && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "bg-red-50 dark:bg-red-900/20 border border-red-200 dark:border-red-800 text-red-700 dark:text-red-400 px-4 py-3 rounded-md", children: error }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-4", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("label", { htmlFor: "email", className: "block text-sm font-medium text-gray-700 dark:text-gray-300", children: "Email address" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "input",
            {
              id: "email",
              name: "email",
              type: "email",
              autoComplete: "email",
              required: true,
              value: email,
              onChange: (e) => setEmail(e.target.value),
              className: "input-field mt-1",
              placeholder: "Enter your email"
            }
          )
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("label", { htmlFor: "password", className: "block text-sm font-medium text-gray-700 dark:text-gray-300", children: "Password" }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mt-1 relative", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "input",
              {
                id: "password",
                name: "password",
                type: showPassword ? "text" : "password",
                autoComplete: "current-password",
                required: true,
                value: password,
                onChange: (e) => setPassword(e.target.value),
                className: "input-field pr-10",
                placeholder: "Enter your password"
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "button",
              {
                type: "button",
                className: "absolute inset-y-0 right-0 pr-3 flex items-center",
                onClick: () => setShowPassword(!showPassword),
                children: showPassword ? /* @__PURE__ */ jsxRuntimeExports.jsx(EyeOff, { className: "h-4 w-4 text-gray-400" }) : /* @__PURE__ */ jsxRuntimeExports.jsx(Eye, { className: "h-4 w-4 text-gray-400" })
              }
            )
          ] })
        ] })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        "button",
        {
          type: "submit",
          disabled: loading,
          className: "w-full btn-primary disabled:opacity-50 disabled:cursor-not-allowed",
          children: loading ? "Signing in..." : "Sign in"
        }
      ) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-center", children: /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-sm text-gray-600 dark:text-gray-400", children: "Demo credentials: admin@example.com / admin123" }) })
    ] })
  ] }) });
}
__name(Login, "Login");
/*!
 * @kurkle/color v0.3.4
 * https://github.com/kurkle/color#readme
 * (c) 2024 Jukka Kurkela
 * Released under the MIT License
 */
function round(v2) {
  return v2 + 0.5 | 0;
}
__name(round, "round");
const lim = /* @__PURE__ */ __name((v2, l2, h3) => Math.max(Math.min(v2, h3), l2), "lim");
function p2b(v2) {
  return lim(round(v2 * 2.55), 0, 255);
}
__name(p2b, "p2b");
function n2b(v2) {
  return lim(round(v2 * 255), 0, 255);
}
__name(n2b, "n2b");
function b2n(v2) {
  return lim(round(v2 / 2.55) / 100, 0, 1);
}
__name(b2n, "b2n");
function n2p(v2) {
  return lim(round(v2 * 100), 0, 100);
}
__name(n2p, "n2p");
const map$1 = { 0: 0, 1: 1, 2: 2, 3: 3, 4: 4, 5: 5, 6: 6, 7: 7, 8: 8, 9: 9, A: 10, B: 11, C: 12, D: 13, E: 14, F: 15, a: 10, b: 11, c: 12, d: 13, e: 14, f: 15 };
const hex = [..."0123456789ABCDEF"];
const h1 = /* @__PURE__ */ __name((b2) => hex[b2 & 15], "h1");
const h2 = /* @__PURE__ */ __name((b2) => hex[(b2 & 240) >> 4] + hex[b2 & 15], "h2");
const eq = /* @__PURE__ */ __name((b2) => (b2 & 240) >> 4 === (b2 & 15), "eq");
const isShort = /* @__PURE__ */ __name((v2) => eq(v2.r) && eq(v2.g) && eq(v2.b) && eq(v2.a), "isShort");
function hexParse(str) {
  var len = str.length;
  var ret;
  if (str[0] === "#") {
    if (len === 4 || len === 5) {
      ret = {
        r: 255 & map$1[str[1]] * 17,
        g: 255 & map$1[str[2]] * 17,
        b: 255 & map$1[str[3]] * 17,
        a: len === 5 ? map$1[str[4]] * 17 : 255
      };
    } else if (len === 7 || len === 9) {
      ret = {
        r: map$1[str[1]] << 4 | map$1[str[2]],
        g: map$1[str[3]] << 4 | map$1[str[4]],
        b: map$1[str[5]] << 4 | map$1[str[6]],
        a: len === 9 ? map$1[str[7]] << 4 | map$1[str[8]] : 255
      };
    }
  }
  return ret;
}
__name(hexParse, "hexParse");
const alpha = /* @__PURE__ */ __name((a2, f2) => a2 < 255 ? f2(a2) : "", "alpha");
function hexString(v2) {
  var f2 = isShort(v2) ? h1 : h2;
  return v2 ? "#" + f2(v2.r) + f2(v2.g) + f2(v2.b) + alpha(v2.a, f2) : void 0;
}
__name(hexString, "hexString");
const HUE_RE = /^(hsla?|hwb|hsv)\(\s*([-+.e\d]+)(?:deg)?[\s,]+([-+.e\d]+)%[\s,]+([-+.e\d]+)%(?:[\s,]+([-+.e\d]+)(%)?)?\s*\)$/;
function hsl2rgbn(h3, s2, l2) {
  const a2 = s2 * Math.min(l2, 1 - l2);
  const f2 = /* @__PURE__ */ __name((n2, k2 = (n2 + h3 / 30) % 12) => l2 - a2 * Math.max(Math.min(k2 - 3, 9 - k2, 1), -1), "f");
  return [f2(0), f2(8), f2(4)];
}
__name(hsl2rgbn, "hsl2rgbn");
function hsv2rgbn(h3, s2, v2) {
  const f2 = /* @__PURE__ */ __name((n2, k2 = (n2 + h3 / 60) % 6) => v2 - v2 * s2 * Math.max(Math.min(k2, 4 - k2, 1), 0), "f");
  return [f2(5), f2(3), f2(1)];
}
__name(hsv2rgbn, "hsv2rgbn");
function hwb2rgbn(h3, w2, b2) {
  const rgb = hsl2rgbn(h3, 1, 0.5);
  let i2;
  if (w2 + b2 > 1) {
    i2 = 1 / (w2 + b2);
    w2 *= i2;
    b2 *= i2;
  }
  for (i2 = 0; i2 < 3; i2++) {
    rgb[i2] *= 1 - w2 - b2;
    rgb[i2] += w2;
  }
  return rgb;
}
__name(hwb2rgbn, "hwb2rgbn");
function hueValue(r, g2, b2, d2, max2) {
  if (r === max2) {
    return (g2 - b2) / d2 + (g2 < b2 ? 6 : 0);
  }
  if (g2 === max2) {
    return (b2 - r) / d2 + 2;
  }
  return (r - g2) / d2 + 4;
}
__name(hueValue, "hueValue");
function rgb2hsl(v2) {
  const range = 255;
  const r = v2.r / range;
  const g2 = v2.g / range;
  const b2 = v2.b / range;
  const max2 = Math.max(r, g2, b2);
  const min = Math.min(r, g2, b2);
  const l2 = (max2 + min) / 2;
  let h3, s2, d2;
  if (max2 !== min) {
    d2 = max2 - min;
    s2 = l2 > 0.5 ? d2 / (2 - max2 - min) : d2 / (max2 + min);
    h3 = hueValue(r, g2, b2, d2, max2);
    h3 = h3 * 60 + 0.5;
  }
  return [h3 | 0, s2 || 0, l2];
}
__name(rgb2hsl, "rgb2hsl");
function calln(f2, a2, b2, c2) {
  return (Array.isArray(a2) ? f2(a2[0], a2[1], a2[2]) : f2(a2, b2, c2)).map(n2b);
}
__name(calln, "calln");
function hsl2rgb(h3, s2, l2) {
  return calln(hsl2rgbn, h3, s2, l2);
}
__name(hsl2rgb, "hsl2rgb");
function hwb2rgb(h3, w2, b2) {
  return calln(hwb2rgbn, h3, w2, b2);
}
__name(hwb2rgb, "hwb2rgb");
function hsv2rgb(h3, s2, v2) {
  return calln(hsv2rgbn, h3, s2, v2);
}
__name(hsv2rgb, "hsv2rgb");
function hue(h3) {
  return (h3 % 360 + 360) % 360;
}
__name(hue, "hue");
function hueParse(str) {
  const m2 = HUE_RE.exec(str);
  let a2 = 255;
  let v2;
  if (!m2) {
    return;
  }
  if (m2[5] !== v2) {
    a2 = m2[6] ? p2b(+m2[5]) : n2b(+m2[5]);
  }
  const h3 = hue(+m2[2]);
  const p1 = +m2[3] / 100;
  const p2 = +m2[4] / 100;
  if (m2[1] === "hwb") {
    v2 = hwb2rgb(h3, p1, p2);
  } else if (m2[1] === "hsv") {
    v2 = hsv2rgb(h3, p1, p2);
  } else {
    v2 = hsl2rgb(h3, p1, p2);
  }
  return {
    r: v2[0],
    g: v2[1],
    b: v2[2],
    a: a2
  };
}
__name(hueParse, "hueParse");
function rotate(v2, deg) {
  var h3 = rgb2hsl(v2);
  h3[0] = hue(h3[0] + deg);
  h3 = hsl2rgb(h3);
  v2.r = h3[0];
  v2.g = h3[1];
  v2.b = h3[2];
}
__name(rotate, "rotate");
function hslString(v2) {
  if (!v2) {
    return;
  }
  const a2 = rgb2hsl(v2);
  const h3 = a2[0];
  const s2 = n2p(a2[1]);
  const l2 = n2p(a2[2]);
  return v2.a < 255 ? `hsla(${h3}, ${s2}%, ${l2}%, ${b2n(v2.a)})` : `hsl(${h3}, ${s2}%, ${l2}%)`;
}
__name(hslString, "hslString");
const map = {
  x: "dark",
  Z: "light",
  Y: "re",
  X: "blu",
  W: "gr",
  V: "medium",
  U: "slate",
  A: "ee",
  T: "ol",
  S: "or",
  B: "ra",
  C: "lateg",
  D: "ights",
  R: "in",
  Q: "turquois",
  E: "hi",
  P: "ro",
  O: "al",
  N: "le",
  M: "de",
  L: "yello",
  F: "en",
  K: "ch",
  G: "arks",
  H: "ea",
  I: "ightg",
  J: "wh"
};
const names$1 = {
  OiceXe: "f0f8ff",
  antiquewEte: "faebd7",
  aqua: "ffff",
  aquamarRe: "7fffd4",
  azuY: "f0ffff",
  beige: "f5f5dc",
  bisque: "ffe4c4",
  black: "0",
  blanKedOmond: "ffebcd",
  Xe: "ff",
  XeviTet: "8a2be2",
  bPwn: "a52a2a",
  burlywood: "deb887",
  caMtXe: "5f9ea0",
  KartYuse: "7fff00",
  KocTate: "d2691e",
  cSO: "ff7f50",
  cSnflowerXe: "6495ed",
  cSnsilk: "fff8dc",
  crimson: "dc143c",
  cyan: "ffff",
  xXe: "8b",
  xcyan: "8b8b",
  xgTMnPd: "b8860b",
  xWay: "a9a9a9",
  xgYF: "6400",
  xgYy: "a9a9a9",
  xkhaki: "bdb76b",
  xmagFta: "8b008b",
  xTivegYF: "556b2f",
  xSange: "ff8c00",
  xScEd: "9932cc",
  xYd: "8b0000",
  xsOmon: "e9967a",
  xsHgYF: "8fbc8f",
  xUXe: "483d8b",
  xUWay: "2f4f4f",
  xUgYy: "2f4f4f",
  xQe: "ced1",
  xviTet: "9400d3",
  dAppRk: "ff1493",
  dApskyXe: "bfff",
  dimWay: "696969",
  dimgYy: "696969",
  dodgerXe: "1e90ff",
  fiYbrick: "b22222",
  flSOwEte: "fffaf0",
  foYstWAn: "228b22",
  fuKsia: "ff00ff",
  gaRsbSo: "dcdcdc",
  ghostwEte: "f8f8ff",
  gTd: "ffd700",
  gTMnPd: "daa520",
  Way: "808080",
  gYF: "8000",
  gYFLw: "adff2f",
  gYy: "808080",
  honeyMw: "f0fff0",
  hotpRk: "ff69b4",
  RdianYd: "cd5c5c",
  Rdigo: "4b0082",
  ivSy: "fffff0",
  khaki: "f0e68c",
  lavFMr: "e6e6fa",
  lavFMrXsh: "fff0f5",
  lawngYF: "7cfc00",
  NmoncEffon: "fffacd",
  ZXe: "add8e6",
  ZcSO: "f08080",
  Zcyan: "e0ffff",
  ZgTMnPdLw: "fafad2",
  ZWay: "d3d3d3",
  ZgYF: "90ee90",
  ZgYy: "d3d3d3",
  ZpRk: "ffb6c1",
  ZsOmon: "ffa07a",
  ZsHgYF: "20b2aa",
  ZskyXe: "87cefa",
  ZUWay: "778899",
  ZUgYy: "778899",
  ZstAlXe: "b0c4de",
  ZLw: "ffffe0",
  lime: "ff00",
  limegYF: "32cd32",
  lRF: "faf0e6",
  magFta: "ff00ff",
  maPon: "800000",
  VaquamarRe: "66cdaa",
  VXe: "cd",
  VScEd: "ba55d3",
  VpurpN: "9370db",
  VsHgYF: "3cb371",
  VUXe: "7b68ee",
  VsprRggYF: "fa9a",
  VQe: "48d1cc",
  VviTetYd: "c71585",
  midnightXe: "191970",
  mRtcYam: "f5fffa",
  mistyPse: "ffe4e1",
  moccasR: "ffe4b5",
  navajowEte: "ffdead",
  navy: "80",
  Tdlace: "fdf5e6",
  Tive: "808000",
  TivedBb: "6b8e23",
  Sange: "ffa500",
  SangeYd: "ff4500",
  ScEd: "da70d6",
  pOegTMnPd: "eee8aa",
  pOegYF: "98fb98",
  pOeQe: "afeeee",
  pOeviTetYd: "db7093",
  papayawEp: "ffefd5",
  pHKpuff: "ffdab9",
  peru: "cd853f",
  pRk: "ffc0cb",
  plum: "dda0dd",
  powMrXe: "b0e0e6",
  purpN: "800080",
  YbeccapurpN: "663399",
  Yd: "ff0000",
  Psybrown: "bc8f8f",
  PyOXe: "4169e1",
  saddNbPwn: "8b4513",
  sOmon: "fa8072",
  sandybPwn: "f4a460",
  sHgYF: "2e8b57",
  sHshell: "fff5ee",
  siFna: "a0522d",
  silver: "c0c0c0",
  skyXe: "87ceeb",
  UXe: "6a5acd",
  UWay: "708090",
  UgYy: "708090",
  snow: "fffafa",
  sprRggYF: "ff7f",
  stAlXe: "4682b4",
  tan: "d2b48c",
  teO: "8080",
  tEstN: "d8bfd8",
  tomato: "ff6347",
  Qe: "40e0d0",
  viTet: "ee82ee",
  JHt: "f5deb3",
  wEte: "ffffff",
  wEtesmoke: "f5f5f5",
  Lw: "ffff00",
  LwgYF: "9acd32"
};
function unpack() {
  const unpacked = {};
  const keys2 = Object.keys(names$1);
  const tkeys = Object.keys(map);
  let i2, j2, k2, ok, nk;
  for (i2 = 0; i2 < keys2.length; i2++) {
    ok = nk = keys2[i2];
    for (j2 = 0; j2 < tkeys.length; j2++) {
      k2 = tkeys[j2];
      nk = nk.replace(k2, map[k2]);
    }
    k2 = parseInt(names$1[ok], 16);
    unpacked[nk] = [k2 >> 16 & 255, k2 >> 8 & 255, k2 & 255];
  }
  return unpacked;
}
__name(unpack, "unpack");
let names;
function nameParse(str) {
  if (!names) {
    names = unpack();
    names.transparent = [0, 0, 0, 0];
  }
  const a2 = names[str.toLowerCase()];
  return a2 && {
    r: a2[0],
    g: a2[1],
    b: a2[2],
    a: a2.length === 4 ? a2[3] : 255
  };
}
__name(nameParse, "nameParse");
const RGB_RE = /^rgba?\(\s*([-+.\d]+)(%)?[\s,]+([-+.e\d]+)(%)?[\s,]+([-+.e\d]+)(%)?(?:[\s,/]+([-+.e\d]+)(%)?)?\s*\)$/;
function rgbParse(str) {
  const m2 = RGB_RE.exec(str);
  let a2 = 255;
  let r, g2, b2;
  if (!m2) {
    return;
  }
  if (m2[7] !== r) {
    const v2 = +m2[7];
    a2 = m2[8] ? p2b(v2) : lim(v2 * 255, 0, 255);
  }
  r = +m2[1];
  g2 = +m2[3];
  b2 = +m2[5];
  r = 255 & (m2[2] ? p2b(r) : lim(r, 0, 255));
  g2 = 255 & (m2[4] ? p2b(g2) : lim(g2, 0, 255));
  b2 = 255 & (m2[6] ? p2b(b2) : lim(b2, 0, 255));
  return {
    r,
    g: g2,
    b: b2,
    a: a2
  };
}
__name(rgbParse, "rgbParse");
function rgbString(v2) {
  return v2 && (v2.a < 255 ? `rgba(${v2.r}, ${v2.g}, ${v2.b}, ${b2n(v2.a)})` : `rgb(${v2.r}, ${v2.g}, ${v2.b})`);
}
__name(rgbString, "rgbString");
const to = /* @__PURE__ */ __name((v2) => v2 <= 31308e-7 ? v2 * 12.92 : Math.pow(v2, 1 / 2.4) * 1.055 - 0.055, "to");
const from = /* @__PURE__ */ __name((v2) => v2 <= 0.04045 ? v2 / 12.92 : Math.pow((v2 + 0.055) / 1.055, 2.4), "from");
function interpolate$1(rgb1, rgb2, t2) {
  const r = from(b2n(rgb1.r));
  const g2 = from(b2n(rgb1.g));
  const b2 = from(b2n(rgb1.b));
  return {
    r: n2b(to(r + t2 * (from(b2n(rgb2.r)) - r))),
    g: n2b(to(g2 + t2 * (from(b2n(rgb2.g)) - g2))),
    b: n2b(to(b2 + t2 * (from(b2n(rgb2.b)) - b2))),
    a: rgb1.a + t2 * (rgb2.a - rgb1.a)
  };
}
__name(interpolate$1, "interpolate$1");
function modHSL(v2, i2, ratio) {
  if (v2) {
    let tmp = rgb2hsl(v2);
    tmp[i2] = Math.max(0, Math.min(tmp[i2] + tmp[i2] * ratio, i2 === 0 ? 360 : 1));
    tmp = hsl2rgb(tmp);
    v2.r = tmp[0];
    v2.g = tmp[1];
    v2.b = tmp[2];
  }
}
__name(modHSL, "modHSL");
function clone$1(v2, proto) {
  return v2 ? Object.assign(proto || {}, v2) : v2;
}
__name(clone$1, "clone$1");
function fromObject(input) {
  var v2 = { r: 0, g: 0, b: 0, a: 255 };
  if (Array.isArray(input)) {
    if (input.length >= 3) {
      v2 = { r: input[0], g: input[1], b: input[2], a: 255 };
      if (input.length > 3) {
        v2.a = n2b(input[3]);
      }
    }
  } else {
    v2 = clone$1(input, { r: 0, g: 0, b: 0, a: 1 });
    v2.a = n2b(v2.a);
  }
  return v2;
}
__name(fromObject, "fromObject");
function functionParse(str) {
  if (str.charAt(0) === "r") {
    return rgbParse(str);
  }
  return hueParse(str);
}
__name(functionParse, "functionParse");
const _Color = class _Color {
  constructor(input) {
    if (input instanceof _Color) {
      return input;
    }
    const type = typeof input;
    let v2;
    if (type === "object") {
      v2 = fromObject(input);
    } else if (type === "string") {
      v2 = hexParse(input) || nameParse(input) || functionParse(input);
    }
    this._rgb = v2;
    this._valid = !!v2;
  }
  get valid() {
    return this._valid;
  }
  get rgb() {
    var v2 = clone$1(this._rgb);
    if (v2) {
      v2.a = b2n(v2.a);
    }
    return v2;
  }
  set rgb(obj) {
    this._rgb = fromObject(obj);
  }
  rgbString() {
    return this._valid ? rgbString(this._rgb) : void 0;
  }
  hexString() {
    return this._valid ? hexString(this._rgb) : void 0;
  }
  hslString() {
    return this._valid ? hslString(this._rgb) : void 0;
  }
  mix(color2, weight) {
    if (color2) {
      const c1 = this.rgb;
      const c2 = color2.rgb;
      let w2;
      const p2 = weight === w2 ? 0.5 : weight;
      const w3 = 2 * p2 - 1;
      const a2 = c1.a - c2.a;
      const w1 = ((w3 * a2 === -1 ? w3 : (w3 + a2) / (1 + w3 * a2)) + 1) / 2;
      w2 = 1 - w1;
      c1.r = 255 & w1 * c1.r + w2 * c2.r + 0.5;
      c1.g = 255 & w1 * c1.g + w2 * c2.g + 0.5;
      c1.b = 255 & w1 * c1.b + w2 * c2.b + 0.5;
      c1.a = p2 * c1.a + (1 - p2) * c2.a;
      this.rgb = c1;
    }
    return this;
  }
  interpolate(color2, t2) {
    if (color2) {
      this._rgb = interpolate$1(this._rgb, color2._rgb, t2);
    }
    return this;
  }
  clone() {
    return new _Color(this.rgb);
  }
  alpha(a2) {
    this._rgb.a = n2b(a2);
    return this;
  }
  clearer(ratio) {
    const rgb = this._rgb;
    rgb.a *= 1 - ratio;
    return this;
  }
  greyscale() {
    const rgb = this._rgb;
    const val = round(rgb.r * 0.3 + rgb.g * 0.59 + rgb.b * 0.11);
    rgb.r = rgb.g = rgb.b = val;
    return this;
  }
  opaquer(ratio) {
    const rgb = this._rgb;
    rgb.a *= 1 + ratio;
    return this;
  }
  negate() {
    const v2 = this._rgb;
    v2.r = 255 - v2.r;
    v2.g = 255 - v2.g;
    v2.b = 255 - v2.b;
    return this;
  }
  lighten(ratio) {
    modHSL(this._rgb, 2, ratio);
    return this;
  }
  darken(ratio) {
    modHSL(this._rgb, 2, -ratio);
    return this;
  }
  saturate(ratio) {
    modHSL(this._rgb, 1, ratio);
    return this;
  }
  desaturate(ratio) {
    modHSL(this._rgb, 1, -ratio);
    return this;
  }
  rotate(deg) {
    rotate(this._rgb, deg);
    return this;
  }
};
__name(_Color, "Color");
let Color = _Color;
/*!
 * Chart.js v4.5.1
 * https://www.chartjs.org
 * (c) 2025 Chart.js Contributors
 * Released under the MIT License
 */
function noop() {
}
__name(noop, "noop");
const uid = (() => {
  let id = 0;
  return () => id++;
})();
function isNullOrUndef(value) {
  return value === null || value === void 0;
}
__name(isNullOrUndef, "isNullOrUndef");
function isArray(value) {
  if (Array.isArray && Array.isArray(value)) {
    return true;
  }
  const type = Object.prototype.toString.call(value);
  if (type.slice(0, 7) === "[object" && type.slice(-6) === "Array]") {
    return true;
  }
  return false;
}
__name(isArray, "isArray");
function isObject(value) {
  return value !== null && Object.prototype.toString.call(value) === "[object Object]";
}
__name(isObject, "isObject");
function isNumberFinite(value) {
  return (typeof value === "number" || value instanceof Number) && isFinite(+value);
}
__name(isNumberFinite, "isNumberFinite");
function finiteOrDefault(value, defaultValue) {
  return isNumberFinite(value) ? value : defaultValue;
}
__name(finiteOrDefault, "finiteOrDefault");
function valueOrDefault(value, defaultValue) {
  return typeof value === "undefined" ? defaultValue : value;
}
__name(valueOrDefault, "valueOrDefault");
const toPercentage = /* @__PURE__ */ __name((value, dimension) => typeof value === "string" && value.endsWith("%") ? parseFloat(value) / 100 : +value / dimension, "toPercentage");
const toDimension = /* @__PURE__ */ __name((value, dimension) => typeof value === "string" && value.endsWith("%") ? parseFloat(value) / 100 * dimension : +value, "toDimension");
function callback(fn, args, thisArg) {
  if (fn && typeof fn.call === "function") {
    return fn.apply(thisArg, args);
  }
}
__name(callback, "callback");
function each(loopable, fn, thisArg, reverse) {
  let i2, len, keys2;
  if (isArray(loopable)) {
    len = loopable.length;
    if (reverse) {
      for (i2 = len - 1; i2 >= 0; i2--) {
        fn.call(thisArg, loopable[i2], i2);
      }
    } else {
      for (i2 = 0; i2 < len; i2++) {
        fn.call(thisArg, loopable[i2], i2);
      }
    }
  } else if (isObject(loopable)) {
    keys2 = Object.keys(loopable);
    len = keys2.length;
    for (i2 = 0; i2 < len; i2++) {
      fn.call(thisArg, loopable[keys2[i2]], keys2[i2]);
    }
  }
}
__name(each, "each");
function _elementsEqual(a0, a1) {
  let i2, ilen, v0, v1;
  if (!a0 || !a1 || a0.length !== a1.length) {
    return false;
  }
  for (i2 = 0, ilen = a0.length; i2 < ilen; ++i2) {
    v0 = a0[i2];
    v1 = a1[i2];
    if (v0.datasetIndex !== v1.datasetIndex || v0.index !== v1.index) {
      return false;
    }
  }
  return true;
}
__name(_elementsEqual, "_elementsEqual");
function clone(source) {
  if (isArray(source)) {
    return source.map(clone);
  }
  if (isObject(source)) {
    const target = /* @__PURE__ */ Object.create(null);
    const keys2 = Object.keys(source);
    const klen = keys2.length;
    let k2 = 0;
    for (; k2 < klen; ++k2) {
      target[keys2[k2]] = clone(source[keys2[k2]]);
    }
    return target;
  }
  return source;
}
__name(clone, "clone");
function isValidKey(key) {
  return [
    "__proto__",
    "prototype",
    "constructor"
  ].indexOf(key) === -1;
}
__name(isValidKey, "isValidKey");
function _merger(key, target, source, options) {
  if (!isValidKey(key)) {
    return;
  }
  const tval = target[key];
  const sval = source[key];
  if (isObject(tval) && isObject(sval)) {
    merge(tval, sval, options);
  } else {
    target[key] = clone(sval);
  }
}
__name(_merger, "_merger");
function merge(target, source, options) {
  const sources = isArray(source) ? source : [
    source
  ];
  const ilen = sources.length;
  if (!isObject(target)) {
    return target;
  }
  options = options || {};
  const merger = options.merger || _merger;
  let current;
  for (let i2 = 0; i2 < ilen; ++i2) {
    current = sources[i2];
    if (!isObject(current)) {
      continue;
    }
    const keys2 = Object.keys(current);
    for (let k2 = 0, klen = keys2.length; k2 < klen; ++k2) {
      merger(keys2[k2], target, current, options);
    }
  }
  return target;
}
__name(merge, "merge");
function mergeIf(target, source) {
  return merge(target, source, {
    merger: _mergerIf
  });
}
__name(mergeIf, "mergeIf");
function _mergerIf(key, target, source) {
  if (!isValidKey(key)) {
    return;
  }
  const tval = target[key];
  const sval = source[key];
  if (isObject(tval) && isObject(sval)) {
    mergeIf(tval, sval);
  } else if (!Object.prototype.hasOwnProperty.call(target, key)) {
    target[key] = clone(sval);
  }
}
__name(_mergerIf, "_mergerIf");
const keyResolvers = {
  // Chart.helpers.core resolveObjectKey should resolve empty key to root object
  "": (v2) => v2,
  // default resolvers
  x: (o2) => o2.x,
  y: (o2) => o2.y
};
function _splitKey(key) {
  const parts = key.split(".");
  const keys2 = [];
  let tmp = "";
  for (const part of parts) {
    tmp += part;
    if (tmp.endsWith("\\")) {
      tmp = tmp.slice(0, -1) + ".";
    } else {
      keys2.push(tmp);
      tmp = "";
    }
  }
  return keys2;
}
__name(_splitKey, "_splitKey");
function _getKeyResolver(key) {
  const keys2 = _splitKey(key);
  return (obj) => {
    for (const k2 of keys2) {
      if (k2 === "") {
        break;
      }
      obj = obj && obj[k2];
    }
    return obj;
  };
}
__name(_getKeyResolver, "_getKeyResolver");
function resolveObjectKey(obj, key) {
  const resolver = keyResolvers[key] || (keyResolvers[key] = _getKeyResolver(key));
  return resolver(obj);
}
__name(resolveObjectKey, "resolveObjectKey");
function _capitalize(str) {
  return str.charAt(0).toUpperCase() + str.slice(1);
}
__name(_capitalize, "_capitalize");
const defined = /* @__PURE__ */ __name((value) => typeof value !== "undefined", "defined");
const isFunction = /* @__PURE__ */ __name((value) => typeof value === "function", "isFunction");
const setsEqual = /* @__PURE__ */ __name((a2, b2) => {
  if (a2.size !== b2.size) {
    return false;
  }
  for (const item of a2) {
    if (!b2.has(item)) {
      return false;
    }
  }
  return true;
}, "setsEqual");
function _isClickEvent(e) {
  return e.type === "mouseup" || e.type === "click" || e.type === "contextmenu";
}
__name(_isClickEvent, "_isClickEvent");
const PI = Math.PI;
const TAU = 2 * PI;
const PITAU = TAU + PI;
const INFINITY = Number.POSITIVE_INFINITY;
const RAD_PER_DEG = PI / 180;
const HALF_PI = PI / 2;
const QUARTER_PI = PI / 4;
const TWO_THIRDS_PI = PI * 2 / 3;
const log10 = Math.log10;
const sign = Math.sign;
function almostEquals(x2, y2, epsilon) {
  return Math.abs(x2 - y2) < epsilon;
}
__name(almostEquals, "almostEquals");
function niceNum(range) {
  const roundedRange = Math.round(range);
  range = almostEquals(range, roundedRange, range / 1e3) ? roundedRange : range;
  const niceRange = Math.pow(10, Math.floor(log10(range)));
  const fraction = range / niceRange;
  const niceFraction = fraction <= 1 ? 1 : fraction <= 2 ? 2 : fraction <= 5 ? 5 : 10;
  return niceFraction * niceRange;
}
__name(niceNum, "niceNum");
function _factorize(value) {
  const result = [];
  const sqrt = Math.sqrt(value);
  let i2;
  for (i2 = 1; i2 < sqrt; i2++) {
    if (value % i2 === 0) {
      result.push(i2);
      result.push(value / i2);
    }
  }
  if (sqrt === (sqrt | 0)) {
    result.push(sqrt);
  }
  result.sort((a2, b2) => a2 - b2).pop();
  return result;
}
__name(_factorize, "_factorize");
function isNonPrimitive(n2) {
  return typeof n2 === "symbol" || typeof n2 === "object" && n2 !== null && !(Symbol.toPrimitive in n2 || "toString" in n2 || "valueOf" in n2);
}
__name(isNonPrimitive, "isNonPrimitive");
function isNumber(n2) {
  return !isNonPrimitive(n2) && !isNaN(parseFloat(n2)) && isFinite(n2);
}
__name(isNumber, "isNumber");
function almostWhole(x2, epsilon) {
  const rounded = Math.round(x2);
  return rounded - epsilon <= x2 && rounded + epsilon >= x2;
}
__name(almostWhole, "almostWhole");
function _setMinAndMaxByKey(array, target, property) {
  let i2, ilen, value;
  for (i2 = 0, ilen = array.length; i2 < ilen; i2++) {
    value = array[i2][property];
    if (!isNaN(value)) {
      target.min = Math.min(target.min, value);
      target.max = Math.max(target.max, value);
    }
  }
}
__name(_setMinAndMaxByKey, "_setMinAndMaxByKey");
function toRadians(degrees) {
  return degrees * (PI / 180);
}
__name(toRadians, "toRadians");
function toDegrees(radians) {
  return radians * (180 / PI);
}
__name(toDegrees, "toDegrees");
function _decimalPlaces(x2) {
  if (!isNumberFinite(x2)) {
    return;
  }
  let e = 1;
  let p2 = 0;
  while (Math.round(x2 * e) / e !== x2) {
    e *= 10;
    p2++;
  }
  return p2;
}
__name(_decimalPlaces, "_decimalPlaces");
function getAngleFromPoint(centrePoint, anglePoint) {
  const distanceFromXCenter = anglePoint.x - centrePoint.x;
  const distanceFromYCenter = anglePoint.y - centrePoint.y;
  const radialDistanceFromCenter = Math.sqrt(distanceFromXCenter * distanceFromXCenter + distanceFromYCenter * distanceFromYCenter);
  let angle = Math.atan2(distanceFromYCenter, distanceFromXCenter);
  if (angle < -0.5 * PI) {
    angle += TAU;
  }
  return {
    angle,
    distance: radialDistanceFromCenter
  };
}
__name(getAngleFromPoint, "getAngleFromPoint");
function distanceBetweenPoints(pt1, pt2) {
  return Math.sqrt(Math.pow(pt2.x - pt1.x, 2) + Math.pow(pt2.y - pt1.y, 2));
}
__name(distanceBetweenPoints, "distanceBetweenPoints");
function _angleDiff(a2, b2) {
  return (a2 - b2 + PITAU) % TAU - PI;
}
__name(_angleDiff, "_angleDiff");
function _normalizeAngle(a2) {
  return (a2 % TAU + TAU) % TAU;
}
__name(_normalizeAngle, "_normalizeAngle");
function _angleBetween(angle, start, end, sameAngleIsFullCircle) {
  const a2 = _normalizeAngle(angle);
  const s2 = _normalizeAngle(start);
  const e = _normalizeAngle(end);
  const angleToStart = _normalizeAngle(s2 - a2);
  const angleToEnd = _normalizeAngle(e - a2);
  const startToAngle = _normalizeAngle(a2 - s2);
  const endToAngle = _normalizeAngle(a2 - e);
  return a2 === s2 || a2 === e || sameAngleIsFullCircle && s2 === e || angleToStart > angleToEnd && startToAngle < endToAngle;
}
__name(_angleBetween, "_angleBetween");
function _limitValue(value, min, max2) {
  return Math.max(min, Math.min(max2, value));
}
__name(_limitValue, "_limitValue");
function _int16Range(value) {
  return _limitValue(value, -32768, 32767);
}
__name(_int16Range, "_int16Range");
function _isBetween(value, start, end, epsilon = 1e-6) {
  return value >= Math.min(start, end) - epsilon && value <= Math.max(start, end) + epsilon;
}
__name(_isBetween, "_isBetween");
function _lookup(table, value, cmp) {
  cmp = cmp || ((index2) => table[index2] < value);
  let hi = table.length - 1;
  let lo = 0;
  let mid;
  while (hi - lo > 1) {
    mid = lo + hi >> 1;
    if (cmp(mid)) {
      lo = mid;
    } else {
      hi = mid;
    }
  }
  return {
    lo,
    hi
  };
}
__name(_lookup, "_lookup");
const _lookupByKey = /* @__PURE__ */ __name((table, key, value, last) => _lookup(table, value, last ? (index2) => {
  const ti = table[index2][key];
  return ti < value || ti === value && table[index2 + 1][key] === value;
} : (index2) => table[index2][key] < value), "_lookupByKey");
const _rlookupByKey = /* @__PURE__ */ __name((table, key, value) => _lookup(table, value, (index2) => table[index2][key] >= value), "_rlookupByKey");
function _filterBetween(values, min, max2) {
  let start = 0;
  let end = values.length;
  while (start < end && values[start] < min) {
    start++;
  }
  while (end > start && values[end - 1] > max2) {
    end--;
  }
  return start > 0 || end < values.length ? values.slice(start, end) : values;
}
__name(_filterBetween, "_filterBetween");
const arrayEvents = [
  "push",
  "pop",
  "shift",
  "splice",
  "unshift"
];
function listenArrayEvents(array, listener) {
  if (array._chartjs) {
    array._chartjs.listeners.push(listener);
    return;
  }
  Object.defineProperty(array, "_chartjs", {
    configurable: true,
    enumerable: false,
    value: {
      listeners: [
        listener
      ]
    }
  });
  arrayEvents.forEach((key) => {
    const method = "_onData" + _capitalize(key);
    const base = array[key];
    Object.defineProperty(array, key, {
      configurable: true,
      enumerable: false,
      value(...args) {
        const res = base.apply(this, args);
        array._chartjs.listeners.forEach((object) => {
          if (typeof object[method] === "function") {
            object[method](...args);
          }
        });
        return res;
      }
    });
  });
}
__name(listenArrayEvents, "listenArrayEvents");
function unlistenArrayEvents(array, listener) {
  const stub = array._chartjs;
  if (!stub) {
    return;
  }
  const listeners = stub.listeners;
  const index2 = listeners.indexOf(listener);
  if (index2 !== -1) {
    listeners.splice(index2, 1);
  }
  if (listeners.length > 0) {
    return;
  }
  arrayEvents.forEach((key) => {
    delete array[key];
  });
  delete array._chartjs;
}
__name(unlistenArrayEvents, "unlistenArrayEvents");
function _arrayUnique(items) {
  const set2 = new Set(items);
  if (set2.size === items.length) {
    return items;
  }
  return Array.from(set2);
}
__name(_arrayUnique, "_arrayUnique");
const requestAnimFrame = function() {
  if (typeof window === "undefined") {
    return function(callback2) {
      return callback2();
    };
  }
  return window.requestAnimationFrame;
}();
function throttled(fn, thisArg) {
  let argsToUse = [];
  let ticking = false;
  return function(...args) {
    argsToUse = args;
    if (!ticking) {
      ticking = true;
      requestAnimFrame.call(window, () => {
        ticking = false;
        fn.apply(thisArg, argsToUse);
      });
    }
  };
}
__name(throttled, "throttled");
function debounce(fn, delay) {
  let timeout;
  return function(...args) {
    if (delay) {
      clearTimeout(timeout);
      timeout = setTimeout(fn, delay, args);
    } else {
      fn.apply(this, args);
    }
    return delay;
  };
}
__name(debounce, "debounce");
const _toLeftRightCenter = /* @__PURE__ */ __name((align) => align === "start" ? "left" : align === "end" ? "right" : "center", "_toLeftRightCenter");
const _alignStartEnd = /* @__PURE__ */ __name((align, start, end) => align === "start" ? start : align === "end" ? end : (start + end) / 2, "_alignStartEnd");
const _textX = /* @__PURE__ */ __name((align, left, right, rtl) => {
  const check = rtl ? "left" : "right";
  return align === check ? right : align === "center" ? (left + right) / 2 : left;
}, "_textX");
function _getStartAndCountOfVisiblePoints(meta, points, animationsDisabled) {
  const pointCount = points.length;
  let start = 0;
  let count = pointCount;
  if (meta._sorted) {
    const { iScale, vScale, _parsed } = meta;
    const spanGaps = meta.dataset ? meta.dataset.options ? meta.dataset.options.spanGaps : null : null;
    const axis = iScale.axis;
    const { min, max: max2, minDefined, maxDefined } = iScale.getUserBounds();
    if (minDefined) {
      start = Math.min(
        // @ts-expect-error Need to type _parsed
        _lookupByKey(_parsed, axis, min).lo,
        // @ts-expect-error Need to fix types on _lookupByKey
        animationsDisabled ? pointCount : _lookupByKey(points, axis, iScale.getPixelForValue(min)).lo
      );
      if (spanGaps) {
        const distanceToDefinedLo = _parsed.slice(0, start + 1).reverse().findIndex((point) => !isNullOrUndef(point[vScale.axis]));
        start -= Math.max(0, distanceToDefinedLo);
      }
      start = _limitValue(start, 0, pointCount - 1);
    }
    if (maxDefined) {
      let end = Math.max(
        // @ts-expect-error Need to type _parsed
        _lookupByKey(_parsed, iScale.axis, max2, true).hi + 1,
        // @ts-expect-error Need to fix types on _lookupByKey
        animationsDisabled ? 0 : _lookupByKey(points, axis, iScale.getPixelForValue(max2), true).hi + 1
      );
      if (spanGaps) {
        const distanceToDefinedHi = _parsed.slice(end - 1).findIndex((point) => !isNullOrUndef(point[vScale.axis]));
        end += Math.max(0, distanceToDefinedHi);
      }
      count = _limitValue(end, start, pointCount) - start;
    } else {
      count = pointCount - start;
    }
  }
  return {
    start,
    count
  };
}
__name(_getStartAndCountOfVisiblePoints, "_getStartAndCountOfVisiblePoints");
function _scaleRangesChanged(meta) {
  const { xScale, yScale, _scaleRanges } = meta;
  const newRanges = {
    xmin: xScale.min,
    xmax: xScale.max,
    ymin: yScale.min,
    ymax: yScale.max
  };
  if (!_scaleRanges) {
    meta._scaleRanges = newRanges;
    return true;
  }
  const changed = _scaleRanges.xmin !== xScale.min || _scaleRanges.xmax !== xScale.max || _scaleRanges.ymin !== yScale.min || _scaleRanges.ymax !== yScale.max;
  Object.assign(_scaleRanges, newRanges);
  return changed;
}
__name(_scaleRangesChanged, "_scaleRangesChanged");
const atEdge = /* @__PURE__ */ __name((t2) => t2 === 0 || t2 === 1, "atEdge");
const elasticIn = /* @__PURE__ */ __name((t2, s2, p2) => -(Math.pow(2, 10 * (t2 -= 1)) * Math.sin((t2 - s2) * TAU / p2)), "elasticIn");
const elasticOut = /* @__PURE__ */ __name((t2, s2, p2) => Math.pow(2, -10 * t2) * Math.sin((t2 - s2) * TAU / p2) + 1, "elasticOut");
const effects = {
  linear: (t2) => t2,
  easeInQuad: (t2) => t2 * t2,
  easeOutQuad: (t2) => -t2 * (t2 - 2),
  easeInOutQuad: (t2) => (t2 /= 0.5) < 1 ? 0.5 * t2 * t2 : -0.5 * (--t2 * (t2 - 2) - 1),
  easeInCubic: (t2) => t2 * t2 * t2,
  easeOutCubic: (t2) => (t2 -= 1) * t2 * t2 + 1,
  easeInOutCubic: (t2) => (t2 /= 0.5) < 1 ? 0.5 * t2 * t2 * t2 : 0.5 * ((t2 -= 2) * t2 * t2 + 2),
  easeInQuart: (t2) => t2 * t2 * t2 * t2,
  easeOutQuart: (t2) => -((t2 -= 1) * t2 * t2 * t2 - 1),
  easeInOutQuart: (t2) => (t2 /= 0.5) < 1 ? 0.5 * t2 * t2 * t2 * t2 : -0.5 * ((t2 -= 2) * t2 * t2 * t2 - 2),
  easeInQuint: (t2) => t2 * t2 * t2 * t2 * t2,
  easeOutQuint: (t2) => (t2 -= 1) * t2 * t2 * t2 * t2 + 1,
  easeInOutQuint: (t2) => (t2 /= 0.5) < 1 ? 0.5 * t2 * t2 * t2 * t2 * t2 : 0.5 * ((t2 -= 2) * t2 * t2 * t2 * t2 + 2),
  easeInSine: (t2) => -Math.cos(t2 * HALF_PI) + 1,
  easeOutSine: (t2) => Math.sin(t2 * HALF_PI),
  easeInOutSine: (t2) => -0.5 * (Math.cos(PI * t2) - 1),
  easeInExpo: (t2) => t2 === 0 ? 0 : Math.pow(2, 10 * (t2 - 1)),
  easeOutExpo: (t2) => t2 === 1 ? 1 : -Math.pow(2, -10 * t2) + 1,
  easeInOutExpo: (t2) => atEdge(t2) ? t2 : t2 < 0.5 ? 0.5 * Math.pow(2, 10 * (t2 * 2 - 1)) : 0.5 * (-Math.pow(2, -10 * (t2 * 2 - 1)) + 2),
  easeInCirc: (t2) => t2 >= 1 ? t2 : -(Math.sqrt(1 - t2 * t2) - 1),
  easeOutCirc: (t2) => Math.sqrt(1 - (t2 -= 1) * t2),
  easeInOutCirc: (t2) => (t2 /= 0.5) < 1 ? -0.5 * (Math.sqrt(1 - t2 * t2) - 1) : 0.5 * (Math.sqrt(1 - (t2 -= 2) * t2) + 1),
  easeInElastic: (t2) => atEdge(t2) ? t2 : elasticIn(t2, 0.075, 0.3),
  easeOutElastic: (t2) => atEdge(t2) ? t2 : elasticOut(t2, 0.075, 0.3),
  easeInOutElastic(t2) {
    const s2 = 0.1125;
    const p2 = 0.45;
    return atEdge(t2) ? t2 : t2 < 0.5 ? 0.5 * elasticIn(t2 * 2, s2, p2) : 0.5 + 0.5 * elasticOut(t2 * 2 - 1, s2, p2);
  },
  easeInBack(t2) {
    const s2 = 1.70158;
    return t2 * t2 * ((s2 + 1) * t2 - s2);
  },
  easeOutBack(t2) {
    const s2 = 1.70158;
    return (t2 -= 1) * t2 * ((s2 + 1) * t2 + s2) + 1;
  },
  easeInOutBack(t2) {
    let s2 = 1.70158;
    if ((t2 /= 0.5) < 1) {
      return 0.5 * (t2 * t2 * (((s2 *= 1.525) + 1) * t2 - s2));
    }
    return 0.5 * ((t2 -= 2) * t2 * (((s2 *= 1.525) + 1) * t2 + s2) + 2);
  },
  easeInBounce: (t2) => 1 - effects.easeOutBounce(1 - t2),
  easeOutBounce(t2) {
    const m2 = 7.5625;
    const d2 = 2.75;
    if (t2 < 1 / d2) {
      return m2 * t2 * t2;
    }
    if (t2 < 2 / d2) {
      return m2 * (t2 -= 1.5 / d2) * t2 + 0.75;
    }
    if (t2 < 2.5 / d2) {
      return m2 * (t2 -= 2.25 / d2) * t2 + 0.9375;
    }
    return m2 * (t2 -= 2.625 / d2) * t2 + 0.984375;
  },
  easeInOutBounce: (t2) => t2 < 0.5 ? effects.easeInBounce(t2 * 2) * 0.5 : effects.easeOutBounce(t2 * 2 - 1) * 0.5 + 0.5
};
function isPatternOrGradient(value) {
  if (value && typeof value === "object") {
    const type = value.toString();
    return type === "[object CanvasPattern]" || type === "[object CanvasGradient]";
  }
  return false;
}
__name(isPatternOrGradient, "isPatternOrGradient");
function color(value) {
  return isPatternOrGradient(value) ? value : new Color(value);
}
__name(color, "color");
function getHoverColor(value) {
  return isPatternOrGradient(value) ? value : new Color(value).saturate(0.5).darken(0.1).hexString();
}
__name(getHoverColor, "getHoverColor");
const numbers = [
  "x",
  "y",
  "borderWidth",
  "radius",
  "tension"
];
const colors = [
  "color",
  "borderColor",
  "backgroundColor"
];
function applyAnimationsDefaults(defaults2) {
  defaults2.set("animation", {
    delay: void 0,
    duration: 1e3,
    easing: "easeOutQuart",
    fn: void 0,
    from: void 0,
    loop: void 0,
    to: void 0,
    type: void 0
  });
  defaults2.describe("animation", {
    _fallback: false,
    _indexable: false,
    _scriptable: (name) => name !== "onProgress" && name !== "onComplete" && name !== "fn"
  });
  defaults2.set("animations", {
    colors: {
      type: "color",
      properties: colors
    },
    numbers: {
      type: "number",
      properties: numbers
    }
  });
  defaults2.describe("animations", {
    _fallback: "animation"
  });
  defaults2.set("transitions", {
    active: {
      animation: {
        duration: 400
      }
    },
    resize: {
      animation: {
        duration: 0
      }
    },
    show: {
      animations: {
        colors: {
          from: "transparent"
        },
        visible: {
          type: "boolean",
          duration: 0
        }
      }
    },
    hide: {
      animations: {
        colors: {
          to: "transparent"
        },
        visible: {
          type: "boolean",
          easing: "linear",
          fn: (v2) => v2 | 0
        }
      }
    }
  });
}
__name(applyAnimationsDefaults, "applyAnimationsDefaults");
function applyLayoutsDefaults(defaults2) {
  defaults2.set("layout", {
    autoPadding: true,
    padding: {
      top: 0,
      right: 0,
      bottom: 0,
      left: 0
    }
  });
}
__name(applyLayoutsDefaults, "applyLayoutsDefaults");
const intlCache = /* @__PURE__ */ new Map();
function getNumberFormat(locale, options) {
  options = options || {};
  const cacheKey = locale + JSON.stringify(options);
  let formatter = intlCache.get(cacheKey);
  if (!formatter) {
    formatter = new Intl.NumberFormat(locale, options);
    intlCache.set(cacheKey, formatter);
  }
  return formatter;
}
__name(getNumberFormat, "getNumberFormat");
function formatNumber(num, locale, options) {
  return getNumberFormat(locale, options).format(num);
}
__name(formatNumber, "formatNumber");
const formatters = {
  values(value) {
    return isArray(value) ? value : "" + value;
  },
  numeric(tickValue, index2, ticks) {
    if (tickValue === 0) {
      return "0";
    }
    const locale = this.chart.options.locale;
    let notation;
    let delta = tickValue;
    if (ticks.length > 1) {
      const maxTick = Math.max(Math.abs(ticks[0].value), Math.abs(ticks[ticks.length - 1].value));
      if (maxTick < 1e-4 || maxTick > 1e15) {
        notation = "scientific";
      }
      delta = calculateDelta(tickValue, ticks);
    }
    const logDelta = log10(Math.abs(delta));
    const numDecimal = isNaN(logDelta) ? 1 : Math.max(Math.min(-1 * Math.floor(logDelta), 20), 0);
    const options = {
      notation,
      minimumFractionDigits: numDecimal,
      maximumFractionDigits: numDecimal
    };
    Object.assign(options, this.options.ticks.format);
    return formatNumber(tickValue, locale, options);
  },
  logarithmic(tickValue, index2, ticks) {
    if (tickValue === 0) {
      return "0";
    }
    const remain = ticks[index2].significand || tickValue / Math.pow(10, Math.floor(log10(tickValue)));
    if ([
      1,
      2,
      3,
      5,
      10,
      15
    ].includes(remain) || index2 > 0.8 * ticks.length) {
      return formatters.numeric.call(this, tickValue, index2, ticks);
    }
    return "";
  }
};
function calculateDelta(tickValue, ticks) {
  let delta = ticks.length > 3 ? ticks[2].value - ticks[1].value : ticks[1].value - ticks[0].value;
  if (Math.abs(delta) >= 1 && tickValue !== Math.floor(tickValue)) {
    delta = tickValue - Math.floor(tickValue);
  }
  return delta;
}
__name(calculateDelta, "calculateDelta");
var Ticks = {
  formatters
};
function applyScaleDefaults(defaults2) {
  defaults2.set("scale", {
    display: true,
    offset: false,
    reverse: false,
    beginAtZero: false,
    bounds: "ticks",
    clip: true,
    grace: 0,
    grid: {
      display: true,
      lineWidth: 1,
      drawOnChartArea: true,
      drawTicks: true,
      tickLength: 8,
      tickWidth: (_ctx, options) => options.lineWidth,
      tickColor: (_ctx, options) => options.color,
      offset: false
    },
    border: {
      display: true,
      dash: [],
      dashOffset: 0,
      width: 1
    },
    title: {
      display: false,
      text: "",
      padding: {
        top: 4,
        bottom: 4
      }
    },
    ticks: {
      minRotation: 0,
      maxRotation: 50,
      mirror: false,
      textStrokeWidth: 0,
      textStrokeColor: "",
      padding: 3,
      display: true,
      autoSkip: true,
      autoSkipPadding: 3,
      labelOffset: 0,
      callback: Ticks.formatters.values,
      minor: {},
      major: {},
      align: "center",
      crossAlign: "near",
      showLabelBackdrop: false,
      backdropColor: "rgba(255, 255, 255, 0.75)",
      backdropPadding: 2
    }
  });
  defaults2.route("scale.ticks", "color", "", "color");
  defaults2.route("scale.grid", "color", "", "borderColor");
  defaults2.route("scale.border", "color", "", "borderColor");
  defaults2.route("scale.title", "color", "", "color");
  defaults2.describe("scale", {
    _fallback: false,
    _scriptable: (name) => !name.startsWith("before") && !name.startsWith("after") && name !== "callback" && name !== "parser",
    _indexable: (name) => name !== "borderDash" && name !== "tickBorderDash" && name !== "dash"
  });
  defaults2.describe("scales", {
    _fallback: "scale"
  });
  defaults2.describe("scale.ticks", {
    _scriptable: (name) => name !== "backdropPadding" && name !== "callback",
    _indexable: (name) => name !== "backdropPadding"
  });
}
__name(applyScaleDefaults, "applyScaleDefaults");
const overrides = /* @__PURE__ */ Object.create(null);
const descriptors = /* @__PURE__ */ Object.create(null);
function getScope$1(node, key) {
  if (!key) {
    return node;
  }
  const keys2 = key.split(".");
  for (let i2 = 0, n2 = keys2.length; i2 < n2; ++i2) {
    const k2 = keys2[i2];
    node = node[k2] || (node[k2] = /* @__PURE__ */ Object.create(null));
  }
  return node;
}
__name(getScope$1, "getScope$1");
function set(root, scope, values) {
  if (typeof scope === "string") {
    return merge(getScope$1(root, scope), values);
  }
  return merge(getScope$1(root, ""), scope);
}
__name(set, "set");
const _Defaults = class _Defaults {
  constructor(_descriptors2, _appliers) {
    this.animation = void 0;
    this.backgroundColor = "rgba(0,0,0,0.1)";
    this.borderColor = "rgba(0,0,0,0.1)";
    this.color = "#666";
    this.datasets = {};
    this.devicePixelRatio = (context) => context.chart.platform.getDevicePixelRatio();
    this.elements = {};
    this.events = [
      "mousemove",
      "mouseout",
      "click",
      "touchstart",
      "touchmove"
    ];
    this.font = {
      family: "'Helvetica Neue', 'Helvetica', 'Arial', sans-serif",
      size: 12,
      style: "normal",
      lineHeight: 1.2,
      weight: null
    };
    this.hover = {};
    this.hoverBackgroundColor = (ctx, options) => getHoverColor(options.backgroundColor);
    this.hoverBorderColor = (ctx, options) => getHoverColor(options.borderColor);
    this.hoverColor = (ctx, options) => getHoverColor(options.color);
    this.indexAxis = "x";
    this.interaction = {
      mode: "nearest",
      intersect: true,
      includeInvisible: false
    };
    this.maintainAspectRatio = true;
    this.onHover = null;
    this.onClick = null;
    this.parsing = true;
    this.plugins = {};
    this.responsive = true;
    this.scale = void 0;
    this.scales = {};
    this.showLine = true;
    this.drawActiveElementsOnTop = true;
    this.describe(_descriptors2);
    this.apply(_appliers);
  }
  set(scope, values) {
    return set(this, scope, values);
  }
  get(scope) {
    return getScope$1(this, scope);
  }
  describe(scope, values) {
    return set(descriptors, scope, values);
  }
  override(scope, values) {
    return set(overrides, scope, values);
  }
  route(scope, name, targetScope, targetName) {
    const scopeObject = getScope$1(this, scope);
    const targetScopeObject = getScope$1(this, targetScope);
    const privateName = "_" + name;
    Object.defineProperties(scopeObject, {
      [privateName]: {
        value: scopeObject[name],
        writable: true
      },
      [name]: {
        enumerable: true,
        get() {
          const local = this[privateName];
          const target = targetScopeObject[targetName];
          if (isObject(local)) {
            return Object.assign({}, target, local);
          }
          return valueOrDefault(local, target);
        },
        set(value) {
          this[privateName] = value;
        }
      }
    });
  }
  apply(appliers) {
    appliers.forEach((apply) => apply(this));
  }
};
__name(_Defaults, "Defaults");
let Defaults = _Defaults;
var defaults = /* @__PURE__ */ new Defaults({
  _scriptable: (name) => !name.startsWith("on"),
  _indexable: (name) => name !== "events",
  hover: {
    _fallback: "interaction"
  },
  interaction: {
    _scriptable: false,
    _indexable: false
  }
}, [
  applyAnimationsDefaults,
  applyLayoutsDefaults,
  applyScaleDefaults
]);
function toFontString(font) {
  if (!font || isNullOrUndef(font.size) || isNullOrUndef(font.family)) {
    return null;
  }
  return (font.style ? font.style + " " : "") + (font.weight ? font.weight + " " : "") + font.size + "px " + font.family;
}
__name(toFontString, "toFontString");
function _measureText(ctx, data, gc, longest, string) {
  let textWidth = data[string];
  if (!textWidth) {
    textWidth = data[string] = ctx.measureText(string).width;
    gc.push(string);
  }
  if (textWidth > longest) {
    longest = textWidth;
  }
  return longest;
}
__name(_measureText, "_measureText");
function _longestText(ctx, font, arrayOfThings, cache) {
  cache = cache || {};
  let data = cache.data = cache.data || {};
  let gc = cache.garbageCollect = cache.garbageCollect || [];
  if (cache.font !== font) {
    data = cache.data = {};
    gc = cache.garbageCollect = [];
    cache.font = font;
  }
  ctx.save();
  ctx.font = font;
  let longest = 0;
  const ilen = arrayOfThings.length;
  let i2, j2, jlen, thing, nestedThing;
  for (i2 = 0; i2 < ilen; i2++) {
    thing = arrayOfThings[i2];
    if (thing !== void 0 && thing !== null && !isArray(thing)) {
      longest = _measureText(ctx, data, gc, longest, thing);
    } else if (isArray(thing)) {
      for (j2 = 0, jlen = thing.length; j2 < jlen; j2++) {
        nestedThing = thing[j2];
        if (nestedThing !== void 0 && nestedThing !== null && !isArray(nestedThing)) {
          longest = _measureText(ctx, data, gc, longest, nestedThing);
        }
      }
    }
  }
  ctx.restore();
  const gcLen = gc.length / 2;
  if (gcLen > arrayOfThings.length) {
    for (i2 = 0; i2 < gcLen; i2++) {
      delete data[gc[i2]];
    }
    gc.splice(0, gcLen);
  }
  return longest;
}
__name(_longestText, "_longestText");
function _alignPixel(chart, pixel, width) {
  const devicePixelRatio = chart.currentDevicePixelRatio;
  const halfWidth = width !== 0 ? Math.max(width / 2, 0.5) : 0;
  return Math.round((pixel - halfWidth) * devicePixelRatio) / devicePixelRatio + halfWidth;
}
__name(_alignPixel, "_alignPixel");
function clearCanvas(canvas, ctx) {
  if (!ctx && !canvas) {
    return;
  }
  ctx = ctx || canvas.getContext("2d");
  ctx.save();
  ctx.resetTransform();
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  ctx.restore();
}
__name(clearCanvas, "clearCanvas");
function drawPoint(ctx, options, x2, y2) {
  drawPointLegend(ctx, options, x2, y2, null);
}
__name(drawPoint, "drawPoint");
function drawPointLegend(ctx, options, x2, y2, w2) {
  let type, xOffset, yOffset, size, cornerRadius, width, xOffsetW, yOffsetW;
  const style = options.pointStyle;
  const rotation = options.rotation;
  const radius = options.radius;
  let rad = (rotation || 0) * RAD_PER_DEG;
  if (style && typeof style === "object") {
    type = style.toString();
    if (type === "[object HTMLImageElement]" || type === "[object HTMLCanvasElement]") {
      ctx.save();
      ctx.translate(x2, y2);
      ctx.rotate(rad);
      ctx.drawImage(style, -style.width / 2, -style.height / 2, style.width, style.height);
      ctx.restore();
      return;
    }
  }
  if (isNaN(radius) || radius <= 0) {
    return;
  }
  ctx.beginPath();
  switch (style) {
    default:
      if (w2) {
        ctx.ellipse(x2, y2, w2 / 2, radius, 0, 0, TAU);
      } else {
        ctx.arc(x2, y2, radius, 0, TAU);
      }
      ctx.closePath();
      break;
    case "triangle":
      width = w2 ? w2 / 2 : radius;
      ctx.moveTo(x2 + Math.sin(rad) * width, y2 - Math.cos(rad) * radius);
      rad += TWO_THIRDS_PI;
      ctx.lineTo(x2 + Math.sin(rad) * width, y2 - Math.cos(rad) * radius);
      rad += TWO_THIRDS_PI;
      ctx.lineTo(x2 + Math.sin(rad) * width, y2 - Math.cos(rad) * radius);
      ctx.closePath();
      break;
    case "rectRounded":
      cornerRadius = radius * 0.516;
      size = radius - cornerRadius;
      xOffset = Math.cos(rad + QUARTER_PI) * size;
      xOffsetW = Math.cos(rad + QUARTER_PI) * (w2 ? w2 / 2 - cornerRadius : size);
      yOffset = Math.sin(rad + QUARTER_PI) * size;
      yOffsetW = Math.sin(rad + QUARTER_PI) * (w2 ? w2 / 2 - cornerRadius : size);
      ctx.arc(x2 - xOffsetW, y2 - yOffset, cornerRadius, rad - PI, rad - HALF_PI);
      ctx.arc(x2 + yOffsetW, y2 - xOffset, cornerRadius, rad - HALF_PI, rad);
      ctx.arc(x2 + xOffsetW, y2 + yOffset, cornerRadius, rad, rad + HALF_PI);
      ctx.arc(x2 - yOffsetW, y2 + xOffset, cornerRadius, rad + HALF_PI, rad + PI);
      ctx.closePath();
      break;
    case "rect":
      if (!rotation) {
        size = Math.SQRT1_2 * radius;
        width = w2 ? w2 / 2 : size;
        ctx.rect(x2 - width, y2 - size, 2 * width, 2 * size);
        break;
      }
      rad += QUARTER_PI;
    case "rectRot":
      xOffsetW = Math.cos(rad) * (w2 ? w2 / 2 : radius);
      xOffset = Math.cos(rad) * radius;
      yOffset = Math.sin(rad) * radius;
      yOffsetW = Math.sin(rad) * (w2 ? w2 / 2 : radius);
      ctx.moveTo(x2 - xOffsetW, y2 - yOffset);
      ctx.lineTo(x2 + yOffsetW, y2 - xOffset);
      ctx.lineTo(x2 + xOffsetW, y2 + yOffset);
      ctx.lineTo(x2 - yOffsetW, y2 + xOffset);
      ctx.closePath();
      break;
    case "crossRot":
      rad += QUARTER_PI;
    case "cross":
      xOffsetW = Math.cos(rad) * (w2 ? w2 / 2 : radius);
      xOffset = Math.cos(rad) * radius;
      yOffset = Math.sin(rad) * radius;
      yOffsetW = Math.sin(rad) * (w2 ? w2 / 2 : radius);
      ctx.moveTo(x2 - xOffsetW, y2 - yOffset);
      ctx.lineTo(x2 + xOffsetW, y2 + yOffset);
      ctx.moveTo(x2 + yOffsetW, y2 - xOffset);
      ctx.lineTo(x2 - yOffsetW, y2 + xOffset);
      break;
    case "star":
      xOffsetW = Math.cos(rad) * (w2 ? w2 / 2 : radius);
      xOffset = Math.cos(rad) * radius;
      yOffset = Math.sin(rad) * radius;
      yOffsetW = Math.sin(rad) * (w2 ? w2 / 2 : radius);
      ctx.moveTo(x2 - xOffsetW, y2 - yOffset);
      ctx.lineTo(x2 + xOffsetW, y2 + yOffset);
      ctx.moveTo(x2 + yOffsetW, y2 - xOffset);
      ctx.lineTo(x2 - yOffsetW, y2 + xOffset);
      rad += QUARTER_PI;
      xOffsetW = Math.cos(rad) * (w2 ? w2 / 2 : radius);
      xOffset = Math.cos(rad) * radius;
      yOffset = Math.sin(rad) * radius;
      yOffsetW = Math.sin(rad) * (w2 ? w2 / 2 : radius);
      ctx.moveTo(x2 - xOffsetW, y2 - yOffset);
      ctx.lineTo(x2 + xOffsetW, y2 + yOffset);
      ctx.moveTo(x2 + yOffsetW, y2 - xOffset);
      ctx.lineTo(x2 - yOffsetW, y2 + xOffset);
      break;
    case "line":
      xOffset = w2 ? w2 / 2 : Math.cos(rad) * radius;
      yOffset = Math.sin(rad) * radius;
      ctx.moveTo(x2 - xOffset, y2 - yOffset);
      ctx.lineTo(x2 + xOffset, y2 + yOffset);
      break;
    case "dash":
      ctx.moveTo(x2, y2);
      ctx.lineTo(x2 + Math.cos(rad) * (w2 ? w2 / 2 : radius), y2 + Math.sin(rad) * radius);
      break;
    case false:
      ctx.closePath();
      break;
  }
  ctx.fill();
  if (options.borderWidth > 0) {
    ctx.stroke();
  }
}
__name(drawPointLegend, "drawPointLegend");
function _isPointInArea(point, area, margin) {
  margin = margin || 0.5;
  return !area || point && point.x > area.left - margin && point.x < area.right + margin && point.y > area.top - margin && point.y < area.bottom + margin;
}
__name(_isPointInArea, "_isPointInArea");
function clipArea(ctx, area) {
  ctx.save();
  ctx.beginPath();
  ctx.rect(area.left, area.top, area.right - area.left, area.bottom - area.top);
  ctx.clip();
}
__name(clipArea, "clipArea");
function unclipArea(ctx) {
  ctx.restore();
}
__name(unclipArea, "unclipArea");
function _steppedLineTo(ctx, previous, target, flip, mode) {
  if (!previous) {
    return ctx.lineTo(target.x, target.y);
  }
  if (mode === "middle") {
    const midpoint = (previous.x + target.x) / 2;
    ctx.lineTo(midpoint, previous.y);
    ctx.lineTo(midpoint, target.y);
  } else if (mode === "after" !== !!flip) {
    ctx.lineTo(previous.x, target.y);
  } else {
    ctx.lineTo(target.x, previous.y);
  }
  ctx.lineTo(target.x, target.y);
}
__name(_steppedLineTo, "_steppedLineTo");
function _bezierCurveTo(ctx, previous, target, flip) {
  if (!previous) {
    return ctx.lineTo(target.x, target.y);
  }
  ctx.bezierCurveTo(flip ? previous.cp1x : previous.cp2x, flip ? previous.cp1y : previous.cp2y, flip ? target.cp2x : target.cp1x, flip ? target.cp2y : target.cp1y, target.x, target.y);
}
__name(_bezierCurveTo, "_bezierCurveTo");
function setRenderOpts(ctx, opts) {
  if (opts.translation) {
    ctx.translate(opts.translation[0], opts.translation[1]);
  }
  if (!isNullOrUndef(opts.rotation)) {
    ctx.rotate(opts.rotation);
  }
  if (opts.color) {
    ctx.fillStyle = opts.color;
  }
  if (opts.textAlign) {
    ctx.textAlign = opts.textAlign;
  }
  if (opts.textBaseline) {
    ctx.textBaseline = opts.textBaseline;
  }
}
__name(setRenderOpts, "setRenderOpts");
function decorateText(ctx, x2, y2, line, opts) {
  if (opts.strikethrough || opts.underline) {
    const metrics = ctx.measureText(line);
    const left = x2 - metrics.actualBoundingBoxLeft;
    const right = x2 + metrics.actualBoundingBoxRight;
    const top = y2 - metrics.actualBoundingBoxAscent;
    const bottom = y2 + metrics.actualBoundingBoxDescent;
    const yDecoration = opts.strikethrough ? (top + bottom) / 2 : bottom;
    ctx.strokeStyle = ctx.fillStyle;
    ctx.beginPath();
    ctx.lineWidth = opts.decorationWidth || 2;
    ctx.moveTo(left, yDecoration);
    ctx.lineTo(right, yDecoration);
    ctx.stroke();
  }
}
__name(decorateText, "decorateText");
function drawBackdrop(ctx, opts) {
  const oldColor = ctx.fillStyle;
  ctx.fillStyle = opts.color;
  ctx.fillRect(opts.left, opts.top, opts.width, opts.height);
  ctx.fillStyle = oldColor;
}
__name(drawBackdrop, "drawBackdrop");
function renderText(ctx, text, x2, y2, font, opts = {}) {
  const lines = isArray(text) ? text : [
    text
  ];
  const stroke = opts.strokeWidth > 0 && opts.strokeColor !== "";
  let i2, line;
  ctx.save();
  ctx.font = font.string;
  setRenderOpts(ctx, opts);
  for (i2 = 0; i2 < lines.length; ++i2) {
    line = lines[i2];
    if (opts.backdrop) {
      drawBackdrop(ctx, opts.backdrop);
    }
    if (stroke) {
      if (opts.strokeColor) {
        ctx.strokeStyle = opts.strokeColor;
      }
      if (!isNullOrUndef(opts.strokeWidth)) {
        ctx.lineWidth = opts.strokeWidth;
      }
      ctx.strokeText(line, x2, y2, opts.maxWidth);
    }
    ctx.fillText(line, x2, y2, opts.maxWidth);
    decorateText(ctx, x2, y2, line, opts);
    y2 += Number(font.lineHeight);
  }
  ctx.restore();
}
__name(renderText, "renderText");
function addRoundedRectPath(ctx, rect) {
  const { x: x2, y: y2, w: w2, h: h3, radius } = rect;
  ctx.arc(x2 + radius.topLeft, y2 + radius.topLeft, radius.topLeft, 1.5 * PI, PI, true);
  ctx.lineTo(x2, y2 + h3 - radius.bottomLeft);
  ctx.arc(x2 + radius.bottomLeft, y2 + h3 - radius.bottomLeft, radius.bottomLeft, PI, HALF_PI, true);
  ctx.lineTo(x2 + w2 - radius.bottomRight, y2 + h3);
  ctx.arc(x2 + w2 - radius.bottomRight, y2 + h3 - radius.bottomRight, radius.bottomRight, HALF_PI, 0, true);
  ctx.lineTo(x2 + w2, y2 + radius.topRight);
  ctx.arc(x2 + w2 - radius.topRight, y2 + radius.topRight, radius.topRight, 0, -HALF_PI, true);
  ctx.lineTo(x2 + radius.topLeft, y2);
}
__name(addRoundedRectPath, "addRoundedRectPath");
const LINE_HEIGHT = /^(normal|(\d+(?:\.\d+)?)(px|em|%)?)$/;
const FONT_STYLE = /^(normal|italic|initial|inherit|unset|(oblique( -?[0-9]?[0-9]deg)?))$/;
function toLineHeight(value, size) {
  const matches = ("" + value).match(LINE_HEIGHT);
  if (!matches || matches[1] === "normal") {
    return size * 1.2;
  }
  value = +matches[2];
  switch (matches[3]) {
    case "px":
      return value;
    case "%":
      value /= 100;
      break;
  }
  return size * value;
}
__name(toLineHeight, "toLineHeight");
const numberOrZero = /* @__PURE__ */ __name((v2) => +v2 || 0, "numberOrZero");
function _readValueToProps(value, props) {
  const ret = {};
  const objProps = isObject(props);
  const keys2 = objProps ? Object.keys(props) : props;
  const read = isObject(value) ? objProps ? (prop) => valueOrDefault(value[prop], value[props[prop]]) : (prop) => value[prop] : () => value;
  for (const prop of keys2) {
    ret[prop] = numberOrZero(read(prop));
  }
  return ret;
}
__name(_readValueToProps, "_readValueToProps");
function toTRBL(value) {
  return _readValueToProps(value, {
    top: "y",
    right: "x",
    bottom: "y",
    left: "x"
  });
}
__name(toTRBL, "toTRBL");
function toTRBLCorners(value) {
  return _readValueToProps(value, [
    "topLeft",
    "topRight",
    "bottomLeft",
    "bottomRight"
  ]);
}
__name(toTRBLCorners, "toTRBLCorners");
function toPadding(value) {
  const obj = toTRBL(value);
  obj.width = obj.left + obj.right;
  obj.height = obj.top + obj.bottom;
  return obj;
}
__name(toPadding, "toPadding");
function toFont(options, fallback) {
  options = options || {};
  fallback = fallback || defaults.font;
  let size = valueOrDefault(options.size, fallback.size);
  if (typeof size === "string") {
    size = parseInt(size, 10);
  }
  let style = valueOrDefault(options.style, fallback.style);
  if (style && !("" + style).match(FONT_STYLE)) {
    console.warn('Invalid font style specified: "' + style + '"');
    style = void 0;
  }
  const font = {
    family: valueOrDefault(options.family, fallback.family),
    lineHeight: toLineHeight(valueOrDefault(options.lineHeight, fallback.lineHeight), size),
    size,
    style,
    weight: valueOrDefault(options.weight, fallback.weight),
    string: ""
  };
  font.string = toFontString(font);
  return font;
}
__name(toFont, "toFont");
function resolve(inputs, context, index2, info) {
  let cacheable = true;
  let i2, ilen, value;
  for (i2 = 0, ilen = inputs.length; i2 < ilen; ++i2) {
    value = inputs[i2];
    if (value === void 0) {
      continue;
    }
    if (context !== void 0 && typeof value === "function") {
      value = value(context);
      cacheable = false;
    }
    if (index2 !== void 0 && isArray(value)) {
      value = value[index2 % value.length];
      cacheable = false;
    }
    if (value !== void 0) {
      if (info && !cacheable) {
        info.cacheable = false;
      }
      return value;
    }
  }
}
__name(resolve, "resolve");
function _addGrace(minmax, grace, beginAtZero) {
  const { min, max: max2 } = minmax;
  const change = toDimension(grace, (max2 - min) / 2);
  const keepZero = /* @__PURE__ */ __name((value, add) => beginAtZero && value === 0 ? 0 : value + add, "keepZero");
  return {
    min: keepZero(min, -Math.abs(change)),
    max: keepZero(max2, change)
  };
}
__name(_addGrace, "_addGrace");
function createContext(parentContext, context) {
  return Object.assign(Object.create(parentContext), context);
}
__name(createContext, "createContext");
function _createResolver(scopes, prefixes = [
  ""
], rootScopes, fallback, getTarget = () => scopes[0]) {
  const finalRootScopes = rootScopes || scopes;
  if (typeof fallback === "undefined") {
    fallback = _resolve("_fallback", scopes);
  }
  const cache = {
    [Symbol.toStringTag]: "Object",
    _cacheable: true,
    _scopes: scopes,
    _rootScopes: finalRootScopes,
    _fallback: fallback,
    _getTarget: getTarget,
    override: (scope) => _createResolver([
      scope,
      ...scopes
    ], prefixes, finalRootScopes, fallback)
  };
  return new Proxy(cache, {
    /**
    * A trap for the delete operator.
    */
    deleteProperty(target, prop) {
      delete target[prop];
      delete target._keys;
      delete scopes[0][prop];
      return true;
    },
    /**
    * A trap for getting property values.
    */
    get(target, prop) {
      return _cached(target, prop, () => _resolveWithPrefixes(prop, prefixes, scopes, target));
    },
    /**
    * A trap for Object.getOwnPropertyDescriptor.
    * Also used by Object.hasOwnProperty.
    */
    getOwnPropertyDescriptor(target, prop) {
      return Reflect.getOwnPropertyDescriptor(target._scopes[0], prop);
    },
    /**
    * A trap for Object.getPrototypeOf.
    */
    getPrototypeOf() {
      return Reflect.getPrototypeOf(scopes[0]);
    },
    /**
    * A trap for the in operator.
    */
    has(target, prop) {
      return getKeysFromAllScopes(target).includes(prop);
    },
    /**
    * A trap for Object.getOwnPropertyNames and Object.getOwnPropertySymbols.
    */
    ownKeys(target) {
      return getKeysFromAllScopes(target);
    },
    /**
    * A trap for setting property values.
    */
    set(target, prop, value) {
      const storage = target._storage || (target._storage = getTarget());
      target[prop] = storage[prop] = value;
      delete target._keys;
      return true;
    }
  });
}
__name(_createResolver, "_createResolver");
function _attachContext(proxy, context, subProxy, descriptorDefaults) {
  const cache = {
    _cacheable: false,
    _proxy: proxy,
    _context: context,
    _subProxy: subProxy,
    _stack: /* @__PURE__ */ new Set(),
    _descriptors: _descriptors(proxy, descriptorDefaults),
    setContext: (ctx) => _attachContext(proxy, ctx, subProxy, descriptorDefaults),
    override: (scope) => _attachContext(proxy.override(scope), context, subProxy, descriptorDefaults)
  };
  return new Proxy(cache, {
    /**
    * A trap for the delete operator.
    */
    deleteProperty(target, prop) {
      delete target[prop];
      delete proxy[prop];
      return true;
    },
    /**
    * A trap for getting property values.
    */
    get(target, prop, receiver) {
      return _cached(target, prop, () => _resolveWithContext(target, prop, receiver));
    },
    /**
    * A trap for Object.getOwnPropertyDescriptor.
    * Also used by Object.hasOwnProperty.
    */
    getOwnPropertyDescriptor(target, prop) {
      return target._descriptors.allKeys ? Reflect.has(proxy, prop) ? {
        enumerable: true,
        configurable: true
      } : void 0 : Reflect.getOwnPropertyDescriptor(proxy, prop);
    },
    /**
    * A trap for Object.getPrototypeOf.
    */
    getPrototypeOf() {
      return Reflect.getPrototypeOf(proxy);
    },
    /**
    * A trap for the in operator.
    */
    has(target, prop) {
      return Reflect.has(proxy, prop);
    },
    /**
    * A trap for Object.getOwnPropertyNames and Object.getOwnPropertySymbols.
    */
    ownKeys() {
      return Reflect.ownKeys(proxy);
    },
    /**
    * A trap for setting property values.
    */
    set(target, prop, value) {
      proxy[prop] = value;
      delete target[prop];
      return true;
    }
  });
}
__name(_attachContext, "_attachContext");
function _descriptors(proxy, defaults2 = {
  scriptable: true,
  indexable: true
}) {
  const { _scriptable = defaults2.scriptable, _indexable = defaults2.indexable, _allKeys = defaults2.allKeys } = proxy;
  return {
    allKeys: _allKeys,
    scriptable: _scriptable,
    indexable: _indexable,
    isScriptable: isFunction(_scriptable) ? _scriptable : () => _scriptable,
    isIndexable: isFunction(_indexable) ? _indexable : () => _indexable
  };
}
__name(_descriptors, "_descriptors");
const readKey = /* @__PURE__ */ __name((prefix, name) => prefix ? prefix + _capitalize(name) : name, "readKey");
const needsSubResolver = /* @__PURE__ */ __name((prop, value) => isObject(value) && prop !== "adapters" && (Object.getPrototypeOf(value) === null || value.constructor === Object), "needsSubResolver");
function _cached(target, prop, resolve2) {
  if (Object.prototype.hasOwnProperty.call(target, prop) || prop === "constructor") {
    return target[prop];
  }
  const value = resolve2();
  target[prop] = value;
  return value;
}
__name(_cached, "_cached");
function _resolveWithContext(target, prop, receiver) {
  const { _proxy, _context, _subProxy, _descriptors: descriptors2 } = target;
  let value = _proxy[prop];
  if (isFunction(value) && descriptors2.isScriptable(prop)) {
    value = _resolveScriptable(prop, value, target, receiver);
  }
  if (isArray(value) && value.length) {
    value = _resolveArray(prop, value, target, descriptors2.isIndexable);
  }
  if (needsSubResolver(prop, value)) {
    value = _attachContext(value, _context, _subProxy && _subProxy[prop], descriptors2);
  }
  return value;
}
__name(_resolveWithContext, "_resolveWithContext");
function _resolveScriptable(prop, getValue, target, receiver) {
  const { _proxy, _context, _subProxy, _stack } = target;
  if (_stack.has(prop)) {
    throw new Error("Recursion detected: " + Array.from(_stack).join("->") + "->" + prop);
  }
  _stack.add(prop);
  let value = getValue(_context, _subProxy || receiver);
  _stack.delete(prop);
  if (needsSubResolver(prop, value)) {
    value = createSubResolver(_proxy._scopes, _proxy, prop, value);
  }
  return value;
}
__name(_resolveScriptable, "_resolveScriptable");
function _resolveArray(prop, value, target, isIndexable) {
  const { _proxy, _context, _subProxy, _descriptors: descriptors2 } = target;
  if (typeof _context.index !== "undefined" && isIndexable(prop)) {
    return value[_context.index % value.length];
  } else if (isObject(value[0])) {
    const arr = value;
    const scopes = _proxy._scopes.filter((s2) => s2 !== arr);
    value = [];
    for (const item of arr) {
      const resolver = createSubResolver(scopes, _proxy, prop, item);
      value.push(_attachContext(resolver, _context, _subProxy && _subProxy[prop], descriptors2));
    }
  }
  return value;
}
__name(_resolveArray, "_resolveArray");
function resolveFallback(fallback, prop, value) {
  return isFunction(fallback) ? fallback(prop, value) : fallback;
}
__name(resolveFallback, "resolveFallback");
const getScope = /* @__PURE__ */ __name((key, parent) => key === true ? parent : typeof key === "string" ? resolveObjectKey(parent, key) : void 0, "getScope");
function addScopes(set2, parentScopes, key, parentFallback, value) {
  for (const parent of parentScopes) {
    const scope = getScope(key, parent);
    if (scope) {
      set2.add(scope);
      const fallback = resolveFallback(scope._fallback, key, value);
      if (typeof fallback !== "undefined" && fallback !== key && fallback !== parentFallback) {
        return fallback;
      }
    } else if (scope === false && typeof parentFallback !== "undefined" && key !== parentFallback) {
      return null;
    }
  }
  return false;
}
__name(addScopes, "addScopes");
function createSubResolver(parentScopes, resolver, prop, value) {
  const rootScopes = resolver._rootScopes;
  const fallback = resolveFallback(resolver._fallback, prop, value);
  const allScopes = [
    ...parentScopes,
    ...rootScopes
  ];
  const set2 = /* @__PURE__ */ new Set();
  set2.add(value);
  let key = addScopesFromKey(set2, allScopes, prop, fallback || prop, value);
  if (key === null) {
    return false;
  }
  if (typeof fallback !== "undefined" && fallback !== prop) {
    key = addScopesFromKey(set2, allScopes, fallback, key, value);
    if (key === null) {
      return false;
    }
  }
  return _createResolver(Array.from(set2), [
    ""
  ], rootScopes, fallback, () => subGetTarget(resolver, prop, value));
}
__name(createSubResolver, "createSubResolver");
function addScopesFromKey(set2, allScopes, key, fallback, item) {
  while (key) {
    key = addScopes(set2, allScopes, key, fallback, item);
  }
  return key;
}
__name(addScopesFromKey, "addScopesFromKey");
function subGetTarget(resolver, prop, value) {
  const parent = resolver._getTarget();
  if (!(prop in parent)) {
    parent[prop] = {};
  }
  const target = parent[prop];
  if (isArray(target) && isObject(value)) {
    return value;
  }
  return target || {};
}
__name(subGetTarget, "subGetTarget");
function _resolveWithPrefixes(prop, prefixes, scopes, proxy) {
  let value;
  for (const prefix of prefixes) {
    value = _resolve(readKey(prefix, prop), scopes);
    if (typeof value !== "undefined") {
      return needsSubResolver(prop, value) ? createSubResolver(scopes, proxy, prop, value) : value;
    }
  }
}
__name(_resolveWithPrefixes, "_resolveWithPrefixes");
function _resolve(key, scopes) {
  for (const scope of scopes) {
    if (!scope) {
      continue;
    }
    const value = scope[key];
    if (typeof value !== "undefined") {
      return value;
    }
  }
}
__name(_resolve, "_resolve");
function getKeysFromAllScopes(target) {
  let keys2 = target._keys;
  if (!keys2) {
    keys2 = target._keys = resolveKeysFromAllScopes(target._scopes);
  }
  return keys2;
}
__name(getKeysFromAllScopes, "getKeysFromAllScopes");
function resolveKeysFromAllScopes(scopes) {
  const set2 = /* @__PURE__ */ new Set();
  for (const scope of scopes) {
    for (const key of Object.keys(scope).filter((k2) => !k2.startsWith("_"))) {
      set2.add(key);
    }
  }
  return Array.from(set2);
}
__name(resolveKeysFromAllScopes, "resolveKeysFromAllScopes");
function _parseObjectDataRadialScale(meta, data, start, count) {
  const { iScale } = meta;
  const { key = "r" } = this._parsing;
  const parsed = new Array(count);
  let i2, ilen, index2, item;
  for (i2 = 0, ilen = count; i2 < ilen; ++i2) {
    index2 = i2 + start;
    item = data[index2];
    parsed[i2] = {
      r: iScale.parse(resolveObjectKey(item, key), index2)
    };
  }
  return parsed;
}
__name(_parseObjectDataRadialScale, "_parseObjectDataRadialScale");
const EPSILON = Number.EPSILON || 1e-14;
const getPoint = /* @__PURE__ */ __name((points, i2) => i2 < points.length && !points[i2].skip && points[i2], "getPoint");
const getValueAxis = /* @__PURE__ */ __name((indexAxis) => indexAxis === "x" ? "y" : "x", "getValueAxis");
function splineCurve(firstPoint, middlePoint, afterPoint, t2) {
  const previous = firstPoint.skip ? middlePoint : firstPoint;
  const current = middlePoint;
  const next = afterPoint.skip ? middlePoint : afterPoint;
  const d01 = distanceBetweenPoints(current, previous);
  const d12 = distanceBetweenPoints(next, current);
  let s01 = d01 / (d01 + d12);
  let s12 = d12 / (d01 + d12);
  s01 = isNaN(s01) ? 0 : s01;
  s12 = isNaN(s12) ? 0 : s12;
  const fa = t2 * s01;
  const fb = t2 * s12;
  return {
    previous: {
      x: current.x - fa * (next.x - previous.x),
      y: current.y - fa * (next.y - previous.y)
    },
    next: {
      x: current.x + fb * (next.x - previous.x),
      y: current.y + fb * (next.y - previous.y)
    }
  };
}
__name(splineCurve, "splineCurve");
function monotoneAdjust(points, deltaK, mK) {
  const pointsLen = points.length;
  let alphaK, betaK, tauK, squaredMagnitude, pointCurrent;
  let pointAfter = getPoint(points, 0);
  for (let i2 = 0; i2 < pointsLen - 1; ++i2) {
    pointCurrent = pointAfter;
    pointAfter = getPoint(points, i2 + 1);
    if (!pointCurrent || !pointAfter) {
      continue;
    }
    if (almostEquals(deltaK[i2], 0, EPSILON)) {
      mK[i2] = mK[i2 + 1] = 0;
      continue;
    }
    alphaK = mK[i2] / deltaK[i2];
    betaK = mK[i2 + 1] / deltaK[i2];
    squaredMagnitude = Math.pow(alphaK, 2) + Math.pow(betaK, 2);
    if (squaredMagnitude <= 9) {
      continue;
    }
    tauK = 3 / Math.sqrt(squaredMagnitude);
    mK[i2] = alphaK * tauK * deltaK[i2];
    mK[i2 + 1] = betaK * tauK * deltaK[i2];
  }
}
__name(monotoneAdjust, "monotoneAdjust");
function monotoneCompute(points, mK, indexAxis = "x") {
  const valueAxis = getValueAxis(indexAxis);
  const pointsLen = points.length;
  let delta, pointBefore, pointCurrent;
  let pointAfter = getPoint(points, 0);
  for (let i2 = 0; i2 < pointsLen; ++i2) {
    pointBefore = pointCurrent;
    pointCurrent = pointAfter;
    pointAfter = getPoint(points, i2 + 1);
    if (!pointCurrent) {
      continue;
    }
    const iPixel = pointCurrent[indexAxis];
    const vPixel = pointCurrent[valueAxis];
    if (pointBefore) {
      delta = (iPixel - pointBefore[indexAxis]) / 3;
      pointCurrent[`cp1${indexAxis}`] = iPixel - delta;
      pointCurrent[`cp1${valueAxis}`] = vPixel - delta * mK[i2];
    }
    if (pointAfter) {
      delta = (pointAfter[indexAxis] - iPixel) / 3;
      pointCurrent[`cp2${indexAxis}`] = iPixel + delta;
      pointCurrent[`cp2${valueAxis}`] = vPixel + delta * mK[i2];
    }
  }
}
__name(monotoneCompute, "monotoneCompute");
function splineCurveMonotone(points, indexAxis = "x") {
  const valueAxis = getValueAxis(indexAxis);
  const pointsLen = points.length;
  const deltaK = Array(pointsLen).fill(0);
  const mK = Array(pointsLen);
  let i2, pointBefore, pointCurrent;
  let pointAfter = getPoint(points, 0);
  for (i2 = 0; i2 < pointsLen; ++i2) {
    pointBefore = pointCurrent;
    pointCurrent = pointAfter;
    pointAfter = getPoint(points, i2 + 1);
    if (!pointCurrent) {
      continue;
    }
    if (pointAfter) {
      const slopeDelta = pointAfter[indexAxis] - pointCurrent[indexAxis];
      deltaK[i2] = slopeDelta !== 0 ? (pointAfter[valueAxis] - pointCurrent[valueAxis]) / slopeDelta : 0;
    }
    mK[i2] = !pointBefore ? deltaK[i2] : !pointAfter ? deltaK[i2 - 1] : sign(deltaK[i2 - 1]) !== sign(deltaK[i2]) ? 0 : (deltaK[i2 - 1] + deltaK[i2]) / 2;
  }
  monotoneAdjust(points, deltaK, mK);
  monotoneCompute(points, mK, indexAxis);
}
__name(splineCurveMonotone, "splineCurveMonotone");
function capControlPoint(pt2, min, max2) {
  return Math.max(Math.min(pt2, max2), min);
}
__name(capControlPoint, "capControlPoint");
function capBezierPoints(points, area) {
  let i2, ilen, point, inArea, inAreaPrev;
  let inAreaNext = _isPointInArea(points[0], area);
  for (i2 = 0, ilen = points.length; i2 < ilen; ++i2) {
    inAreaPrev = inArea;
    inArea = inAreaNext;
    inAreaNext = i2 < ilen - 1 && _isPointInArea(points[i2 + 1], area);
    if (!inArea) {
      continue;
    }
    point = points[i2];
    if (inAreaPrev) {
      point.cp1x = capControlPoint(point.cp1x, area.left, area.right);
      point.cp1y = capControlPoint(point.cp1y, area.top, area.bottom);
    }
    if (inAreaNext) {
      point.cp2x = capControlPoint(point.cp2x, area.left, area.right);
      point.cp2y = capControlPoint(point.cp2y, area.top, area.bottom);
    }
  }
}
__name(capBezierPoints, "capBezierPoints");
function _updateBezierControlPoints(points, options, area, loop, indexAxis) {
  let i2, ilen, point, controlPoints;
  if (options.spanGaps) {
    points = points.filter((pt2) => !pt2.skip);
  }
  if (options.cubicInterpolationMode === "monotone") {
    splineCurveMonotone(points, indexAxis);
  } else {
    let prev = loop ? points[points.length - 1] : points[0];
    for (i2 = 0, ilen = points.length; i2 < ilen; ++i2) {
      point = points[i2];
      controlPoints = splineCurve(prev, point, points[Math.min(i2 + 1, ilen - (loop ? 0 : 1)) % ilen], options.tension);
      point.cp1x = controlPoints.previous.x;
      point.cp1y = controlPoints.previous.y;
      point.cp2x = controlPoints.next.x;
      point.cp2y = controlPoints.next.y;
      prev = point;
    }
  }
  if (options.capBezierPoints) {
    capBezierPoints(points, area);
  }
}
__name(_updateBezierControlPoints, "_updateBezierControlPoints");
function _isDomSupported() {
  return typeof window !== "undefined" && typeof document !== "undefined";
}
__name(_isDomSupported, "_isDomSupported");
function _getParentNode(domNode) {
  let parent = domNode.parentNode;
  if (parent && parent.toString() === "[object ShadowRoot]") {
    parent = parent.host;
  }
  return parent;
}
__name(_getParentNode, "_getParentNode");
function parseMaxStyle(styleValue, node, parentProperty) {
  let valueInPixels;
  if (typeof styleValue === "string") {
    valueInPixels = parseInt(styleValue, 10);
    if (styleValue.indexOf("%") !== -1) {
      valueInPixels = valueInPixels / 100 * node.parentNode[parentProperty];
    }
  } else {
    valueInPixels = styleValue;
  }
  return valueInPixels;
}
__name(parseMaxStyle, "parseMaxStyle");
const getComputedStyle$1 = /* @__PURE__ */ __name((element) => element.ownerDocument.defaultView.getComputedStyle(element, null), "getComputedStyle$1");
function getStyle(el, property) {
  return getComputedStyle$1(el).getPropertyValue(property);
}
__name(getStyle, "getStyle");
const positions = [
  "top",
  "right",
  "bottom",
  "left"
];
function getPositionedStyle(styles, style, suffix) {
  const result = {};
  suffix = suffix ? "-" + suffix : "";
  for (let i2 = 0; i2 < 4; i2++) {
    const pos = positions[i2];
    result[pos] = parseFloat(styles[style + "-" + pos + suffix]) || 0;
  }
  result.width = result.left + result.right;
  result.height = result.top + result.bottom;
  return result;
}
__name(getPositionedStyle, "getPositionedStyle");
const useOffsetPos = /* @__PURE__ */ __name((x2, y2, target) => (x2 > 0 || y2 > 0) && (!target || !target.shadowRoot), "useOffsetPos");
function getCanvasPosition(e, canvas) {
  const touches = e.touches;
  const source = touches && touches.length ? touches[0] : e;
  const { offsetX, offsetY } = source;
  let box = false;
  let x2, y2;
  if (useOffsetPos(offsetX, offsetY, e.target)) {
    x2 = offsetX;
    y2 = offsetY;
  } else {
    const rect = canvas.getBoundingClientRect();
    x2 = source.clientX - rect.left;
    y2 = source.clientY - rect.top;
    box = true;
  }
  return {
    x: x2,
    y: y2,
    box
  };
}
__name(getCanvasPosition, "getCanvasPosition");
function getRelativePosition(event, chart) {
  if ("native" in event) {
    return event;
  }
  const { canvas, currentDevicePixelRatio } = chart;
  const style = getComputedStyle$1(canvas);
  const borderBox = style.boxSizing === "border-box";
  const paddings = getPositionedStyle(style, "padding");
  const borders = getPositionedStyle(style, "border", "width");
  const { x: x2, y: y2, box } = getCanvasPosition(event, canvas);
  const xOffset = paddings.left + (box && borders.left);
  const yOffset = paddings.top + (box && borders.top);
  let { width, height } = chart;
  if (borderBox) {
    width -= paddings.width + borders.width;
    height -= paddings.height + borders.height;
  }
  return {
    x: Math.round((x2 - xOffset) / width * canvas.width / currentDevicePixelRatio),
    y: Math.round((y2 - yOffset) / height * canvas.height / currentDevicePixelRatio)
  };
}
__name(getRelativePosition, "getRelativePosition");
function getContainerSize(canvas, width, height) {
  let maxWidth, maxHeight;
  if (width === void 0 || height === void 0) {
    const container = canvas && _getParentNode(canvas);
    if (!container) {
      width = canvas.clientWidth;
      height = canvas.clientHeight;
    } else {
      const rect = container.getBoundingClientRect();
      const containerStyle = getComputedStyle$1(container);
      const containerBorder = getPositionedStyle(containerStyle, "border", "width");
      const containerPadding = getPositionedStyle(containerStyle, "padding");
      width = rect.width - containerPadding.width - containerBorder.width;
      height = rect.height - containerPadding.height - containerBorder.height;
      maxWidth = parseMaxStyle(containerStyle.maxWidth, container, "clientWidth");
      maxHeight = parseMaxStyle(containerStyle.maxHeight, container, "clientHeight");
    }
  }
  return {
    width,
    height,
    maxWidth: maxWidth || INFINITY,
    maxHeight: maxHeight || INFINITY
  };
}
__name(getContainerSize, "getContainerSize");
const round1 = /* @__PURE__ */ __name((v2) => Math.round(v2 * 10) / 10, "round1");
function getMaximumSize(canvas, bbWidth, bbHeight, aspectRatio) {
  const style = getComputedStyle$1(canvas);
  const margins = getPositionedStyle(style, "margin");
  const maxWidth = parseMaxStyle(style.maxWidth, canvas, "clientWidth") || INFINITY;
  const maxHeight = parseMaxStyle(style.maxHeight, canvas, "clientHeight") || INFINITY;
  const containerSize = getContainerSize(canvas, bbWidth, bbHeight);
  let { width, height } = containerSize;
  if (style.boxSizing === "content-box") {
    const borders = getPositionedStyle(style, "border", "width");
    const paddings = getPositionedStyle(style, "padding");
    width -= paddings.width + borders.width;
    height -= paddings.height + borders.height;
  }
  width = Math.max(0, width - margins.width);
  height = Math.max(0, aspectRatio ? width / aspectRatio : height - margins.height);
  width = round1(Math.min(width, maxWidth, containerSize.maxWidth));
  height = round1(Math.min(height, maxHeight, containerSize.maxHeight));
  if (width && !height) {
    height = round1(width / 2);
  }
  const maintainHeight = bbWidth !== void 0 || bbHeight !== void 0;
  if (maintainHeight && aspectRatio && containerSize.height && height > containerSize.height) {
    height = containerSize.height;
    width = round1(Math.floor(height * aspectRatio));
  }
  return {
    width,
    height
  };
}
__name(getMaximumSize, "getMaximumSize");
function retinaScale(chart, forceRatio, forceStyle) {
  const pixelRatio = forceRatio || 1;
  const deviceHeight = round1(chart.height * pixelRatio);
  const deviceWidth = round1(chart.width * pixelRatio);
  chart.height = round1(chart.height);
  chart.width = round1(chart.width);
  const canvas = chart.canvas;
  if (canvas.style && (forceStyle || !canvas.style.height && !canvas.style.width)) {
    canvas.style.height = `${chart.height}px`;
    canvas.style.width = `${chart.width}px`;
  }
  if (chart.currentDevicePixelRatio !== pixelRatio || canvas.height !== deviceHeight || canvas.width !== deviceWidth) {
    chart.currentDevicePixelRatio = pixelRatio;
    canvas.height = deviceHeight;
    canvas.width = deviceWidth;
    chart.ctx.setTransform(pixelRatio, 0, 0, pixelRatio, 0, 0);
    return true;
  }
  return false;
}
__name(retinaScale, "retinaScale");
const supportsEventListenerOptions = function() {
  let passiveSupported = false;
  try {
    const options = {
      get passive() {
        passiveSupported = true;
        return false;
      }
    };
    if (_isDomSupported()) {
      window.addEventListener("test", null, options);
      window.removeEventListener("test", null, options);
    }
  } catch (e) {
  }
  return passiveSupported;
}();
function readUsedSize(element, property) {
  const value = getStyle(element, property);
  const matches = value && value.match(/^(\d+)(\.\d+)?px$/);
  return matches ? +matches[1] : void 0;
}
__name(readUsedSize, "readUsedSize");
function _pointInLine(p1, p2, t2, mode) {
  return {
    x: p1.x + t2 * (p2.x - p1.x),
    y: p1.y + t2 * (p2.y - p1.y)
  };
}
__name(_pointInLine, "_pointInLine");
function _steppedInterpolation(p1, p2, t2, mode) {
  return {
    x: p1.x + t2 * (p2.x - p1.x),
    y: mode === "middle" ? t2 < 0.5 ? p1.y : p2.y : mode === "after" ? t2 < 1 ? p1.y : p2.y : t2 > 0 ? p2.y : p1.y
  };
}
__name(_steppedInterpolation, "_steppedInterpolation");
function _bezierInterpolation(p1, p2, t2, mode) {
  const cp1 = {
    x: p1.cp2x,
    y: p1.cp2y
  };
  const cp2 = {
    x: p2.cp1x,
    y: p2.cp1y
  };
  const a2 = _pointInLine(p1, cp1, t2);
  const b2 = _pointInLine(cp1, cp2, t2);
  const c2 = _pointInLine(cp2, p2, t2);
  const d2 = _pointInLine(a2, b2, t2);
  const e = _pointInLine(b2, c2, t2);
  return _pointInLine(d2, e, t2);
}
__name(_bezierInterpolation, "_bezierInterpolation");
const getRightToLeftAdapter = /* @__PURE__ */ __name(function(rectX, width) {
  return {
    x(x2) {
      return rectX + rectX + width - x2;
    },
    setWidth(w2) {
      width = w2;
    },
    textAlign(align) {
      if (align === "center") {
        return align;
      }
      return align === "right" ? "left" : "right";
    },
    xPlus(x2, value) {
      return x2 - value;
    },
    leftForLtr(x2, itemWidth) {
      return x2 - itemWidth;
    }
  };
}, "getRightToLeftAdapter");
const getLeftToRightAdapter = /* @__PURE__ */ __name(function() {
  return {
    x(x2) {
      return x2;
    },
    setWidth(w2) {
    },
    textAlign(align) {
      return align;
    },
    xPlus(x2, value) {
      return x2 + value;
    },
    leftForLtr(x2, _itemWidth) {
      return x2;
    }
  };
}, "getLeftToRightAdapter");
function getRtlAdapter(rtl, rectX, width) {
  return rtl ? getRightToLeftAdapter(rectX, width) : getLeftToRightAdapter();
}
__name(getRtlAdapter, "getRtlAdapter");
function overrideTextDirection(ctx, direction) {
  let style, original;
  if (direction === "ltr" || direction === "rtl") {
    style = ctx.canvas.style;
    original = [
      style.getPropertyValue("direction"),
      style.getPropertyPriority("direction")
    ];
    style.setProperty("direction", direction, "important");
    ctx.prevTextDirection = original;
  }
}
__name(overrideTextDirection, "overrideTextDirection");
function restoreTextDirection(ctx, original) {
  if (original !== void 0) {
    delete ctx.prevTextDirection;
    ctx.canvas.style.setProperty("direction", original[0], original[1]);
  }
}
__name(restoreTextDirection, "restoreTextDirection");
function propertyFn(property) {
  if (property === "angle") {
    return {
      between: _angleBetween,
      compare: _angleDiff,
      normalize: _normalizeAngle
    };
  }
  return {
    between: _isBetween,
    compare: (a2, b2) => a2 - b2,
    normalize: (x2) => x2
  };
}
__name(propertyFn, "propertyFn");
function normalizeSegment({ start, end, count, loop, style }) {
  return {
    start: start % count,
    end: end % count,
    loop: loop && (end - start + 1) % count === 0,
    style
  };
}
__name(normalizeSegment, "normalizeSegment");
function getSegment(segment, points, bounds) {
  const { property, start: startBound, end: endBound } = bounds;
  const { between, normalize } = propertyFn(property);
  const count = points.length;
  let { start, end, loop } = segment;
  let i2, ilen;
  if (loop) {
    start += count;
    end += count;
    for (i2 = 0, ilen = count; i2 < ilen; ++i2) {
      if (!between(normalize(points[start % count][property]), startBound, endBound)) {
        break;
      }
      start--;
      end--;
    }
    start %= count;
    end %= count;
  }
  if (end < start) {
    end += count;
  }
  return {
    start,
    end,
    loop,
    style: segment.style
  };
}
__name(getSegment, "getSegment");
function _boundSegment(segment, points, bounds) {
  if (!bounds) {
    return [
      segment
    ];
  }
  const { property, start: startBound, end: endBound } = bounds;
  const count = points.length;
  const { compare, between, normalize } = propertyFn(property);
  const { start, end, loop, style } = getSegment(segment, points, bounds);
  const result = [];
  let inside = false;
  let subStart = null;
  let value, point, prevValue;
  const startIsBefore = /* @__PURE__ */ __name(() => between(startBound, prevValue, value) && compare(startBound, prevValue) !== 0, "startIsBefore");
  const endIsBefore = /* @__PURE__ */ __name(() => compare(endBound, value) === 0 || between(endBound, prevValue, value), "endIsBefore");
  const shouldStart = /* @__PURE__ */ __name(() => inside || startIsBefore(), "shouldStart");
  const shouldStop = /* @__PURE__ */ __name(() => !inside || endIsBefore(), "shouldStop");
  for (let i2 = start, prev = start; i2 <= end; ++i2) {
    point = points[i2 % count];
    if (point.skip) {
      continue;
    }
    value = normalize(point[property]);
    if (value === prevValue) {
      continue;
    }
    inside = between(value, startBound, endBound);
    if (subStart === null && shouldStart()) {
      subStart = compare(value, startBound) === 0 ? i2 : prev;
    }
    if (subStart !== null && shouldStop()) {
      result.push(normalizeSegment({
        start: subStart,
        end: i2,
        loop,
        count,
        style
      }));
      subStart = null;
    }
    prev = i2;
    prevValue = value;
  }
  if (subStart !== null) {
    result.push(normalizeSegment({
      start: subStart,
      end,
      loop,
      count,
      style
    }));
  }
  return result;
}
__name(_boundSegment, "_boundSegment");
function _boundSegments(line, bounds) {
  const result = [];
  const segments = line.segments;
  for (let i2 = 0; i2 < segments.length; i2++) {
    const sub = _boundSegment(segments[i2], line.points, bounds);
    if (sub.length) {
      result.push(...sub);
    }
  }
  return result;
}
__name(_boundSegments, "_boundSegments");
function findStartAndEnd(points, count, loop, spanGaps) {
  let start = 0;
  let end = count - 1;
  if (loop && !spanGaps) {
    while (start < count && !points[start].skip) {
      start++;
    }
  }
  while (start < count && points[start].skip) {
    start++;
  }
  start %= count;
  if (loop) {
    end += start;
  }
  while (end > start && points[end % count].skip) {
    end--;
  }
  end %= count;
  return {
    start,
    end
  };
}
__name(findStartAndEnd, "findStartAndEnd");
function solidSegments(points, start, max2, loop) {
  const count = points.length;
  const result = [];
  let last = start;
  let prev = points[start];
  let end;
  for (end = start + 1; end <= max2; ++end) {
    const cur = points[end % count];
    if (cur.skip || cur.stop) {
      if (!prev.skip) {
        loop = false;
        result.push({
          start: start % count,
          end: (end - 1) % count,
          loop
        });
        start = last = cur.stop ? end : null;
      }
    } else {
      last = end;
      if (prev.skip) {
        start = end;
      }
    }
    prev = cur;
  }
  if (last !== null) {
    result.push({
      start: start % count,
      end: last % count,
      loop
    });
  }
  return result;
}
__name(solidSegments, "solidSegments");
function _computeSegments(line, segmentOptions) {
  const points = line.points;
  const spanGaps = line.options.spanGaps;
  const count = points.length;
  if (!count) {
    return [];
  }
  const loop = !!line._loop;
  const { start, end } = findStartAndEnd(points, count, loop, spanGaps);
  if (spanGaps === true) {
    return splitByStyles(line, [
      {
        start,
        end,
        loop
      }
    ], points, segmentOptions);
  }
  const max2 = end < start ? end + count : end;
  const completeLoop = !!line._fullLoop && start === 0 && end === count - 1;
  return splitByStyles(line, solidSegments(points, start, max2, completeLoop), points, segmentOptions);
}
__name(_computeSegments, "_computeSegments");
function splitByStyles(line, segments, points, segmentOptions) {
  if (!segmentOptions || !segmentOptions.setContext || !points) {
    return segments;
  }
  return doSplitByStyles(line, segments, points, segmentOptions);
}
__name(splitByStyles, "splitByStyles");
function doSplitByStyles(line, segments, points, segmentOptions) {
  const chartContext = line._chart.getContext();
  const baseStyle = readStyle(line.options);
  const { _datasetIndex: datasetIndex, options: { spanGaps } } = line;
  const count = points.length;
  const result = [];
  let prevStyle = baseStyle;
  let start = segments[0].start;
  let i2 = start;
  function addStyle(s2, e, l2, st2) {
    const dir = spanGaps ? -1 : 1;
    if (s2 === e) {
      return;
    }
    s2 += count;
    while (points[s2 % count].skip) {
      s2 -= dir;
    }
    while (points[e % count].skip) {
      e += dir;
    }
    if (s2 % count !== e % count) {
      result.push({
        start: s2 % count,
        end: e % count,
        loop: l2,
        style: st2
      });
      prevStyle = st2;
      start = e % count;
    }
  }
  __name(addStyle, "addStyle");
  for (const segment of segments) {
    start = spanGaps ? start : segment.start;
    let prev = points[start % count];
    let style;
    for (i2 = start + 1; i2 <= segment.end; i2++) {
      const pt2 = points[i2 % count];
      style = readStyle(segmentOptions.setContext(createContext(chartContext, {
        type: "segment",
        p0: prev,
        p1: pt2,
        p0DataIndex: (i2 - 1) % count,
        p1DataIndex: i2 % count,
        datasetIndex
      })));
      if (styleChanged(style, prevStyle)) {
        addStyle(start, i2 - 1, segment.loop, prevStyle);
      }
      prev = pt2;
      prevStyle = style;
    }
    if (start < i2 - 1) {
      addStyle(start, i2 - 1, segment.loop, prevStyle);
    }
  }
  return result;
}
__name(doSplitByStyles, "doSplitByStyles");
function readStyle(options) {
  return {
    backgroundColor: options.backgroundColor,
    borderCapStyle: options.borderCapStyle,
    borderDash: options.borderDash,
    borderDashOffset: options.borderDashOffset,
    borderJoinStyle: options.borderJoinStyle,
    borderWidth: options.borderWidth,
    borderColor: options.borderColor
  };
}
__name(readStyle, "readStyle");
function styleChanged(style, prevStyle) {
  if (!prevStyle) {
    return false;
  }
  const cache = [];
  const replacer = /* @__PURE__ */ __name(function(key, value) {
    if (!isPatternOrGradient(value)) {
      return value;
    }
    if (!cache.includes(value)) {
      cache.push(value);
    }
    return cache.indexOf(value);
  }, "replacer");
  return JSON.stringify(style, replacer) !== JSON.stringify(prevStyle, replacer);
}
__name(styleChanged, "styleChanged");
function getSizeForArea(scale, chartArea, field) {
  return scale.options.clip ? scale[field] : chartArea[field];
}
__name(getSizeForArea, "getSizeForArea");
function getDatasetArea(meta, chartArea) {
  const { xScale, yScale } = meta;
  if (xScale && yScale) {
    return {
      left: getSizeForArea(xScale, chartArea, "left"),
      right: getSizeForArea(xScale, chartArea, "right"),
      top: getSizeForArea(yScale, chartArea, "top"),
      bottom: getSizeForArea(yScale, chartArea, "bottom")
    };
  }
  return chartArea;
}
__name(getDatasetArea, "getDatasetArea");
function getDatasetClipArea(chart, meta) {
  const clip = meta._clip;
  if (clip.disabled) {
    return false;
  }
  const area = getDatasetArea(meta, chart.chartArea);
  return {
    left: clip.left === false ? 0 : area.left - (clip.left === true ? 0 : clip.left),
    right: clip.right === false ? chart.width : area.right + (clip.right === true ? 0 : clip.right),
    top: clip.top === false ? 0 : area.top - (clip.top === true ? 0 : clip.top),
    bottom: clip.bottom === false ? chart.height : area.bottom + (clip.bottom === true ? 0 : clip.bottom)
  };
}
__name(getDatasetClipArea, "getDatasetClipArea");
/*!
 * Chart.js v4.5.1
 * https://www.chartjs.org
 * (c) 2025 Chart.js Contributors
 * Released under the MIT License
 */
const _Animator = class _Animator {
  constructor() {
    this._request = null;
    this._charts = /* @__PURE__ */ new Map();
    this._running = false;
    this._lastDate = void 0;
  }
  _notify(chart, anims, date, type) {
    const callbacks = anims.listeners[type];
    const numSteps = anims.duration;
    callbacks.forEach((fn) => fn({
      chart,
      initial: anims.initial,
      numSteps,
      currentStep: Math.min(date - anims.start, numSteps)
    }));
  }
  _refresh() {
    if (this._request) {
      return;
    }
    this._running = true;
    this._request = requestAnimFrame.call(window, () => {
      this._update();
      this._request = null;
      if (this._running) {
        this._refresh();
      }
    });
  }
  _update(date = Date.now()) {
    let remaining = 0;
    this._charts.forEach((anims, chart) => {
      if (!anims.running || !anims.items.length) {
        return;
      }
      const items = anims.items;
      let i2 = items.length - 1;
      let draw2 = false;
      let item;
      for (; i2 >= 0; --i2) {
        item = items[i2];
        if (item._active) {
          if (item._total > anims.duration) {
            anims.duration = item._total;
          }
          item.tick(date);
          draw2 = true;
        } else {
          items[i2] = items[items.length - 1];
          items.pop();
        }
      }
      if (draw2) {
        chart.draw();
        this._notify(chart, anims, date, "progress");
      }
      if (!items.length) {
        anims.running = false;
        this._notify(chart, anims, date, "complete");
        anims.initial = false;
      }
      remaining += items.length;
    });
    this._lastDate = date;
    if (remaining === 0) {
      this._running = false;
    }
  }
  _getAnims(chart) {
    const charts = this._charts;
    let anims = charts.get(chart);
    if (!anims) {
      anims = {
        running: false,
        initial: true,
        items: [],
        listeners: {
          complete: [],
          progress: []
        }
      };
      charts.set(chart, anims);
    }
    return anims;
  }
  listen(chart, event, cb) {
    this._getAnims(chart).listeners[event].push(cb);
  }
  add(chart, items) {
    if (!items || !items.length) {
      return;
    }
    this._getAnims(chart).items.push(...items);
  }
  has(chart) {
    return this._getAnims(chart).items.length > 0;
  }
  start(chart) {
    const anims = this._charts.get(chart);
    if (!anims) {
      return;
    }
    anims.running = true;
    anims.start = Date.now();
    anims.duration = anims.items.reduce((acc, cur) => Math.max(acc, cur._duration), 0);
    this._refresh();
  }
  running(chart) {
    if (!this._running) {
      return false;
    }
    const anims = this._charts.get(chart);
    if (!anims || !anims.running || !anims.items.length) {
      return false;
    }
    return true;
  }
  stop(chart) {
    const anims = this._charts.get(chart);
    if (!anims || !anims.items.length) {
      return;
    }
    const items = anims.items;
    let i2 = items.length - 1;
    for (; i2 >= 0; --i2) {
      items[i2].cancel();
    }
    anims.items = [];
    this._notify(chart, anims, Date.now(), "complete");
  }
  remove(chart) {
    return this._charts.delete(chart);
  }
};
__name(_Animator, "Animator");
let Animator = _Animator;
var animator = /* @__PURE__ */ new Animator();
const transparent = "transparent";
const interpolators = {
  boolean(from2, to2, factor) {
    return factor > 0.5 ? to2 : from2;
  },
  color(from2, to2, factor) {
    const c0 = color(from2 || transparent);
    const c1 = c0.valid && color(to2 || transparent);
    return c1 && c1.valid ? c1.mix(c0, factor).hexString() : to2;
  },
  number(from2, to2, factor) {
    return from2 + (to2 - from2) * factor;
  }
};
const _Animation = class _Animation {
  constructor(cfg, target, prop, to2) {
    const currentValue = target[prop];
    to2 = resolve([
      cfg.to,
      to2,
      currentValue,
      cfg.from
    ]);
    const from2 = resolve([
      cfg.from,
      currentValue,
      to2
    ]);
    this._active = true;
    this._fn = cfg.fn || interpolators[cfg.type || typeof from2];
    this._easing = effects[cfg.easing] || effects.linear;
    this._start = Math.floor(Date.now() + (cfg.delay || 0));
    this._duration = this._total = Math.floor(cfg.duration);
    this._loop = !!cfg.loop;
    this._target = target;
    this._prop = prop;
    this._from = from2;
    this._to = to2;
    this._promises = void 0;
  }
  active() {
    return this._active;
  }
  update(cfg, to2, date) {
    if (this._active) {
      this._notify(false);
      const currentValue = this._target[this._prop];
      const elapsed = date - this._start;
      const remain = this._duration - elapsed;
      this._start = date;
      this._duration = Math.floor(Math.max(remain, cfg.duration));
      this._total += elapsed;
      this._loop = !!cfg.loop;
      this._to = resolve([
        cfg.to,
        to2,
        currentValue,
        cfg.from
      ]);
      this._from = resolve([
        cfg.from,
        currentValue,
        to2
      ]);
    }
  }
  cancel() {
    if (this._active) {
      this.tick(Date.now());
      this._active = false;
      this._notify(false);
    }
  }
  tick(date) {
    const elapsed = date - this._start;
    const duration = this._duration;
    const prop = this._prop;
    const from2 = this._from;
    const loop = this._loop;
    const to2 = this._to;
    let factor;
    this._active = from2 !== to2 && (loop || elapsed < duration);
    if (!this._active) {
      this._target[prop] = to2;
      this._notify(true);
      return;
    }
    if (elapsed < 0) {
      this._target[prop] = from2;
      return;
    }
    factor = elapsed / duration % 2;
    factor = loop && factor > 1 ? 2 - factor : factor;
    factor = this._easing(Math.min(1, Math.max(0, factor)));
    this._target[prop] = this._fn(from2, to2, factor);
  }
  wait() {
    const promises = this._promises || (this._promises = []);
    return new Promise((res, rej) => {
      promises.push({
        res,
        rej
      });
    });
  }
  _notify(resolved) {
    const method = resolved ? "res" : "rej";
    const promises = this._promises || [];
    for (let i2 = 0; i2 < promises.length; i2++) {
      promises[i2][method]();
    }
  }
};
__name(_Animation, "Animation");
let Animation = _Animation;
const _Animations = class _Animations {
  constructor(chart, config) {
    this._chart = chart;
    this._properties = /* @__PURE__ */ new Map();
    this.configure(config);
  }
  configure(config) {
    if (!isObject(config)) {
      return;
    }
    const animationOptions = Object.keys(defaults.animation);
    const animatedProps = this._properties;
    Object.getOwnPropertyNames(config).forEach((key) => {
      const cfg = config[key];
      if (!isObject(cfg)) {
        return;
      }
      const resolved = {};
      for (const option of animationOptions) {
        resolved[option] = cfg[option];
      }
      (isArray(cfg.properties) && cfg.properties || [
        key
      ]).forEach((prop) => {
        if (prop === key || !animatedProps.has(prop)) {
          animatedProps.set(prop, resolved);
        }
      });
    });
  }
  _animateOptions(target, values) {
    const newOptions = values.options;
    const options = resolveTargetOptions(target, newOptions);
    if (!options) {
      return [];
    }
    const animations = this._createAnimations(options, newOptions);
    if (newOptions.$shared) {
      awaitAll(target.options.$animations, newOptions).then(() => {
        target.options = newOptions;
      }, () => {
      });
    }
    return animations;
  }
  _createAnimations(target, values) {
    const animatedProps = this._properties;
    const animations = [];
    const running = target.$animations || (target.$animations = {});
    const props = Object.keys(values);
    const date = Date.now();
    let i2;
    for (i2 = props.length - 1; i2 >= 0; --i2) {
      const prop = props[i2];
      if (prop.charAt(0) === "$") {
        continue;
      }
      if (prop === "options") {
        animations.push(...this._animateOptions(target, values));
        continue;
      }
      const value = values[prop];
      let animation = running[prop];
      const cfg = animatedProps.get(prop);
      if (animation) {
        if (cfg && animation.active()) {
          animation.update(cfg, value, date);
          continue;
        } else {
          animation.cancel();
        }
      }
      if (!cfg || !cfg.duration) {
        target[prop] = value;
        continue;
      }
      running[prop] = animation = new Animation(cfg, target, prop, value);
      animations.push(animation);
    }
    return animations;
  }
  update(target, values) {
    if (this._properties.size === 0) {
      Object.assign(target, values);
      return;
    }
    const animations = this._createAnimations(target, values);
    if (animations.length) {
      animator.add(this._chart, animations);
      return true;
    }
  }
};
__name(_Animations, "Animations");
let Animations = _Animations;
function awaitAll(animations, properties) {
  const running = [];
  const keys2 = Object.keys(properties);
  for (let i2 = 0; i2 < keys2.length; i2++) {
    const anim = animations[keys2[i2]];
    if (anim && anim.active()) {
      running.push(anim.wait());
    }
  }
  return Promise.all(running);
}
__name(awaitAll, "awaitAll");
function resolveTargetOptions(target, newOptions) {
  if (!newOptions) {
    return;
  }
  let options = target.options;
  if (!options) {
    target.options = newOptions;
    return;
  }
  if (options.$shared) {
    target.options = options = Object.assign({}, options, {
      $shared: false,
      $animations: {}
    });
  }
  return options;
}
__name(resolveTargetOptions, "resolveTargetOptions");
function scaleClip(scale, allowedOverflow) {
  const opts = scale && scale.options || {};
  const reverse = opts.reverse;
  const min = opts.min === void 0 ? allowedOverflow : 0;
  const max2 = opts.max === void 0 ? allowedOverflow : 0;
  return {
    start: reverse ? max2 : min,
    end: reverse ? min : max2
  };
}
__name(scaleClip, "scaleClip");
function defaultClip(xScale, yScale, allowedOverflow) {
  if (allowedOverflow === false) {
    return false;
  }
  const x2 = scaleClip(xScale, allowedOverflow);
  const y2 = scaleClip(yScale, allowedOverflow);
  return {
    top: y2.end,
    right: x2.end,
    bottom: y2.start,
    left: x2.start
  };
}
__name(defaultClip, "defaultClip");
function toClip(value) {
  let t2, r, b2, l2;
  if (isObject(value)) {
    t2 = value.top;
    r = value.right;
    b2 = value.bottom;
    l2 = value.left;
  } else {
    t2 = r = b2 = l2 = value;
  }
  return {
    top: t2,
    right: r,
    bottom: b2,
    left: l2,
    disabled: value === false
  };
}
__name(toClip, "toClip");
function getSortedDatasetIndices(chart, filterVisible) {
  const keys2 = [];
  const metasets = chart._getSortedDatasetMetas(filterVisible);
  let i2, ilen;
  for (i2 = 0, ilen = metasets.length; i2 < ilen; ++i2) {
    keys2.push(metasets[i2].index);
  }
  return keys2;
}
__name(getSortedDatasetIndices, "getSortedDatasetIndices");
function applyStack(stack, value, dsIndex, options = {}) {
  const keys2 = stack.keys;
  const singleMode = options.mode === "single";
  let i2, ilen, datasetIndex, otherValue;
  if (value === null) {
    return;
  }
  let found = false;
  for (i2 = 0, ilen = keys2.length; i2 < ilen; ++i2) {
    datasetIndex = +keys2[i2];
    if (datasetIndex === dsIndex) {
      found = true;
      if (options.all) {
        continue;
      }
      break;
    }
    otherValue = stack.values[datasetIndex];
    if (isNumberFinite(otherValue) && (singleMode || value === 0 || sign(value) === sign(otherValue))) {
      value += otherValue;
    }
  }
  if (!found && !options.all) {
    return 0;
  }
  return value;
}
__name(applyStack, "applyStack");
function convertObjectDataToArray(data, meta) {
  const { iScale, vScale } = meta;
  const iAxisKey = iScale.axis === "x" ? "x" : "y";
  const vAxisKey = vScale.axis === "x" ? "x" : "y";
  const keys2 = Object.keys(data);
  const adata = new Array(keys2.length);
  let i2, ilen, key;
  for (i2 = 0, ilen = keys2.length; i2 < ilen; ++i2) {
    key = keys2[i2];
    adata[i2] = {
      [iAxisKey]: key,
      [vAxisKey]: data[key]
    };
  }
  return adata;
}
__name(convertObjectDataToArray, "convertObjectDataToArray");
function isStacked(scale, meta) {
  const stacked = scale && scale.options.stacked;
  return stacked || stacked === void 0 && meta.stack !== void 0;
}
__name(isStacked, "isStacked");
function getStackKey(indexScale, valueScale, meta) {
  return `${indexScale.id}.${valueScale.id}.${meta.stack || meta.type}`;
}
__name(getStackKey, "getStackKey");
function getUserBounds(scale) {
  const { min, max: max2, minDefined, maxDefined } = scale.getUserBounds();
  return {
    min: minDefined ? min : Number.NEGATIVE_INFINITY,
    max: maxDefined ? max2 : Number.POSITIVE_INFINITY
  };
}
__name(getUserBounds, "getUserBounds");
function getOrCreateStack(stacks, stackKey, indexValue) {
  const subStack = stacks[stackKey] || (stacks[stackKey] = {});
  return subStack[indexValue] || (subStack[indexValue] = {});
}
__name(getOrCreateStack, "getOrCreateStack");
function getLastIndexInStack(stack, vScale, positive, type) {
  for (const meta of vScale.getMatchingVisibleMetas(type).reverse()) {
    const value = stack[meta.index];
    if (positive && value > 0 || !positive && value < 0) {
      return meta.index;
    }
  }
  return null;
}
__name(getLastIndexInStack, "getLastIndexInStack");
function updateStacks(controller, parsed) {
  const { chart, _cachedMeta: meta } = controller;
  const stacks = chart._stacks || (chart._stacks = {});
  const { iScale, vScale, index: datasetIndex } = meta;
  const iAxis = iScale.axis;
  const vAxis = vScale.axis;
  const key = getStackKey(iScale, vScale, meta);
  const ilen = parsed.length;
  let stack;
  for (let i2 = 0; i2 < ilen; ++i2) {
    const item = parsed[i2];
    const { [iAxis]: index2, [vAxis]: value } = item;
    const itemStacks = item._stacks || (item._stacks = {});
    stack = itemStacks[vAxis] = getOrCreateStack(stacks, key, index2);
    stack[datasetIndex] = value;
    stack._top = getLastIndexInStack(stack, vScale, true, meta.type);
    stack._bottom = getLastIndexInStack(stack, vScale, false, meta.type);
    const visualValues = stack._visualValues || (stack._visualValues = {});
    visualValues[datasetIndex] = value;
  }
}
__name(updateStacks, "updateStacks");
function getFirstScaleId(chart, axis) {
  const scales = chart.scales;
  return Object.keys(scales).filter((key) => scales[key].axis === axis).shift();
}
__name(getFirstScaleId, "getFirstScaleId");
function createDatasetContext(parent, index2) {
  return createContext(parent, {
    active: false,
    dataset: void 0,
    datasetIndex: index2,
    index: index2,
    mode: "default",
    type: "dataset"
  });
}
__name(createDatasetContext, "createDatasetContext");
function createDataContext(parent, index2, element) {
  return createContext(parent, {
    active: false,
    dataIndex: index2,
    parsed: void 0,
    raw: void 0,
    element,
    index: index2,
    mode: "default",
    type: "data"
  });
}
__name(createDataContext, "createDataContext");
function clearStacks(meta, items) {
  const datasetIndex = meta.controller.index;
  const axis = meta.vScale && meta.vScale.axis;
  if (!axis) {
    return;
  }
  items = items || meta._parsed;
  for (const parsed of items) {
    const stacks = parsed._stacks;
    if (!stacks || stacks[axis] === void 0 || stacks[axis][datasetIndex] === void 0) {
      return;
    }
    delete stacks[axis][datasetIndex];
    if (stacks[axis]._visualValues !== void 0 && stacks[axis]._visualValues[datasetIndex] !== void 0) {
      delete stacks[axis]._visualValues[datasetIndex];
    }
  }
}
__name(clearStacks, "clearStacks");
const isDirectUpdateMode = /* @__PURE__ */ __name((mode) => mode === "reset" || mode === "none", "isDirectUpdateMode");
const cloneIfNotShared = /* @__PURE__ */ __name((cached, shared) => shared ? cached : Object.assign({}, cached), "cloneIfNotShared");
const createStack = /* @__PURE__ */ __name((canStack, meta, chart) => canStack && !meta.hidden && meta._stacked && {
  keys: getSortedDatasetIndices(chart, true),
  values: null
}, "createStack");
const _DatasetController = class _DatasetController {
  constructor(chart, datasetIndex) {
    this.chart = chart;
    this._ctx = chart.ctx;
    this.index = datasetIndex;
    this._cachedDataOpts = {};
    this._cachedMeta = this.getMeta();
    this._type = this._cachedMeta.type;
    this.options = void 0;
    this._parsing = false;
    this._data = void 0;
    this._objectData = void 0;
    this._sharedOptions = void 0;
    this._drawStart = void 0;
    this._drawCount = void 0;
    this.enableOptionSharing = false;
    this.supportsDecimation = false;
    this.$context = void 0;
    this._syncList = [];
    this.datasetElementType = new.target.datasetElementType;
    this.dataElementType = new.target.dataElementType;
    this.initialize();
  }
  initialize() {
    const meta = this._cachedMeta;
    this.configure();
    this.linkScales();
    meta._stacked = isStacked(meta.vScale, meta);
    this.addElements();
    if (this.options.fill && !this.chart.isPluginEnabled("filler")) {
      console.warn("Tried to use the 'fill' option without the 'Filler' plugin enabled. Please import and register the 'Filler' plugin and make sure it is not disabled in the options");
    }
  }
  updateIndex(datasetIndex) {
    if (this.index !== datasetIndex) {
      clearStacks(this._cachedMeta);
    }
    this.index = datasetIndex;
  }
  linkScales() {
    const chart = this.chart;
    const meta = this._cachedMeta;
    const dataset = this.getDataset();
    const chooseId = /* @__PURE__ */ __name((axis, x2, y2, r) => axis === "x" ? x2 : axis === "r" ? r : y2, "chooseId");
    const xid = meta.xAxisID = valueOrDefault(dataset.xAxisID, getFirstScaleId(chart, "x"));
    const yid = meta.yAxisID = valueOrDefault(dataset.yAxisID, getFirstScaleId(chart, "y"));
    const rid = meta.rAxisID = valueOrDefault(dataset.rAxisID, getFirstScaleId(chart, "r"));
    const indexAxis = meta.indexAxis;
    const iid = meta.iAxisID = chooseId(indexAxis, xid, yid, rid);
    const vid = meta.vAxisID = chooseId(indexAxis, yid, xid, rid);
    meta.xScale = this.getScaleForId(xid);
    meta.yScale = this.getScaleForId(yid);
    meta.rScale = this.getScaleForId(rid);
    meta.iScale = this.getScaleForId(iid);
    meta.vScale = this.getScaleForId(vid);
  }
  getDataset() {
    return this.chart.data.datasets[this.index];
  }
  getMeta() {
    return this.chart.getDatasetMeta(this.index);
  }
  getScaleForId(scaleID) {
    return this.chart.scales[scaleID];
  }
  _getOtherScale(scale) {
    const meta = this._cachedMeta;
    return scale === meta.iScale ? meta.vScale : meta.iScale;
  }
  reset() {
    this._update("reset");
  }
  _destroy() {
    const meta = this._cachedMeta;
    if (this._data) {
      unlistenArrayEvents(this._data, this);
    }
    if (meta._stacked) {
      clearStacks(meta);
    }
  }
  _dataCheck() {
    const dataset = this.getDataset();
    const data = dataset.data || (dataset.data = []);
    const _data = this._data;
    if (isObject(data)) {
      const meta = this._cachedMeta;
      this._data = convertObjectDataToArray(data, meta);
    } else if (_data !== data) {
      if (_data) {
        unlistenArrayEvents(_data, this);
        const meta = this._cachedMeta;
        clearStacks(meta);
        meta._parsed = [];
      }
      if (data && Object.isExtensible(data)) {
        listenArrayEvents(data, this);
      }
      this._syncList = [];
      this._data = data;
    }
  }
  addElements() {
    const meta = this._cachedMeta;
    this._dataCheck();
    if (this.datasetElementType) {
      meta.dataset = new this.datasetElementType();
    }
  }
  buildOrUpdateElements(resetNewElements) {
    const meta = this._cachedMeta;
    const dataset = this.getDataset();
    let stackChanged = false;
    this._dataCheck();
    const oldStacked = meta._stacked;
    meta._stacked = isStacked(meta.vScale, meta);
    if (meta.stack !== dataset.stack) {
      stackChanged = true;
      clearStacks(meta);
      meta.stack = dataset.stack;
    }
    this._resyncElements(resetNewElements);
    if (stackChanged || oldStacked !== meta._stacked) {
      updateStacks(this, meta._parsed);
      meta._stacked = isStacked(meta.vScale, meta);
    }
  }
  configure() {
    const config = this.chart.config;
    const scopeKeys = config.datasetScopeKeys(this._type);
    const scopes = config.getOptionScopes(this.getDataset(), scopeKeys, true);
    this.options = config.createResolver(scopes, this.getContext());
    this._parsing = this.options.parsing;
    this._cachedDataOpts = {};
  }
  parse(start, count) {
    const { _cachedMeta: meta, _data: data } = this;
    const { iScale, _stacked } = meta;
    const iAxis = iScale.axis;
    let sorted = start === 0 && count === data.length ? true : meta._sorted;
    let prev = start > 0 && meta._parsed[start - 1];
    let i2, cur, parsed;
    if (this._parsing === false) {
      meta._parsed = data;
      meta._sorted = true;
      parsed = data;
    } else {
      if (isArray(data[start])) {
        parsed = this.parseArrayData(meta, data, start, count);
      } else if (isObject(data[start])) {
        parsed = this.parseObjectData(meta, data, start, count);
      } else {
        parsed = this.parsePrimitiveData(meta, data, start, count);
      }
      const isNotInOrderComparedToPrev = /* @__PURE__ */ __name(() => cur[iAxis] === null || prev && cur[iAxis] < prev[iAxis], "isNotInOrderComparedToPrev");
      for (i2 = 0; i2 < count; ++i2) {
        meta._parsed[i2 + start] = cur = parsed[i2];
        if (sorted) {
          if (isNotInOrderComparedToPrev()) {
            sorted = false;
          }
          prev = cur;
        }
      }
      meta._sorted = sorted;
    }
    if (_stacked) {
      updateStacks(this, parsed);
    }
  }
  parsePrimitiveData(meta, data, start, count) {
    const { iScale, vScale } = meta;
    const iAxis = iScale.axis;
    const vAxis = vScale.axis;
    const labels = iScale.getLabels();
    const singleScale = iScale === vScale;
    const parsed = new Array(count);
    let i2, ilen, index2;
    for (i2 = 0, ilen = count; i2 < ilen; ++i2) {
      index2 = i2 + start;
      parsed[i2] = {
        [iAxis]: singleScale || iScale.parse(labels[index2], index2),
        [vAxis]: vScale.parse(data[index2], index2)
      };
    }
    return parsed;
  }
  parseArrayData(meta, data, start, count) {
    const { xScale, yScale } = meta;
    const parsed = new Array(count);
    let i2, ilen, index2, item;
    for (i2 = 0, ilen = count; i2 < ilen; ++i2) {
      index2 = i2 + start;
      item = data[index2];
      parsed[i2] = {
        x: xScale.parse(item[0], index2),
        y: yScale.parse(item[1], index2)
      };
    }
    return parsed;
  }
  parseObjectData(meta, data, start, count) {
    const { xScale, yScale } = meta;
    const { xAxisKey = "x", yAxisKey = "y" } = this._parsing;
    const parsed = new Array(count);
    let i2, ilen, index2, item;
    for (i2 = 0, ilen = count; i2 < ilen; ++i2) {
      index2 = i2 + start;
      item = data[index2];
      parsed[i2] = {
        x: xScale.parse(resolveObjectKey(item, xAxisKey), index2),
        y: yScale.parse(resolveObjectKey(item, yAxisKey), index2)
      };
    }
    return parsed;
  }
  getParsed(index2) {
    return this._cachedMeta._parsed[index2];
  }
  getDataElement(index2) {
    return this._cachedMeta.data[index2];
  }
  applyStack(scale, parsed, mode) {
    const chart = this.chart;
    const meta = this._cachedMeta;
    const value = parsed[scale.axis];
    const stack = {
      keys: getSortedDatasetIndices(chart, true),
      values: parsed._stacks[scale.axis]._visualValues
    };
    return applyStack(stack, value, meta.index, {
      mode
    });
  }
  updateRangeFromParsed(range, scale, parsed, stack) {
    const parsedValue = parsed[scale.axis];
    let value = parsedValue === null ? NaN : parsedValue;
    const values = stack && parsed._stacks[scale.axis];
    if (stack && values) {
      stack.values = values;
      value = applyStack(stack, parsedValue, this._cachedMeta.index);
    }
    range.min = Math.min(range.min, value);
    range.max = Math.max(range.max, value);
  }
  getMinMax(scale, canStack) {
    const meta = this._cachedMeta;
    const _parsed = meta._parsed;
    const sorted = meta._sorted && scale === meta.iScale;
    const ilen = _parsed.length;
    const otherScale = this._getOtherScale(scale);
    const stack = createStack(canStack, meta, this.chart);
    const range = {
      min: Number.POSITIVE_INFINITY,
      max: Number.NEGATIVE_INFINITY
    };
    const { min: otherMin, max: otherMax } = getUserBounds(otherScale);
    let i2, parsed;
    function _skip() {
      parsed = _parsed[i2];
      const otherValue = parsed[otherScale.axis];
      return !isNumberFinite(parsed[scale.axis]) || otherMin > otherValue || otherMax < otherValue;
    }
    __name(_skip, "_skip");
    for (i2 = 0; i2 < ilen; ++i2) {
      if (_skip()) {
        continue;
      }
      this.updateRangeFromParsed(range, scale, parsed, stack);
      if (sorted) {
        break;
      }
    }
    if (sorted) {
      for (i2 = ilen - 1; i2 >= 0; --i2) {
        if (_skip()) {
          continue;
        }
        this.updateRangeFromParsed(range, scale, parsed, stack);
        break;
      }
    }
    return range;
  }
  getAllParsedValues(scale) {
    const parsed = this._cachedMeta._parsed;
    const values = [];
    let i2, ilen, value;
    for (i2 = 0, ilen = parsed.length; i2 < ilen; ++i2) {
      value = parsed[i2][scale.axis];
      if (isNumberFinite(value)) {
        values.push(value);
      }
    }
    return values;
  }
  getMaxOverflow() {
    return false;
  }
  getLabelAndValue(index2) {
    const meta = this._cachedMeta;
    const iScale = meta.iScale;
    const vScale = meta.vScale;
    const parsed = this.getParsed(index2);
    return {
      label: iScale ? "" + iScale.getLabelForValue(parsed[iScale.axis]) : "",
      value: vScale ? "" + vScale.getLabelForValue(parsed[vScale.axis]) : ""
    };
  }
  _update(mode) {
    const meta = this._cachedMeta;
    this.update(mode || "default");
    meta._clip = toClip(valueOrDefault(this.options.clip, defaultClip(meta.xScale, meta.yScale, this.getMaxOverflow())));
  }
  update(mode) {
  }
  draw() {
    const ctx = this._ctx;
    const chart = this.chart;
    const meta = this._cachedMeta;
    const elements = meta.data || [];
    const area = chart.chartArea;
    const active = [];
    const start = this._drawStart || 0;
    const count = this._drawCount || elements.length - start;
    const drawActiveElementsOnTop = this.options.drawActiveElementsOnTop;
    let i2;
    if (meta.dataset) {
      meta.dataset.draw(ctx, area, start, count);
    }
    for (i2 = start; i2 < start + count; ++i2) {
      const element = elements[i2];
      if (element.hidden) {
        continue;
      }
      if (element.active && drawActiveElementsOnTop) {
        active.push(element);
      } else {
        element.draw(ctx, area);
      }
    }
    for (i2 = 0; i2 < active.length; ++i2) {
      active[i2].draw(ctx, area);
    }
  }
  getStyle(index2, active) {
    const mode = active ? "active" : "default";
    return index2 === void 0 && this._cachedMeta.dataset ? this.resolveDatasetElementOptions(mode) : this.resolveDataElementOptions(index2 || 0, mode);
  }
  getContext(index2, active, mode) {
    const dataset = this.getDataset();
    let context;
    if (index2 >= 0 && index2 < this._cachedMeta.data.length) {
      const element = this._cachedMeta.data[index2];
      context = element.$context || (element.$context = createDataContext(this.getContext(), index2, element));
      context.parsed = this.getParsed(index2);
      context.raw = dataset.data[index2];
      context.index = context.dataIndex = index2;
    } else {
      context = this.$context || (this.$context = createDatasetContext(this.chart.getContext(), this.index));
      context.dataset = dataset;
      context.index = context.datasetIndex = this.index;
    }
    context.active = !!active;
    context.mode = mode;
    return context;
  }
  resolveDatasetElementOptions(mode) {
    return this._resolveElementOptions(this.datasetElementType.id, mode);
  }
  resolveDataElementOptions(index2, mode) {
    return this._resolveElementOptions(this.dataElementType.id, mode, index2);
  }
  _resolveElementOptions(elementType, mode = "default", index2) {
    const active = mode === "active";
    const cache = this._cachedDataOpts;
    const cacheKey = elementType + "-" + mode;
    const cached = cache[cacheKey];
    const sharing = this.enableOptionSharing && defined(index2);
    if (cached) {
      return cloneIfNotShared(cached, sharing);
    }
    const config = this.chart.config;
    const scopeKeys = config.datasetElementScopeKeys(this._type, elementType);
    const prefixes = active ? [
      `${elementType}Hover`,
      "hover",
      elementType,
      ""
    ] : [
      elementType,
      ""
    ];
    const scopes = config.getOptionScopes(this.getDataset(), scopeKeys);
    const names2 = Object.keys(defaults.elements[elementType]);
    const context = /* @__PURE__ */ __name(() => this.getContext(index2, active, mode), "context");
    const values = config.resolveNamedOptions(scopes, names2, context, prefixes);
    if (values.$shared) {
      values.$shared = sharing;
      cache[cacheKey] = Object.freeze(cloneIfNotShared(values, sharing));
    }
    return values;
  }
  _resolveAnimations(index2, transition, active) {
    const chart = this.chart;
    const cache = this._cachedDataOpts;
    const cacheKey = `animation-${transition}`;
    const cached = cache[cacheKey];
    if (cached) {
      return cached;
    }
    let options;
    if (chart.options.animation !== false) {
      const config = this.chart.config;
      const scopeKeys = config.datasetAnimationScopeKeys(this._type, transition);
      const scopes = config.getOptionScopes(this.getDataset(), scopeKeys);
      options = config.createResolver(scopes, this.getContext(index2, active, transition));
    }
    const animations = new Animations(chart, options && options.animations);
    if (options && options._cacheable) {
      cache[cacheKey] = Object.freeze(animations);
    }
    return animations;
  }
  getSharedOptions(options) {
    if (!options.$shared) {
      return;
    }
    return this._sharedOptions || (this._sharedOptions = Object.assign({}, options));
  }
  includeOptions(mode, sharedOptions) {
    return !sharedOptions || isDirectUpdateMode(mode) || this.chart._animationsDisabled;
  }
  _getSharedOptions(start, mode) {
    const firstOpts = this.resolveDataElementOptions(start, mode);
    const previouslySharedOptions = this._sharedOptions;
    const sharedOptions = this.getSharedOptions(firstOpts);
    const includeOptions = this.includeOptions(mode, sharedOptions) || sharedOptions !== previouslySharedOptions;
    this.updateSharedOptions(sharedOptions, mode, firstOpts);
    return {
      sharedOptions,
      includeOptions
    };
  }
  updateElement(element, index2, properties, mode) {
    if (isDirectUpdateMode(mode)) {
      Object.assign(element, properties);
    } else {
      this._resolveAnimations(index2, mode).update(element, properties);
    }
  }
  updateSharedOptions(sharedOptions, mode, newOptions) {
    if (sharedOptions && !isDirectUpdateMode(mode)) {
      this._resolveAnimations(void 0, mode).update(sharedOptions, newOptions);
    }
  }
  _setStyle(element, index2, mode, active) {
    element.active = active;
    const options = this.getStyle(index2, active);
    this._resolveAnimations(index2, mode, active).update(element, {
      options: !active && this.getSharedOptions(options) || options
    });
  }
  removeHoverStyle(element, datasetIndex, index2) {
    this._setStyle(element, index2, "active", false);
  }
  setHoverStyle(element, datasetIndex, index2) {
    this._setStyle(element, index2, "active", true);
  }
  _removeDatasetHoverStyle() {
    const element = this._cachedMeta.dataset;
    if (element) {
      this._setStyle(element, void 0, "active", false);
    }
  }
  _setDatasetHoverStyle() {
    const element = this._cachedMeta.dataset;
    if (element) {
      this._setStyle(element, void 0, "active", true);
    }
  }
  _resyncElements(resetNewElements) {
    const data = this._data;
    const elements = this._cachedMeta.data;
    for (const [method, arg1, arg2] of this._syncList) {
      this[method](arg1, arg2);
    }
    this._syncList = [];
    const numMeta = elements.length;
    const numData = data.length;
    const count = Math.min(numData, numMeta);
    if (count) {
      this.parse(0, count);
    }
    if (numData > numMeta) {
      this._insertElements(numMeta, numData - numMeta, resetNewElements);
    } else if (numData < numMeta) {
      this._removeElements(numData, numMeta - numData);
    }
  }
  _insertElements(start, count, resetNewElements = true) {
    const meta = this._cachedMeta;
    const data = meta.data;
    const end = start + count;
    let i2;
    const move = /* @__PURE__ */ __name((arr) => {
      arr.length += count;
      for (i2 = arr.length - 1; i2 >= end; i2--) {
        arr[i2] = arr[i2 - count];
      }
    }, "move");
    move(data);
    for (i2 = start; i2 < end; ++i2) {
      data[i2] = new this.dataElementType();
    }
    if (this._parsing) {
      move(meta._parsed);
    }
    this.parse(start, count);
    if (resetNewElements) {
      this.updateElements(data, start, count, "reset");
    }
  }
  updateElements(element, start, count, mode) {
  }
  _removeElements(start, count) {
    const meta = this._cachedMeta;
    if (this._parsing) {
      const removed = meta._parsed.splice(start, count);
      if (meta._stacked) {
        clearStacks(meta, removed);
      }
    }
    meta.data.splice(start, count);
  }
  _sync(args) {
    if (this._parsing) {
      this._syncList.push(args);
    } else {
      const [method, arg1, arg2] = args;
      this[method](arg1, arg2);
    }
    this.chart._dataChanges.push([
      this.index,
      ...args
    ]);
  }
  _onDataPush() {
    const count = arguments.length;
    this._sync([
      "_insertElements",
      this.getDataset().data.length - count,
      count
    ]);
  }
  _onDataPop() {
    this._sync([
      "_removeElements",
      this._cachedMeta.data.length - 1,
      1
    ]);
  }
  _onDataShift() {
    this._sync([
      "_removeElements",
      0,
      1
    ]);
  }
  _onDataSplice(start, count) {
    if (count) {
      this._sync([
        "_removeElements",
        start,
        count
      ]);
    }
    const newCount = arguments.length - 2;
    if (newCount) {
      this._sync([
        "_insertElements",
        start,
        newCount
      ]);
    }
  }
  _onDataUnshift() {
    this._sync([
      "_insertElements",
      0,
      arguments.length
    ]);
  }
};
__name(_DatasetController, "DatasetController");
__publicField(_DatasetController, "defaults", {});
__publicField(_DatasetController, "datasetElementType", null);
__publicField(_DatasetController, "dataElementType", null);
let DatasetController = _DatasetController;
function getAllScaleValues(scale, type) {
  if (!scale._cache.$bar) {
    const visibleMetas = scale.getMatchingVisibleMetas(type);
    let values = [];
    for (let i2 = 0, ilen = visibleMetas.length; i2 < ilen; i2++) {
      values = values.concat(visibleMetas[i2].controller.getAllParsedValues(scale));
    }
    scale._cache.$bar = _arrayUnique(values.sort((a2, b2) => a2 - b2));
  }
  return scale._cache.$bar;
}
__name(getAllScaleValues, "getAllScaleValues");
function computeMinSampleSize(meta) {
  const scale = meta.iScale;
  const values = getAllScaleValues(scale, meta.type);
  let min = scale._length;
  let i2, ilen, curr, prev;
  const updateMinAndPrev = /* @__PURE__ */ __name(() => {
    if (curr === 32767 || curr === -32768) {
      return;
    }
    if (defined(prev)) {
      min = Math.min(min, Math.abs(curr - prev) || min);
    }
    prev = curr;
  }, "updateMinAndPrev");
  for (i2 = 0, ilen = values.length; i2 < ilen; ++i2) {
    curr = scale.getPixelForValue(values[i2]);
    updateMinAndPrev();
  }
  prev = void 0;
  for (i2 = 0, ilen = scale.ticks.length; i2 < ilen; ++i2) {
    curr = scale.getPixelForTick(i2);
    updateMinAndPrev();
  }
  return min;
}
__name(computeMinSampleSize, "computeMinSampleSize");
function computeFitCategoryTraits(index2, ruler, options, stackCount) {
  const thickness = options.barThickness;
  let size, ratio;
  if (isNullOrUndef(thickness)) {
    size = ruler.min * options.categoryPercentage;
    ratio = options.barPercentage;
  } else {
    size = thickness * stackCount;
    ratio = 1;
  }
  return {
    chunk: size / stackCount,
    ratio,
    start: ruler.pixels[index2] - size / 2
  };
}
__name(computeFitCategoryTraits, "computeFitCategoryTraits");
function computeFlexCategoryTraits(index2, ruler, options, stackCount) {
  const pixels = ruler.pixels;
  const curr = pixels[index2];
  let prev = index2 > 0 ? pixels[index2 - 1] : null;
  let next = index2 < pixels.length - 1 ? pixels[index2 + 1] : null;
  const percent = options.categoryPercentage;
  if (prev === null) {
    prev = curr - (next === null ? ruler.end - ruler.start : next - curr);
  }
  if (next === null) {
    next = curr + curr - prev;
  }
  const start = curr - (curr - Math.min(prev, next)) / 2 * percent;
  const size = Math.abs(next - prev) / 2 * percent;
  return {
    chunk: size / stackCount,
    ratio: options.barPercentage,
    start
  };
}
__name(computeFlexCategoryTraits, "computeFlexCategoryTraits");
function parseFloatBar(entry, item, vScale, i2) {
  const startValue = vScale.parse(entry[0], i2);
  const endValue = vScale.parse(entry[1], i2);
  const min = Math.min(startValue, endValue);
  const max2 = Math.max(startValue, endValue);
  let barStart = min;
  let barEnd = max2;
  if (Math.abs(min) > Math.abs(max2)) {
    barStart = max2;
    barEnd = min;
  }
  item[vScale.axis] = barEnd;
  item._custom = {
    barStart,
    barEnd,
    start: startValue,
    end: endValue,
    min,
    max: max2
  };
}
__name(parseFloatBar, "parseFloatBar");
function parseValue(entry, item, vScale, i2) {
  if (isArray(entry)) {
    parseFloatBar(entry, item, vScale, i2);
  } else {
    item[vScale.axis] = vScale.parse(entry, i2);
  }
  return item;
}
__name(parseValue, "parseValue");
function parseArrayOrPrimitive(meta, data, start, count) {
  const iScale = meta.iScale;
  const vScale = meta.vScale;
  const labels = iScale.getLabels();
  const singleScale = iScale === vScale;
  const parsed = [];
  let i2, ilen, item, entry;
  for (i2 = start, ilen = start + count; i2 < ilen; ++i2) {
    entry = data[i2];
    item = {};
    item[iScale.axis] = singleScale || iScale.parse(labels[i2], i2);
    parsed.push(parseValue(entry, item, vScale, i2));
  }
  return parsed;
}
__name(parseArrayOrPrimitive, "parseArrayOrPrimitive");
function isFloatBar(custom) {
  return custom && custom.barStart !== void 0 && custom.barEnd !== void 0;
}
__name(isFloatBar, "isFloatBar");
function barSign(size, vScale, actualBase) {
  if (size !== 0) {
    return sign(size);
  }
  return (vScale.isHorizontal() ? 1 : -1) * (vScale.min >= actualBase ? 1 : -1);
}
__name(barSign, "barSign");
function borderProps(properties) {
  let reverse, start, end, top, bottom;
  if (properties.horizontal) {
    reverse = properties.base > properties.x;
    start = "left";
    end = "right";
  } else {
    reverse = properties.base < properties.y;
    start = "bottom";
    end = "top";
  }
  if (reverse) {
    top = "end";
    bottom = "start";
  } else {
    top = "start";
    bottom = "end";
  }
  return {
    start,
    end,
    reverse,
    top,
    bottom
  };
}
__name(borderProps, "borderProps");
function setBorderSkipped(properties, options, stack, index2) {
  let edge = options.borderSkipped;
  const res = {};
  if (!edge) {
    properties.borderSkipped = res;
    return;
  }
  if (edge === true) {
    properties.borderSkipped = {
      top: true,
      right: true,
      bottom: true,
      left: true
    };
    return;
  }
  const { start, end, reverse, top, bottom } = borderProps(properties);
  if (edge === "middle" && stack) {
    properties.enableBorderRadius = true;
    if ((stack._top || 0) === index2) {
      edge = top;
    } else if ((stack._bottom || 0) === index2) {
      edge = bottom;
    } else {
      res[parseEdge(bottom, start, end, reverse)] = true;
      edge = top;
    }
  }
  res[parseEdge(edge, start, end, reverse)] = true;
  properties.borderSkipped = res;
}
__name(setBorderSkipped, "setBorderSkipped");
function parseEdge(edge, a2, b2, reverse) {
  if (reverse) {
    edge = swap(edge, a2, b2);
    edge = startEnd(edge, b2, a2);
  } else {
    edge = startEnd(edge, a2, b2);
  }
  return edge;
}
__name(parseEdge, "parseEdge");
function swap(orig, v1, v2) {
  return orig === v1 ? v2 : orig === v2 ? v1 : orig;
}
__name(swap, "swap");
function startEnd(v2, start, end) {
  return v2 === "start" ? start : v2 === "end" ? end : v2;
}
__name(startEnd, "startEnd");
function setInflateAmount(properties, { inflateAmount }, ratio) {
  properties.inflateAmount = inflateAmount === "auto" ? ratio === 1 ? 0.33 : 0 : inflateAmount;
}
__name(setInflateAmount, "setInflateAmount");
const _BarController = class _BarController extends DatasetController {
  parsePrimitiveData(meta, data, start, count) {
    return parseArrayOrPrimitive(meta, data, start, count);
  }
  parseArrayData(meta, data, start, count) {
    return parseArrayOrPrimitive(meta, data, start, count);
  }
  parseObjectData(meta, data, start, count) {
    const { iScale, vScale } = meta;
    const { xAxisKey = "x", yAxisKey = "y" } = this._parsing;
    const iAxisKey = iScale.axis === "x" ? xAxisKey : yAxisKey;
    const vAxisKey = vScale.axis === "x" ? xAxisKey : yAxisKey;
    const parsed = [];
    let i2, ilen, item, obj;
    for (i2 = start, ilen = start + count; i2 < ilen; ++i2) {
      obj = data[i2];
      item = {};
      item[iScale.axis] = iScale.parse(resolveObjectKey(obj, iAxisKey), i2);
      parsed.push(parseValue(resolveObjectKey(obj, vAxisKey), item, vScale, i2));
    }
    return parsed;
  }
  updateRangeFromParsed(range, scale, parsed, stack) {
    super.updateRangeFromParsed(range, scale, parsed, stack);
    const custom = parsed._custom;
    if (custom && scale === this._cachedMeta.vScale) {
      range.min = Math.min(range.min, custom.min);
      range.max = Math.max(range.max, custom.max);
    }
  }
  getMaxOverflow() {
    return 0;
  }
  getLabelAndValue(index2) {
    const meta = this._cachedMeta;
    const { iScale, vScale } = meta;
    const parsed = this.getParsed(index2);
    const custom = parsed._custom;
    const value = isFloatBar(custom) ? "[" + custom.start + ", " + custom.end + "]" : "" + vScale.getLabelForValue(parsed[vScale.axis]);
    return {
      label: "" + iScale.getLabelForValue(parsed[iScale.axis]),
      value
    };
  }
  initialize() {
    this.enableOptionSharing = true;
    super.initialize();
    const meta = this._cachedMeta;
    meta.stack = this.getDataset().stack;
  }
  update(mode) {
    const meta = this._cachedMeta;
    this.updateElements(meta.data, 0, meta.data.length, mode);
  }
  updateElements(bars, start, count, mode) {
    const reset = mode === "reset";
    const { index: index2, _cachedMeta: { vScale } } = this;
    const base = vScale.getBasePixel();
    const horizontal = vScale.isHorizontal();
    const ruler = this._getRuler();
    const { sharedOptions, includeOptions } = this._getSharedOptions(start, mode);
    for (let i2 = start; i2 < start + count; i2++) {
      const parsed = this.getParsed(i2);
      const vpixels = reset || isNullOrUndef(parsed[vScale.axis]) ? {
        base,
        head: base
      } : this._calculateBarValuePixels(i2);
      const ipixels = this._calculateBarIndexPixels(i2, ruler);
      const stack = (parsed._stacks || {})[vScale.axis];
      const properties = {
        horizontal,
        base: vpixels.base,
        enableBorderRadius: !stack || isFloatBar(parsed._custom) || index2 === stack._top || index2 === stack._bottom,
        x: horizontal ? vpixels.head : ipixels.center,
        y: horizontal ? ipixels.center : vpixels.head,
        height: horizontal ? ipixels.size : Math.abs(vpixels.size),
        width: horizontal ? Math.abs(vpixels.size) : ipixels.size
      };
      if (includeOptions) {
        properties.options = sharedOptions || this.resolveDataElementOptions(i2, bars[i2].active ? "active" : mode);
      }
      const options = properties.options || bars[i2].options;
      setBorderSkipped(properties, options, stack, index2);
      setInflateAmount(properties, options, ruler.ratio);
      this.updateElement(bars[i2], i2, properties, mode);
    }
  }
  _getStacks(last, dataIndex) {
    const { iScale } = this._cachedMeta;
    const metasets = iScale.getMatchingVisibleMetas(this._type).filter((meta) => meta.controller.options.grouped);
    const stacked = iScale.options.stacked;
    const stacks = [];
    const currentParsed = this._cachedMeta.controller.getParsed(dataIndex);
    const iScaleValue = currentParsed && currentParsed[iScale.axis];
    const skipNull = /* @__PURE__ */ __name((meta) => {
      const parsed = meta._parsed.find((item) => item[iScale.axis] === iScaleValue);
      const val = parsed && parsed[meta.vScale.axis];
      if (isNullOrUndef(val) || isNaN(val)) {
        return true;
      }
    }, "skipNull");
    for (const meta of metasets) {
      if (dataIndex !== void 0 && skipNull(meta)) {
        continue;
      }
      if (stacked === false || stacks.indexOf(meta.stack) === -1 || stacked === void 0 && meta.stack === void 0) {
        stacks.push(meta.stack);
      }
      if (meta.index === last) {
        break;
      }
    }
    if (!stacks.length) {
      stacks.push(void 0);
    }
    return stacks;
  }
  _getStackCount(index2) {
    return this._getStacks(void 0, index2).length;
  }
  _getAxisCount() {
    return this._getAxis().length;
  }
  getFirstScaleIdForIndexAxis() {
    const scales = this.chart.scales;
    const indexScaleId = this.chart.options.indexAxis;
    return Object.keys(scales).filter((key) => scales[key].axis === indexScaleId).shift();
  }
  _getAxis() {
    const axis = {};
    const firstScaleAxisId = this.getFirstScaleIdForIndexAxis();
    for (const dataset of this.chart.data.datasets) {
      axis[valueOrDefault(this.chart.options.indexAxis === "x" ? dataset.xAxisID : dataset.yAxisID, firstScaleAxisId)] = true;
    }
    return Object.keys(axis);
  }
  _getStackIndex(datasetIndex, name, dataIndex) {
    const stacks = this._getStacks(datasetIndex, dataIndex);
    const index2 = name !== void 0 ? stacks.indexOf(name) : -1;
    return index2 === -1 ? stacks.length - 1 : index2;
  }
  _getRuler() {
    const opts = this.options;
    const meta = this._cachedMeta;
    const iScale = meta.iScale;
    const pixels = [];
    let i2, ilen;
    for (i2 = 0, ilen = meta.data.length; i2 < ilen; ++i2) {
      pixels.push(iScale.getPixelForValue(this.getParsed(i2)[iScale.axis], i2));
    }
    const barThickness = opts.barThickness;
    const min = barThickness || computeMinSampleSize(meta);
    return {
      min,
      pixels,
      start: iScale._startPixel,
      end: iScale._endPixel,
      stackCount: this._getStackCount(),
      scale: iScale,
      grouped: opts.grouped,
      ratio: barThickness ? 1 : opts.categoryPercentage * opts.barPercentage
    };
  }
  _calculateBarValuePixels(index2) {
    const { _cachedMeta: { vScale, _stacked, index: datasetIndex }, options: { base: baseValue, minBarLength } } = this;
    const actualBase = baseValue || 0;
    const parsed = this.getParsed(index2);
    const custom = parsed._custom;
    const floating = isFloatBar(custom);
    let value = parsed[vScale.axis];
    let start = 0;
    let length = _stacked ? this.applyStack(vScale, parsed, _stacked) : value;
    let head, size;
    if (length !== value) {
      start = length - value;
      length = value;
    }
    if (floating) {
      value = custom.barStart;
      length = custom.barEnd - custom.barStart;
      if (value !== 0 && sign(value) !== sign(custom.barEnd)) {
        start = 0;
      }
      start += value;
    }
    const startValue = !isNullOrUndef(baseValue) && !floating ? baseValue : start;
    let base = vScale.getPixelForValue(startValue);
    if (this.chart.getDataVisibility(index2)) {
      head = vScale.getPixelForValue(start + length);
    } else {
      head = base;
    }
    size = head - base;
    if (Math.abs(size) < minBarLength) {
      size = barSign(size, vScale, actualBase) * minBarLength;
      if (value === actualBase) {
        base -= size / 2;
      }
      const startPixel = vScale.getPixelForDecimal(0);
      const endPixel = vScale.getPixelForDecimal(1);
      const min = Math.min(startPixel, endPixel);
      const max2 = Math.max(startPixel, endPixel);
      base = Math.max(Math.min(base, max2), min);
      head = base + size;
      if (_stacked && !floating) {
        parsed._stacks[vScale.axis]._visualValues[datasetIndex] = vScale.getValueForPixel(head) - vScale.getValueForPixel(base);
      }
    }
    if (base === vScale.getPixelForValue(actualBase)) {
      const halfGrid = sign(size) * vScale.getLineWidthForValue(actualBase) / 2;
      base += halfGrid;
      size -= halfGrid;
    }
    return {
      size,
      base,
      head,
      center: head + size / 2
    };
  }
  _calculateBarIndexPixels(index2, ruler) {
    const scale = ruler.scale;
    const options = this.options;
    const skipNull = options.skipNull;
    const maxBarThickness = valueOrDefault(options.maxBarThickness, Infinity);
    let center, size;
    const axisCount = this._getAxisCount();
    if (ruler.grouped) {
      const stackCount = skipNull ? this._getStackCount(index2) : ruler.stackCount;
      const range = options.barThickness === "flex" ? computeFlexCategoryTraits(index2, ruler, options, stackCount * axisCount) : computeFitCategoryTraits(index2, ruler, options, stackCount * axisCount);
      const axisID = this.chart.options.indexAxis === "x" ? this.getDataset().xAxisID : this.getDataset().yAxisID;
      const axisNumber = this._getAxis().indexOf(valueOrDefault(axisID, this.getFirstScaleIdForIndexAxis()));
      const stackIndex = this._getStackIndex(this.index, this._cachedMeta.stack, skipNull ? index2 : void 0) + axisNumber;
      center = range.start + range.chunk * stackIndex + range.chunk / 2;
      size = Math.min(maxBarThickness, range.chunk * range.ratio);
    } else {
      center = scale.getPixelForValue(this.getParsed(index2)[scale.axis], index2);
      size = Math.min(maxBarThickness, ruler.min * ruler.ratio);
    }
    return {
      base: center - size / 2,
      head: center + size / 2,
      center,
      size
    };
  }
  draw() {
    const meta = this._cachedMeta;
    const vScale = meta.vScale;
    const rects = meta.data;
    const ilen = rects.length;
    let i2 = 0;
    for (; i2 < ilen; ++i2) {
      if (this.getParsed(i2)[vScale.axis] !== null && !rects[i2].hidden) {
        rects[i2].draw(this._ctx);
      }
    }
  }
};
__name(_BarController, "BarController");
__publicField(_BarController, "id", "bar");
__publicField(_BarController, "defaults", {
  datasetElementType: false,
  dataElementType: "bar",
  categoryPercentage: 0.8,
  barPercentage: 0.9,
  grouped: true,
  animations: {
    numbers: {
      type: "number",
      properties: [
        "x",
        "y",
        "base",
        "width",
        "height"
      ]
    }
  }
});
__publicField(_BarController, "overrides", {
  scales: {
    _index_: {
      type: "category",
      offset: true,
      grid: {
        offset: true
      }
    },
    _value_: {
      type: "linear",
      beginAtZero: true
    }
  }
});
let BarController = _BarController;
function getRatioAndOffset(rotation, circumference, cutout) {
  let ratioX = 1;
  let ratioY = 1;
  let offsetX = 0;
  let offsetY = 0;
  if (circumference < TAU) {
    const startAngle = rotation;
    const endAngle = startAngle + circumference;
    const startX = Math.cos(startAngle);
    const startY = Math.sin(startAngle);
    const endX = Math.cos(endAngle);
    const endY = Math.sin(endAngle);
    const calcMax = /* @__PURE__ */ __name((angle, a2, b2) => _angleBetween(angle, startAngle, endAngle, true) ? 1 : Math.max(a2, a2 * cutout, b2, b2 * cutout), "calcMax");
    const calcMin = /* @__PURE__ */ __name((angle, a2, b2) => _angleBetween(angle, startAngle, endAngle, true) ? -1 : Math.min(a2, a2 * cutout, b2, b2 * cutout), "calcMin");
    const maxX = calcMax(0, startX, endX);
    const maxY = calcMax(HALF_PI, startY, endY);
    const minX = calcMin(PI, startX, endX);
    const minY = calcMin(PI + HALF_PI, startY, endY);
    ratioX = (maxX - minX) / 2;
    ratioY = (maxY - minY) / 2;
    offsetX = -(maxX + minX) / 2;
    offsetY = -(maxY + minY) / 2;
  }
  return {
    ratioX,
    ratioY,
    offsetX,
    offsetY
  };
}
__name(getRatioAndOffset, "getRatioAndOffset");
const _DoughnutController = class _DoughnutController extends DatasetController {
  constructor(chart, datasetIndex) {
    super(chart, datasetIndex);
    this.enableOptionSharing = true;
    this.innerRadius = void 0;
    this.outerRadius = void 0;
    this.offsetX = void 0;
    this.offsetY = void 0;
  }
  linkScales() {
  }
  parse(start, count) {
    const data = this.getDataset().data;
    const meta = this._cachedMeta;
    if (this._parsing === false) {
      meta._parsed = data;
    } else {
      let getter = /* @__PURE__ */ __name((i3) => +data[i3], "getter");
      if (isObject(data[start])) {
        const { key = "value" } = this._parsing;
        getter = /* @__PURE__ */ __name((i3) => +resolveObjectKey(data[i3], key), "getter");
      }
      let i2, ilen;
      for (i2 = start, ilen = start + count; i2 < ilen; ++i2) {
        meta._parsed[i2] = getter(i2);
      }
    }
  }
  _getRotation() {
    return toRadians(this.options.rotation - 90);
  }
  _getCircumference() {
    return toRadians(this.options.circumference);
  }
  _getRotationExtents() {
    let min = TAU;
    let max2 = -TAU;
    for (let i2 = 0; i2 < this.chart.data.datasets.length; ++i2) {
      if (this.chart.isDatasetVisible(i2) && this.chart.getDatasetMeta(i2).type === this._type) {
        const controller = this.chart.getDatasetMeta(i2).controller;
        const rotation = controller._getRotation();
        const circumference = controller._getCircumference();
        min = Math.min(min, rotation);
        max2 = Math.max(max2, rotation + circumference);
      }
    }
    return {
      rotation: min,
      circumference: max2 - min
    };
  }
  update(mode) {
    const chart = this.chart;
    const { chartArea } = chart;
    const meta = this._cachedMeta;
    const arcs = meta.data;
    const spacing = this.getMaxBorderWidth() + this.getMaxOffset(arcs) + this.options.spacing;
    const maxSize = Math.max((Math.min(chartArea.width, chartArea.height) - spacing) / 2, 0);
    const cutout = Math.min(toPercentage(this.options.cutout, maxSize), 1);
    const chartWeight = this._getRingWeight(this.index);
    const { circumference, rotation } = this._getRotationExtents();
    const { ratioX, ratioY, offsetX, offsetY } = getRatioAndOffset(rotation, circumference, cutout);
    const maxWidth = (chartArea.width - spacing) / ratioX;
    const maxHeight = (chartArea.height - spacing) / ratioY;
    const maxRadius = Math.max(Math.min(maxWidth, maxHeight) / 2, 0);
    const outerRadius = toDimension(this.options.radius, maxRadius);
    const innerRadius = Math.max(outerRadius * cutout, 0);
    const radiusLength = (outerRadius - innerRadius) / this._getVisibleDatasetWeightTotal();
    this.offsetX = offsetX * outerRadius;
    this.offsetY = offsetY * outerRadius;
    meta.total = this.calculateTotal();
    this.outerRadius = outerRadius - radiusLength * this._getRingWeightOffset(this.index);
    this.innerRadius = Math.max(this.outerRadius - radiusLength * chartWeight, 0);
    this.updateElements(arcs, 0, arcs.length, mode);
  }
  _circumference(i2, reset) {
    const opts = this.options;
    const meta = this._cachedMeta;
    const circumference = this._getCircumference();
    if (reset && opts.animation.animateRotate || !this.chart.getDataVisibility(i2) || meta._parsed[i2] === null || meta.data[i2].hidden) {
      return 0;
    }
    return this.calculateCircumference(meta._parsed[i2] * circumference / TAU);
  }
  updateElements(arcs, start, count, mode) {
    const reset = mode === "reset";
    const chart = this.chart;
    const chartArea = chart.chartArea;
    const opts = chart.options;
    const animationOpts = opts.animation;
    const centerX = (chartArea.left + chartArea.right) / 2;
    const centerY = (chartArea.top + chartArea.bottom) / 2;
    const animateScale = reset && animationOpts.animateScale;
    const innerRadius = animateScale ? 0 : this.innerRadius;
    const outerRadius = animateScale ? 0 : this.outerRadius;
    const { sharedOptions, includeOptions } = this._getSharedOptions(start, mode);
    let startAngle = this._getRotation();
    let i2;
    for (i2 = 0; i2 < start; ++i2) {
      startAngle += this._circumference(i2, reset);
    }
    for (i2 = start; i2 < start + count; ++i2) {
      const circumference = this._circumference(i2, reset);
      const arc = arcs[i2];
      const properties = {
        x: centerX + this.offsetX,
        y: centerY + this.offsetY,
        startAngle,
        endAngle: startAngle + circumference,
        circumference,
        outerRadius,
        innerRadius
      };
      if (includeOptions) {
        properties.options = sharedOptions || this.resolveDataElementOptions(i2, arc.active ? "active" : mode);
      }
      startAngle += circumference;
      this.updateElement(arc, i2, properties, mode);
    }
  }
  calculateTotal() {
    const meta = this._cachedMeta;
    const metaData = meta.data;
    let total = 0;
    let i2;
    for (i2 = 0; i2 < metaData.length; i2++) {
      const value = meta._parsed[i2];
      if (value !== null && !isNaN(value) && this.chart.getDataVisibility(i2) && !metaData[i2].hidden) {
        total += Math.abs(value);
      }
    }
    return total;
  }
  calculateCircumference(value) {
    const total = this._cachedMeta.total;
    if (total > 0 && !isNaN(value)) {
      return TAU * (Math.abs(value) / total);
    }
    return 0;
  }
  getLabelAndValue(index2) {
    const meta = this._cachedMeta;
    const chart = this.chart;
    const labels = chart.data.labels || [];
    const value = formatNumber(meta._parsed[index2], chart.options.locale);
    return {
      label: labels[index2] || "",
      value
    };
  }
  getMaxBorderWidth(arcs) {
    let max2 = 0;
    const chart = this.chart;
    let i2, ilen, meta, controller, options;
    if (!arcs) {
      for (i2 = 0, ilen = chart.data.datasets.length; i2 < ilen; ++i2) {
        if (chart.isDatasetVisible(i2)) {
          meta = chart.getDatasetMeta(i2);
          arcs = meta.data;
          controller = meta.controller;
          break;
        }
      }
    }
    if (!arcs) {
      return 0;
    }
    for (i2 = 0, ilen = arcs.length; i2 < ilen; ++i2) {
      options = controller.resolveDataElementOptions(i2);
      if (options.borderAlign !== "inner") {
        max2 = Math.max(max2, options.borderWidth || 0, options.hoverBorderWidth || 0);
      }
    }
    return max2;
  }
  getMaxOffset(arcs) {
    let max2 = 0;
    for (let i2 = 0, ilen = arcs.length; i2 < ilen; ++i2) {
      const options = this.resolveDataElementOptions(i2);
      max2 = Math.max(max2, options.offset || 0, options.hoverOffset || 0);
    }
    return max2;
  }
  _getRingWeightOffset(datasetIndex) {
    let ringWeightOffset = 0;
    for (let i2 = 0; i2 < datasetIndex; ++i2) {
      if (this.chart.isDatasetVisible(i2)) {
        ringWeightOffset += this._getRingWeight(i2);
      }
    }
    return ringWeightOffset;
  }
  _getRingWeight(datasetIndex) {
    return Math.max(valueOrDefault(this.chart.data.datasets[datasetIndex].weight, 1), 0);
  }
  _getVisibleDatasetWeightTotal() {
    return this._getRingWeightOffset(this.chart.data.datasets.length) || 1;
  }
};
__name(_DoughnutController, "DoughnutController");
__publicField(_DoughnutController, "id", "doughnut");
__publicField(_DoughnutController, "defaults", {
  datasetElementType: false,
  dataElementType: "arc",
  animation: {
    animateRotate: true,
    animateScale: false
  },
  animations: {
    numbers: {
      type: "number",
      properties: [
        "circumference",
        "endAngle",
        "innerRadius",
        "outerRadius",
        "startAngle",
        "x",
        "y",
        "offset",
        "borderWidth",
        "spacing"
      ]
    }
  },
  cutout: "50%",
  rotation: 0,
  circumference: 360,
  radius: "100%",
  spacing: 0,
  indexAxis: "r"
});
__publicField(_DoughnutController, "descriptors", {
  _scriptable: (name) => name !== "spacing",
  _indexable: (name) => name !== "spacing" && !name.startsWith("borderDash") && !name.startsWith("hoverBorderDash")
});
__publicField(_DoughnutController, "overrides", {
  aspectRatio: 1,
  plugins: {
    legend: {
      labels: {
        generateLabels(chart) {
          const data = chart.data;
          const { labels: { pointStyle, textAlign, color: color2, useBorderRadius, borderRadius } } = chart.legend.options;
          if (data.labels.length && data.datasets.length) {
            return data.labels.map((label, i2) => {
              const meta = chart.getDatasetMeta(0);
              const style = meta.controller.getStyle(i2);
              return {
                text: label,
                fillStyle: style.backgroundColor,
                fontColor: color2,
                hidden: !chart.getDataVisibility(i2),
                lineDash: style.borderDash,
                lineDashOffset: style.borderDashOffset,
                lineJoin: style.borderJoinStyle,
                lineWidth: style.borderWidth,
                strokeStyle: style.borderColor,
                textAlign,
                pointStyle,
                borderRadius: useBorderRadius && (borderRadius || style.borderRadius),
                index: i2
              };
            });
          }
          return [];
        }
      },
      onClick(e, legendItem, legend) {
        legend.chart.toggleDataVisibility(legendItem.index);
        legend.chart.update();
      }
    }
  }
});
let DoughnutController = _DoughnutController;
const _LineController = class _LineController extends DatasetController {
  initialize() {
    this.enableOptionSharing = true;
    this.supportsDecimation = true;
    super.initialize();
  }
  update(mode) {
    const meta = this._cachedMeta;
    const { dataset: line, data: points = [], _dataset } = meta;
    const animationsDisabled = this.chart._animationsDisabled;
    let { start, count } = _getStartAndCountOfVisiblePoints(meta, points, animationsDisabled);
    this._drawStart = start;
    this._drawCount = count;
    if (_scaleRangesChanged(meta)) {
      start = 0;
      count = points.length;
    }
    line._chart = this.chart;
    line._datasetIndex = this.index;
    line._decimated = !!_dataset._decimated;
    line.points = points;
    const options = this.resolveDatasetElementOptions(mode);
    if (!this.options.showLine) {
      options.borderWidth = 0;
    }
    options.segment = this.options.segment;
    this.updateElement(line, void 0, {
      animated: !animationsDisabled,
      options
    }, mode);
    this.updateElements(points, start, count, mode);
  }
  updateElements(points, start, count, mode) {
    const reset = mode === "reset";
    const { iScale, vScale, _stacked, _dataset } = this._cachedMeta;
    const { sharedOptions, includeOptions } = this._getSharedOptions(start, mode);
    const iAxis = iScale.axis;
    const vAxis = vScale.axis;
    const { spanGaps, segment } = this.options;
    const maxGapLength = isNumber(spanGaps) ? spanGaps : Number.POSITIVE_INFINITY;
    const directUpdate = this.chart._animationsDisabled || reset || mode === "none";
    const end = start + count;
    const pointsCount = points.length;
    let prevParsed = start > 0 && this.getParsed(start - 1);
    for (let i2 = 0; i2 < pointsCount; ++i2) {
      const point = points[i2];
      const properties = directUpdate ? point : {};
      if (i2 < start || i2 >= end) {
        properties.skip = true;
        continue;
      }
      const parsed = this.getParsed(i2);
      const nullData = isNullOrUndef(parsed[vAxis]);
      const iPixel = properties[iAxis] = iScale.getPixelForValue(parsed[iAxis], i2);
      const vPixel = properties[vAxis] = reset || nullData ? vScale.getBasePixel() : vScale.getPixelForValue(_stacked ? this.applyStack(vScale, parsed, _stacked) : parsed[vAxis], i2);
      properties.skip = isNaN(iPixel) || isNaN(vPixel) || nullData;
      properties.stop = i2 > 0 && Math.abs(parsed[iAxis] - prevParsed[iAxis]) > maxGapLength;
      if (segment) {
        properties.parsed = parsed;
        properties.raw = _dataset.data[i2];
      }
      if (includeOptions) {
        properties.options = sharedOptions || this.resolveDataElementOptions(i2, point.active ? "active" : mode);
      }
      if (!directUpdate) {
        this.updateElement(point, i2, properties, mode);
      }
      prevParsed = parsed;
    }
  }
  getMaxOverflow() {
    const meta = this._cachedMeta;
    const dataset = meta.dataset;
    const border = dataset.options && dataset.options.borderWidth || 0;
    const data = meta.data || [];
    if (!data.length) {
      return border;
    }
    const firstPoint = data[0].size(this.resolveDataElementOptions(0));
    const lastPoint = data[data.length - 1].size(this.resolveDataElementOptions(data.length - 1));
    return Math.max(border, firstPoint, lastPoint) / 2;
  }
  draw() {
    const meta = this._cachedMeta;
    meta.dataset.updateControlPoints(this.chart.chartArea, meta.iScale.axis);
    super.draw();
  }
};
__name(_LineController, "LineController");
__publicField(_LineController, "id", "line");
__publicField(_LineController, "defaults", {
  datasetElementType: "line",
  dataElementType: "point",
  showLine: true,
  spanGaps: false
});
__publicField(_LineController, "overrides", {
  scales: {
    _index_: {
      type: "category"
    },
    _value_: {
      type: "linear"
    }
  }
});
let LineController = _LineController;
const _RadarController = class _RadarController extends DatasetController {
  getLabelAndValue(index2) {
    const vScale = this._cachedMeta.vScale;
    const parsed = this.getParsed(index2);
    return {
      label: vScale.getLabels()[index2],
      value: "" + vScale.getLabelForValue(parsed[vScale.axis])
    };
  }
  parseObjectData(meta, data, start, count) {
    return _parseObjectDataRadialScale.bind(this)(meta, data, start, count);
  }
  update(mode) {
    const meta = this._cachedMeta;
    const line = meta.dataset;
    const points = meta.data || [];
    const labels = meta.iScale.getLabels();
    line.points = points;
    if (mode !== "resize") {
      const options = this.resolveDatasetElementOptions(mode);
      if (!this.options.showLine) {
        options.borderWidth = 0;
      }
      const properties = {
        _loop: true,
        _fullLoop: labels.length === points.length,
        options
      };
      this.updateElement(line, void 0, properties, mode);
    }
    this.updateElements(points, 0, points.length, mode);
  }
  updateElements(points, start, count, mode) {
    const scale = this._cachedMeta.rScale;
    const reset = mode === "reset";
    for (let i2 = start; i2 < start + count; i2++) {
      const point = points[i2];
      const options = this.resolveDataElementOptions(i2, point.active ? "active" : mode);
      const pointPosition = scale.getPointPositionForValue(i2, this.getParsed(i2).r);
      const x2 = reset ? scale.xCenter : pointPosition.x;
      const y2 = reset ? scale.yCenter : pointPosition.y;
      const properties = {
        x: x2,
        y: y2,
        angle: pointPosition.angle,
        skip: isNaN(x2) || isNaN(y2),
        options
      };
      this.updateElement(point, i2, properties, mode);
    }
  }
};
__name(_RadarController, "RadarController");
__publicField(_RadarController, "id", "radar");
__publicField(_RadarController, "defaults", {
  datasetElementType: "line",
  dataElementType: "point",
  indexAxis: "r",
  showLine: true,
  elements: {
    line: {
      fill: "start"
    }
  }
});
__publicField(_RadarController, "overrides", {
  aspectRatio: 1,
  scales: {
    r: {
      type: "radialLinear"
    }
  }
});
let RadarController = _RadarController;
function abstract() {
  throw new Error("This method is not implemented: Check that a complete date adapter is provided.");
}
__name(abstract, "abstract");
const _DateAdapterBase = class _DateAdapterBase {
  constructor(options) {
    __publicField(this, "options");
    this.options = options || {};
  }
  /**
  * Override default date adapter methods.
  * Accepts type parameter to define options type.
  * @example
  * Chart._adapters._date.override<{myAdapterOption: string}>({
  *   init() {
  *     console.log(this.options.myAdapterOption);
  *   }
  * })
  */
  static override(members) {
    Object.assign(_DateAdapterBase.prototype, members);
  }
  // eslint-disable-next-line @typescript-eslint/no-empty-function
  init() {
  }
  formats() {
    return abstract();
  }
  parse() {
    return abstract();
  }
  format() {
    return abstract();
  }
  add() {
    return abstract();
  }
  diff() {
    return abstract();
  }
  startOf() {
    return abstract();
  }
  endOf() {
    return abstract();
  }
};
__name(_DateAdapterBase, "DateAdapterBase");
let DateAdapterBase = _DateAdapterBase;
var adapters = {
  _date: DateAdapterBase
};
function binarySearch(metaset, axis, value, intersect) {
  const { controller, data, _sorted } = metaset;
  const iScale = controller._cachedMeta.iScale;
  const spanGaps = metaset.dataset ? metaset.dataset.options ? metaset.dataset.options.spanGaps : null : null;
  if (iScale && axis === iScale.axis && axis !== "r" && _sorted && data.length) {
    const lookupMethod = iScale._reversePixels ? _rlookupByKey : _lookupByKey;
    if (!intersect) {
      const result = lookupMethod(data, axis, value);
      if (spanGaps) {
        const { vScale } = controller._cachedMeta;
        const { _parsed } = metaset;
        const distanceToDefinedLo = _parsed.slice(0, result.lo + 1).reverse().findIndex((point) => !isNullOrUndef(point[vScale.axis]));
        result.lo -= Math.max(0, distanceToDefinedLo);
        const distanceToDefinedHi = _parsed.slice(result.hi).findIndex((point) => !isNullOrUndef(point[vScale.axis]));
        result.hi += Math.max(0, distanceToDefinedHi);
      }
      return result;
    } else if (controller._sharedOptions) {
      const el = data[0];
      const range = typeof el.getRange === "function" && el.getRange(axis);
      if (range) {
        const start = lookupMethod(data, axis, value - range);
        const end = lookupMethod(data, axis, value + range);
        return {
          lo: start.lo,
          hi: end.hi
        };
      }
    }
  }
  return {
    lo: 0,
    hi: data.length - 1
  };
}
__name(binarySearch, "binarySearch");
function evaluateInteractionItems(chart, axis, position, handler, intersect) {
  const metasets = chart.getSortedVisibleDatasetMetas();
  const value = position[axis];
  for (let i2 = 0, ilen = metasets.length; i2 < ilen; ++i2) {
    const { index: index2, data } = metasets[i2];
    const { lo, hi } = binarySearch(metasets[i2], axis, value, intersect);
    for (let j2 = lo; j2 <= hi; ++j2) {
      const element = data[j2];
      if (!element.skip) {
        handler(element, index2, j2);
      }
    }
  }
}
__name(evaluateInteractionItems, "evaluateInteractionItems");
function getDistanceMetricForAxis(axis) {
  const useX = axis.indexOf("x") !== -1;
  const useY = axis.indexOf("y") !== -1;
  return function(pt1, pt2) {
    const deltaX = useX ? Math.abs(pt1.x - pt2.x) : 0;
    const deltaY = useY ? Math.abs(pt1.y - pt2.y) : 0;
    return Math.sqrt(Math.pow(deltaX, 2) + Math.pow(deltaY, 2));
  };
}
__name(getDistanceMetricForAxis, "getDistanceMetricForAxis");
function getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible) {
  const items = [];
  if (!includeInvisible && !chart.isPointInArea(position)) {
    return items;
  }
  const evaluationFunc = /* @__PURE__ */ __name(function(element, datasetIndex, index2) {
    if (!includeInvisible && !_isPointInArea(element, chart.chartArea, 0)) {
      return;
    }
    if (element.inRange(position.x, position.y, useFinalPosition)) {
      items.push({
        element,
        datasetIndex,
        index: index2
      });
    }
  }, "evaluationFunc");
  evaluateInteractionItems(chart, axis, position, evaluationFunc, true);
  return items;
}
__name(getIntersectItems, "getIntersectItems");
function getNearestRadialItems(chart, position, axis, useFinalPosition) {
  let items = [];
  function evaluationFunc(element, datasetIndex, index2) {
    const { startAngle, endAngle } = element.getProps([
      "startAngle",
      "endAngle"
    ], useFinalPosition);
    const { angle } = getAngleFromPoint(element, {
      x: position.x,
      y: position.y
    });
    if (_angleBetween(angle, startAngle, endAngle)) {
      items.push({
        element,
        datasetIndex,
        index: index2
      });
    }
  }
  __name(evaluationFunc, "evaluationFunc");
  evaluateInteractionItems(chart, axis, position, evaluationFunc);
  return items;
}
__name(getNearestRadialItems, "getNearestRadialItems");
function getNearestCartesianItems(chart, position, axis, intersect, useFinalPosition, includeInvisible) {
  let items = [];
  const distanceMetric = getDistanceMetricForAxis(axis);
  let minDistance = Number.POSITIVE_INFINITY;
  function evaluationFunc(element, datasetIndex, index2) {
    const inRange2 = element.inRange(position.x, position.y, useFinalPosition);
    if (intersect && !inRange2) {
      return;
    }
    const center = element.getCenterPoint(useFinalPosition);
    const pointInArea = !!includeInvisible || chart.isPointInArea(center);
    if (!pointInArea && !inRange2) {
      return;
    }
    const distance = distanceMetric(position, center);
    if (distance < minDistance) {
      items = [
        {
          element,
          datasetIndex,
          index: index2
        }
      ];
      minDistance = distance;
    } else if (distance === minDistance) {
      items.push({
        element,
        datasetIndex,
        index: index2
      });
    }
  }
  __name(evaluationFunc, "evaluationFunc");
  evaluateInteractionItems(chart, axis, position, evaluationFunc);
  return items;
}
__name(getNearestCartesianItems, "getNearestCartesianItems");
function getNearestItems(chart, position, axis, intersect, useFinalPosition, includeInvisible) {
  if (!includeInvisible && !chart.isPointInArea(position)) {
    return [];
  }
  return axis === "r" && !intersect ? getNearestRadialItems(chart, position, axis, useFinalPosition) : getNearestCartesianItems(chart, position, axis, intersect, useFinalPosition, includeInvisible);
}
__name(getNearestItems, "getNearestItems");
function getAxisItems(chart, position, axis, intersect, useFinalPosition) {
  const items = [];
  const rangeMethod = axis === "x" ? "inXRange" : "inYRange";
  let intersectsItem = false;
  evaluateInteractionItems(chart, axis, position, (element, datasetIndex, index2) => {
    if (element[rangeMethod] && element[rangeMethod](position[axis], useFinalPosition)) {
      items.push({
        element,
        datasetIndex,
        index: index2
      });
      intersectsItem = intersectsItem || element.inRange(position.x, position.y, useFinalPosition);
    }
  });
  if (intersect && !intersectsItem) {
    return [];
  }
  return items;
}
__name(getAxisItems, "getAxisItems");
var Interaction = {
  evaluateInteractionItems,
  modes: {
    index(chart, e, options, useFinalPosition) {
      const position = getRelativePosition(e, chart);
      const axis = options.axis || "x";
      const includeInvisible = options.includeInvisible || false;
      const items = options.intersect ? getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible) : getNearestItems(chart, position, axis, false, useFinalPosition, includeInvisible);
      const elements = [];
      if (!items.length) {
        return [];
      }
      chart.getSortedVisibleDatasetMetas().forEach((meta) => {
        const index2 = items[0].index;
        const element = meta.data[index2];
        if (element && !element.skip) {
          elements.push({
            element,
            datasetIndex: meta.index,
            index: index2
          });
        }
      });
      return elements;
    },
    dataset(chart, e, options, useFinalPosition) {
      const position = getRelativePosition(e, chart);
      const axis = options.axis || "xy";
      const includeInvisible = options.includeInvisible || false;
      let items = options.intersect ? getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible) : getNearestItems(chart, position, axis, false, useFinalPosition, includeInvisible);
      if (items.length > 0) {
        const datasetIndex = items[0].datasetIndex;
        const data = chart.getDatasetMeta(datasetIndex).data;
        items = [];
        for (let i2 = 0; i2 < data.length; ++i2) {
          items.push({
            element: data[i2],
            datasetIndex,
            index: i2
          });
        }
      }
      return items;
    },
    point(chart, e, options, useFinalPosition) {
      const position = getRelativePosition(e, chart);
      const axis = options.axis || "xy";
      const includeInvisible = options.includeInvisible || false;
      return getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible);
    },
    nearest(chart, e, options, useFinalPosition) {
      const position = getRelativePosition(e, chart);
      const axis = options.axis || "xy";
      const includeInvisible = options.includeInvisible || false;
      return getNearestItems(chart, position, axis, options.intersect, useFinalPosition, includeInvisible);
    },
    x(chart, e, options, useFinalPosition) {
      const position = getRelativePosition(e, chart);
      return getAxisItems(chart, position, "x", options.intersect, useFinalPosition);
    },
    y(chart, e, options, useFinalPosition) {
      const position = getRelativePosition(e, chart);
      return getAxisItems(chart, position, "y", options.intersect, useFinalPosition);
    }
  }
};
const STATIC_POSITIONS = [
  "left",
  "top",
  "right",
  "bottom"
];
function filterByPosition(array, position) {
  return array.filter((v2) => v2.pos === position);
}
__name(filterByPosition, "filterByPosition");
function filterDynamicPositionByAxis(array, axis) {
  return array.filter((v2) => STATIC_POSITIONS.indexOf(v2.pos) === -1 && v2.box.axis === axis);
}
__name(filterDynamicPositionByAxis, "filterDynamicPositionByAxis");
function sortByWeight(array, reverse) {
  return array.sort((a2, b2) => {
    const v0 = reverse ? b2 : a2;
    const v1 = reverse ? a2 : b2;
    return v0.weight === v1.weight ? v0.index - v1.index : v0.weight - v1.weight;
  });
}
__name(sortByWeight, "sortByWeight");
function wrapBoxes(boxes) {
  const layoutBoxes = [];
  let i2, ilen, box, pos, stack, stackWeight;
  for (i2 = 0, ilen = (boxes || []).length; i2 < ilen; ++i2) {
    box = boxes[i2];
    ({ position: pos, options: { stack, stackWeight = 1 } } = box);
    layoutBoxes.push({
      index: i2,
      box,
      pos,
      horizontal: box.isHorizontal(),
      weight: box.weight,
      stack: stack && pos + stack,
      stackWeight
    });
  }
  return layoutBoxes;
}
__name(wrapBoxes, "wrapBoxes");
function buildStacks(layouts2) {
  const stacks = {};
  for (const wrap of layouts2) {
    const { stack, pos, stackWeight } = wrap;
    if (!stack || !STATIC_POSITIONS.includes(pos)) {
      continue;
    }
    const _stack = stacks[stack] || (stacks[stack] = {
      count: 0,
      placed: 0,
      weight: 0,
      size: 0
    });
    _stack.count++;
    _stack.weight += stackWeight;
  }
  return stacks;
}
__name(buildStacks, "buildStacks");
function setLayoutDims(layouts2, params) {
  const stacks = buildStacks(layouts2);
  const { vBoxMaxWidth, hBoxMaxHeight } = params;
  let i2, ilen, layout;
  for (i2 = 0, ilen = layouts2.length; i2 < ilen; ++i2) {
    layout = layouts2[i2];
    const { fullSize } = layout.box;
    const stack = stacks[layout.stack];
    const factor = stack && layout.stackWeight / stack.weight;
    if (layout.horizontal) {
      layout.width = factor ? factor * vBoxMaxWidth : fullSize && params.availableWidth;
      layout.height = hBoxMaxHeight;
    } else {
      layout.width = vBoxMaxWidth;
      layout.height = factor ? factor * hBoxMaxHeight : fullSize && params.availableHeight;
    }
  }
  return stacks;
}
__name(setLayoutDims, "setLayoutDims");
function buildLayoutBoxes(boxes) {
  const layoutBoxes = wrapBoxes(boxes);
  const fullSize = sortByWeight(layoutBoxes.filter((wrap) => wrap.box.fullSize), true);
  const left = sortByWeight(filterByPosition(layoutBoxes, "left"), true);
  const right = sortByWeight(filterByPosition(layoutBoxes, "right"));
  const top = sortByWeight(filterByPosition(layoutBoxes, "top"), true);
  const bottom = sortByWeight(filterByPosition(layoutBoxes, "bottom"));
  const centerHorizontal = filterDynamicPositionByAxis(layoutBoxes, "x");
  const centerVertical = filterDynamicPositionByAxis(layoutBoxes, "y");
  return {
    fullSize,
    leftAndTop: left.concat(top),
    rightAndBottom: right.concat(centerVertical).concat(bottom).concat(centerHorizontal),
    chartArea: filterByPosition(layoutBoxes, "chartArea"),
    vertical: left.concat(right).concat(centerVertical),
    horizontal: top.concat(bottom).concat(centerHorizontal)
  };
}
__name(buildLayoutBoxes, "buildLayoutBoxes");
function getCombinedMax(maxPadding, chartArea, a2, b2) {
  return Math.max(maxPadding[a2], chartArea[a2]) + Math.max(maxPadding[b2], chartArea[b2]);
}
__name(getCombinedMax, "getCombinedMax");
function updateMaxPadding(maxPadding, boxPadding) {
  maxPadding.top = Math.max(maxPadding.top, boxPadding.top);
  maxPadding.left = Math.max(maxPadding.left, boxPadding.left);
  maxPadding.bottom = Math.max(maxPadding.bottom, boxPadding.bottom);
  maxPadding.right = Math.max(maxPadding.right, boxPadding.right);
}
__name(updateMaxPadding, "updateMaxPadding");
function updateDims(chartArea, params, layout, stacks) {
  const { pos, box } = layout;
  const maxPadding = chartArea.maxPadding;
  if (!isObject(pos)) {
    if (layout.size) {
      chartArea[pos] -= layout.size;
    }
    const stack = stacks[layout.stack] || {
      size: 0,
      count: 1
    };
    stack.size = Math.max(stack.size, layout.horizontal ? box.height : box.width);
    layout.size = stack.size / stack.count;
    chartArea[pos] += layout.size;
  }
  if (box.getPadding) {
    updateMaxPadding(maxPadding, box.getPadding());
  }
  const newWidth = Math.max(0, params.outerWidth - getCombinedMax(maxPadding, chartArea, "left", "right"));
  const newHeight = Math.max(0, params.outerHeight - getCombinedMax(maxPadding, chartArea, "top", "bottom"));
  const widthChanged = newWidth !== chartArea.w;
  const heightChanged = newHeight !== chartArea.h;
  chartArea.w = newWidth;
  chartArea.h = newHeight;
  return layout.horizontal ? {
    same: widthChanged,
    other: heightChanged
  } : {
    same: heightChanged,
    other: widthChanged
  };
}
__name(updateDims, "updateDims");
function handleMaxPadding(chartArea) {
  const maxPadding = chartArea.maxPadding;
  function updatePos(pos) {
    const change = Math.max(maxPadding[pos] - chartArea[pos], 0);
    chartArea[pos] += change;
    return change;
  }
  __name(updatePos, "updatePos");
  chartArea.y += updatePos("top");
  chartArea.x += updatePos("left");
  updatePos("right");
  updatePos("bottom");
}
__name(handleMaxPadding, "handleMaxPadding");
function getMargins(horizontal, chartArea) {
  const maxPadding = chartArea.maxPadding;
  function marginForPositions(positions2) {
    const margin = {
      left: 0,
      top: 0,
      right: 0,
      bottom: 0
    };
    positions2.forEach((pos) => {
      margin[pos] = Math.max(chartArea[pos], maxPadding[pos]);
    });
    return margin;
  }
  __name(marginForPositions, "marginForPositions");
  return horizontal ? marginForPositions([
    "left",
    "right"
  ]) : marginForPositions([
    "top",
    "bottom"
  ]);
}
__name(getMargins, "getMargins");
function fitBoxes(boxes, chartArea, params, stacks) {
  const refitBoxes = [];
  let i2, ilen, layout, box, refit, changed;
  for (i2 = 0, ilen = boxes.length, refit = 0; i2 < ilen; ++i2) {
    layout = boxes[i2];
    box = layout.box;
    box.update(layout.width || chartArea.w, layout.height || chartArea.h, getMargins(layout.horizontal, chartArea));
    const { same, other } = updateDims(chartArea, params, layout, stacks);
    refit |= same && refitBoxes.length;
    changed = changed || other;
    if (!box.fullSize) {
      refitBoxes.push(layout);
    }
  }
  return refit && fitBoxes(refitBoxes, chartArea, params, stacks) || changed;
}
__name(fitBoxes, "fitBoxes");
function setBoxDims(box, left, top, width, height) {
  box.top = top;
  box.left = left;
  box.right = left + width;
  box.bottom = top + height;
  box.width = width;
  box.height = height;
}
__name(setBoxDims, "setBoxDims");
function placeBoxes(boxes, chartArea, params, stacks) {
  const userPadding = params.padding;
  let { x: x2, y: y2 } = chartArea;
  for (const layout of boxes) {
    const box = layout.box;
    const stack = stacks[layout.stack] || {
      count: 1,
      placed: 0,
      weight: 1
    };
    const weight = layout.stackWeight / stack.weight || 1;
    if (layout.horizontal) {
      const width = chartArea.w * weight;
      const height = stack.size || box.height;
      if (defined(stack.start)) {
        y2 = stack.start;
      }
      if (box.fullSize) {
        setBoxDims(box, userPadding.left, y2, params.outerWidth - userPadding.right - userPadding.left, height);
      } else {
        setBoxDims(box, chartArea.left + stack.placed, y2, width, height);
      }
      stack.start = y2;
      stack.placed += width;
      y2 = box.bottom;
    } else {
      const height = chartArea.h * weight;
      const width = stack.size || box.width;
      if (defined(stack.start)) {
        x2 = stack.start;
      }
      if (box.fullSize) {
        setBoxDims(box, x2, userPadding.top, width, params.outerHeight - userPadding.bottom - userPadding.top);
      } else {
        setBoxDims(box, x2, chartArea.top + stack.placed, width, height);
      }
      stack.start = x2;
      stack.placed += height;
      x2 = box.right;
    }
  }
  chartArea.x = x2;
  chartArea.y = y2;
}
__name(placeBoxes, "placeBoxes");
var layouts = {
  addBox(chart, item) {
    if (!chart.boxes) {
      chart.boxes = [];
    }
    item.fullSize = item.fullSize || false;
    item.position = item.position || "top";
    item.weight = item.weight || 0;
    item._layers = item._layers || function() {
      return [
        {
          z: 0,
          draw(chartArea) {
            item.draw(chartArea);
          }
        }
      ];
    };
    chart.boxes.push(item);
  },
  removeBox(chart, layoutItem) {
    const index2 = chart.boxes ? chart.boxes.indexOf(layoutItem) : -1;
    if (index2 !== -1) {
      chart.boxes.splice(index2, 1);
    }
  },
  configure(chart, item, options) {
    item.fullSize = options.fullSize;
    item.position = options.position;
    item.weight = options.weight;
  },
  update(chart, width, height, minPadding) {
    if (!chart) {
      return;
    }
    const padding = toPadding(chart.options.layout.padding);
    const availableWidth = Math.max(width - padding.width, 0);
    const availableHeight = Math.max(height - padding.height, 0);
    const boxes = buildLayoutBoxes(chart.boxes);
    const verticalBoxes = boxes.vertical;
    const horizontalBoxes = boxes.horizontal;
    each(chart.boxes, (box) => {
      if (typeof box.beforeLayout === "function") {
        box.beforeLayout();
      }
    });
    const visibleVerticalBoxCount = verticalBoxes.reduce((total, wrap) => wrap.box.options && wrap.box.options.display === false ? total : total + 1, 0) || 1;
    const params = Object.freeze({
      outerWidth: width,
      outerHeight: height,
      padding,
      availableWidth,
      availableHeight,
      vBoxMaxWidth: availableWidth / 2 / visibleVerticalBoxCount,
      hBoxMaxHeight: availableHeight / 2
    });
    const maxPadding = Object.assign({}, padding);
    updateMaxPadding(maxPadding, toPadding(minPadding));
    const chartArea = Object.assign({
      maxPadding,
      w: availableWidth,
      h: availableHeight,
      x: padding.left,
      y: padding.top
    }, padding);
    const stacks = setLayoutDims(verticalBoxes.concat(horizontalBoxes), params);
    fitBoxes(boxes.fullSize, chartArea, params, stacks);
    fitBoxes(verticalBoxes, chartArea, params, stacks);
    if (fitBoxes(horizontalBoxes, chartArea, params, stacks)) {
      fitBoxes(verticalBoxes, chartArea, params, stacks);
    }
    handleMaxPadding(chartArea);
    placeBoxes(boxes.leftAndTop, chartArea, params, stacks);
    chartArea.x += chartArea.w;
    chartArea.y += chartArea.h;
    placeBoxes(boxes.rightAndBottom, chartArea, params, stacks);
    chart.chartArea = {
      left: chartArea.left,
      top: chartArea.top,
      right: chartArea.left + chartArea.w,
      bottom: chartArea.top + chartArea.h,
      height: chartArea.h,
      width: chartArea.w
    };
    each(boxes.chartArea, (layout) => {
      const box = layout.box;
      Object.assign(box, chart.chartArea);
      box.update(chartArea.w, chartArea.h, {
        left: 0,
        top: 0,
        right: 0,
        bottom: 0
      });
    });
  }
};
const _BasePlatform = class _BasePlatform {
  acquireContext(canvas, aspectRatio) {
  }
  releaseContext(context) {
    return false;
  }
  addEventListener(chart, type, listener) {
  }
  removeEventListener(chart, type, listener) {
  }
  getDevicePixelRatio() {
    return 1;
  }
  getMaximumSize(element, width, height, aspectRatio) {
    width = Math.max(0, width || element.width);
    height = height || element.height;
    return {
      width,
      height: Math.max(0, aspectRatio ? Math.floor(width / aspectRatio) : height)
    };
  }
  isAttached(canvas) {
    return true;
  }
  updateConfig(config) {
  }
};
__name(_BasePlatform, "BasePlatform");
let BasePlatform = _BasePlatform;
const _BasicPlatform = class _BasicPlatform extends BasePlatform {
  acquireContext(item) {
    return item && item.getContext && item.getContext("2d") || null;
  }
  updateConfig(config) {
    config.options.animation = false;
  }
};
__name(_BasicPlatform, "BasicPlatform");
let BasicPlatform = _BasicPlatform;
const EXPANDO_KEY = "$chartjs";
const EVENT_TYPES = {
  touchstart: "mousedown",
  touchmove: "mousemove",
  touchend: "mouseup",
  pointerenter: "mouseenter",
  pointerdown: "mousedown",
  pointermove: "mousemove",
  pointerup: "mouseup",
  pointerleave: "mouseout",
  pointerout: "mouseout"
};
const isNullOrEmpty = /* @__PURE__ */ __name((value) => value === null || value === "", "isNullOrEmpty");
function initCanvas(canvas, aspectRatio) {
  const style = canvas.style;
  const renderHeight = canvas.getAttribute("height");
  const renderWidth = canvas.getAttribute("width");
  canvas[EXPANDO_KEY] = {
    initial: {
      height: renderHeight,
      width: renderWidth,
      style: {
        display: style.display,
        height: style.height,
        width: style.width
      }
    }
  };
  style.display = style.display || "block";
  style.boxSizing = style.boxSizing || "border-box";
  if (isNullOrEmpty(renderWidth)) {
    const displayWidth = readUsedSize(canvas, "width");
    if (displayWidth !== void 0) {
      canvas.width = displayWidth;
    }
  }
  if (isNullOrEmpty(renderHeight)) {
    if (canvas.style.height === "") {
      canvas.height = canvas.width / (aspectRatio || 2);
    } else {
      const displayHeight = readUsedSize(canvas, "height");
      if (displayHeight !== void 0) {
        canvas.height = displayHeight;
      }
    }
  }
  return canvas;
}
__name(initCanvas, "initCanvas");
const eventListenerOptions = supportsEventListenerOptions ? {
  passive: true
} : false;
function addListener(node, type, listener) {
  if (node) {
    node.addEventListener(type, listener, eventListenerOptions);
  }
}
__name(addListener, "addListener");
function removeListener(chart, type, listener) {
  if (chart && chart.canvas) {
    chart.canvas.removeEventListener(type, listener, eventListenerOptions);
  }
}
__name(removeListener, "removeListener");
function fromNativeEvent(event, chart) {
  const type = EVENT_TYPES[event.type] || event.type;
  const { x: x2, y: y2 } = getRelativePosition(event, chart);
  return {
    type,
    chart,
    native: event,
    x: x2 !== void 0 ? x2 : null,
    y: y2 !== void 0 ? y2 : null
  };
}
__name(fromNativeEvent, "fromNativeEvent");
function nodeListContains(nodeList, canvas) {
  for (const node of nodeList) {
    if (node === canvas || node.contains(canvas)) {
      return true;
    }
  }
}
__name(nodeListContains, "nodeListContains");
function createAttachObserver(chart, type, listener) {
  const canvas = chart.canvas;
  const observer = new MutationObserver((entries) => {
    let trigger = false;
    for (const entry of entries) {
      trigger = trigger || nodeListContains(entry.addedNodes, canvas);
      trigger = trigger && !nodeListContains(entry.removedNodes, canvas);
    }
    if (trigger) {
      listener();
    }
  });
  observer.observe(document, {
    childList: true,
    subtree: true
  });
  return observer;
}
__name(createAttachObserver, "createAttachObserver");
function createDetachObserver(chart, type, listener) {
  const canvas = chart.canvas;
  const observer = new MutationObserver((entries) => {
    let trigger = false;
    for (const entry of entries) {
      trigger = trigger || nodeListContains(entry.removedNodes, canvas);
      trigger = trigger && !nodeListContains(entry.addedNodes, canvas);
    }
    if (trigger) {
      listener();
    }
  });
  observer.observe(document, {
    childList: true,
    subtree: true
  });
  return observer;
}
__name(createDetachObserver, "createDetachObserver");
const drpListeningCharts = /* @__PURE__ */ new Map();
let oldDevicePixelRatio = 0;
function onWindowResize() {
  const dpr = window.devicePixelRatio;
  if (dpr === oldDevicePixelRatio) {
    return;
  }
  oldDevicePixelRatio = dpr;
  drpListeningCharts.forEach((resize, chart) => {
    if (chart.currentDevicePixelRatio !== dpr) {
      resize();
    }
  });
}
__name(onWindowResize, "onWindowResize");
function listenDevicePixelRatioChanges(chart, resize) {
  if (!drpListeningCharts.size) {
    window.addEventListener("resize", onWindowResize);
  }
  drpListeningCharts.set(chart, resize);
}
__name(listenDevicePixelRatioChanges, "listenDevicePixelRatioChanges");
function unlistenDevicePixelRatioChanges(chart) {
  drpListeningCharts.delete(chart);
  if (!drpListeningCharts.size) {
    window.removeEventListener("resize", onWindowResize);
  }
}
__name(unlistenDevicePixelRatioChanges, "unlistenDevicePixelRatioChanges");
function createResizeObserver(chart, type, listener) {
  const canvas = chart.canvas;
  const container = canvas && _getParentNode(canvas);
  if (!container) {
    return;
  }
  const resize = throttled((width, height) => {
    const w2 = container.clientWidth;
    listener(width, height);
    if (w2 < container.clientWidth) {
      listener();
    }
  }, window);
  const observer = new ResizeObserver((entries) => {
    const entry = entries[0];
    const width = entry.contentRect.width;
    const height = entry.contentRect.height;
    if (width === 0 && height === 0) {
      return;
    }
    resize(width, height);
  });
  observer.observe(container);
  listenDevicePixelRatioChanges(chart, resize);
  return observer;
}
__name(createResizeObserver, "createResizeObserver");
function releaseObserver(chart, type, observer) {
  if (observer) {
    observer.disconnect();
  }
  if (type === "resize") {
    unlistenDevicePixelRatioChanges(chart);
  }
}
__name(releaseObserver, "releaseObserver");
function createProxyAndListen(chart, type, listener) {
  const canvas = chart.canvas;
  const proxy = throttled((event) => {
    if (chart.ctx !== null) {
      listener(fromNativeEvent(event, chart));
    }
  }, chart);
  addListener(canvas, type, proxy);
  return proxy;
}
__name(createProxyAndListen, "createProxyAndListen");
const _DomPlatform = class _DomPlatform extends BasePlatform {
  acquireContext(canvas, aspectRatio) {
    const context = canvas && canvas.getContext && canvas.getContext("2d");
    if (context && context.canvas === canvas) {
      initCanvas(canvas, aspectRatio);
      return context;
    }
    return null;
  }
  releaseContext(context) {
    const canvas = context.canvas;
    if (!canvas[EXPANDO_KEY]) {
      return false;
    }
    const initial = canvas[EXPANDO_KEY].initial;
    [
      "height",
      "width"
    ].forEach((prop) => {
      const value = initial[prop];
      if (isNullOrUndef(value)) {
        canvas.removeAttribute(prop);
      } else {
        canvas.setAttribute(prop, value);
      }
    });
    const style = initial.style || {};
    Object.keys(style).forEach((key) => {
      canvas.style[key] = style[key];
    });
    canvas.width = canvas.width;
    delete canvas[EXPANDO_KEY];
    return true;
  }
  addEventListener(chart, type, listener) {
    this.removeEventListener(chart, type);
    const proxies = chart.$proxies || (chart.$proxies = {});
    const handlers = {
      attach: createAttachObserver,
      detach: createDetachObserver,
      resize: createResizeObserver
    };
    const handler = handlers[type] || createProxyAndListen;
    proxies[type] = handler(chart, type, listener);
  }
  removeEventListener(chart, type) {
    const proxies = chart.$proxies || (chart.$proxies = {});
    const proxy = proxies[type];
    if (!proxy) {
      return;
    }
    const handlers = {
      attach: releaseObserver,
      detach: releaseObserver,
      resize: releaseObserver
    };
    const handler = handlers[type] || removeListener;
    handler(chart, type, proxy);
    proxies[type] = void 0;
  }
  getDevicePixelRatio() {
    return window.devicePixelRatio;
  }
  getMaximumSize(canvas, width, height, aspectRatio) {
    return getMaximumSize(canvas, width, height, aspectRatio);
  }
  isAttached(canvas) {
    const container = canvas && _getParentNode(canvas);
    return !!(container && container.isConnected);
  }
};
__name(_DomPlatform, "DomPlatform");
let DomPlatform = _DomPlatform;
function _detectPlatform(canvas) {
  if (!_isDomSupported() || typeof OffscreenCanvas !== "undefined" && canvas instanceof OffscreenCanvas) {
    return BasicPlatform;
  }
  return DomPlatform;
}
__name(_detectPlatform, "_detectPlatform");
const _Element = class _Element {
  constructor() {
    __publicField(this, "x");
    __publicField(this, "y");
    __publicField(this, "active", false);
    __publicField(this, "options");
    __publicField(this, "$animations");
  }
  tooltipPosition(useFinalPosition) {
    const { x: x2, y: y2 } = this.getProps([
      "x",
      "y"
    ], useFinalPosition);
    return {
      x: x2,
      y: y2
    };
  }
  hasValue() {
    return isNumber(this.x) && isNumber(this.y);
  }
  getProps(props, final) {
    const anims = this.$animations;
    if (!final || !anims) {
      return this;
    }
    const ret = {};
    props.forEach((prop) => {
      ret[prop] = anims[prop] && anims[prop].active() ? anims[prop]._to : this[prop];
    });
    return ret;
  }
};
__name(_Element, "Element");
__publicField(_Element, "defaults", {});
__publicField(_Element, "defaultRoutes");
let Element = _Element;
function autoSkip(scale, ticks) {
  const tickOpts = scale.options.ticks;
  const determinedMaxTicks = determineMaxTicks(scale);
  const ticksLimit = Math.min(tickOpts.maxTicksLimit || determinedMaxTicks, determinedMaxTicks);
  const majorIndices = tickOpts.major.enabled ? getMajorIndices(ticks) : [];
  const numMajorIndices = majorIndices.length;
  const first = majorIndices[0];
  const last = majorIndices[numMajorIndices - 1];
  const newTicks = [];
  if (numMajorIndices > ticksLimit) {
    skipMajors(ticks, newTicks, majorIndices, numMajorIndices / ticksLimit);
    return newTicks;
  }
  const spacing = calculateSpacing(majorIndices, ticks, ticksLimit);
  if (numMajorIndices > 0) {
    let i2, ilen;
    const avgMajorSpacing = numMajorIndices > 1 ? Math.round((last - first) / (numMajorIndices - 1)) : null;
    skip(ticks, newTicks, spacing, isNullOrUndef(avgMajorSpacing) ? 0 : first - avgMajorSpacing, first);
    for (i2 = 0, ilen = numMajorIndices - 1; i2 < ilen; i2++) {
      skip(ticks, newTicks, spacing, majorIndices[i2], majorIndices[i2 + 1]);
    }
    skip(ticks, newTicks, spacing, last, isNullOrUndef(avgMajorSpacing) ? ticks.length : last + avgMajorSpacing);
    return newTicks;
  }
  skip(ticks, newTicks, spacing);
  return newTicks;
}
__name(autoSkip, "autoSkip");
function determineMaxTicks(scale) {
  const offset = scale.options.offset;
  const tickLength = scale._tickSize();
  const maxScale = scale._length / tickLength + (offset ? 0 : 1);
  const maxChart = scale._maxLength / tickLength;
  return Math.floor(Math.min(maxScale, maxChart));
}
__name(determineMaxTicks, "determineMaxTicks");
function calculateSpacing(majorIndices, ticks, ticksLimit) {
  const evenMajorSpacing = getEvenSpacing(majorIndices);
  const spacing = ticks.length / ticksLimit;
  if (!evenMajorSpacing) {
    return Math.max(spacing, 1);
  }
  const factors = _factorize(evenMajorSpacing);
  for (let i2 = 0, ilen = factors.length - 1; i2 < ilen; i2++) {
    const factor = factors[i2];
    if (factor > spacing) {
      return factor;
    }
  }
  return Math.max(spacing, 1);
}
__name(calculateSpacing, "calculateSpacing");
function getMajorIndices(ticks) {
  const result = [];
  let i2, ilen;
  for (i2 = 0, ilen = ticks.length; i2 < ilen; i2++) {
    if (ticks[i2].major) {
      result.push(i2);
    }
  }
  return result;
}
__name(getMajorIndices, "getMajorIndices");
function skipMajors(ticks, newTicks, majorIndices, spacing) {
  let count = 0;
  let next = majorIndices[0];
  let i2;
  spacing = Math.ceil(spacing);
  for (i2 = 0; i2 < ticks.length; i2++) {
    if (i2 === next) {
      newTicks.push(ticks[i2]);
      count++;
      next = majorIndices[count * spacing];
    }
  }
}
__name(skipMajors, "skipMajors");
function skip(ticks, newTicks, spacing, majorStart, majorEnd) {
  const start = valueOrDefault(majorStart, 0);
  const end = Math.min(valueOrDefault(majorEnd, ticks.length), ticks.length);
  let count = 0;
  let length, i2, next;
  spacing = Math.ceil(spacing);
  if (majorEnd) {
    length = majorEnd - majorStart;
    spacing = length / Math.floor(length / spacing);
  }
  next = start;
  while (next < 0) {
    count++;
    next = Math.round(start + count * spacing);
  }
  for (i2 = Math.max(start, 0); i2 < end; i2++) {
    if (i2 === next) {
      newTicks.push(ticks[i2]);
      count++;
      next = Math.round(start + count * spacing);
    }
  }
}
__name(skip, "skip");
function getEvenSpacing(arr) {
  const len = arr.length;
  let i2, diff;
  if (len < 2) {
    return false;
  }
  for (diff = arr[0], i2 = 1; i2 < len; ++i2) {
    if (arr[i2] - arr[i2 - 1] !== diff) {
      return false;
    }
  }
  return diff;
}
__name(getEvenSpacing, "getEvenSpacing");
const reverseAlign = /* @__PURE__ */ __name((align) => align === "left" ? "right" : align === "right" ? "left" : align, "reverseAlign");
const offsetFromEdge = /* @__PURE__ */ __name((scale, edge, offset) => edge === "top" || edge === "left" ? scale[edge] + offset : scale[edge] - offset, "offsetFromEdge");
const getTicksLimit = /* @__PURE__ */ __name((ticksLength, maxTicksLimit) => Math.min(maxTicksLimit || ticksLength, ticksLength), "getTicksLimit");
function sample(arr, numItems) {
  const result = [];
  const increment = arr.length / numItems;
  const len = arr.length;
  let i2 = 0;
  for (; i2 < len; i2 += increment) {
    result.push(arr[Math.floor(i2)]);
  }
  return result;
}
__name(sample, "sample");
function getPixelForGridLine(scale, index2, offsetGridLines) {
  const length = scale.ticks.length;
  const validIndex2 = Math.min(index2, length - 1);
  const start = scale._startPixel;
  const end = scale._endPixel;
  const epsilon = 1e-6;
  let lineValue = scale.getPixelForTick(validIndex2);
  let offset;
  if (offsetGridLines) {
    if (length === 1) {
      offset = Math.max(lineValue - start, end - lineValue);
    } else if (index2 === 0) {
      offset = (scale.getPixelForTick(1) - lineValue) / 2;
    } else {
      offset = (lineValue - scale.getPixelForTick(validIndex2 - 1)) / 2;
    }
    lineValue += validIndex2 < index2 ? offset : -offset;
    if (lineValue < start - epsilon || lineValue > end + epsilon) {
      return;
    }
  }
  return lineValue;
}
__name(getPixelForGridLine, "getPixelForGridLine");
function garbageCollect(caches, length) {
  each(caches, (cache) => {
    const gc = cache.gc;
    const gcLen = gc.length / 2;
    let i2;
    if (gcLen > length) {
      for (i2 = 0; i2 < gcLen; ++i2) {
        delete cache.data[gc[i2]];
      }
      gc.splice(0, gcLen);
    }
  });
}
__name(garbageCollect, "garbageCollect");
function getTickMarkLength(options) {
  return options.drawTicks ? options.tickLength : 0;
}
__name(getTickMarkLength, "getTickMarkLength");
function getTitleHeight(options, fallback) {
  if (!options.display) {
    return 0;
  }
  const font = toFont(options.font, fallback);
  const padding = toPadding(options.padding);
  const lines = isArray(options.text) ? options.text.length : 1;
  return lines * font.lineHeight + padding.height;
}
__name(getTitleHeight, "getTitleHeight");
function createScaleContext(parent, scale) {
  return createContext(parent, {
    scale,
    type: "scale"
  });
}
__name(createScaleContext, "createScaleContext");
function createTickContext(parent, index2, tick) {
  return createContext(parent, {
    tick,
    index: index2,
    type: "tick"
  });
}
__name(createTickContext, "createTickContext");
function titleAlign(align, position, reverse) {
  let ret = _toLeftRightCenter(align);
  if (reverse && position !== "right" || !reverse && position === "right") {
    ret = reverseAlign(ret);
  }
  return ret;
}
__name(titleAlign, "titleAlign");
function titleArgs(scale, offset, position, align) {
  const { top, left, bottom, right, chart } = scale;
  const { chartArea, scales } = chart;
  let rotation = 0;
  let maxWidth, titleX, titleY;
  const height = bottom - top;
  const width = right - left;
  if (scale.isHorizontal()) {
    titleX = _alignStartEnd(align, left, right);
    if (isObject(position)) {
      const positionAxisID = Object.keys(position)[0];
      const value = position[positionAxisID];
      titleY = scales[positionAxisID].getPixelForValue(value) + height - offset;
    } else if (position === "center") {
      titleY = (chartArea.bottom + chartArea.top) / 2 + height - offset;
    } else {
      titleY = offsetFromEdge(scale, position, offset);
    }
    maxWidth = right - left;
  } else {
    if (isObject(position)) {
      const positionAxisID = Object.keys(position)[0];
      const value = position[positionAxisID];
      titleX = scales[positionAxisID].getPixelForValue(value) - width + offset;
    } else if (position === "center") {
      titleX = (chartArea.left + chartArea.right) / 2 - width + offset;
    } else {
      titleX = offsetFromEdge(scale, position, offset);
    }
    titleY = _alignStartEnd(align, bottom, top);
    rotation = position === "left" ? -HALF_PI : HALF_PI;
  }
  return {
    titleX,
    titleY,
    maxWidth,
    rotation
  };
}
__name(titleArgs, "titleArgs");
const _Scale = class _Scale extends Element {
  constructor(cfg) {
    super();
    this.id = cfg.id;
    this.type = cfg.type;
    this.options = void 0;
    this.ctx = cfg.ctx;
    this.chart = cfg.chart;
    this.top = void 0;
    this.bottom = void 0;
    this.left = void 0;
    this.right = void 0;
    this.width = void 0;
    this.height = void 0;
    this._margins = {
      left: 0,
      right: 0,
      top: 0,
      bottom: 0
    };
    this.maxWidth = void 0;
    this.maxHeight = void 0;
    this.paddingTop = void 0;
    this.paddingBottom = void 0;
    this.paddingLeft = void 0;
    this.paddingRight = void 0;
    this.axis = void 0;
    this.labelRotation = void 0;
    this.min = void 0;
    this.max = void 0;
    this._range = void 0;
    this.ticks = [];
    this._gridLineItems = null;
    this._labelItems = null;
    this._labelSizes = null;
    this._length = 0;
    this._maxLength = 0;
    this._longestTextCache = {};
    this._startPixel = void 0;
    this._endPixel = void 0;
    this._reversePixels = false;
    this._userMax = void 0;
    this._userMin = void 0;
    this._suggestedMax = void 0;
    this._suggestedMin = void 0;
    this._ticksLength = 0;
    this._borderValue = 0;
    this._cache = {};
    this._dataLimitsCached = false;
    this.$context = void 0;
  }
  init(options) {
    this.options = options.setContext(this.getContext());
    this.axis = options.axis;
    this._userMin = this.parse(options.min);
    this._userMax = this.parse(options.max);
    this._suggestedMin = this.parse(options.suggestedMin);
    this._suggestedMax = this.parse(options.suggestedMax);
  }
  parse(raw, index2) {
    return raw;
  }
  getUserBounds() {
    let { _userMin, _userMax, _suggestedMin, _suggestedMax } = this;
    _userMin = finiteOrDefault(_userMin, Number.POSITIVE_INFINITY);
    _userMax = finiteOrDefault(_userMax, Number.NEGATIVE_INFINITY);
    _suggestedMin = finiteOrDefault(_suggestedMin, Number.POSITIVE_INFINITY);
    _suggestedMax = finiteOrDefault(_suggestedMax, Number.NEGATIVE_INFINITY);
    return {
      min: finiteOrDefault(_userMin, _suggestedMin),
      max: finiteOrDefault(_userMax, _suggestedMax),
      minDefined: isNumberFinite(_userMin),
      maxDefined: isNumberFinite(_userMax)
    };
  }
  getMinMax(canStack) {
    let { min, max: max2, minDefined, maxDefined } = this.getUserBounds();
    let range;
    if (minDefined && maxDefined) {
      return {
        min,
        max: max2
      };
    }
    const metas = this.getMatchingVisibleMetas();
    for (let i2 = 0, ilen = metas.length; i2 < ilen; ++i2) {
      range = metas[i2].controller.getMinMax(this, canStack);
      if (!minDefined) {
        min = Math.min(min, range.min);
      }
      if (!maxDefined) {
        max2 = Math.max(max2, range.max);
      }
    }
    min = maxDefined && min > max2 ? max2 : min;
    max2 = minDefined && min > max2 ? min : max2;
    return {
      min: finiteOrDefault(min, finiteOrDefault(max2, min)),
      max: finiteOrDefault(max2, finiteOrDefault(min, max2))
    };
  }
  getPadding() {
    return {
      left: this.paddingLeft || 0,
      top: this.paddingTop || 0,
      right: this.paddingRight || 0,
      bottom: this.paddingBottom || 0
    };
  }
  getTicks() {
    return this.ticks;
  }
  getLabels() {
    const data = this.chart.data;
    return this.options.labels || (this.isHorizontal() ? data.xLabels : data.yLabels) || data.labels || [];
  }
  getLabelItems(chartArea = this.chart.chartArea) {
    const items = this._labelItems || (this._labelItems = this._computeLabelItems(chartArea));
    return items;
  }
  beforeLayout() {
    this._cache = {};
    this._dataLimitsCached = false;
  }
  beforeUpdate() {
    callback(this.options.beforeUpdate, [
      this
    ]);
  }
  update(maxWidth, maxHeight, margins) {
    const { beginAtZero, grace, ticks: tickOpts } = this.options;
    const sampleSize = tickOpts.sampleSize;
    this.beforeUpdate();
    this.maxWidth = maxWidth;
    this.maxHeight = maxHeight;
    this._margins = margins = Object.assign({
      left: 0,
      right: 0,
      top: 0,
      bottom: 0
    }, margins);
    this.ticks = null;
    this._labelSizes = null;
    this._gridLineItems = null;
    this._labelItems = null;
    this.beforeSetDimensions();
    this.setDimensions();
    this.afterSetDimensions();
    this._maxLength = this.isHorizontal() ? this.width + margins.left + margins.right : this.height + margins.top + margins.bottom;
    if (!this._dataLimitsCached) {
      this.beforeDataLimits();
      this.determineDataLimits();
      this.afterDataLimits();
      this._range = _addGrace(this, grace, beginAtZero);
      this._dataLimitsCached = true;
    }
    this.beforeBuildTicks();
    this.ticks = this.buildTicks() || [];
    this.afterBuildTicks();
    const samplingEnabled = sampleSize < this.ticks.length;
    this._convertTicksToLabels(samplingEnabled ? sample(this.ticks, sampleSize) : this.ticks);
    this.configure();
    this.beforeCalculateLabelRotation();
    this.calculateLabelRotation();
    this.afterCalculateLabelRotation();
    if (tickOpts.display && (tickOpts.autoSkip || tickOpts.source === "auto")) {
      this.ticks = autoSkip(this, this.ticks);
      this._labelSizes = null;
      this.afterAutoSkip();
    }
    if (samplingEnabled) {
      this._convertTicksToLabels(this.ticks);
    }
    this.beforeFit();
    this.fit();
    this.afterFit();
    this.afterUpdate();
  }
  configure() {
    let reversePixels = this.options.reverse;
    let startPixel, endPixel;
    if (this.isHorizontal()) {
      startPixel = this.left;
      endPixel = this.right;
    } else {
      startPixel = this.top;
      endPixel = this.bottom;
      reversePixels = !reversePixels;
    }
    this._startPixel = startPixel;
    this._endPixel = endPixel;
    this._reversePixels = reversePixels;
    this._length = endPixel - startPixel;
    this._alignToPixels = this.options.alignToPixels;
  }
  afterUpdate() {
    callback(this.options.afterUpdate, [
      this
    ]);
  }
  beforeSetDimensions() {
    callback(this.options.beforeSetDimensions, [
      this
    ]);
  }
  setDimensions() {
    if (this.isHorizontal()) {
      this.width = this.maxWidth;
      this.left = 0;
      this.right = this.width;
    } else {
      this.height = this.maxHeight;
      this.top = 0;
      this.bottom = this.height;
    }
    this.paddingLeft = 0;
    this.paddingTop = 0;
    this.paddingRight = 0;
    this.paddingBottom = 0;
  }
  afterSetDimensions() {
    callback(this.options.afterSetDimensions, [
      this
    ]);
  }
  _callHooks(name) {
    this.chart.notifyPlugins(name, this.getContext());
    callback(this.options[name], [
      this
    ]);
  }
  beforeDataLimits() {
    this._callHooks("beforeDataLimits");
  }
  determineDataLimits() {
  }
  afterDataLimits() {
    this._callHooks("afterDataLimits");
  }
  beforeBuildTicks() {
    this._callHooks("beforeBuildTicks");
  }
  buildTicks() {
    return [];
  }
  afterBuildTicks() {
    this._callHooks("afterBuildTicks");
  }
  beforeTickToLabelConversion() {
    callback(this.options.beforeTickToLabelConversion, [
      this
    ]);
  }
  generateTickLabels(ticks) {
    const tickOpts = this.options.ticks;
    let i2, ilen, tick;
    for (i2 = 0, ilen = ticks.length; i2 < ilen; i2++) {
      tick = ticks[i2];
      tick.label = callback(tickOpts.callback, [
        tick.value,
        i2,
        ticks
      ], this);
    }
  }
  afterTickToLabelConversion() {
    callback(this.options.afterTickToLabelConversion, [
      this
    ]);
  }
  beforeCalculateLabelRotation() {
    callback(this.options.beforeCalculateLabelRotation, [
      this
    ]);
  }
  calculateLabelRotation() {
    const options = this.options;
    const tickOpts = options.ticks;
    const numTicks = getTicksLimit(this.ticks.length, options.ticks.maxTicksLimit);
    const minRotation = tickOpts.minRotation || 0;
    const maxRotation = tickOpts.maxRotation;
    let labelRotation = minRotation;
    let tickWidth, maxHeight, maxLabelDiagonal;
    if (!this._isVisible() || !tickOpts.display || minRotation >= maxRotation || numTicks <= 1 || !this.isHorizontal()) {
      this.labelRotation = minRotation;
      return;
    }
    const labelSizes = this._getLabelSizes();
    const maxLabelWidth = labelSizes.widest.width;
    const maxLabelHeight = labelSizes.highest.height;
    const maxWidth = _limitValue(this.chart.width - maxLabelWidth, 0, this.maxWidth);
    tickWidth = options.offset ? this.maxWidth / numTicks : maxWidth / (numTicks - 1);
    if (maxLabelWidth + 6 > tickWidth) {
      tickWidth = maxWidth / (numTicks - (options.offset ? 0.5 : 1));
      maxHeight = this.maxHeight - getTickMarkLength(options.grid) - tickOpts.padding - getTitleHeight(options.title, this.chart.options.font);
      maxLabelDiagonal = Math.sqrt(maxLabelWidth * maxLabelWidth + maxLabelHeight * maxLabelHeight);
      labelRotation = toDegrees(Math.min(Math.asin(_limitValue((labelSizes.highest.height + 6) / tickWidth, -1, 1)), Math.asin(_limitValue(maxHeight / maxLabelDiagonal, -1, 1)) - Math.asin(_limitValue(maxLabelHeight / maxLabelDiagonal, -1, 1))));
      labelRotation = Math.max(minRotation, Math.min(maxRotation, labelRotation));
    }
    this.labelRotation = labelRotation;
  }
  afterCalculateLabelRotation() {
    callback(this.options.afterCalculateLabelRotation, [
      this
    ]);
  }
  afterAutoSkip() {
  }
  beforeFit() {
    callback(this.options.beforeFit, [
      this
    ]);
  }
  fit() {
    const minSize = {
      width: 0,
      height: 0
    };
    const { chart, options: { ticks: tickOpts, title: titleOpts, grid: gridOpts } } = this;
    const display = this._isVisible();
    const isHorizontal = this.isHorizontal();
    if (display) {
      const titleHeight = getTitleHeight(titleOpts, chart.options.font);
      if (isHorizontal) {
        minSize.width = this.maxWidth;
        minSize.height = getTickMarkLength(gridOpts) + titleHeight;
      } else {
        minSize.height = this.maxHeight;
        minSize.width = getTickMarkLength(gridOpts) + titleHeight;
      }
      if (tickOpts.display && this.ticks.length) {
        const { first, last, widest, highest } = this._getLabelSizes();
        const tickPadding = tickOpts.padding * 2;
        const angleRadians = toRadians(this.labelRotation);
        const cos = Math.cos(angleRadians);
        const sin = Math.sin(angleRadians);
        if (isHorizontal) {
          const labelHeight = tickOpts.mirror ? 0 : sin * widest.width + cos * highest.height;
          minSize.height = Math.min(this.maxHeight, minSize.height + labelHeight + tickPadding);
        } else {
          const labelWidth = tickOpts.mirror ? 0 : cos * widest.width + sin * highest.height;
          minSize.width = Math.min(this.maxWidth, minSize.width + labelWidth + tickPadding);
        }
        this._calculatePadding(first, last, sin, cos);
      }
    }
    this._handleMargins();
    if (isHorizontal) {
      this.width = this._length = chart.width - this._margins.left - this._margins.right;
      this.height = minSize.height;
    } else {
      this.width = minSize.width;
      this.height = this._length = chart.height - this._margins.top - this._margins.bottom;
    }
  }
  _calculatePadding(first, last, sin, cos) {
    const { ticks: { align, padding }, position } = this.options;
    const isRotated = this.labelRotation !== 0;
    const labelsBelowTicks = position !== "top" && this.axis === "x";
    if (this.isHorizontal()) {
      const offsetLeft = this.getPixelForTick(0) - this.left;
      const offsetRight = this.right - this.getPixelForTick(this.ticks.length - 1);
      let paddingLeft = 0;
      let paddingRight = 0;
      if (isRotated) {
        if (labelsBelowTicks) {
          paddingLeft = cos * first.width;
          paddingRight = sin * last.height;
        } else {
          paddingLeft = sin * first.height;
          paddingRight = cos * last.width;
        }
      } else if (align === "start") {
        paddingRight = last.width;
      } else if (align === "end") {
        paddingLeft = first.width;
      } else if (align !== "inner") {
        paddingLeft = first.width / 2;
        paddingRight = last.width / 2;
      }
      this.paddingLeft = Math.max((paddingLeft - offsetLeft + padding) * this.width / (this.width - offsetLeft), 0);
      this.paddingRight = Math.max((paddingRight - offsetRight + padding) * this.width / (this.width - offsetRight), 0);
    } else {
      let paddingTop = last.height / 2;
      let paddingBottom = first.height / 2;
      if (align === "start") {
        paddingTop = 0;
        paddingBottom = first.height;
      } else if (align === "end") {
        paddingTop = last.height;
        paddingBottom = 0;
      }
      this.paddingTop = paddingTop + padding;
      this.paddingBottom = paddingBottom + padding;
    }
  }
  _handleMargins() {
    if (this._margins) {
      this._margins.left = Math.max(this.paddingLeft, this._margins.left);
      this._margins.top = Math.max(this.paddingTop, this._margins.top);
      this._margins.right = Math.max(this.paddingRight, this._margins.right);
      this._margins.bottom = Math.max(this.paddingBottom, this._margins.bottom);
    }
  }
  afterFit() {
    callback(this.options.afterFit, [
      this
    ]);
  }
  isHorizontal() {
    const { axis, position } = this.options;
    return position === "top" || position === "bottom" || axis === "x";
  }
  isFullSize() {
    return this.options.fullSize;
  }
  _convertTicksToLabels(ticks) {
    this.beforeTickToLabelConversion();
    this.generateTickLabels(ticks);
    let i2, ilen;
    for (i2 = 0, ilen = ticks.length; i2 < ilen; i2++) {
      if (isNullOrUndef(ticks[i2].label)) {
        ticks.splice(i2, 1);
        ilen--;
        i2--;
      }
    }
    this.afterTickToLabelConversion();
  }
  _getLabelSizes() {
    let labelSizes = this._labelSizes;
    if (!labelSizes) {
      const sampleSize = this.options.ticks.sampleSize;
      let ticks = this.ticks;
      if (sampleSize < ticks.length) {
        ticks = sample(ticks, sampleSize);
      }
      this._labelSizes = labelSizes = this._computeLabelSizes(ticks, ticks.length, this.options.ticks.maxTicksLimit);
    }
    return labelSizes;
  }
  _computeLabelSizes(ticks, length, maxTicksLimit) {
    const { ctx, _longestTextCache: caches } = this;
    const widths = [];
    const heights = [];
    const increment = Math.floor(length / getTicksLimit(length, maxTicksLimit));
    let widestLabelSize = 0;
    let highestLabelSize = 0;
    let i2, j2, jlen, label, tickFont, fontString, cache, lineHeight, width, height, nestedLabel;
    for (i2 = 0; i2 < length; i2 += increment) {
      label = ticks[i2].label;
      tickFont = this._resolveTickFontOptions(i2);
      ctx.font = fontString = tickFont.string;
      cache = caches[fontString] = caches[fontString] || {
        data: {},
        gc: []
      };
      lineHeight = tickFont.lineHeight;
      width = height = 0;
      if (!isNullOrUndef(label) && !isArray(label)) {
        width = _measureText(ctx, cache.data, cache.gc, width, label);
        height = lineHeight;
      } else if (isArray(label)) {
        for (j2 = 0, jlen = label.length; j2 < jlen; ++j2) {
          nestedLabel = label[j2];
          if (!isNullOrUndef(nestedLabel) && !isArray(nestedLabel)) {
            width = _measureText(ctx, cache.data, cache.gc, width, nestedLabel);
            height += lineHeight;
          }
        }
      }
      widths.push(width);
      heights.push(height);
      widestLabelSize = Math.max(width, widestLabelSize);
      highestLabelSize = Math.max(height, highestLabelSize);
    }
    garbageCollect(caches, length);
    const widest = widths.indexOf(widestLabelSize);
    const highest = heights.indexOf(highestLabelSize);
    const valueAt = /* @__PURE__ */ __name((idx) => ({
      width: widths[idx] || 0,
      height: heights[idx] || 0
    }), "valueAt");
    return {
      first: valueAt(0),
      last: valueAt(length - 1),
      widest: valueAt(widest),
      highest: valueAt(highest),
      widths,
      heights
    };
  }
  getLabelForValue(value) {
    return value;
  }
  getPixelForValue(value, index2) {
    return NaN;
  }
  getValueForPixel(pixel) {
  }
  getPixelForTick(index2) {
    const ticks = this.ticks;
    if (index2 < 0 || index2 > ticks.length - 1) {
      return null;
    }
    return this.getPixelForValue(ticks[index2].value);
  }
  getPixelForDecimal(decimal) {
    if (this._reversePixels) {
      decimal = 1 - decimal;
    }
    const pixel = this._startPixel + decimal * this._length;
    return _int16Range(this._alignToPixels ? _alignPixel(this.chart, pixel, 0) : pixel);
  }
  getDecimalForPixel(pixel) {
    const decimal = (pixel - this._startPixel) / this._length;
    return this._reversePixels ? 1 - decimal : decimal;
  }
  getBasePixel() {
    return this.getPixelForValue(this.getBaseValue());
  }
  getBaseValue() {
    const { min, max: max2 } = this;
    return min < 0 && max2 < 0 ? max2 : min > 0 && max2 > 0 ? min : 0;
  }
  getContext(index2) {
    const ticks = this.ticks || [];
    if (index2 >= 0 && index2 < ticks.length) {
      const tick = ticks[index2];
      return tick.$context || (tick.$context = createTickContext(this.getContext(), index2, tick));
    }
    return this.$context || (this.$context = createScaleContext(this.chart.getContext(), this));
  }
  _tickSize() {
    const optionTicks = this.options.ticks;
    const rot = toRadians(this.labelRotation);
    const cos = Math.abs(Math.cos(rot));
    const sin = Math.abs(Math.sin(rot));
    const labelSizes = this._getLabelSizes();
    const padding = optionTicks.autoSkipPadding || 0;
    const w2 = labelSizes ? labelSizes.widest.width + padding : 0;
    const h3 = labelSizes ? labelSizes.highest.height + padding : 0;
    return this.isHorizontal() ? h3 * cos > w2 * sin ? w2 / cos : h3 / sin : h3 * sin < w2 * cos ? h3 / cos : w2 / sin;
  }
  _isVisible() {
    const display = this.options.display;
    if (display !== "auto") {
      return !!display;
    }
    return this.getMatchingVisibleMetas().length > 0;
  }
  _computeGridLineItems(chartArea) {
    const axis = this.axis;
    const chart = this.chart;
    const options = this.options;
    const { grid, position, border } = options;
    const offset = grid.offset;
    const isHorizontal = this.isHorizontal();
    const ticks = this.ticks;
    const ticksLength = ticks.length + (offset ? 1 : 0);
    const tl = getTickMarkLength(grid);
    const items = [];
    const borderOpts = border.setContext(this.getContext());
    const axisWidth = borderOpts.display ? borderOpts.width : 0;
    const axisHalfWidth = axisWidth / 2;
    const alignBorderValue = /* @__PURE__ */ __name(function(pixel) {
      return _alignPixel(chart, pixel, axisWidth);
    }, "alignBorderValue");
    let borderValue, i2, lineValue, alignedLineValue;
    let tx1, ty1, tx2, ty2, x1, y1, x2, y2;
    if (position === "top") {
      borderValue = alignBorderValue(this.bottom);
      ty1 = this.bottom - tl;
      ty2 = borderValue - axisHalfWidth;
      y1 = alignBorderValue(chartArea.top) + axisHalfWidth;
      y2 = chartArea.bottom;
    } else if (position === "bottom") {
      borderValue = alignBorderValue(this.top);
      y1 = chartArea.top;
      y2 = alignBorderValue(chartArea.bottom) - axisHalfWidth;
      ty1 = borderValue + axisHalfWidth;
      ty2 = this.top + tl;
    } else if (position === "left") {
      borderValue = alignBorderValue(this.right);
      tx1 = this.right - tl;
      tx2 = borderValue - axisHalfWidth;
      x1 = alignBorderValue(chartArea.left) + axisHalfWidth;
      x2 = chartArea.right;
    } else if (position === "right") {
      borderValue = alignBorderValue(this.left);
      x1 = chartArea.left;
      x2 = alignBorderValue(chartArea.right) - axisHalfWidth;
      tx1 = borderValue + axisHalfWidth;
      tx2 = this.left + tl;
    } else if (axis === "x") {
      if (position === "center") {
        borderValue = alignBorderValue((chartArea.top + chartArea.bottom) / 2 + 0.5);
      } else if (isObject(position)) {
        const positionAxisID = Object.keys(position)[0];
        const value = position[positionAxisID];
        borderValue = alignBorderValue(this.chart.scales[positionAxisID].getPixelForValue(value));
      }
      y1 = chartArea.top;
      y2 = chartArea.bottom;
      ty1 = borderValue + axisHalfWidth;
      ty2 = ty1 + tl;
    } else if (axis === "y") {
      if (position === "center") {
        borderValue = alignBorderValue((chartArea.left + chartArea.right) / 2);
      } else if (isObject(position)) {
        const positionAxisID = Object.keys(position)[0];
        const value = position[positionAxisID];
        borderValue = alignBorderValue(this.chart.scales[positionAxisID].getPixelForValue(value));
      }
      tx1 = borderValue - axisHalfWidth;
      tx2 = tx1 - tl;
      x1 = chartArea.left;
      x2 = chartArea.right;
    }
    const limit = valueOrDefault(options.ticks.maxTicksLimit, ticksLength);
    const step = Math.max(1, Math.ceil(ticksLength / limit));
    for (i2 = 0; i2 < ticksLength; i2 += step) {
      const context = this.getContext(i2);
      const optsAtIndex = grid.setContext(context);
      const optsAtIndexBorder = border.setContext(context);
      const lineWidth = optsAtIndex.lineWidth;
      const lineColor = optsAtIndex.color;
      const borderDash = optsAtIndexBorder.dash || [];
      const borderDashOffset = optsAtIndexBorder.dashOffset;
      const tickWidth = optsAtIndex.tickWidth;
      const tickColor = optsAtIndex.tickColor;
      const tickBorderDash = optsAtIndex.tickBorderDash || [];
      const tickBorderDashOffset = optsAtIndex.tickBorderDashOffset;
      lineValue = getPixelForGridLine(this, i2, offset);
      if (lineValue === void 0) {
        continue;
      }
      alignedLineValue = _alignPixel(chart, lineValue, lineWidth);
      if (isHorizontal) {
        tx1 = tx2 = x1 = x2 = alignedLineValue;
      } else {
        ty1 = ty2 = y1 = y2 = alignedLineValue;
      }
      items.push({
        tx1,
        ty1,
        tx2,
        ty2,
        x1,
        y1,
        x2,
        y2,
        width: lineWidth,
        color: lineColor,
        borderDash,
        borderDashOffset,
        tickWidth,
        tickColor,
        tickBorderDash,
        tickBorderDashOffset
      });
    }
    this._ticksLength = ticksLength;
    this._borderValue = borderValue;
    return items;
  }
  _computeLabelItems(chartArea) {
    const axis = this.axis;
    const options = this.options;
    const { position, ticks: optionTicks } = options;
    const isHorizontal = this.isHorizontal();
    const ticks = this.ticks;
    const { align, crossAlign, padding, mirror } = optionTicks;
    const tl = getTickMarkLength(options.grid);
    const tickAndPadding = tl + padding;
    const hTickAndPadding = mirror ? -padding : tickAndPadding;
    const rotation = -toRadians(this.labelRotation);
    const items = [];
    let i2, ilen, tick, label, x2, y2, textAlign, pixel, font, lineHeight, lineCount, textOffset;
    let textBaseline = "middle";
    if (position === "top") {
      y2 = this.bottom - hTickAndPadding;
      textAlign = this._getXAxisLabelAlignment();
    } else if (position === "bottom") {
      y2 = this.top + hTickAndPadding;
      textAlign = this._getXAxisLabelAlignment();
    } else if (position === "left") {
      const ret = this._getYAxisLabelAlignment(tl);
      textAlign = ret.textAlign;
      x2 = ret.x;
    } else if (position === "right") {
      const ret = this._getYAxisLabelAlignment(tl);
      textAlign = ret.textAlign;
      x2 = ret.x;
    } else if (axis === "x") {
      if (position === "center") {
        y2 = (chartArea.top + chartArea.bottom) / 2 + tickAndPadding;
      } else if (isObject(position)) {
        const positionAxisID = Object.keys(position)[0];
        const value = position[positionAxisID];
        y2 = this.chart.scales[positionAxisID].getPixelForValue(value) + tickAndPadding;
      }
      textAlign = this._getXAxisLabelAlignment();
    } else if (axis === "y") {
      if (position === "center") {
        x2 = (chartArea.left + chartArea.right) / 2 - tickAndPadding;
      } else if (isObject(position)) {
        const positionAxisID = Object.keys(position)[0];
        const value = position[positionAxisID];
        x2 = this.chart.scales[positionAxisID].getPixelForValue(value);
      }
      textAlign = this._getYAxisLabelAlignment(tl).textAlign;
    }
    if (axis === "y") {
      if (align === "start") {
        textBaseline = "top";
      } else if (align === "end") {
        textBaseline = "bottom";
      }
    }
    const labelSizes = this._getLabelSizes();
    for (i2 = 0, ilen = ticks.length; i2 < ilen; ++i2) {
      tick = ticks[i2];
      label = tick.label;
      const optsAtIndex = optionTicks.setContext(this.getContext(i2));
      pixel = this.getPixelForTick(i2) + optionTicks.labelOffset;
      font = this._resolveTickFontOptions(i2);
      lineHeight = font.lineHeight;
      lineCount = isArray(label) ? label.length : 1;
      const halfCount = lineCount / 2;
      const color2 = optsAtIndex.color;
      const strokeColor = optsAtIndex.textStrokeColor;
      const strokeWidth = optsAtIndex.textStrokeWidth;
      let tickTextAlign = textAlign;
      if (isHorizontal) {
        x2 = pixel;
        if (textAlign === "inner") {
          if (i2 === ilen - 1) {
            tickTextAlign = !this.options.reverse ? "right" : "left";
          } else if (i2 === 0) {
            tickTextAlign = !this.options.reverse ? "left" : "right";
          } else {
            tickTextAlign = "center";
          }
        }
        if (position === "top") {
          if (crossAlign === "near" || rotation !== 0) {
            textOffset = -lineCount * lineHeight + lineHeight / 2;
          } else if (crossAlign === "center") {
            textOffset = -labelSizes.highest.height / 2 - halfCount * lineHeight + lineHeight;
          } else {
            textOffset = -labelSizes.highest.height + lineHeight / 2;
          }
        } else {
          if (crossAlign === "near" || rotation !== 0) {
            textOffset = lineHeight / 2;
          } else if (crossAlign === "center") {
            textOffset = labelSizes.highest.height / 2 - halfCount * lineHeight;
          } else {
            textOffset = labelSizes.highest.height - lineCount * lineHeight;
          }
        }
        if (mirror) {
          textOffset *= -1;
        }
        if (rotation !== 0 && !optsAtIndex.showLabelBackdrop) {
          x2 += lineHeight / 2 * Math.sin(rotation);
        }
      } else {
        y2 = pixel;
        textOffset = (1 - lineCount) * lineHeight / 2;
      }
      let backdrop;
      if (optsAtIndex.showLabelBackdrop) {
        const labelPadding = toPadding(optsAtIndex.backdropPadding);
        const height = labelSizes.heights[i2];
        const width = labelSizes.widths[i2];
        let top = textOffset - labelPadding.top;
        let left = 0 - labelPadding.left;
        switch (textBaseline) {
          case "middle":
            top -= height / 2;
            break;
          case "bottom":
            top -= height;
            break;
        }
        switch (textAlign) {
          case "center":
            left -= width / 2;
            break;
          case "right":
            left -= width;
            break;
          case "inner":
            if (i2 === ilen - 1) {
              left -= width;
            } else if (i2 > 0) {
              left -= width / 2;
            }
            break;
        }
        backdrop = {
          left,
          top,
          width: width + labelPadding.width,
          height: height + labelPadding.height,
          color: optsAtIndex.backdropColor
        };
      }
      items.push({
        label,
        font,
        textOffset,
        options: {
          rotation,
          color: color2,
          strokeColor,
          strokeWidth,
          textAlign: tickTextAlign,
          textBaseline,
          translation: [
            x2,
            y2
          ],
          backdrop
        }
      });
    }
    return items;
  }
  _getXAxisLabelAlignment() {
    const { position, ticks } = this.options;
    const rotation = -toRadians(this.labelRotation);
    if (rotation) {
      return position === "top" ? "left" : "right";
    }
    let align = "center";
    if (ticks.align === "start") {
      align = "left";
    } else if (ticks.align === "end") {
      align = "right";
    } else if (ticks.align === "inner") {
      align = "inner";
    }
    return align;
  }
  _getYAxisLabelAlignment(tl) {
    const { position, ticks: { crossAlign, mirror, padding } } = this.options;
    const labelSizes = this._getLabelSizes();
    const tickAndPadding = tl + padding;
    const widest = labelSizes.widest.width;
    let textAlign;
    let x2;
    if (position === "left") {
      if (mirror) {
        x2 = this.right + padding;
        if (crossAlign === "near") {
          textAlign = "left";
        } else if (crossAlign === "center") {
          textAlign = "center";
          x2 += widest / 2;
        } else {
          textAlign = "right";
          x2 += widest;
        }
      } else {
        x2 = this.right - tickAndPadding;
        if (crossAlign === "near") {
          textAlign = "right";
        } else if (crossAlign === "center") {
          textAlign = "center";
          x2 -= widest / 2;
        } else {
          textAlign = "left";
          x2 = this.left;
        }
      }
    } else if (position === "right") {
      if (mirror) {
        x2 = this.left + padding;
        if (crossAlign === "near") {
          textAlign = "right";
        } else if (crossAlign === "center") {
          textAlign = "center";
          x2 -= widest / 2;
        } else {
          textAlign = "left";
          x2 -= widest;
        }
      } else {
        x2 = this.left + tickAndPadding;
        if (crossAlign === "near") {
          textAlign = "left";
        } else if (crossAlign === "center") {
          textAlign = "center";
          x2 += widest / 2;
        } else {
          textAlign = "right";
          x2 = this.right;
        }
      }
    } else {
      textAlign = "right";
    }
    return {
      textAlign,
      x: x2
    };
  }
  _computeLabelArea() {
    if (this.options.ticks.mirror) {
      return;
    }
    const chart = this.chart;
    const position = this.options.position;
    if (position === "left" || position === "right") {
      return {
        top: 0,
        left: this.left,
        bottom: chart.height,
        right: this.right
      };
    }
    if (position === "top" || position === "bottom") {
      return {
        top: this.top,
        left: 0,
        bottom: this.bottom,
        right: chart.width
      };
    }
  }
  drawBackground() {
    const { ctx, options: { backgroundColor }, left, top, width, height } = this;
    if (backgroundColor) {
      ctx.save();
      ctx.fillStyle = backgroundColor;
      ctx.fillRect(left, top, width, height);
      ctx.restore();
    }
  }
  getLineWidthForValue(value) {
    const grid = this.options.grid;
    if (!this._isVisible() || !grid.display) {
      return 0;
    }
    const ticks = this.ticks;
    const index2 = ticks.findIndex((t2) => t2.value === value);
    if (index2 >= 0) {
      const opts = grid.setContext(this.getContext(index2));
      return opts.lineWidth;
    }
    return 0;
  }
  drawGrid(chartArea) {
    const grid = this.options.grid;
    const ctx = this.ctx;
    const items = this._gridLineItems || (this._gridLineItems = this._computeGridLineItems(chartArea));
    let i2, ilen;
    const drawLine = /* @__PURE__ */ __name((p1, p2, style) => {
      if (!style.width || !style.color) {
        return;
      }
      ctx.save();
      ctx.lineWidth = style.width;
      ctx.strokeStyle = style.color;
      ctx.setLineDash(style.borderDash || []);
      ctx.lineDashOffset = style.borderDashOffset;
      ctx.beginPath();
      ctx.moveTo(p1.x, p1.y);
      ctx.lineTo(p2.x, p2.y);
      ctx.stroke();
      ctx.restore();
    }, "drawLine");
    if (grid.display) {
      for (i2 = 0, ilen = items.length; i2 < ilen; ++i2) {
        const item = items[i2];
        if (grid.drawOnChartArea) {
          drawLine({
            x: item.x1,
            y: item.y1
          }, {
            x: item.x2,
            y: item.y2
          }, item);
        }
        if (grid.drawTicks) {
          drawLine({
            x: item.tx1,
            y: item.ty1
          }, {
            x: item.tx2,
            y: item.ty2
          }, {
            color: item.tickColor,
            width: item.tickWidth,
            borderDash: item.tickBorderDash,
            borderDashOffset: item.tickBorderDashOffset
          });
        }
      }
    }
  }
  drawBorder() {
    const { chart, ctx, options: { border, grid } } = this;
    const borderOpts = border.setContext(this.getContext());
    const axisWidth = border.display ? borderOpts.width : 0;
    if (!axisWidth) {
      return;
    }
    const lastLineWidth = grid.setContext(this.getContext(0)).lineWidth;
    const borderValue = this._borderValue;
    let x1, x2, y1, y2;
    if (this.isHorizontal()) {
      x1 = _alignPixel(chart, this.left, axisWidth) - axisWidth / 2;
      x2 = _alignPixel(chart, this.right, lastLineWidth) + lastLineWidth / 2;
      y1 = y2 = borderValue;
    } else {
      y1 = _alignPixel(chart, this.top, axisWidth) - axisWidth / 2;
      y2 = _alignPixel(chart, this.bottom, lastLineWidth) + lastLineWidth / 2;
      x1 = x2 = borderValue;
    }
    ctx.save();
    ctx.lineWidth = borderOpts.width;
    ctx.strokeStyle = borderOpts.color;
    ctx.beginPath();
    ctx.moveTo(x1, y1);
    ctx.lineTo(x2, y2);
    ctx.stroke();
    ctx.restore();
  }
  drawLabels(chartArea) {
    const optionTicks = this.options.ticks;
    if (!optionTicks.display) {
      return;
    }
    const ctx = this.ctx;
    const area = this._computeLabelArea();
    if (area) {
      clipArea(ctx, area);
    }
    const items = this.getLabelItems(chartArea);
    for (const item of items) {
      const renderTextOptions = item.options;
      const tickFont = item.font;
      const label = item.label;
      const y2 = item.textOffset;
      renderText(ctx, label, 0, y2, tickFont, renderTextOptions);
    }
    if (area) {
      unclipArea(ctx);
    }
  }
  drawTitle() {
    const { ctx, options: { position, title, reverse } } = this;
    if (!title.display) {
      return;
    }
    const font = toFont(title.font);
    const padding = toPadding(title.padding);
    const align = title.align;
    let offset = font.lineHeight / 2;
    if (position === "bottom" || position === "center" || isObject(position)) {
      offset += padding.bottom;
      if (isArray(title.text)) {
        offset += font.lineHeight * (title.text.length - 1);
      }
    } else {
      offset += padding.top;
    }
    const { titleX, titleY, maxWidth, rotation } = titleArgs(this, offset, position, align);
    renderText(ctx, title.text, 0, 0, font, {
      color: title.color,
      maxWidth,
      rotation,
      textAlign: titleAlign(align, position, reverse),
      textBaseline: "middle",
      translation: [
        titleX,
        titleY
      ]
    });
  }
  draw(chartArea) {
    if (!this._isVisible()) {
      return;
    }
    this.drawBackground();
    this.drawGrid(chartArea);
    this.drawBorder();
    this.drawTitle();
    this.drawLabels(chartArea);
  }
  _layers() {
    const opts = this.options;
    const tz = opts.ticks && opts.ticks.z || 0;
    const gz = valueOrDefault(opts.grid && opts.grid.z, -1);
    const bz = valueOrDefault(opts.border && opts.border.z, 0);
    if (!this._isVisible() || this.draw !== _Scale.prototype.draw) {
      return [
        {
          z: tz,
          draw: (chartArea) => {
            this.draw(chartArea);
          }
        }
      ];
    }
    return [
      {
        z: gz,
        draw: (chartArea) => {
          this.drawBackground();
          this.drawGrid(chartArea);
          this.drawTitle();
        }
      },
      {
        z: bz,
        draw: () => {
          this.drawBorder();
        }
      },
      {
        z: tz,
        draw: (chartArea) => {
          this.drawLabels(chartArea);
        }
      }
    ];
  }
  getMatchingVisibleMetas(type) {
    const metas = this.chart.getSortedVisibleDatasetMetas();
    const axisID = this.axis + "AxisID";
    const result = [];
    let i2, ilen;
    for (i2 = 0, ilen = metas.length; i2 < ilen; ++i2) {
      const meta = metas[i2];
      if (meta[axisID] === this.id && (!type || meta.type === type)) {
        result.push(meta);
      }
    }
    return result;
  }
  _resolveTickFontOptions(index2) {
    const opts = this.options.ticks.setContext(this.getContext(index2));
    return toFont(opts.font);
  }
  _maxDigits() {
    const fontSize = this._resolveTickFontOptions(0).lineHeight;
    return (this.isHorizontal() ? this.width : this.height) / fontSize;
  }
};
__name(_Scale, "Scale");
let Scale = _Scale;
const _TypedRegistry = class _TypedRegistry {
  constructor(type, scope, override) {
    this.type = type;
    this.scope = scope;
    this.override = override;
    this.items = /* @__PURE__ */ Object.create(null);
  }
  isForType(type) {
    return Object.prototype.isPrototypeOf.call(this.type.prototype, type.prototype);
  }
  register(item) {
    const proto = Object.getPrototypeOf(item);
    let parentScope;
    if (isIChartComponent(proto)) {
      parentScope = this.register(proto);
    }
    const items = this.items;
    const id = item.id;
    const scope = this.scope + "." + id;
    if (!id) {
      throw new Error("class does not have id: " + item);
    }
    if (id in items) {
      return scope;
    }
    items[id] = item;
    registerDefaults(item, scope, parentScope);
    if (this.override) {
      defaults.override(item.id, item.overrides);
    }
    return scope;
  }
  get(id) {
    return this.items[id];
  }
  unregister(item) {
    const items = this.items;
    const id = item.id;
    const scope = this.scope;
    if (id in items) {
      delete items[id];
    }
    if (scope && id in defaults[scope]) {
      delete defaults[scope][id];
      if (this.override) {
        delete overrides[id];
      }
    }
  }
};
__name(_TypedRegistry, "TypedRegistry");
let TypedRegistry = _TypedRegistry;
function registerDefaults(item, scope, parentScope) {
  const itemDefaults = merge(/* @__PURE__ */ Object.create(null), [
    parentScope ? defaults.get(parentScope) : {},
    defaults.get(scope),
    item.defaults
  ]);
  defaults.set(scope, itemDefaults);
  if (item.defaultRoutes) {
    routeDefaults(scope, item.defaultRoutes);
  }
  if (item.descriptors) {
    defaults.describe(scope, item.descriptors);
  }
}
__name(registerDefaults, "registerDefaults");
function routeDefaults(scope, routes) {
  Object.keys(routes).forEach((property) => {
    const propertyParts = property.split(".");
    const sourceName = propertyParts.pop();
    const sourceScope = [
      scope
    ].concat(propertyParts).join(".");
    const parts = routes[property].split(".");
    const targetName = parts.pop();
    const targetScope = parts.join(".");
    defaults.route(sourceScope, sourceName, targetScope, targetName);
  });
}
__name(routeDefaults, "routeDefaults");
function isIChartComponent(proto) {
  return "id" in proto && "defaults" in proto;
}
__name(isIChartComponent, "isIChartComponent");
const _Registry = class _Registry {
  constructor() {
    this.controllers = new TypedRegistry(DatasetController, "datasets", true);
    this.elements = new TypedRegistry(Element, "elements");
    this.plugins = new TypedRegistry(Object, "plugins");
    this.scales = new TypedRegistry(Scale, "scales");
    this._typedRegistries = [
      this.controllers,
      this.scales,
      this.elements
    ];
  }
  add(...args) {
    this._each("register", args);
  }
  remove(...args) {
    this._each("unregister", args);
  }
  addControllers(...args) {
    this._each("register", args, this.controllers);
  }
  addElements(...args) {
    this._each("register", args, this.elements);
  }
  addPlugins(...args) {
    this._each("register", args, this.plugins);
  }
  addScales(...args) {
    this._each("register", args, this.scales);
  }
  getController(id) {
    return this._get(id, this.controllers, "controller");
  }
  getElement(id) {
    return this._get(id, this.elements, "element");
  }
  getPlugin(id) {
    return this._get(id, this.plugins, "plugin");
  }
  getScale(id) {
    return this._get(id, this.scales, "scale");
  }
  removeControllers(...args) {
    this._each("unregister", args, this.controllers);
  }
  removeElements(...args) {
    this._each("unregister", args, this.elements);
  }
  removePlugins(...args) {
    this._each("unregister", args, this.plugins);
  }
  removeScales(...args) {
    this._each("unregister", args, this.scales);
  }
  _each(method, args, typedRegistry) {
    [
      ...args
    ].forEach((arg) => {
      const reg = typedRegistry || this._getRegistryForType(arg);
      if (typedRegistry || reg.isForType(arg) || reg === this.plugins && arg.id) {
        this._exec(method, reg, arg);
      } else {
        each(arg, (item) => {
          const itemReg = typedRegistry || this._getRegistryForType(item);
          this._exec(method, itemReg, item);
        });
      }
    });
  }
  _exec(method, registry2, component) {
    const camelMethod = _capitalize(method);
    callback(component["before" + camelMethod], [], component);
    registry2[method](component);
    callback(component["after" + camelMethod], [], component);
  }
  _getRegistryForType(type) {
    for (let i2 = 0; i2 < this._typedRegistries.length; i2++) {
      const reg = this._typedRegistries[i2];
      if (reg.isForType(type)) {
        return reg;
      }
    }
    return this.plugins;
  }
  _get(id, typedRegistry, type) {
    const item = typedRegistry.get(id);
    if (item === void 0) {
      throw new Error('"' + id + '" is not a registered ' + type + ".");
    }
    return item;
  }
};
__name(_Registry, "Registry");
let Registry = _Registry;
var registry = /* @__PURE__ */ new Registry();
const _PluginService = class _PluginService {
  constructor() {
    this._init = void 0;
  }
  notify(chart, hook, args, filter) {
    if (hook === "beforeInit") {
      this._init = this._createDescriptors(chart, true);
      this._notify(this._init, chart, "install");
    }
    if (this._init === void 0) {
      return;
    }
    const descriptors2 = filter ? this._descriptors(chart).filter(filter) : this._descriptors(chart);
    const result = this._notify(descriptors2, chart, hook, args);
    if (hook === "afterDestroy") {
      this._notify(descriptors2, chart, "stop");
      this._notify(this._init, chart, "uninstall");
      this._init = void 0;
    }
    return result;
  }
  _notify(descriptors2, chart, hook, args) {
    args = args || {};
    for (const descriptor of descriptors2) {
      const plugin = descriptor.plugin;
      const method = plugin[hook];
      const params = [
        chart,
        args,
        descriptor.options
      ];
      if (callback(method, params, plugin) === false && args.cancelable) {
        return false;
      }
    }
    return true;
  }
  invalidate() {
    if (!isNullOrUndef(this._cache)) {
      this._oldCache = this._cache;
      this._cache = void 0;
    }
  }
  _descriptors(chart) {
    if (this._cache) {
      return this._cache;
    }
    const descriptors2 = this._cache = this._createDescriptors(chart);
    this._notifyStateChanges(chart);
    return descriptors2;
  }
  _createDescriptors(chart, all) {
    const config = chart && chart.config;
    const options = valueOrDefault(config.options && config.options.plugins, {});
    const plugins = allPlugins(config);
    return options === false && !all ? [] : createDescriptors(chart, plugins, options, all);
  }
  _notifyStateChanges(chart) {
    const previousDescriptors = this._oldCache || [];
    const descriptors2 = this._cache;
    const diff = /* @__PURE__ */ __name((a2, b2) => a2.filter((x2) => !b2.some((y2) => x2.plugin.id === y2.plugin.id)), "diff");
    this._notify(diff(previousDescriptors, descriptors2), chart, "stop");
    this._notify(diff(descriptors2, previousDescriptors), chart, "start");
  }
};
__name(_PluginService, "PluginService");
let PluginService = _PluginService;
function allPlugins(config) {
  const localIds = {};
  const plugins = [];
  const keys2 = Object.keys(registry.plugins.items);
  for (let i2 = 0; i2 < keys2.length; i2++) {
    plugins.push(registry.getPlugin(keys2[i2]));
  }
  const local = config.plugins || [];
  for (let i2 = 0; i2 < local.length; i2++) {
    const plugin = local[i2];
    if (plugins.indexOf(plugin) === -1) {
      plugins.push(plugin);
      localIds[plugin.id] = true;
    }
  }
  return {
    plugins,
    localIds
  };
}
__name(allPlugins, "allPlugins");
function getOpts(options, all) {
  if (!all && options === false) {
    return null;
  }
  if (options === true) {
    return {};
  }
  return options;
}
__name(getOpts, "getOpts");
function createDescriptors(chart, { plugins, localIds }, options, all) {
  const result = [];
  const context = chart.getContext();
  for (const plugin of plugins) {
    const id = plugin.id;
    const opts = getOpts(options[id], all);
    if (opts === null) {
      continue;
    }
    result.push({
      plugin,
      options: pluginOpts(chart.config, {
        plugin,
        local: localIds[id]
      }, opts, context)
    });
  }
  return result;
}
__name(createDescriptors, "createDescriptors");
function pluginOpts(config, { plugin, local }, opts, context) {
  const keys2 = config.pluginScopeKeys(plugin);
  const scopes = config.getOptionScopes(opts, keys2);
  if (local && plugin.defaults) {
    scopes.push(plugin.defaults);
  }
  return config.createResolver(scopes, context, [
    ""
  ], {
    scriptable: false,
    indexable: false,
    allKeys: true
  });
}
__name(pluginOpts, "pluginOpts");
function getIndexAxis(type, options) {
  const datasetDefaults = defaults.datasets[type] || {};
  const datasetOptions = (options.datasets || {})[type] || {};
  return datasetOptions.indexAxis || options.indexAxis || datasetDefaults.indexAxis || "x";
}
__name(getIndexAxis, "getIndexAxis");
function getAxisFromDefaultScaleID(id, indexAxis) {
  let axis = id;
  if (id === "_index_") {
    axis = indexAxis;
  } else if (id === "_value_") {
    axis = indexAxis === "x" ? "y" : "x";
  }
  return axis;
}
__name(getAxisFromDefaultScaleID, "getAxisFromDefaultScaleID");
function getDefaultScaleIDFromAxis(axis, indexAxis) {
  return axis === indexAxis ? "_index_" : "_value_";
}
__name(getDefaultScaleIDFromAxis, "getDefaultScaleIDFromAxis");
function idMatchesAxis(id) {
  if (id === "x" || id === "y" || id === "r") {
    return id;
  }
}
__name(idMatchesAxis, "idMatchesAxis");
function axisFromPosition(position) {
  if (position === "top" || position === "bottom") {
    return "x";
  }
  if (position === "left" || position === "right") {
    return "y";
  }
}
__name(axisFromPosition, "axisFromPosition");
function determineAxis(id, ...scaleOptions) {
  if (idMatchesAxis(id)) {
    return id;
  }
  for (const opts of scaleOptions) {
    const axis = opts.axis || axisFromPosition(opts.position) || id.length > 1 && idMatchesAxis(id[0].toLowerCase());
    if (axis) {
      return axis;
    }
  }
  throw new Error(`Cannot determine type of '${id}' axis. Please provide 'axis' or 'position' option.`);
}
__name(determineAxis, "determineAxis");
function getAxisFromDataset(id, axis, dataset) {
  if (dataset[axis + "AxisID"] === id) {
    return {
      axis
    };
  }
}
__name(getAxisFromDataset, "getAxisFromDataset");
function retrieveAxisFromDatasets(id, config) {
  if (config.data && config.data.datasets) {
    const boundDs = config.data.datasets.filter((d2) => d2.xAxisID === id || d2.yAxisID === id);
    if (boundDs.length) {
      return getAxisFromDataset(id, "x", boundDs[0]) || getAxisFromDataset(id, "y", boundDs[0]);
    }
  }
  return {};
}
__name(retrieveAxisFromDatasets, "retrieveAxisFromDatasets");
function mergeScaleConfig(config, options) {
  const chartDefaults = overrides[config.type] || {
    scales: {}
  };
  const configScales = options.scales || {};
  const chartIndexAxis = getIndexAxis(config.type, options);
  const scales = /* @__PURE__ */ Object.create(null);
  Object.keys(configScales).forEach((id) => {
    const scaleConf = configScales[id];
    if (!isObject(scaleConf)) {
      return console.error(`Invalid scale configuration for scale: ${id}`);
    }
    if (scaleConf._proxy) {
      return console.warn(`Ignoring resolver passed as options for scale: ${id}`);
    }
    const axis = determineAxis(id, scaleConf, retrieveAxisFromDatasets(id, config), defaults.scales[scaleConf.type]);
    const defaultId = getDefaultScaleIDFromAxis(axis, chartIndexAxis);
    const defaultScaleOptions = chartDefaults.scales || {};
    scales[id] = mergeIf(/* @__PURE__ */ Object.create(null), [
      {
        axis
      },
      scaleConf,
      defaultScaleOptions[axis],
      defaultScaleOptions[defaultId]
    ]);
  });
  config.data.datasets.forEach((dataset) => {
    const type = dataset.type || config.type;
    const indexAxis = dataset.indexAxis || getIndexAxis(type, options);
    const datasetDefaults = overrides[type] || {};
    const defaultScaleOptions = datasetDefaults.scales || {};
    Object.keys(defaultScaleOptions).forEach((defaultID) => {
      const axis = getAxisFromDefaultScaleID(defaultID, indexAxis);
      const id = dataset[axis + "AxisID"] || axis;
      scales[id] = scales[id] || /* @__PURE__ */ Object.create(null);
      mergeIf(scales[id], [
        {
          axis
        },
        configScales[id],
        defaultScaleOptions[defaultID]
      ]);
    });
  });
  Object.keys(scales).forEach((key) => {
    const scale = scales[key];
    mergeIf(scale, [
      defaults.scales[scale.type],
      defaults.scale
    ]);
  });
  return scales;
}
__name(mergeScaleConfig, "mergeScaleConfig");
function initOptions(config) {
  const options = config.options || (config.options = {});
  options.plugins = valueOrDefault(options.plugins, {});
  options.scales = mergeScaleConfig(config, options);
}
__name(initOptions, "initOptions");
function initData(data) {
  data = data || {};
  data.datasets = data.datasets || [];
  data.labels = data.labels || [];
  return data;
}
__name(initData, "initData");
function initConfig(config) {
  config = config || {};
  config.data = initData(config.data);
  initOptions(config);
  return config;
}
__name(initConfig, "initConfig");
const keyCache = /* @__PURE__ */ new Map();
const keysCached = /* @__PURE__ */ new Set();
function cachedKeys(cacheKey, generate) {
  let keys2 = keyCache.get(cacheKey);
  if (!keys2) {
    keys2 = generate();
    keyCache.set(cacheKey, keys2);
    keysCached.add(keys2);
  }
  return keys2;
}
__name(cachedKeys, "cachedKeys");
const addIfFound = /* @__PURE__ */ __name((set2, obj, key) => {
  const opts = resolveObjectKey(obj, key);
  if (opts !== void 0) {
    set2.add(opts);
  }
}, "addIfFound");
const _Config = class _Config {
  constructor(config) {
    this._config = initConfig(config);
    this._scopeCache = /* @__PURE__ */ new Map();
    this._resolverCache = /* @__PURE__ */ new Map();
  }
  get platform() {
    return this._config.platform;
  }
  get type() {
    return this._config.type;
  }
  set type(type) {
    this._config.type = type;
  }
  get data() {
    return this._config.data;
  }
  set data(data) {
    this._config.data = initData(data);
  }
  get options() {
    return this._config.options;
  }
  set options(options) {
    this._config.options = options;
  }
  get plugins() {
    return this._config.plugins;
  }
  update() {
    const config = this._config;
    this.clearCache();
    initOptions(config);
  }
  clearCache() {
    this._scopeCache.clear();
    this._resolverCache.clear();
  }
  datasetScopeKeys(datasetType) {
    return cachedKeys(datasetType, () => [
      [
        `datasets.${datasetType}`,
        ""
      ]
    ]);
  }
  datasetAnimationScopeKeys(datasetType, transition) {
    return cachedKeys(`${datasetType}.transition.${transition}`, () => [
      [
        `datasets.${datasetType}.transitions.${transition}`,
        `transitions.${transition}`
      ],
      [
        `datasets.${datasetType}`,
        ""
      ]
    ]);
  }
  datasetElementScopeKeys(datasetType, elementType) {
    return cachedKeys(`${datasetType}-${elementType}`, () => [
      [
        `datasets.${datasetType}.elements.${elementType}`,
        `datasets.${datasetType}`,
        `elements.${elementType}`,
        ""
      ]
    ]);
  }
  pluginScopeKeys(plugin) {
    const id = plugin.id;
    const type = this.type;
    return cachedKeys(`${type}-plugin-${id}`, () => [
      [
        `plugins.${id}`,
        ...plugin.additionalOptionScopes || []
      ]
    ]);
  }
  _cachedScopes(mainScope, resetCache) {
    const _scopeCache = this._scopeCache;
    let cache = _scopeCache.get(mainScope);
    if (!cache || resetCache) {
      cache = /* @__PURE__ */ new Map();
      _scopeCache.set(mainScope, cache);
    }
    return cache;
  }
  getOptionScopes(mainScope, keyLists, resetCache) {
    const { options, type } = this;
    const cache = this._cachedScopes(mainScope, resetCache);
    const cached = cache.get(keyLists);
    if (cached) {
      return cached;
    }
    const scopes = /* @__PURE__ */ new Set();
    keyLists.forEach((keys2) => {
      if (mainScope) {
        scopes.add(mainScope);
        keys2.forEach((key) => addIfFound(scopes, mainScope, key));
      }
      keys2.forEach((key) => addIfFound(scopes, options, key));
      keys2.forEach((key) => addIfFound(scopes, overrides[type] || {}, key));
      keys2.forEach((key) => addIfFound(scopes, defaults, key));
      keys2.forEach((key) => addIfFound(scopes, descriptors, key));
    });
    const array = Array.from(scopes);
    if (array.length === 0) {
      array.push(/* @__PURE__ */ Object.create(null));
    }
    if (keysCached.has(keyLists)) {
      cache.set(keyLists, array);
    }
    return array;
  }
  chartOptionScopes() {
    const { options, type } = this;
    return [
      options,
      overrides[type] || {},
      defaults.datasets[type] || {},
      {
        type
      },
      defaults,
      descriptors
    ];
  }
  resolveNamedOptions(scopes, names2, context, prefixes = [
    ""
  ]) {
    const result = {
      $shared: true
    };
    const { resolver, subPrefixes } = getResolver(this._resolverCache, scopes, prefixes);
    let options = resolver;
    if (needContext(resolver, names2)) {
      result.$shared = false;
      context = isFunction(context) ? context() : context;
      const subResolver = this.createResolver(scopes, context, subPrefixes);
      options = _attachContext(resolver, context, subResolver);
    }
    for (const prop of names2) {
      result[prop] = options[prop];
    }
    return result;
  }
  createResolver(scopes, context, prefixes = [
    ""
  ], descriptorDefaults) {
    const { resolver } = getResolver(this._resolverCache, scopes, prefixes);
    return isObject(context) ? _attachContext(resolver, context, void 0, descriptorDefaults) : resolver;
  }
};
__name(_Config, "Config");
let Config = _Config;
function getResolver(resolverCache, scopes, prefixes) {
  let cache = resolverCache.get(scopes);
  if (!cache) {
    cache = /* @__PURE__ */ new Map();
    resolverCache.set(scopes, cache);
  }
  const cacheKey = prefixes.join();
  let cached = cache.get(cacheKey);
  if (!cached) {
    const resolver = _createResolver(scopes, prefixes);
    cached = {
      resolver,
      subPrefixes: prefixes.filter((p2) => !p2.toLowerCase().includes("hover"))
    };
    cache.set(cacheKey, cached);
  }
  return cached;
}
__name(getResolver, "getResolver");
const hasFunction = /* @__PURE__ */ __name((value) => isObject(value) && Object.getOwnPropertyNames(value).some((key) => isFunction(value[key])), "hasFunction");
function needContext(proxy, names2) {
  const { isScriptable, isIndexable } = _descriptors(proxy);
  for (const prop of names2) {
    const scriptable = isScriptable(prop);
    const indexable = isIndexable(prop);
    const value = (indexable || scriptable) && proxy[prop];
    if (scriptable && (isFunction(value) || hasFunction(value)) || indexable && isArray(value)) {
      return true;
    }
  }
  return false;
}
__name(needContext, "needContext");
var version = "4.5.1";
const KNOWN_POSITIONS = [
  "top",
  "bottom",
  "left",
  "right",
  "chartArea"
];
function positionIsHorizontal(position, axis) {
  return position === "top" || position === "bottom" || KNOWN_POSITIONS.indexOf(position) === -1 && axis === "x";
}
__name(positionIsHorizontal, "positionIsHorizontal");
function compare2Level(l1, l2) {
  return function(a2, b2) {
    return a2[l1] === b2[l1] ? a2[l2] - b2[l2] : a2[l1] - b2[l1];
  };
}
__name(compare2Level, "compare2Level");
function onAnimationsComplete(context) {
  const chart = context.chart;
  const animationOptions = chart.options.animation;
  chart.notifyPlugins("afterRender");
  callback(animationOptions && animationOptions.onComplete, [
    context
  ], chart);
}
__name(onAnimationsComplete, "onAnimationsComplete");
function onAnimationProgress(context) {
  const chart = context.chart;
  const animationOptions = chart.options.animation;
  callback(animationOptions && animationOptions.onProgress, [
    context
  ], chart);
}
__name(onAnimationProgress, "onAnimationProgress");
function getCanvas(item) {
  if (_isDomSupported() && typeof item === "string") {
    item = document.getElementById(item);
  } else if (item && item.length) {
    item = item[0];
  }
  if (item && item.canvas) {
    item = item.canvas;
  }
  return item;
}
__name(getCanvas, "getCanvas");
const instances = {};
const getChart = /* @__PURE__ */ __name((key) => {
  const canvas = getCanvas(key);
  return Object.values(instances).filter((c2) => c2.canvas === canvas).pop();
}, "getChart");
function moveNumericKeys(obj, start, move) {
  const keys2 = Object.keys(obj);
  for (const key of keys2) {
    const intKey = +key;
    if (intKey >= start) {
      const value = obj[key];
      delete obj[key];
      if (move > 0 || intKey > start) {
        obj[intKey + move] = value;
      }
    }
  }
}
__name(moveNumericKeys, "moveNumericKeys");
function determineLastEvent(e, lastEvent, inChartArea, isClick) {
  if (!inChartArea || e.type === "mouseout") {
    return null;
  }
  if (isClick) {
    return lastEvent;
  }
  return e;
}
__name(determineLastEvent, "determineLastEvent");
let Chart$1 = (_a2 = class {
  static register(...items) {
    registry.add(...items);
    invalidatePlugins();
  }
  static unregister(...items) {
    registry.remove(...items);
    invalidatePlugins();
  }
  constructor(item, userConfig) {
    const config = this.config = new Config(userConfig);
    const initialCanvas = getCanvas(item);
    const existingChart = getChart(initialCanvas);
    if (existingChart) {
      throw new Error("Canvas is already in use. Chart with ID '" + existingChart.id + "' must be destroyed before the canvas with ID '" + existingChart.canvas.id + "' can be reused.");
    }
    const options = config.createResolver(config.chartOptionScopes(), this.getContext());
    this.platform = new (config.platform || _detectPlatform(initialCanvas))();
    this.platform.updateConfig(config);
    const context = this.platform.acquireContext(initialCanvas, options.aspectRatio);
    const canvas = context && context.canvas;
    const height = canvas && canvas.height;
    const width = canvas && canvas.width;
    this.id = uid();
    this.ctx = context;
    this.canvas = canvas;
    this.width = width;
    this.height = height;
    this._options = options;
    this._aspectRatio = this.aspectRatio;
    this._layers = [];
    this._metasets = [];
    this._stacks = void 0;
    this.boxes = [];
    this.currentDevicePixelRatio = void 0;
    this.chartArea = void 0;
    this._active = [];
    this._lastEvent = void 0;
    this._listeners = {};
    this._responsiveListeners = void 0;
    this._sortedMetasets = [];
    this.scales = {};
    this._plugins = new PluginService();
    this.$proxies = {};
    this._hiddenIndices = {};
    this.attached = false;
    this._animationsDisabled = void 0;
    this.$context = void 0;
    this._doResize = debounce((mode) => this.update(mode), options.resizeDelay || 0);
    this._dataChanges = [];
    instances[this.id] = this;
    if (!context || !canvas) {
      console.error("Failed to create chart: can't acquire context from the given item");
      return;
    }
    animator.listen(this, "complete", onAnimationsComplete);
    animator.listen(this, "progress", onAnimationProgress);
    this._initialize();
    if (this.attached) {
      this.update();
    }
  }
  get aspectRatio() {
    const { options: { aspectRatio, maintainAspectRatio }, width, height, _aspectRatio } = this;
    if (!isNullOrUndef(aspectRatio)) {
      return aspectRatio;
    }
    if (maintainAspectRatio && _aspectRatio) {
      return _aspectRatio;
    }
    return height ? width / height : null;
  }
  get data() {
    return this.config.data;
  }
  set data(data) {
    this.config.data = data;
  }
  get options() {
    return this._options;
  }
  set options(options) {
    this.config.options = options;
  }
  get registry() {
    return registry;
  }
  _initialize() {
    this.notifyPlugins("beforeInit");
    if (this.options.responsive) {
      this.resize();
    } else {
      retinaScale(this, this.options.devicePixelRatio);
    }
    this.bindEvents();
    this.notifyPlugins("afterInit");
    return this;
  }
  clear() {
    clearCanvas(this.canvas, this.ctx);
    return this;
  }
  stop() {
    animator.stop(this);
    return this;
  }
  resize(width, height) {
    if (!animator.running(this)) {
      this._resize(width, height);
    } else {
      this._resizeBeforeDraw = {
        width,
        height
      };
    }
  }
  _resize(width, height) {
    const options = this.options;
    const canvas = this.canvas;
    const aspectRatio = options.maintainAspectRatio && this.aspectRatio;
    const newSize = this.platform.getMaximumSize(canvas, width, height, aspectRatio);
    const newRatio = options.devicePixelRatio || this.platform.getDevicePixelRatio();
    const mode = this.width ? "resize" : "attach";
    this.width = newSize.width;
    this.height = newSize.height;
    this._aspectRatio = this.aspectRatio;
    if (!retinaScale(this, newRatio, true)) {
      return;
    }
    this.notifyPlugins("resize", {
      size: newSize
    });
    callback(options.onResize, [
      this,
      newSize
    ], this);
    if (this.attached) {
      if (this._doResize(mode)) {
        this.render();
      }
    }
  }
  ensureScalesHaveIDs() {
    const options = this.options;
    const scalesOptions = options.scales || {};
    each(scalesOptions, (axisOptions, axisID) => {
      axisOptions.id = axisID;
    });
  }
  buildOrUpdateScales() {
    const options = this.options;
    const scaleOpts = options.scales;
    const scales = this.scales;
    const updated = Object.keys(scales).reduce((obj, id) => {
      obj[id] = false;
      return obj;
    }, {});
    let items = [];
    if (scaleOpts) {
      items = items.concat(Object.keys(scaleOpts).map((id) => {
        const scaleOptions = scaleOpts[id];
        const axis = determineAxis(id, scaleOptions);
        const isRadial = axis === "r";
        const isHorizontal = axis === "x";
        return {
          options: scaleOptions,
          dposition: isRadial ? "chartArea" : isHorizontal ? "bottom" : "left",
          dtype: isRadial ? "radialLinear" : isHorizontal ? "category" : "linear"
        };
      }));
    }
    each(items, (item) => {
      const scaleOptions = item.options;
      const id = scaleOptions.id;
      const axis = determineAxis(id, scaleOptions);
      const scaleType = valueOrDefault(scaleOptions.type, item.dtype);
      if (scaleOptions.position === void 0 || positionIsHorizontal(scaleOptions.position, axis) !== positionIsHorizontal(item.dposition)) {
        scaleOptions.position = item.dposition;
      }
      updated[id] = true;
      let scale = null;
      if (id in scales && scales[id].type === scaleType) {
        scale = scales[id];
      } else {
        const scaleClass = registry.getScale(scaleType);
        scale = new scaleClass({
          id,
          type: scaleType,
          ctx: this.ctx,
          chart: this
        });
        scales[scale.id] = scale;
      }
      scale.init(scaleOptions, options);
    });
    each(updated, (hasUpdated, id) => {
      if (!hasUpdated) {
        delete scales[id];
      }
    });
    each(scales, (scale) => {
      layouts.configure(this, scale, scale.options);
      layouts.addBox(this, scale);
    });
  }
  _updateMetasets() {
    const metasets = this._metasets;
    const numData = this.data.datasets.length;
    const numMeta = metasets.length;
    metasets.sort((a2, b2) => a2.index - b2.index);
    if (numMeta > numData) {
      for (let i2 = numData; i2 < numMeta; ++i2) {
        this._destroyDatasetMeta(i2);
      }
      metasets.splice(numData, numMeta - numData);
    }
    this._sortedMetasets = metasets.slice(0).sort(compare2Level("order", "index"));
  }
  _removeUnreferencedMetasets() {
    const { _metasets: metasets, data: { datasets } } = this;
    if (metasets.length > datasets.length) {
      delete this._stacks;
    }
    metasets.forEach((meta, index2) => {
      if (datasets.filter((x2) => x2 === meta._dataset).length === 0) {
        this._destroyDatasetMeta(index2);
      }
    });
  }
  buildOrUpdateControllers() {
    const newControllers = [];
    const datasets = this.data.datasets;
    let i2, ilen;
    this._removeUnreferencedMetasets();
    for (i2 = 0, ilen = datasets.length; i2 < ilen; i2++) {
      const dataset = datasets[i2];
      let meta = this.getDatasetMeta(i2);
      const type = dataset.type || this.config.type;
      if (meta.type && meta.type !== type) {
        this._destroyDatasetMeta(i2);
        meta = this.getDatasetMeta(i2);
      }
      meta.type = type;
      meta.indexAxis = dataset.indexAxis || getIndexAxis(type, this.options);
      meta.order = dataset.order || 0;
      meta.index = i2;
      meta.label = "" + dataset.label;
      meta.visible = this.isDatasetVisible(i2);
      if (meta.controller) {
        meta.controller.updateIndex(i2);
        meta.controller.linkScales();
      } else {
        const ControllerClass = registry.getController(type);
        const { datasetElementType, dataElementType } = defaults.datasets[type];
        Object.assign(ControllerClass, {
          dataElementType: registry.getElement(dataElementType),
          datasetElementType: datasetElementType && registry.getElement(datasetElementType)
        });
        meta.controller = new ControllerClass(this, i2);
        newControllers.push(meta.controller);
      }
    }
    this._updateMetasets();
    return newControllers;
  }
  _resetElements() {
    each(this.data.datasets, (dataset, datasetIndex) => {
      this.getDatasetMeta(datasetIndex).controller.reset();
    }, this);
  }
  reset() {
    this._resetElements();
    this.notifyPlugins("reset");
  }
  update(mode) {
    const config = this.config;
    config.update();
    const options = this._options = config.createResolver(config.chartOptionScopes(), this.getContext());
    const animsDisabled = this._animationsDisabled = !options.animation;
    this._updateScales();
    this._checkEventBindings();
    this._updateHiddenIndices();
    this._plugins.invalidate();
    if (this.notifyPlugins("beforeUpdate", {
      mode,
      cancelable: true
    }) === false) {
      return;
    }
    const newControllers = this.buildOrUpdateControllers();
    this.notifyPlugins("beforeElementsUpdate");
    let minPadding = 0;
    for (let i2 = 0, ilen = this.data.datasets.length; i2 < ilen; i2++) {
      const { controller } = this.getDatasetMeta(i2);
      const reset = !animsDisabled && newControllers.indexOf(controller) === -1;
      controller.buildOrUpdateElements(reset);
      minPadding = Math.max(+controller.getMaxOverflow(), minPadding);
    }
    minPadding = this._minPadding = options.layout.autoPadding ? minPadding : 0;
    this._updateLayout(minPadding);
    if (!animsDisabled) {
      each(newControllers, (controller) => {
        controller.reset();
      });
    }
    this._updateDatasets(mode);
    this.notifyPlugins("afterUpdate", {
      mode
    });
    this._layers.sort(compare2Level("z", "_idx"));
    const { _active, _lastEvent } = this;
    if (_lastEvent) {
      this._eventHandler(_lastEvent, true);
    } else if (_active.length) {
      this._updateHoverStyles(_active, _active, true);
    }
    this.render();
  }
  _updateScales() {
    each(this.scales, (scale) => {
      layouts.removeBox(this, scale);
    });
    this.ensureScalesHaveIDs();
    this.buildOrUpdateScales();
  }
  _checkEventBindings() {
    const options = this.options;
    const existingEvents = new Set(Object.keys(this._listeners));
    const newEvents = new Set(options.events);
    if (!setsEqual(existingEvents, newEvents) || !!this._responsiveListeners !== options.responsive) {
      this.unbindEvents();
      this.bindEvents();
    }
  }
  _updateHiddenIndices() {
    const { _hiddenIndices } = this;
    const changes = this._getUniformDataChanges() || [];
    for (const { method, start, count } of changes) {
      const move = method === "_removeElements" ? -count : count;
      moveNumericKeys(_hiddenIndices, start, move);
    }
  }
  _getUniformDataChanges() {
    const _dataChanges = this._dataChanges;
    if (!_dataChanges || !_dataChanges.length) {
      return;
    }
    this._dataChanges = [];
    const datasetCount = this.data.datasets.length;
    const makeSet = /* @__PURE__ */ __name((idx) => new Set(_dataChanges.filter((c2) => c2[0] === idx).map((c2, i2) => i2 + "," + c2.splice(1).join(","))), "makeSet");
    const changeSet = makeSet(0);
    for (let i2 = 1; i2 < datasetCount; i2++) {
      if (!setsEqual(changeSet, makeSet(i2))) {
        return;
      }
    }
    return Array.from(changeSet).map((c2) => c2.split(",")).map((a2) => ({
      method: a2[1],
      start: +a2[2],
      count: +a2[3]
    }));
  }
  _updateLayout(minPadding) {
    if (this.notifyPlugins("beforeLayout", {
      cancelable: true
    }) === false) {
      return;
    }
    layouts.update(this, this.width, this.height, minPadding);
    const area = this.chartArea;
    const noArea = area.width <= 0 || area.height <= 0;
    this._layers = [];
    each(this.boxes, (box) => {
      if (noArea && box.position === "chartArea") {
        return;
      }
      if (box.configure) {
        box.configure();
      }
      this._layers.push(...box._layers());
    }, this);
    this._layers.forEach((item, index2) => {
      item._idx = index2;
    });
    this.notifyPlugins("afterLayout");
  }
  _updateDatasets(mode) {
    if (this.notifyPlugins("beforeDatasetsUpdate", {
      mode,
      cancelable: true
    }) === false) {
      return;
    }
    for (let i2 = 0, ilen = this.data.datasets.length; i2 < ilen; ++i2) {
      this.getDatasetMeta(i2).controller.configure();
    }
    for (let i2 = 0, ilen = this.data.datasets.length; i2 < ilen; ++i2) {
      this._updateDataset(i2, isFunction(mode) ? mode({
        datasetIndex: i2
      }) : mode);
    }
    this.notifyPlugins("afterDatasetsUpdate", {
      mode
    });
  }
  _updateDataset(index2, mode) {
    const meta = this.getDatasetMeta(index2);
    const args = {
      meta,
      index: index2,
      mode,
      cancelable: true
    };
    if (this.notifyPlugins("beforeDatasetUpdate", args) === false) {
      return;
    }
    meta.controller._update(mode);
    args.cancelable = false;
    this.notifyPlugins("afterDatasetUpdate", args);
  }
  render() {
    if (this.notifyPlugins("beforeRender", {
      cancelable: true
    }) === false) {
      return;
    }
    if (animator.has(this)) {
      if (this.attached && !animator.running(this)) {
        animator.start(this);
      }
    } else {
      this.draw();
      onAnimationsComplete({
        chart: this
      });
    }
  }
  draw() {
    let i2;
    if (this._resizeBeforeDraw) {
      const { width, height } = this._resizeBeforeDraw;
      this._resizeBeforeDraw = null;
      this._resize(width, height);
    }
    this.clear();
    if (this.width <= 0 || this.height <= 0) {
      return;
    }
    if (this.notifyPlugins("beforeDraw", {
      cancelable: true
    }) === false) {
      return;
    }
    const layers = this._layers;
    for (i2 = 0; i2 < layers.length && layers[i2].z <= 0; ++i2) {
      layers[i2].draw(this.chartArea);
    }
    this._drawDatasets();
    for (; i2 < layers.length; ++i2) {
      layers[i2].draw(this.chartArea);
    }
    this.notifyPlugins("afterDraw");
  }
  _getSortedDatasetMetas(filterVisible) {
    const metasets = this._sortedMetasets;
    const result = [];
    let i2, ilen;
    for (i2 = 0, ilen = metasets.length; i2 < ilen; ++i2) {
      const meta = metasets[i2];
      if (!filterVisible || meta.visible) {
        result.push(meta);
      }
    }
    return result;
  }
  getSortedVisibleDatasetMetas() {
    return this._getSortedDatasetMetas(true);
  }
  _drawDatasets() {
    if (this.notifyPlugins("beforeDatasetsDraw", {
      cancelable: true
    }) === false) {
      return;
    }
    const metasets = this.getSortedVisibleDatasetMetas();
    for (let i2 = metasets.length - 1; i2 >= 0; --i2) {
      this._drawDataset(metasets[i2]);
    }
    this.notifyPlugins("afterDatasetsDraw");
  }
  _drawDataset(meta) {
    const ctx = this.ctx;
    const args = {
      meta,
      index: meta.index,
      cancelable: true
    };
    const clip = getDatasetClipArea(this, meta);
    if (this.notifyPlugins("beforeDatasetDraw", args) === false) {
      return;
    }
    if (clip) {
      clipArea(ctx, clip);
    }
    meta.controller.draw();
    if (clip) {
      unclipArea(ctx);
    }
    args.cancelable = false;
    this.notifyPlugins("afterDatasetDraw", args);
  }
  isPointInArea(point) {
    return _isPointInArea(point, this.chartArea, this._minPadding);
  }
  getElementsAtEventForMode(e, mode, options, useFinalPosition) {
    const method = Interaction.modes[mode];
    if (typeof method === "function") {
      return method(this, e, options, useFinalPosition);
    }
    return [];
  }
  getDatasetMeta(datasetIndex) {
    const dataset = this.data.datasets[datasetIndex];
    const metasets = this._metasets;
    let meta = metasets.filter((x2) => x2 && x2._dataset === dataset).pop();
    if (!meta) {
      meta = {
        type: null,
        data: [],
        dataset: null,
        controller: null,
        hidden: null,
        xAxisID: null,
        yAxisID: null,
        order: dataset && dataset.order || 0,
        index: datasetIndex,
        _dataset: dataset,
        _parsed: [],
        _sorted: false
      };
      metasets.push(meta);
    }
    return meta;
  }
  getContext() {
    return this.$context || (this.$context = createContext(null, {
      chart: this,
      type: "chart"
    }));
  }
  getVisibleDatasetCount() {
    return this.getSortedVisibleDatasetMetas().length;
  }
  isDatasetVisible(datasetIndex) {
    const dataset = this.data.datasets[datasetIndex];
    if (!dataset) {
      return false;
    }
    const meta = this.getDatasetMeta(datasetIndex);
    return typeof meta.hidden === "boolean" ? !meta.hidden : !dataset.hidden;
  }
  setDatasetVisibility(datasetIndex, visible) {
    const meta = this.getDatasetMeta(datasetIndex);
    meta.hidden = !visible;
  }
  toggleDataVisibility(index2) {
    this._hiddenIndices[index2] = !this._hiddenIndices[index2];
  }
  getDataVisibility(index2) {
    return !this._hiddenIndices[index2];
  }
  _updateVisibility(datasetIndex, dataIndex, visible) {
    const mode = visible ? "show" : "hide";
    const meta = this.getDatasetMeta(datasetIndex);
    const anims = meta.controller._resolveAnimations(void 0, mode);
    if (defined(dataIndex)) {
      meta.data[dataIndex].hidden = !visible;
      this.update();
    } else {
      this.setDatasetVisibility(datasetIndex, visible);
      anims.update(meta, {
        visible
      });
      this.update((ctx) => ctx.datasetIndex === datasetIndex ? mode : void 0);
    }
  }
  hide(datasetIndex, dataIndex) {
    this._updateVisibility(datasetIndex, dataIndex, false);
  }
  show(datasetIndex, dataIndex) {
    this._updateVisibility(datasetIndex, dataIndex, true);
  }
  _destroyDatasetMeta(datasetIndex) {
    const meta = this._metasets[datasetIndex];
    if (meta && meta.controller) {
      meta.controller._destroy();
    }
    delete this._metasets[datasetIndex];
  }
  _stop() {
    let i2, ilen;
    this.stop();
    animator.remove(this);
    for (i2 = 0, ilen = this.data.datasets.length; i2 < ilen; ++i2) {
      this._destroyDatasetMeta(i2);
    }
  }
  destroy() {
    this.notifyPlugins("beforeDestroy");
    const { canvas, ctx } = this;
    this._stop();
    this.config.clearCache();
    if (canvas) {
      this.unbindEvents();
      clearCanvas(canvas, ctx);
      this.platform.releaseContext(ctx);
      this.canvas = null;
      this.ctx = null;
    }
    delete instances[this.id];
    this.notifyPlugins("afterDestroy");
  }
  toBase64Image(...args) {
    return this.canvas.toDataURL(...args);
  }
  bindEvents() {
    this.bindUserEvents();
    if (this.options.responsive) {
      this.bindResponsiveEvents();
    } else {
      this.attached = true;
    }
  }
  bindUserEvents() {
    const listeners = this._listeners;
    const platform = this.platform;
    const _add = /* @__PURE__ */ __name((type, listener2) => {
      platform.addEventListener(this, type, listener2);
      listeners[type] = listener2;
    }, "_add");
    const listener = /* @__PURE__ */ __name((e, x2, y2) => {
      e.offsetX = x2;
      e.offsetY = y2;
      this._eventHandler(e);
    }, "listener");
    each(this.options.events, (type) => _add(type, listener));
  }
  bindResponsiveEvents() {
    if (!this._responsiveListeners) {
      this._responsiveListeners = {};
    }
    const listeners = this._responsiveListeners;
    const platform = this.platform;
    const _add = /* @__PURE__ */ __name((type, listener2) => {
      platform.addEventListener(this, type, listener2);
      listeners[type] = listener2;
    }, "_add");
    const _remove = /* @__PURE__ */ __name((type, listener2) => {
      if (listeners[type]) {
        platform.removeEventListener(this, type, listener2);
        delete listeners[type];
      }
    }, "_remove");
    const listener = /* @__PURE__ */ __name((width, height) => {
      if (this.canvas) {
        this.resize(width, height);
      }
    }, "listener");
    let detached;
    const attached = /* @__PURE__ */ __name(() => {
      _remove("attach", attached);
      this.attached = true;
      this.resize();
      _add("resize", listener);
      _add("detach", detached);
    }, "attached");
    detached = /* @__PURE__ */ __name(() => {
      this.attached = false;
      _remove("resize", listener);
      this._stop();
      this._resize(0, 0);
      _add("attach", attached);
    }, "detached");
    if (platform.isAttached(this.canvas)) {
      attached();
    } else {
      detached();
    }
  }
  unbindEvents() {
    each(this._listeners, (listener, type) => {
      this.platform.removeEventListener(this, type, listener);
    });
    this._listeners = {};
    each(this._responsiveListeners, (listener, type) => {
      this.platform.removeEventListener(this, type, listener);
    });
    this._responsiveListeners = void 0;
  }
  updateHoverStyle(items, mode, enabled) {
    const prefix = enabled ? "set" : "remove";
    let meta, item, i2, ilen;
    if (mode === "dataset") {
      meta = this.getDatasetMeta(items[0].datasetIndex);
      meta.controller["_" + prefix + "DatasetHoverStyle"]();
    }
    for (i2 = 0, ilen = items.length; i2 < ilen; ++i2) {
      item = items[i2];
      const controller = item && this.getDatasetMeta(item.datasetIndex).controller;
      if (controller) {
        controller[prefix + "HoverStyle"](item.element, item.datasetIndex, item.index);
      }
    }
  }
  getActiveElements() {
    return this._active || [];
  }
  setActiveElements(activeElements) {
    const lastActive = this._active || [];
    const active = activeElements.map(({ datasetIndex, index: index2 }) => {
      const meta = this.getDatasetMeta(datasetIndex);
      if (!meta) {
        throw new Error("No dataset found at index " + datasetIndex);
      }
      return {
        datasetIndex,
        element: meta.data[index2],
        index: index2
      };
    });
    const changed = !_elementsEqual(active, lastActive);
    if (changed) {
      this._active = active;
      this._lastEvent = null;
      this._updateHoverStyles(active, lastActive);
    }
  }
  notifyPlugins(hook, args, filter) {
    return this._plugins.notify(this, hook, args, filter);
  }
  isPluginEnabled(pluginId) {
    return this._plugins._cache.filter((p2) => p2.plugin.id === pluginId).length === 1;
  }
  _updateHoverStyles(active, lastActive, replay) {
    const hoverOptions = this.options.hover;
    const diff = /* @__PURE__ */ __name((a2, b2) => a2.filter((x2) => !b2.some((y2) => x2.datasetIndex === y2.datasetIndex && x2.index === y2.index)), "diff");
    const deactivated = diff(lastActive, active);
    const activated = replay ? active : diff(active, lastActive);
    if (deactivated.length) {
      this.updateHoverStyle(deactivated, hoverOptions.mode, false);
    }
    if (activated.length && hoverOptions.mode) {
      this.updateHoverStyle(activated, hoverOptions.mode, true);
    }
  }
  _eventHandler(e, replay) {
    const args = {
      event: e,
      replay,
      cancelable: true,
      inChartArea: this.isPointInArea(e)
    };
    const eventFilter = /* @__PURE__ */ __name((plugin) => (plugin.options.events || this.options.events).includes(e.native.type), "eventFilter");
    if (this.notifyPlugins("beforeEvent", args, eventFilter) === false) {
      return;
    }
    const changed = this._handleEvent(e, replay, args.inChartArea);
    args.cancelable = false;
    this.notifyPlugins("afterEvent", args, eventFilter);
    if (changed || args.changed) {
      this.render();
    }
    return this;
  }
  _handleEvent(e, replay, inChartArea) {
    const { _active: lastActive = [], options } = this;
    const useFinalPosition = replay;
    const active = this._getActiveElements(e, lastActive, inChartArea, useFinalPosition);
    const isClick = _isClickEvent(e);
    const lastEvent = determineLastEvent(e, this._lastEvent, inChartArea, isClick);
    if (inChartArea) {
      this._lastEvent = null;
      callback(options.onHover, [
        e,
        active,
        this
      ], this);
      if (isClick) {
        callback(options.onClick, [
          e,
          active,
          this
        ], this);
      }
    }
    const changed = !_elementsEqual(active, lastActive);
    if (changed || replay) {
      this._active = active;
      this._updateHoverStyles(active, lastActive, replay);
    }
    this._lastEvent = lastEvent;
    return changed;
  }
  _getActiveElements(e, lastActive, inChartArea, useFinalPosition) {
    if (e.type === "mouseout") {
      return [];
    }
    if (!inChartArea) {
      return lastActive;
    }
    const hoverOptions = this.options.hover;
    return this.getElementsAtEventForMode(e, hoverOptions.mode, hoverOptions, useFinalPosition);
  }
}, __name(_a2, "Chart"), __publicField(_a2, "defaults", defaults), __publicField(_a2, "instances", instances), __publicField(_a2, "overrides", overrides), __publicField(_a2, "registry", registry), __publicField(_a2, "version", version), __publicField(_a2, "getChart", getChart), _a2);
function invalidatePlugins() {
  return each(Chart$1.instances, (chart) => chart._plugins.invalidate());
}
__name(invalidatePlugins, "invalidatePlugins");
function clipSelf(ctx, element, endAngle) {
  const { startAngle, x: x2, y: y2, outerRadius, innerRadius, options } = element;
  const { borderWidth, borderJoinStyle } = options;
  const outerAngleClip = Math.min(borderWidth / outerRadius, _normalizeAngle(startAngle - endAngle));
  ctx.beginPath();
  ctx.arc(x2, y2, outerRadius - borderWidth / 2, startAngle + outerAngleClip / 2, endAngle - outerAngleClip / 2);
  if (innerRadius > 0) {
    const innerAngleClip = Math.min(borderWidth / innerRadius, _normalizeAngle(startAngle - endAngle));
    ctx.arc(x2, y2, innerRadius + borderWidth / 2, endAngle - innerAngleClip / 2, startAngle + innerAngleClip / 2, true);
  } else {
    const clipWidth = Math.min(borderWidth / 2, outerRadius * _normalizeAngle(startAngle - endAngle));
    if (borderJoinStyle === "round") {
      ctx.arc(x2, y2, clipWidth, endAngle - PI / 2, startAngle + PI / 2, true);
    } else if (borderJoinStyle === "bevel") {
      const r = 2 * clipWidth * clipWidth;
      const endX = -r * Math.cos(endAngle + PI / 2) + x2;
      const endY = -r * Math.sin(endAngle + PI / 2) + y2;
      const startX = r * Math.cos(startAngle + PI / 2) + x2;
      const startY = r * Math.sin(startAngle + PI / 2) + y2;
      ctx.lineTo(endX, endY);
      ctx.lineTo(startX, startY);
    }
  }
  ctx.closePath();
  ctx.moveTo(0, 0);
  ctx.rect(0, 0, ctx.canvas.width, ctx.canvas.height);
  ctx.clip("evenodd");
}
__name(clipSelf, "clipSelf");
function clipArc(ctx, element, endAngle) {
  const { startAngle, pixelMargin, x: x2, y: y2, outerRadius, innerRadius } = element;
  let angleMargin = pixelMargin / outerRadius;
  ctx.beginPath();
  ctx.arc(x2, y2, outerRadius, startAngle - angleMargin, endAngle + angleMargin);
  if (innerRadius > pixelMargin) {
    angleMargin = pixelMargin / innerRadius;
    ctx.arc(x2, y2, innerRadius, endAngle + angleMargin, startAngle - angleMargin, true);
  } else {
    ctx.arc(x2, y2, pixelMargin, endAngle + HALF_PI, startAngle - HALF_PI);
  }
  ctx.closePath();
  ctx.clip();
}
__name(clipArc, "clipArc");
function toRadiusCorners(value) {
  return _readValueToProps(value, [
    "outerStart",
    "outerEnd",
    "innerStart",
    "innerEnd"
  ]);
}
__name(toRadiusCorners, "toRadiusCorners");
function parseBorderRadius$1(arc, innerRadius, outerRadius, angleDelta) {
  const o2 = toRadiusCorners(arc.options.borderRadius);
  const halfThickness = (outerRadius - innerRadius) / 2;
  const innerLimit = Math.min(halfThickness, angleDelta * innerRadius / 2);
  const computeOuterLimit = /* @__PURE__ */ __name((val) => {
    const outerArcLimit = (outerRadius - Math.min(halfThickness, val)) * angleDelta / 2;
    return _limitValue(val, 0, Math.min(halfThickness, outerArcLimit));
  }, "computeOuterLimit");
  return {
    outerStart: computeOuterLimit(o2.outerStart),
    outerEnd: computeOuterLimit(o2.outerEnd),
    innerStart: _limitValue(o2.innerStart, 0, innerLimit),
    innerEnd: _limitValue(o2.innerEnd, 0, innerLimit)
  };
}
__name(parseBorderRadius$1, "parseBorderRadius$1");
function rThetaToXY(r, theta, x2, y2) {
  return {
    x: x2 + r * Math.cos(theta),
    y: y2 + r * Math.sin(theta)
  };
}
__name(rThetaToXY, "rThetaToXY");
function pathArc(ctx, element, offset, spacing, end, circular) {
  const { x: x2, y: y2, startAngle: start, pixelMargin, innerRadius: innerR } = element;
  const outerRadius = Math.max(element.outerRadius + spacing + offset - pixelMargin, 0);
  const innerRadius = innerR > 0 ? innerR + spacing + offset + pixelMargin : 0;
  let spacingOffset = 0;
  const alpha2 = end - start;
  if (spacing) {
    const noSpacingInnerRadius = innerR > 0 ? innerR - spacing : 0;
    const noSpacingOuterRadius = outerRadius > 0 ? outerRadius - spacing : 0;
    const avNogSpacingRadius = (noSpacingInnerRadius + noSpacingOuterRadius) / 2;
    const adjustedAngle = avNogSpacingRadius !== 0 ? alpha2 * avNogSpacingRadius / (avNogSpacingRadius + spacing) : alpha2;
    spacingOffset = (alpha2 - adjustedAngle) / 2;
  }
  const beta = Math.max(1e-3, alpha2 * outerRadius - offset / PI) / outerRadius;
  const angleOffset = (alpha2 - beta) / 2;
  const startAngle = start + angleOffset + spacingOffset;
  const endAngle = end - angleOffset - spacingOffset;
  const { outerStart, outerEnd, innerStart, innerEnd } = parseBorderRadius$1(element, innerRadius, outerRadius, endAngle - startAngle);
  const outerStartAdjustedRadius = outerRadius - outerStart;
  const outerEndAdjustedRadius = outerRadius - outerEnd;
  const outerStartAdjustedAngle = startAngle + outerStart / outerStartAdjustedRadius;
  const outerEndAdjustedAngle = endAngle - outerEnd / outerEndAdjustedRadius;
  const innerStartAdjustedRadius = innerRadius + innerStart;
  const innerEndAdjustedRadius = innerRadius + innerEnd;
  const innerStartAdjustedAngle = startAngle + innerStart / innerStartAdjustedRadius;
  const innerEndAdjustedAngle = endAngle - innerEnd / innerEndAdjustedRadius;
  ctx.beginPath();
  if (circular) {
    const outerMidAdjustedAngle = (outerStartAdjustedAngle + outerEndAdjustedAngle) / 2;
    ctx.arc(x2, y2, outerRadius, outerStartAdjustedAngle, outerMidAdjustedAngle);
    ctx.arc(x2, y2, outerRadius, outerMidAdjustedAngle, outerEndAdjustedAngle);
    if (outerEnd > 0) {
      const pCenter = rThetaToXY(outerEndAdjustedRadius, outerEndAdjustedAngle, x2, y2);
      ctx.arc(pCenter.x, pCenter.y, outerEnd, outerEndAdjustedAngle, endAngle + HALF_PI);
    }
    const p4 = rThetaToXY(innerEndAdjustedRadius, endAngle, x2, y2);
    ctx.lineTo(p4.x, p4.y);
    if (innerEnd > 0) {
      const pCenter = rThetaToXY(innerEndAdjustedRadius, innerEndAdjustedAngle, x2, y2);
      ctx.arc(pCenter.x, pCenter.y, innerEnd, endAngle + HALF_PI, innerEndAdjustedAngle + Math.PI);
    }
    const innerMidAdjustedAngle = (endAngle - innerEnd / innerRadius + (startAngle + innerStart / innerRadius)) / 2;
    ctx.arc(x2, y2, innerRadius, endAngle - innerEnd / innerRadius, innerMidAdjustedAngle, true);
    ctx.arc(x2, y2, innerRadius, innerMidAdjustedAngle, startAngle + innerStart / innerRadius, true);
    if (innerStart > 0) {
      const pCenter = rThetaToXY(innerStartAdjustedRadius, innerStartAdjustedAngle, x2, y2);
      ctx.arc(pCenter.x, pCenter.y, innerStart, innerStartAdjustedAngle + Math.PI, startAngle - HALF_PI);
    }
    const p8 = rThetaToXY(outerStartAdjustedRadius, startAngle, x2, y2);
    ctx.lineTo(p8.x, p8.y);
    if (outerStart > 0) {
      const pCenter = rThetaToXY(outerStartAdjustedRadius, outerStartAdjustedAngle, x2, y2);
      ctx.arc(pCenter.x, pCenter.y, outerStart, startAngle - HALF_PI, outerStartAdjustedAngle);
    }
  } else {
    ctx.moveTo(x2, y2);
    const outerStartX = Math.cos(outerStartAdjustedAngle) * outerRadius + x2;
    const outerStartY = Math.sin(outerStartAdjustedAngle) * outerRadius + y2;
    ctx.lineTo(outerStartX, outerStartY);
    const outerEndX = Math.cos(outerEndAdjustedAngle) * outerRadius + x2;
    const outerEndY = Math.sin(outerEndAdjustedAngle) * outerRadius + y2;
    ctx.lineTo(outerEndX, outerEndY);
  }
  ctx.closePath();
}
__name(pathArc, "pathArc");
function drawArc(ctx, element, offset, spacing, circular) {
  const { fullCircles, startAngle, circumference } = element;
  let endAngle = element.endAngle;
  if (fullCircles) {
    pathArc(ctx, element, offset, spacing, endAngle, circular);
    for (let i2 = 0; i2 < fullCircles; ++i2) {
      ctx.fill();
    }
    if (!isNaN(circumference)) {
      endAngle = startAngle + (circumference % TAU || TAU);
    }
  }
  pathArc(ctx, element, offset, spacing, endAngle, circular);
  ctx.fill();
  return endAngle;
}
__name(drawArc, "drawArc");
function drawBorder(ctx, element, offset, spacing, circular) {
  const { fullCircles, startAngle, circumference, options } = element;
  const { borderWidth, borderJoinStyle, borderDash, borderDashOffset, borderRadius } = options;
  const inner = options.borderAlign === "inner";
  if (!borderWidth) {
    return;
  }
  ctx.setLineDash(borderDash || []);
  ctx.lineDashOffset = borderDashOffset;
  if (inner) {
    ctx.lineWidth = borderWidth * 2;
    ctx.lineJoin = borderJoinStyle || "round";
  } else {
    ctx.lineWidth = borderWidth;
    ctx.lineJoin = borderJoinStyle || "bevel";
  }
  let endAngle = element.endAngle;
  if (fullCircles) {
    pathArc(ctx, element, offset, spacing, endAngle, circular);
    for (let i2 = 0; i2 < fullCircles; ++i2) {
      ctx.stroke();
    }
    if (!isNaN(circumference)) {
      endAngle = startAngle + (circumference % TAU || TAU);
    }
  }
  if (inner) {
    clipArc(ctx, element, endAngle);
  }
  if (options.selfJoin && endAngle - startAngle >= PI && borderRadius === 0 && borderJoinStyle !== "miter") {
    clipSelf(ctx, element, endAngle);
  }
  if (!fullCircles) {
    pathArc(ctx, element, offset, spacing, endAngle, circular);
    ctx.stroke();
  }
}
__name(drawBorder, "drawBorder");
const _ArcElement = class _ArcElement extends Element {
  constructor(cfg) {
    super();
    __publicField(this, "circumference");
    __publicField(this, "endAngle");
    __publicField(this, "fullCircles");
    __publicField(this, "innerRadius");
    __publicField(this, "outerRadius");
    __publicField(this, "pixelMargin");
    __publicField(this, "startAngle");
    this.options = void 0;
    this.circumference = void 0;
    this.startAngle = void 0;
    this.endAngle = void 0;
    this.innerRadius = void 0;
    this.outerRadius = void 0;
    this.pixelMargin = 0;
    this.fullCircles = 0;
    if (cfg) {
      Object.assign(this, cfg);
    }
  }
  inRange(chartX, chartY, useFinalPosition) {
    const point = this.getProps([
      "x",
      "y"
    ], useFinalPosition);
    const { angle, distance } = getAngleFromPoint(point, {
      x: chartX,
      y: chartY
    });
    const { startAngle, endAngle, innerRadius, outerRadius, circumference } = this.getProps([
      "startAngle",
      "endAngle",
      "innerRadius",
      "outerRadius",
      "circumference"
    ], useFinalPosition);
    const rAdjust = (this.options.spacing + this.options.borderWidth) / 2;
    const _circumference = valueOrDefault(circumference, endAngle - startAngle);
    const nonZeroBetween = _angleBetween(angle, startAngle, endAngle) && startAngle !== endAngle;
    const betweenAngles = _circumference >= TAU || nonZeroBetween;
    const withinRadius = _isBetween(distance, innerRadius + rAdjust, outerRadius + rAdjust);
    return betweenAngles && withinRadius;
  }
  getCenterPoint(useFinalPosition) {
    const { x: x2, y: y2, startAngle, endAngle, innerRadius, outerRadius } = this.getProps([
      "x",
      "y",
      "startAngle",
      "endAngle",
      "innerRadius",
      "outerRadius"
    ], useFinalPosition);
    const { offset, spacing } = this.options;
    const halfAngle = (startAngle + endAngle) / 2;
    const halfRadius = (innerRadius + outerRadius + spacing + offset) / 2;
    return {
      x: x2 + Math.cos(halfAngle) * halfRadius,
      y: y2 + Math.sin(halfAngle) * halfRadius
    };
  }
  tooltipPosition(useFinalPosition) {
    return this.getCenterPoint(useFinalPosition);
  }
  draw(ctx) {
    const { options, circumference } = this;
    const offset = (options.offset || 0) / 4;
    const spacing = (options.spacing || 0) / 2;
    const circular = options.circular;
    this.pixelMargin = options.borderAlign === "inner" ? 0.33 : 0;
    this.fullCircles = circumference > TAU ? Math.floor(circumference / TAU) : 0;
    if (circumference === 0 || this.innerRadius < 0 || this.outerRadius < 0) {
      return;
    }
    ctx.save();
    const halfAngle = (this.startAngle + this.endAngle) / 2;
    ctx.translate(Math.cos(halfAngle) * offset, Math.sin(halfAngle) * offset);
    const fix = 1 - Math.sin(Math.min(PI, circumference || 0));
    const radiusOffset = offset * fix;
    ctx.fillStyle = options.backgroundColor;
    ctx.strokeStyle = options.borderColor;
    drawArc(ctx, this, radiusOffset, spacing, circular);
    drawBorder(ctx, this, radiusOffset, spacing, circular);
    ctx.restore();
  }
};
__name(_ArcElement, "ArcElement");
__publicField(_ArcElement, "id", "arc");
__publicField(_ArcElement, "defaults", {
  borderAlign: "center",
  borderColor: "#fff",
  borderDash: [],
  borderDashOffset: 0,
  borderJoinStyle: void 0,
  borderRadius: 0,
  borderWidth: 2,
  offset: 0,
  spacing: 0,
  angle: void 0,
  circular: true,
  selfJoin: false
});
__publicField(_ArcElement, "defaultRoutes", {
  backgroundColor: "backgroundColor"
});
__publicField(_ArcElement, "descriptors", {
  _scriptable: true,
  _indexable: (name) => name !== "borderDash"
});
let ArcElement = _ArcElement;
function setStyle(ctx, options, style = options) {
  ctx.lineCap = valueOrDefault(style.borderCapStyle, options.borderCapStyle);
  ctx.setLineDash(valueOrDefault(style.borderDash, options.borderDash));
  ctx.lineDashOffset = valueOrDefault(style.borderDashOffset, options.borderDashOffset);
  ctx.lineJoin = valueOrDefault(style.borderJoinStyle, options.borderJoinStyle);
  ctx.lineWidth = valueOrDefault(style.borderWidth, options.borderWidth);
  ctx.strokeStyle = valueOrDefault(style.borderColor, options.borderColor);
}
__name(setStyle, "setStyle");
function lineTo(ctx, previous, target) {
  ctx.lineTo(target.x, target.y);
}
__name(lineTo, "lineTo");
function getLineMethod(options) {
  if (options.stepped) {
    return _steppedLineTo;
  }
  if (options.tension || options.cubicInterpolationMode === "monotone") {
    return _bezierCurveTo;
  }
  return lineTo;
}
__name(getLineMethod, "getLineMethod");
function pathVars(points, segment, params = {}) {
  const count = points.length;
  const { start: paramsStart = 0, end: paramsEnd = count - 1 } = params;
  const { start: segmentStart, end: segmentEnd } = segment;
  const start = Math.max(paramsStart, segmentStart);
  const end = Math.min(paramsEnd, segmentEnd);
  const outside = paramsStart < segmentStart && paramsEnd < segmentStart || paramsStart > segmentEnd && paramsEnd > segmentEnd;
  return {
    count,
    start,
    loop: segment.loop,
    ilen: end < start && !outside ? count + end - start : end - start
  };
}
__name(pathVars, "pathVars");
function pathSegment(ctx, line, segment, params) {
  const { points, options } = line;
  const { count, start, loop, ilen } = pathVars(points, segment, params);
  const lineMethod = getLineMethod(options);
  let { move = true, reverse } = params || {};
  let i2, point, prev;
  for (i2 = 0; i2 <= ilen; ++i2) {
    point = points[(start + (reverse ? ilen - i2 : i2)) % count];
    if (point.skip) {
      continue;
    } else if (move) {
      ctx.moveTo(point.x, point.y);
      move = false;
    } else {
      lineMethod(ctx, prev, point, reverse, options.stepped);
    }
    prev = point;
  }
  if (loop) {
    point = points[(start + (reverse ? ilen : 0)) % count];
    lineMethod(ctx, prev, point, reverse, options.stepped);
  }
  return !!loop;
}
__name(pathSegment, "pathSegment");
function fastPathSegment(ctx, line, segment, params) {
  const points = line.points;
  const { count, start, ilen } = pathVars(points, segment, params);
  const { move = true, reverse } = params || {};
  let avgX = 0;
  let countX = 0;
  let i2, point, prevX, minY, maxY, lastY;
  const pointIndex = /* @__PURE__ */ __name((index2) => (start + (reverse ? ilen - index2 : index2)) % count, "pointIndex");
  const drawX = /* @__PURE__ */ __name(() => {
    if (minY !== maxY) {
      ctx.lineTo(avgX, maxY);
      ctx.lineTo(avgX, minY);
      ctx.lineTo(avgX, lastY);
    }
  }, "drawX");
  if (move) {
    point = points[pointIndex(0)];
    ctx.moveTo(point.x, point.y);
  }
  for (i2 = 0; i2 <= ilen; ++i2) {
    point = points[pointIndex(i2)];
    if (point.skip) {
      continue;
    }
    const x2 = point.x;
    const y2 = point.y;
    const truncX = x2 | 0;
    if (truncX === prevX) {
      if (y2 < minY) {
        minY = y2;
      } else if (y2 > maxY) {
        maxY = y2;
      }
      avgX = (countX * avgX + x2) / ++countX;
    } else {
      drawX();
      ctx.lineTo(x2, y2);
      prevX = truncX;
      countX = 0;
      minY = maxY = y2;
    }
    lastY = y2;
  }
  drawX();
}
__name(fastPathSegment, "fastPathSegment");
function _getSegmentMethod(line) {
  const opts = line.options;
  const borderDash = opts.borderDash && opts.borderDash.length;
  const useFastPath = !line._decimated && !line._loop && !opts.tension && opts.cubicInterpolationMode !== "monotone" && !opts.stepped && !borderDash;
  return useFastPath ? fastPathSegment : pathSegment;
}
__name(_getSegmentMethod, "_getSegmentMethod");
function _getInterpolationMethod(options) {
  if (options.stepped) {
    return _steppedInterpolation;
  }
  if (options.tension || options.cubicInterpolationMode === "monotone") {
    return _bezierInterpolation;
  }
  return _pointInLine;
}
__name(_getInterpolationMethod, "_getInterpolationMethod");
function strokePathWithCache(ctx, line, start, count) {
  let path = line._path;
  if (!path) {
    path = line._path = new Path2D();
    if (line.path(path, start, count)) {
      path.closePath();
    }
  }
  setStyle(ctx, line.options);
  ctx.stroke(path);
}
__name(strokePathWithCache, "strokePathWithCache");
function strokePathDirect(ctx, line, start, count) {
  const { segments, options } = line;
  const segmentMethod = _getSegmentMethod(line);
  for (const segment of segments) {
    setStyle(ctx, options, segment.style);
    ctx.beginPath();
    if (segmentMethod(ctx, line, segment, {
      start,
      end: start + count - 1
    })) {
      ctx.closePath();
    }
    ctx.stroke();
  }
}
__name(strokePathDirect, "strokePathDirect");
const usePath2D = typeof Path2D === "function";
function draw(ctx, line, start, count) {
  if (usePath2D && !line.options.segment) {
    strokePathWithCache(ctx, line, start, count);
  } else {
    strokePathDirect(ctx, line, start, count);
  }
}
__name(draw, "draw");
const _LineElement = class _LineElement extends Element {
  constructor(cfg) {
    super();
    this.animated = true;
    this.options = void 0;
    this._chart = void 0;
    this._loop = void 0;
    this._fullLoop = void 0;
    this._path = void 0;
    this._points = void 0;
    this._segments = void 0;
    this._decimated = false;
    this._pointsUpdated = false;
    this._datasetIndex = void 0;
    if (cfg) {
      Object.assign(this, cfg);
    }
  }
  updateControlPoints(chartArea, indexAxis) {
    const options = this.options;
    if ((options.tension || options.cubicInterpolationMode === "monotone") && !options.stepped && !this._pointsUpdated) {
      const loop = options.spanGaps ? this._loop : this._fullLoop;
      _updateBezierControlPoints(this._points, options, chartArea, loop, indexAxis);
      this._pointsUpdated = true;
    }
  }
  set points(points) {
    this._points = points;
    delete this._segments;
    delete this._path;
    this._pointsUpdated = false;
  }
  get points() {
    return this._points;
  }
  get segments() {
    return this._segments || (this._segments = _computeSegments(this, this.options.segment));
  }
  first() {
    const segments = this.segments;
    const points = this.points;
    return segments.length && points[segments[0].start];
  }
  last() {
    const segments = this.segments;
    const points = this.points;
    const count = segments.length;
    return count && points[segments[count - 1].end];
  }
  interpolate(point, property) {
    const options = this.options;
    const value = point[property];
    const points = this.points;
    const segments = _boundSegments(this, {
      property,
      start: value,
      end: value
    });
    if (!segments.length) {
      return;
    }
    const result = [];
    const _interpolate = _getInterpolationMethod(options);
    let i2, ilen;
    for (i2 = 0, ilen = segments.length; i2 < ilen; ++i2) {
      const { start, end } = segments[i2];
      const p1 = points[start];
      const p2 = points[end];
      if (p1 === p2) {
        result.push(p1);
        continue;
      }
      const t2 = Math.abs((value - p1[property]) / (p2[property] - p1[property]));
      const interpolated = _interpolate(p1, p2, t2, options.stepped);
      interpolated[property] = point[property];
      result.push(interpolated);
    }
    return result.length === 1 ? result[0] : result;
  }
  pathSegment(ctx, segment, params) {
    const segmentMethod = _getSegmentMethod(this);
    return segmentMethod(ctx, this, segment, params);
  }
  path(ctx, start, count) {
    const segments = this.segments;
    const segmentMethod = _getSegmentMethod(this);
    let loop = this._loop;
    start = start || 0;
    count = count || this.points.length - start;
    for (const segment of segments) {
      loop &= segmentMethod(ctx, this, segment, {
        start,
        end: start + count - 1
      });
    }
    return !!loop;
  }
  draw(ctx, chartArea, start, count) {
    const options = this.options || {};
    const points = this.points || [];
    if (points.length && options.borderWidth) {
      ctx.save();
      draw(ctx, this, start, count);
      ctx.restore();
    }
    if (this.animated) {
      this._pointsUpdated = false;
      this._path = void 0;
    }
  }
};
__name(_LineElement, "LineElement");
__publicField(_LineElement, "id", "line");
__publicField(_LineElement, "defaults", {
  borderCapStyle: "butt",
  borderDash: [],
  borderDashOffset: 0,
  borderJoinStyle: "miter",
  borderWidth: 3,
  capBezierPoints: true,
  cubicInterpolationMode: "default",
  fill: false,
  spanGaps: false,
  stepped: false,
  tension: 0
});
__publicField(_LineElement, "defaultRoutes", {
  backgroundColor: "backgroundColor",
  borderColor: "borderColor"
});
__publicField(_LineElement, "descriptors", {
  _scriptable: true,
  _indexable: (name) => name !== "borderDash" && name !== "fill"
});
let LineElement = _LineElement;
function inRange$1(el, pos, axis, useFinalPosition) {
  const options = el.options;
  const { [axis]: value } = el.getProps([
    axis
  ], useFinalPosition);
  return Math.abs(pos - value) < options.radius + options.hitRadius;
}
__name(inRange$1, "inRange$1");
const _PointElement = class _PointElement extends Element {
  constructor(cfg) {
    super();
    __publicField(this, "parsed");
    __publicField(this, "skip");
    __publicField(this, "stop");
    this.options = void 0;
    this.parsed = void 0;
    this.skip = void 0;
    this.stop = void 0;
    if (cfg) {
      Object.assign(this, cfg);
    }
  }
  inRange(mouseX, mouseY, useFinalPosition) {
    const options = this.options;
    const { x: x2, y: y2 } = this.getProps([
      "x",
      "y"
    ], useFinalPosition);
    return Math.pow(mouseX - x2, 2) + Math.pow(mouseY - y2, 2) < Math.pow(options.hitRadius + options.radius, 2);
  }
  inXRange(mouseX, useFinalPosition) {
    return inRange$1(this, mouseX, "x", useFinalPosition);
  }
  inYRange(mouseY, useFinalPosition) {
    return inRange$1(this, mouseY, "y", useFinalPosition);
  }
  getCenterPoint(useFinalPosition) {
    const { x: x2, y: y2 } = this.getProps([
      "x",
      "y"
    ], useFinalPosition);
    return {
      x: x2,
      y: y2
    };
  }
  size(options) {
    options = options || this.options || {};
    let radius = options.radius || 0;
    radius = Math.max(radius, radius && options.hoverRadius || 0);
    const borderWidth = radius && options.borderWidth || 0;
    return (radius + borderWidth) * 2;
  }
  draw(ctx, area) {
    const options = this.options;
    if (this.skip || options.radius < 0.1 || !_isPointInArea(this, area, this.size(options) / 2)) {
      return;
    }
    ctx.strokeStyle = options.borderColor;
    ctx.lineWidth = options.borderWidth;
    ctx.fillStyle = options.backgroundColor;
    drawPoint(ctx, options, this.x, this.y);
  }
  getRange() {
    const options = this.options || {};
    return options.radius + options.hitRadius;
  }
};
__name(_PointElement, "PointElement");
__publicField(_PointElement, "id", "point");
/**
* @type {any}
*/
__publicField(_PointElement, "defaults", {
  borderWidth: 1,
  hitRadius: 1,
  hoverBorderWidth: 1,
  hoverRadius: 4,
  pointStyle: "circle",
  radius: 3,
  rotation: 0
});
/**
* @type {any}
*/
__publicField(_PointElement, "defaultRoutes", {
  backgroundColor: "backgroundColor",
  borderColor: "borderColor"
});
let PointElement = _PointElement;
function getBarBounds(bar, useFinalPosition) {
  const { x: x2, y: y2, base, width, height } = bar.getProps([
    "x",
    "y",
    "base",
    "width",
    "height"
  ], useFinalPosition);
  let left, right, top, bottom, half;
  if (bar.horizontal) {
    half = height / 2;
    left = Math.min(x2, base);
    right = Math.max(x2, base);
    top = y2 - half;
    bottom = y2 + half;
  } else {
    half = width / 2;
    left = x2 - half;
    right = x2 + half;
    top = Math.min(y2, base);
    bottom = Math.max(y2, base);
  }
  return {
    left,
    top,
    right,
    bottom
  };
}
__name(getBarBounds, "getBarBounds");
function skipOrLimit(skip2, value, min, max2) {
  return skip2 ? 0 : _limitValue(value, min, max2);
}
__name(skipOrLimit, "skipOrLimit");
function parseBorderWidth(bar, maxW, maxH) {
  const value = bar.options.borderWidth;
  const skip2 = bar.borderSkipped;
  const o2 = toTRBL(value);
  return {
    t: skipOrLimit(skip2.top, o2.top, 0, maxH),
    r: skipOrLimit(skip2.right, o2.right, 0, maxW),
    b: skipOrLimit(skip2.bottom, o2.bottom, 0, maxH),
    l: skipOrLimit(skip2.left, o2.left, 0, maxW)
  };
}
__name(parseBorderWidth, "parseBorderWidth");
function parseBorderRadius(bar, maxW, maxH) {
  const { enableBorderRadius } = bar.getProps([
    "enableBorderRadius"
  ]);
  const value = bar.options.borderRadius;
  const o2 = toTRBLCorners(value);
  const maxR = Math.min(maxW, maxH);
  const skip2 = bar.borderSkipped;
  const enableBorder = enableBorderRadius || isObject(value);
  return {
    topLeft: skipOrLimit(!enableBorder || skip2.top || skip2.left, o2.topLeft, 0, maxR),
    topRight: skipOrLimit(!enableBorder || skip2.top || skip2.right, o2.topRight, 0, maxR),
    bottomLeft: skipOrLimit(!enableBorder || skip2.bottom || skip2.left, o2.bottomLeft, 0, maxR),
    bottomRight: skipOrLimit(!enableBorder || skip2.bottom || skip2.right, o2.bottomRight, 0, maxR)
  };
}
__name(parseBorderRadius, "parseBorderRadius");
function boundingRects(bar) {
  const bounds = getBarBounds(bar);
  const width = bounds.right - bounds.left;
  const height = bounds.bottom - bounds.top;
  const border = parseBorderWidth(bar, width / 2, height / 2);
  const radius = parseBorderRadius(bar, width / 2, height / 2);
  return {
    outer: {
      x: bounds.left,
      y: bounds.top,
      w: width,
      h: height,
      radius
    },
    inner: {
      x: bounds.left + border.l,
      y: bounds.top + border.t,
      w: width - border.l - border.r,
      h: height - border.t - border.b,
      radius: {
        topLeft: Math.max(0, radius.topLeft - Math.max(border.t, border.l)),
        topRight: Math.max(0, radius.topRight - Math.max(border.t, border.r)),
        bottomLeft: Math.max(0, radius.bottomLeft - Math.max(border.b, border.l)),
        bottomRight: Math.max(0, radius.bottomRight - Math.max(border.b, border.r))
      }
    }
  };
}
__name(boundingRects, "boundingRects");
function inRange(bar, x2, y2, useFinalPosition) {
  const skipX = x2 === null;
  const skipY = y2 === null;
  const skipBoth = skipX && skipY;
  const bounds = bar && !skipBoth && getBarBounds(bar, useFinalPosition);
  return bounds && (skipX || _isBetween(x2, bounds.left, bounds.right)) && (skipY || _isBetween(y2, bounds.top, bounds.bottom));
}
__name(inRange, "inRange");
function hasRadius(radius) {
  return radius.topLeft || radius.topRight || radius.bottomLeft || radius.bottomRight;
}
__name(hasRadius, "hasRadius");
function addNormalRectPath(ctx, rect) {
  ctx.rect(rect.x, rect.y, rect.w, rect.h);
}
__name(addNormalRectPath, "addNormalRectPath");
function inflateRect(rect, amount, refRect = {}) {
  const x2 = rect.x !== refRect.x ? -amount : 0;
  const y2 = rect.y !== refRect.y ? -amount : 0;
  const w2 = (rect.x + rect.w !== refRect.x + refRect.w ? amount : 0) - x2;
  const h3 = (rect.y + rect.h !== refRect.y + refRect.h ? amount : 0) - y2;
  return {
    x: rect.x + x2,
    y: rect.y + y2,
    w: rect.w + w2,
    h: rect.h + h3,
    radius: rect.radius
  };
}
__name(inflateRect, "inflateRect");
const _BarElement = class _BarElement extends Element {
  constructor(cfg) {
    super();
    this.options = void 0;
    this.horizontal = void 0;
    this.base = void 0;
    this.width = void 0;
    this.height = void 0;
    this.inflateAmount = void 0;
    if (cfg) {
      Object.assign(this, cfg);
    }
  }
  draw(ctx) {
    const { inflateAmount, options: { borderColor, backgroundColor } } = this;
    const { inner, outer } = boundingRects(this);
    const addRectPath = hasRadius(outer.radius) ? addRoundedRectPath : addNormalRectPath;
    ctx.save();
    if (outer.w !== inner.w || outer.h !== inner.h) {
      ctx.beginPath();
      addRectPath(ctx, inflateRect(outer, inflateAmount, inner));
      ctx.clip();
      addRectPath(ctx, inflateRect(inner, -inflateAmount, outer));
      ctx.fillStyle = borderColor;
      ctx.fill("evenodd");
    }
    ctx.beginPath();
    addRectPath(ctx, inflateRect(inner, inflateAmount));
    ctx.fillStyle = backgroundColor;
    ctx.fill();
    ctx.restore();
  }
  inRange(mouseX, mouseY, useFinalPosition) {
    return inRange(this, mouseX, mouseY, useFinalPosition);
  }
  inXRange(mouseX, useFinalPosition) {
    return inRange(this, mouseX, null, useFinalPosition);
  }
  inYRange(mouseY, useFinalPosition) {
    return inRange(this, null, mouseY, useFinalPosition);
  }
  getCenterPoint(useFinalPosition) {
    const { x: x2, y: y2, base, horizontal } = this.getProps([
      "x",
      "y",
      "base",
      "horizontal"
    ], useFinalPosition);
    return {
      x: horizontal ? (x2 + base) / 2 : x2,
      y: horizontal ? y2 : (y2 + base) / 2
    };
  }
  getRange(axis) {
    return axis === "x" ? this.width / 2 : this.height / 2;
  }
};
__name(_BarElement, "BarElement");
__publicField(_BarElement, "id", "bar");
__publicField(_BarElement, "defaults", {
  borderSkipped: "start",
  borderWidth: 0,
  borderRadius: 0,
  inflateAmount: "auto",
  pointStyle: void 0
});
__publicField(_BarElement, "defaultRoutes", {
  backgroundColor: "backgroundColor",
  borderColor: "borderColor"
});
let BarElement = _BarElement;
const getBoxSize = /* @__PURE__ */ __name((labelOpts, fontSize) => {
  let { boxHeight = fontSize, boxWidth = fontSize } = labelOpts;
  if (labelOpts.usePointStyle) {
    boxHeight = Math.min(boxHeight, fontSize);
    boxWidth = labelOpts.pointStyleWidth || Math.min(boxWidth, fontSize);
  }
  return {
    boxWidth,
    boxHeight,
    itemHeight: Math.max(fontSize, boxHeight)
  };
}, "getBoxSize");
const itemsEqual = /* @__PURE__ */ __name((a2, b2) => a2 !== null && b2 !== null && a2.datasetIndex === b2.datasetIndex && a2.index === b2.index, "itemsEqual");
const _Legend = class _Legend extends Element {
  constructor(config) {
    super();
    this._added = false;
    this.legendHitBoxes = [];
    this._hoveredItem = null;
    this.doughnutMode = false;
    this.chart = config.chart;
    this.options = config.options;
    this.ctx = config.ctx;
    this.legendItems = void 0;
    this.columnSizes = void 0;
    this.lineWidths = void 0;
    this.maxHeight = void 0;
    this.maxWidth = void 0;
    this.top = void 0;
    this.bottom = void 0;
    this.left = void 0;
    this.right = void 0;
    this.height = void 0;
    this.width = void 0;
    this._margins = void 0;
    this.position = void 0;
    this.weight = void 0;
    this.fullSize = void 0;
  }
  update(maxWidth, maxHeight, margins) {
    this.maxWidth = maxWidth;
    this.maxHeight = maxHeight;
    this._margins = margins;
    this.setDimensions();
    this.buildLabels();
    this.fit();
  }
  setDimensions() {
    if (this.isHorizontal()) {
      this.width = this.maxWidth;
      this.left = this._margins.left;
      this.right = this.width;
    } else {
      this.height = this.maxHeight;
      this.top = this._margins.top;
      this.bottom = this.height;
    }
  }
  buildLabels() {
    const labelOpts = this.options.labels || {};
    let legendItems = callback(labelOpts.generateLabels, [
      this.chart
    ], this) || [];
    if (labelOpts.filter) {
      legendItems = legendItems.filter((item) => labelOpts.filter(item, this.chart.data));
    }
    if (labelOpts.sort) {
      legendItems = legendItems.sort((a2, b2) => labelOpts.sort(a2, b2, this.chart.data));
    }
    if (this.options.reverse) {
      legendItems.reverse();
    }
    this.legendItems = legendItems;
  }
  fit() {
    const { options, ctx } = this;
    if (!options.display) {
      this.width = this.height = 0;
      return;
    }
    const labelOpts = options.labels;
    const labelFont = toFont(labelOpts.font);
    const fontSize = labelFont.size;
    const titleHeight = this._computeTitleHeight();
    const { boxWidth, itemHeight } = getBoxSize(labelOpts, fontSize);
    let width, height;
    ctx.font = labelFont.string;
    if (this.isHorizontal()) {
      width = this.maxWidth;
      height = this._fitRows(titleHeight, fontSize, boxWidth, itemHeight) + 10;
    } else {
      height = this.maxHeight;
      width = this._fitCols(titleHeight, labelFont, boxWidth, itemHeight) + 10;
    }
    this.width = Math.min(width, options.maxWidth || this.maxWidth);
    this.height = Math.min(height, options.maxHeight || this.maxHeight);
  }
  _fitRows(titleHeight, fontSize, boxWidth, itemHeight) {
    const { ctx, maxWidth, options: { labels: { padding } } } = this;
    const hitboxes = this.legendHitBoxes = [];
    const lineWidths = this.lineWidths = [
      0
    ];
    const lineHeight = itemHeight + padding;
    let totalHeight = titleHeight;
    ctx.textAlign = "left";
    ctx.textBaseline = "middle";
    let row = -1;
    let top = -lineHeight;
    this.legendItems.forEach((legendItem, i2) => {
      const itemWidth = boxWidth + fontSize / 2 + ctx.measureText(legendItem.text).width;
      if (i2 === 0 || lineWidths[lineWidths.length - 1] + itemWidth + 2 * padding > maxWidth) {
        totalHeight += lineHeight;
        lineWidths[lineWidths.length - (i2 > 0 ? 0 : 1)] = 0;
        top += lineHeight;
        row++;
      }
      hitboxes[i2] = {
        left: 0,
        top,
        row,
        width: itemWidth,
        height: itemHeight
      };
      lineWidths[lineWidths.length - 1] += itemWidth + padding;
    });
    return totalHeight;
  }
  _fitCols(titleHeight, labelFont, boxWidth, _itemHeight) {
    const { ctx, maxHeight, options: { labels: { padding } } } = this;
    const hitboxes = this.legendHitBoxes = [];
    const columnSizes = this.columnSizes = [];
    const heightLimit = maxHeight - titleHeight;
    let totalWidth = padding;
    let currentColWidth = 0;
    let currentColHeight = 0;
    let left = 0;
    let col = 0;
    this.legendItems.forEach((legendItem, i2) => {
      const { itemWidth, itemHeight } = calculateItemSize(boxWidth, labelFont, ctx, legendItem, _itemHeight);
      if (i2 > 0 && currentColHeight + itemHeight + 2 * padding > heightLimit) {
        totalWidth += currentColWidth + padding;
        columnSizes.push({
          width: currentColWidth,
          height: currentColHeight
        });
        left += currentColWidth + padding;
        col++;
        currentColWidth = currentColHeight = 0;
      }
      hitboxes[i2] = {
        left,
        top: currentColHeight,
        col,
        width: itemWidth,
        height: itemHeight
      };
      currentColWidth = Math.max(currentColWidth, itemWidth);
      currentColHeight += itemHeight + padding;
    });
    totalWidth += currentColWidth;
    columnSizes.push({
      width: currentColWidth,
      height: currentColHeight
    });
    return totalWidth;
  }
  adjustHitBoxes() {
    if (!this.options.display) {
      return;
    }
    const titleHeight = this._computeTitleHeight();
    const { legendHitBoxes: hitboxes, options: { align, labels: { padding }, rtl } } = this;
    const rtlHelper = getRtlAdapter(rtl, this.left, this.width);
    if (this.isHorizontal()) {
      let row = 0;
      let left = _alignStartEnd(align, this.left + padding, this.right - this.lineWidths[row]);
      for (const hitbox of hitboxes) {
        if (row !== hitbox.row) {
          row = hitbox.row;
          left = _alignStartEnd(align, this.left + padding, this.right - this.lineWidths[row]);
        }
        hitbox.top += this.top + titleHeight + padding;
        hitbox.left = rtlHelper.leftForLtr(rtlHelper.x(left), hitbox.width);
        left += hitbox.width + padding;
      }
    } else {
      let col = 0;
      let top = _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - this.columnSizes[col].height);
      for (const hitbox of hitboxes) {
        if (hitbox.col !== col) {
          col = hitbox.col;
          top = _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - this.columnSizes[col].height);
        }
        hitbox.top = top;
        hitbox.left += this.left + padding;
        hitbox.left = rtlHelper.leftForLtr(rtlHelper.x(hitbox.left), hitbox.width);
        top += hitbox.height + padding;
      }
    }
  }
  isHorizontal() {
    return this.options.position === "top" || this.options.position === "bottom";
  }
  draw() {
    if (this.options.display) {
      const ctx = this.ctx;
      clipArea(ctx, this);
      this._draw();
      unclipArea(ctx);
    }
  }
  _draw() {
    const { options: opts, columnSizes, lineWidths, ctx } = this;
    const { align, labels: labelOpts } = opts;
    const defaultColor = defaults.color;
    const rtlHelper = getRtlAdapter(opts.rtl, this.left, this.width);
    const labelFont = toFont(labelOpts.font);
    const { padding } = labelOpts;
    const fontSize = labelFont.size;
    const halfFontSize = fontSize / 2;
    let cursor;
    this.drawTitle();
    ctx.textAlign = rtlHelper.textAlign("left");
    ctx.textBaseline = "middle";
    ctx.lineWidth = 0.5;
    ctx.font = labelFont.string;
    const { boxWidth, boxHeight, itemHeight } = getBoxSize(labelOpts, fontSize);
    const drawLegendBox = /* @__PURE__ */ __name(function(x2, y2, legendItem) {
      if (isNaN(boxWidth) || boxWidth <= 0 || isNaN(boxHeight) || boxHeight < 0) {
        return;
      }
      ctx.save();
      const lineWidth = valueOrDefault(legendItem.lineWidth, 1);
      ctx.fillStyle = valueOrDefault(legendItem.fillStyle, defaultColor);
      ctx.lineCap = valueOrDefault(legendItem.lineCap, "butt");
      ctx.lineDashOffset = valueOrDefault(legendItem.lineDashOffset, 0);
      ctx.lineJoin = valueOrDefault(legendItem.lineJoin, "miter");
      ctx.lineWidth = lineWidth;
      ctx.strokeStyle = valueOrDefault(legendItem.strokeStyle, defaultColor);
      ctx.setLineDash(valueOrDefault(legendItem.lineDash, []));
      if (labelOpts.usePointStyle) {
        const drawOptions = {
          radius: boxHeight * Math.SQRT2 / 2,
          pointStyle: legendItem.pointStyle,
          rotation: legendItem.rotation,
          borderWidth: lineWidth
        };
        const centerX = rtlHelper.xPlus(x2, boxWidth / 2);
        const centerY = y2 + halfFontSize;
        drawPointLegend(ctx, drawOptions, centerX, centerY, labelOpts.pointStyleWidth && boxWidth);
      } else {
        const yBoxTop = y2 + Math.max((fontSize - boxHeight) / 2, 0);
        const xBoxLeft = rtlHelper.leftForLtr(x2, boxWidth);
        const borderRadius = toTRBLCorners(legendItem.borderRadius);
        ctx.beginPath();
        if (Object.values(borderRadius).some((v2) => v2 !== 0)) {
          addRoundedRectPath(ctx, {
            x: xBoxLeft,
            y: yBoxTop,
            w: boxWidth,
            h: boxHeight,
            radius: borderRadius
          });
        } else {
          ctx.rect(xBoxLeft, yBoxTop, boxWidth, boxHeight);
        }
        ctx.fill();
        if (lineWidth !== 0) {
          ctx.stroke();
        }
      }
      ctx.restore();
    }, "drawLegendBox");
    const fillText = /* @__PURE__ */ __name(function(x2, y2, legendItem) {
      renderText(ctx, legendItem.text, x2, y2 + itemHeight / 2, labelFont, {
        strikethrough: legendItem.hidden,
        textAlign: rtlHelper.textAlign(legendItem.textAlign)
      });
    }, "fillText");
    const isHorizontal = this.isHorizontal();
    const titleHeight = this._computeTitleHeight();
    if (isHorizontal) {
      cursor = {
        x: _alignStartEnd(align, this.left + padding, this.right - lineWidths[0]),
        y: this.top + padding + titleHeight,
        line: 0
      };
    } else {
      cursor = {
        x: this.left + padding,
        y: _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - columnSizes[0].height),
        line: 0
      };
    }
    overrideTextDirection(this.ctx, opts.textDirection);
    const lineHeight = itemHeight + padding;
    this.legendItems.forEach((legendItem, i2) => {
      ctx.strokeStyle = legendItem.fontColor;
      ctx.fillStyle = legendItem.fontColor;
      const textWidth = ctx.measureText(legendItem.text).width;
      const textAlign = rtlHelper.textAlign(legendItem.textAlign || (legendItem.textAlign = labelOpts.textAlign));
      const width = boxWidth + halfFontSize + textWidth;
      let x2 = cursor.x;
      let y2 = cursor.y;
      rtlHelper.setWidth(this.width);
      if (isHorizontal) {
        if (i2 > 0 && x2 + width + padding > this.right) {
          y2 = cursor.y += lineHeight;
          cursor.line++;
          x2 = cursor.x = _alignStartEnd(align, this.left + padding, this.right - lineWidths[cursor.line]);
        }
      } else if (i2 > 0 && y2 + lineHeight > this.bottom) {
        x2 = cursor.x = x2 + columnSizes[cursor.line].width + padding;
        cursor.line++;
        y2 = cursor.y = _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - columnSizes[cursor.line].height);
      }
      const realX = rtlHelper.x(x2);
      drawLegendBox(realX, y2, legendItem);
      x2 = _textX(textAlign, x2 + boxWidth + halfFontSize, isHorizontal ? x2 + width : this.right, opts.rtl);
      fillText(rtlHelper.x(x2), y2, legendItem);
      if (isHorizontal) {
        cursor.x += width + padding;
      } else if (typeof legendItem.text !== "string") {
        const fontLineHeight = labelFont.lineHeight;
        cursor.y += calculateLegendItemHeight(legendItem, fontLineHeight) + padding;
      } else {
        cursor.y += lineHeight;
      }
    });
    restoreTextDirection(this.ctx, opts.textDirection);
  }
  drawTitle() {
    const opts = this.options;
    const titleOpts = opts.title;
    const titleFont = toFont(titleOpts.font);
    const titlePadding = toPadding(titleOpts.padding);
    if (!titleOpts.display) {
      return;
    }
    const rtlHelper = getRtlAdapter(opts.rtl, this.left, this.width);
    const ctx = this.ctx;
    const position = titleOpts.position;
    const halfFontSize = titleFont.size / 2;
    const topPaddingPlusHalfFontSize = titlePadding.top + halfFontSize;
    let y2;
    let left = this.left;
    let maxWidth = this.width;
    if (this.isHorizontal()) {
      maxWidth = Math.max(...this.lineWidths);
      y2 = this.top + topPaddingPlusHalfFontSize;
      left = _alignStartEnd(opts.align, left, this.right - maxWidth);
    } else {
      const maxHeight = this.columnSizes.reduce((acc, size) => Math.max(acc, size.height), 0);
      y2 = topPaddingPlusHalfFontSize + _alignStartEnd(opts.align, this.top, this.bottom - maxHeight - opts.labels.padding - this._computeTitleHeight());
    }
    const x2 = _alignStartEnd(position, left, left + maxWidth);
    ctx.textAlign = rtlHelper.textAlign(_toLeftRightCenter(position));
    ctx.textBaseline = "middle";
    ctx.strokeStyle = titleOpts.color;
    ctx.fillStyle = titleOpts.color;
    ctx.font = titleFont.string;
    renderText(ctx, titleOpts.text, x2, y2, titleFont);
  }
  _computeTitleHeight() {
    const titleOpts = this.options.title;
    const titleFont = toFont(titleOpts.font);
    const titlePadding = toPadding(titleOpts.padding);
    return titleOpts.display ? titleFont.lineHeight + titlePadding.height : 0;
  }
  _getLegendItemAt(x2, y2) {
    let i2, hitBox, lh;
    if (_isBetween(x2, this.left, this.right) && _isBetween(y2, this.top, this.bottom)) {
      lh = this.legendHitBoxes;
      for (i2 = 0; i2 < lh.length; ++i2) {
        hitBox = lh[i2];
        if (_isBetween(x2, hitBox.left, hitBox.left + hitBox.width) && _isBetween(y2, hitBox.top, hitBox.top + hitBox.height)) {
          return this.legendItems[i2];
        }
      }
    }
    return null;
  }
  handleEvent(e) {
    const opts = this.options;
    if (!isListened(e.type, opts)) {
      return;
    }
    const hoveredItem = this._getLegendItemAt(e.x, e.y);
    if (e.type === "mousemove" || e.type === "mouseout") {
      const previous = this._hoveredItem;
      const sameItem = itemsEqual(previous, hoveredItem);
      if (previous && !sameItem) {
        callback(opts.onLeave, [
          e,
          previous,
          this
        ], this);
      }
      this._hoveredItem = hoveredItem;
      if (hoveredItem && !sameItem) {
        callback(opts.onHover, [
          e,
          hoveredItem,
          this
        ], this);
      }
    } else if (hoveredItem) {
      callback(opts.onClick, [
        e,
        hoveredItem,
        this
      ], this);
    }
  }
};
__name(_Legend, "Legend");
let Legend = _Legend;
function calculateItemSize(boxWidth, labelFont, ctx, legendItem, _itemHeight) {
  const itemWidth = calculateItemWidth(legendItem, boxWidth, labelFont, ctx);
  const itemHeight = calculateItemHeight(_itemHeight, legendItem, labelFont.lineHeight);
  return {
    itemWidth,
    itemHeight
  };
}
__name(calculateItemSize, "calculateItemSize");
function calculateItemWidth(legendItem, boxWidth, labelFont, ctx) {
  let legendItemText = legendItem.text;
  if (legendItemText && typeof legendItemText !== "string") {
    legendItemText = legendItemText.reduce((a2, b2) => a2.length > b2.length ? a2 : b2);
  }
  return boxWidth + labelFont.size / 2 + ctx.measureText(legendItemText).width;
}
__name(calculateItemWidth, "calculateItemWidth");
function calculateItemHeight(_itemHeight, legendItem, fontLineHeight) {
  let itemHeight = _itemHeight;
  if (typeof legendItem.text !== "string") {
    itemHeight = calculateLegendItemHeight(legendItem, fontLineHeight);
  }
  return itemHeight;
}
__name(calculateItemHeight, "calculateItemHeight");
function calculateLegendItemHeight(legendItem, fontLineHeight) {
  const labelHeight = legendItem.text ? legendItem.text.length : 0;
  return fontLineHeight * labelHeight;
}
__name(calculateLegendItemHeight, "calculateLegendItemHeight");
function isListened(type, opts) {
  if ((type === "mousemove" || type === "mouseout") && (opts.onHover || opts.onLeave)) {
    return true;
  }
  if (opts.onClick && (type === "click" || type === "mouseup")) {
    return true;
  }
  return false;
}
__name(isListened, "isListened");
var plugin_legend = {
  id: "legend",
  _element: Legend,
  start(chart, _args, options) {
    const legend = chart.legend = new Legend({
      ctx: chart.ctx,
      options,
      chart
    });
    layouts.configure(chart, legend, options);
    layouts.addBox(chart, legend);
  },
  stop(chart) {
    layouts.removeBox(chart, chart.legend);
    delete chart.legend;
  },
  beforeUpdate(chart, _args, options) {
    const legend = chart.legend;
    layouts.configure(chart, legend, options);
    legend.options = options;
  },
  afterUpdate(chart) {
    const legend = chart.legend;
    legend.buildLabels();
    legend.adjustHitBoxes();
  },
  afterEvent(chart, args) {
    if (!args.replay) {
      chart.legend.handleEvent(args.event);
    }
  },
  defaults: {
    display: true,
    position: "top",
    align: "center",
    fullSize: true,
    reverse: false,
    weight: 1e3,
    onClick(e, legendItem, legend) {
      const index2 = legendItem.datasetIndex;
      const ci = legend.chart;
      if (ci.isDatasetVisible(index2)) {
        ci.hide(index2);
        legendItem.hidden = true;
      } else {
        ci.show(index2);
        legendItem.hidden = false;
      }
    },
    onHover: null,
    onLeave: null,
    labels: {
      color: (ctx) => ctx.chart.options.color,
      boxWidth: 40,
      padding: 10,
      generateLabels(chart) {
        const datasets = chart.data.datasets;
        const { labels: { usePointStyle, pointStyle, textAlign, color: color2, useBorderRadius, borderRadius } } = chart.legend.options;
        return chart._getSortedDatasetMetas().map((meta) => {
          const style = meta.controller.getStyle(usePointStyle ? 0 : void 0);
          const borderWidth = toPadding(style.borderWidth);
          return {
            text: datasets[meta.index].label,
            fillStyle: style.backgroundColor,
            fontColor: color2,
            hidden: !meta.visible,
            lineCap: style.borderCapStyle,
            lineDash: style.borderDash,
            lineDashOffset: style.borderDashOffset,
            lineJoin: style.borderJoinStyle,
            lineWidth: (borderWidth.width + borderWidth.height) / 4,
            strokeStyle: style.borderColor,
            pointStyle: pointStyle || style.pointStyle,
            rotation: style.rotation,
            textAlign: textAlign || style.textAlign,
            borderRadius: useBorderRadius && (borderRadius || style.borderRadius),
            datasetIndex: meta.index
          };
        }, this);
      }
    },
    title: {
      color: (ctx) => ctx.chart.options.color,
      display: false,
      position: "center",
      text: ""
    }
  },
  descriptors: {
    _scriptable: (name) => !name.startsWith("on"),
    labels: {
      _scriptable: (name) => ![
        "generateLabels",
        "filter",
        "sort"
      ].includes(name)
    }
  }
};
const _Title = class _Title extends Element {
  constructor(config) {
    super();
    this.chart = config.chart;
    this.options = config.options;
    this.ctx = config.ctx;
    this._padding = void 0;
    this.top = void 0;
    this.bottom = void 0;
    this.left = void 0;
    this.right = void 0;
    this.width = void 0;
    this.height = void 0;
    this.position = void 0;
    this.weight = void 0;
    this.fullSize = void 0;
  }
  update(maxWidth, maxHeight) {
    const opts = this.options;
    this.left = 0;
    this.top = 0;
    if (!opts.display) {
      this.width = this.height = this.right = this.bottom = 0;
      return;
    }
    this.width = this.right = maxWidth;
    this.height = this.bottom = maxHeight;
    const lineCount = isArray(opts.text) ? opts.text.length : 1;
    this._padding = toPadding(opts.padding);
    const textSize = lineCount * toFont(opts.font).lineHeight + this._padding.height;
    if (this.isHorizontal()) {
      this.height = textSize;
    } else {
      this.width = textSize;
    }
  }
  isHorizontal() {
    const pos = this.options.position;
    return pos === "top" || pos === "bottom";
  }
  _drawArgs(offset) {
    const { top, left, bottom, right, options } = this;
    const align = options.align;
    let rotation = 0;
    let maxWidth, titleX, titleY;
    if (this.isHorizontal()) {
      titleX = _alignStartEnd(align, left, right);
      titleY = top + offset;
      maxWidth = right - left;
    } else {
      if (options.position === "left") {
        titleX = left + offset;
        titleY = _alignStartEnd(align, bottom, top);
        rotation = PI * -0.5;
      } else {
        titleX = right - offset;
        titleY = _alignStartEnd(align, top, bottom);
        rotation = PI * 0.5;
      }
      maxWidth = bottom - top;
    }
    return {
      titleX,
      titleY,
      maxWidth,
      rotation
    };
  }
  draw() {
    const ctx = this.ctx;
    const opts = this.options;
    if (!opts.display) {
      return;
    }
    const fontOpts = toFont(opts.font);
    const lineHeight = fontOpts.lineHeight;
    const offset = lineHeight / 2 + this._padding.top;
    const { titleX, titleY, maxWidth, rotation } = this._drawArgs(offset);
    renderText(ctx, opts.text, 0, 0, fontOpts, {
      color: opts.color,
      maxWidth,
      rotation,
      textAlign: _toLeftRightCenter(opts.align),
      textBaseline: "middle",
      translation: [
        titleX,
        titleY
      ]
    });
  }
};
__name(_Title, "Title");
let Title = _Title;
function createTitle(chart, titleOpts) {
  const title = new Title({
    ctx: chart.ctx,
    options: titleOpts,
    chart
  });
  layouts.configure(chart, title, titleOpts);
  layouts.addBox(chart, title);
  chart.titleBlock = title;
}
__name(createTitle, "createTitle");
var plugin_title = {
  id: "title",
  _element: Title,
  start(chart, _args, options) {
    createTitle(chart, options);
  },
  stop(chart) {
    const titleBlock = chart.titleBlock;
    layouts.removeBox(chart, titleBlock);
    delete chart.titleBlock;
  },
  beforeUpdate(chart, _args, options) {
    const title = chart.titleBlock;
    layouts.configure(chart, title, options);
    title.options = options;
  },
  defaults: {
    align: "center",
    display: false,
    font: {
      weight: "bold"
    },
    fullSize: true,
    padding: 10,
    position: "top",
    text: "",
    weight: 2e3
  },
  defaultRoutes: {
    color: "color"
  },
  descriptors: {
    _scriptable: true,
    _indexable: false
  }
};
const positioners = {
  average(items) {
    if (!items.length) {
      return false;
    }
    let i2, len;
    let xSet = /* @__PURE__ */ new Set();
    let y2 = 0;
    let count = 0;
    for (i2 = 0, len = items.length; i2 < len; ++i2) {
      const el = items[i2].element;
      if (el && el.hasValue()) {
        const pos = el.tooltipPosition();
        xSet.add(pos.x);
        y2 += pos.y;
        ++count;
      }
    }
    if (count === 0 || xSet.size === 0) {
      return false;
    }
    const xAverage = [
      ...xSet
    ].reduce((a2, b2) => a2 + b2) / xSet.size;
    return {
      x: xAverage,
      y: y2 / count
    };
  },
  nearest(items, eventPosition) {
    if (!items.length) {
      return false;
    }
    let x2 = eventPosition.x;
    let y2 = eventPosition.y;
    let minDistance = Number.POSITIVE_INFINITY;
    let i2, len, nearestElement;
    for (i2 = 0, len = items.length; i2 < len; ++i2) {
      const el = items[i2].element;
      if (el && el.hasValue()) {
        const center = el.getCenterPoint();
        const d2 = distanceBetweenPoints(eventPosition, center);
        if (d2 < minDistance) {
          minDistance = d2;
          nearestElement = el;
        }
      }
    }
    if (nearestElement) {
      const tp = nearestElement.tooltipPosition();
      x2 = tp.x;
      y2 = tp.y;
    }
    return {
      x: x2,
      y: y2
    };
  }
};
function pushOrConcat(base, toPush) {
  if (toPush) {
    if (isArray(toPush)) {
      Array.prototype.push.apply(base, toPush);
    } else {
      base.push(toPush);
    }
  }
  return base;
}
__name(pushOrConcat, "pushOrConcat");
function splitNewlines(str) {
  if ((typeof str === "string" || str instanceof String) && str.indexOf("\n") > -1) {
    return str.split("\n");
  }
  return str;
}
__name(splitNewlines, "splitNewlines");
function createTooltipItem(chart, item) {
  const { element, datasetIndex, index: index2 } = item;
  const controller = chart.getDatasetMeta(datasetIndex).controller;
  const { label, value } = controller.getLabelAndValue(index2);
  return {
    chart,
    label,
    parsed: controller.getParsed(index2),
    raw: chart.data.datasets[datasetIndex].data[index2],
    formattedValue: value,
    dataset: controller.getDataset(),
    dataIndex: index2,
    datasetIndex,
    element
  };
}
__name(createTooltipItem, "createTooltipItem");
function getTooltipSize(tooltip, options) {
  const ctx = tooltip.chart.ctx;
  const { body, footer, title } = tooltip;
  const { boxWidth, boxHeight } = options;
  const bodyFont = toFont(options.bodyFont);
  const titleFont = toFont(options.titleFont);
  const footerFont = toFont(options.footerFont);
  const titleLineCount = title.length;
  const footerLineCount = footer.length;
  const bodyLineItemCount = body.length;
  const padding = toPadding(options.padding);
  let height = padding.height;
  let width = 0;
  let combinedBodyLength = body.reduce((count, bodyItem) => count + bodyItem.before.length + bodyItem.lines.length + bodyItem.after.length, 0);
  combinedBodyLength += tooltip.beforeBody.length + tooltip.afterBody.length;
  if (titleLineCount) {
    height += titleLineCount * titleFont.lineHeight + (titleLineCount - 1) * options.titleSpacing + options.titleMarginBottom;
  }
  if (combinedBodyLength) {
    const bodyLineHeight = options.displayColors ? Math.max(boxHeight, bodyFont.lineHeight) : bodyFont.lineHeight;
    height += bodyLineItemCount * bodyLineHeight + (combinedBodyLength - bodyLineItemCount) * bodyFont.lineHeight + (combinedBodyLength - 1) * options.bodySpacing;
  }
  if (footerLineCount) {
    height += options.footerMarginTop + footerLineCount * footerFont.lineHeight + (footerLineCount - 1) * options.footerSpacing;
  }
  let widthPadding = 0;
  const maxLineWidth = /* @__PURE__ */ __name(function(line) {
    width = Math.max(width, ctx.measureText(line).width + widthPadding);
  }, "maxLineWidth");
  ctx.save();
  ctx.font = titleFont.string;
  each(tooltip.title, maxLineWidth);
  ctx.font = bodyFont.string;
  each(tooltip.beforeBody.concat(tooltip.afterBody), maxLineWidth);
  widthPadding = options.displayColors ? boxWidth + 2 + options.boxPadding : 0;
  each(body, (bodyItem) => {
    each(bodyItem.before, maxLineWidth);
    each(bodyItem.lines, maxLineWidth);
    each(bodyItem.after, maxLineWidth);
  });
  widthPadding = 0;
  ctx.font = footerFont.string;
  each(tooltip.footer, maxLineWidth);
  ctx.restore();
  width += padding.width;
  return {
    width,
    height
  };
}
__name(getTooltipSize, "getTooltipSize");
function determineYAlign(chart, size) {
  const { y: y2, height } = size;
  if (y2 < height / 2) {
    return "top";
  } else if (y2 > chart.height - height / 2) {
    return "bottom";
  }
  return "center";
}
__name(determineYAlign, "determineYAlign");
function doesNotFitWithAlign(xAlign, chart, options, size) {
  const { x: x2, width } = size;
  const caret = options.caretSize + options.caretPadding;
  if (xAlign === "left" && x2 + width + caret > chart.width) {
    return true;
  }
  if (xAlign === "right" && x2 - width - caret < 0) {
    return true;
  }
}
__name(doesNotFitWithAlign, "doesNotFitWithAlign");
function determineXAlign(chart, options, size, yAlign) {
  const { x: x2, width } = size;
  const { width: chartWidth, chartArea: { left, right } } = chart;
  let xAlign = "center";
  if (yAlign === "center") {
    xAlign = x2 <= (left + right) / 2 ? "left" : "right";
  } else if (x2 <= width / 2) {
    xAlign = "left";
  } else if (x2 >= chartWidth - width / 2) {
    xAlign = "right";
  }
  if (doesNotFitWithAlign(xAlign, chart, options, size)) {
    xAlign = "center";
  }
  return xAlign;
}
__name(determineXAlign, "determineXAlign");
function determineAlignment(chart, options, size) {
  const yAlign = size.yAlign || options.yAlign || determineYAlign(chart, size);
  return {
    xAlign: size.xAlign || options.xAlign || determineXAlign(chart, options, size, yAlign),
    yAlign
  };
}
__name(determineAlignment, "determineAlignment");
function alignX(size, xAlign) {
  let { x: x2, width } = size;
  if (xAlign === "right") {
    x2 -= width;
  } else if (xAlign === "center") {
    x2 -= width / 2;
  }
  return x2;
}
__name(alignX, "alignX");
function alignY(size, yAlign, paddingAndSize) {
  let { y: y2, height } = size;
  if (yAlign === "top") {
    y2 += paddingAndSize;
  } else if (yAlign === "bottom") {
    y2 -= height + paddingAndSize;
  } else {
    y2 -= height / 2;
  }
  return y2;
}
__name(alignY, "alignY");
function getBackgroundPoint(options, size, alignment, chart) {
  const { caretSize, caretPadding, cornerRadius } = options;
  const { xAlign, yAlign } = alignment;
  const paddingAndSize = caretSize + caretPadding;
  const { topLeft, topRight, bottomLeft, bottomRight } = toTRBLCorners(cornerRadius);
  let x2 = alignX(size, xAlign);
  const y2 = alignY(size, yAlign, paddingAndSize);
  if (yAlign === "center") {
    if (xAlign === "left") {
      x2 += paddingAndSize;
    } else if (xAlign === "right") {
      x2 -= paddingAndSize;
    }
  } else if (xAlign === "left") {
    x2 -= Math.max(topLeft, bottomLeft) + caretSize;
  } else if (xAlign === "right") {
    x2 += Math.max(topRight, bottomRight) + caretSize;
  }
  return {
    x: _limitValue(x2, 0, chart.width - size.width),
    y: _limitValue(y2, 0, chart.height - size.height)
  };
}
__name(getBackgroundPoint, "getBackgroundPoint");
function getAlignedX(tooltip, align, options) {
  const padding = toPadding(options.padding);
  return align === "center" ? tooltip.x + tooltip.width / 2 : align === "right" ? tooltip.x + tooltip.width - padding.right : tooltip.x + padding.left;
}
__name(getAlignedX, "getAlignedX");
function getBeforeAfterBodyLines(callback2) {
  return pushOrConcat([], splitNewlines(callback2));
}
__name(getBeforeAfterBodyLines, "getBeforeAfterBodyLines");
function createTooltipContext(parent, tooltip, tooltipItems) {
  return createContext(parent, {
    tooltip,
    tooltipItems,
    type: "tooltip"
  });
}
__name(createTooltipContext, "createTooltipContext");
function overrideCallbacks(callbacks, context) {
  const override = context && context.dataset && context.dataset.tooltip && context.dataset.tooltip.callbacks;
  return override ? callbacks.override(override) : callbacks;
}
__name(overrideCallbacks, "overrideCallbacks");
const defaultCallbacks = {
  beforeTitle: noop,
  title(tooltipItems) {
    if (tooltipItems.length > 0) {
      const item = tooltipItems[0];
      const labels = item.chart.data.labels;
      const labelCount = labels ? labels.length : 0;
      if (this && this.options && this.options.mode === "dataset") {
        return item.dataset.label || "";
      } else if (item.label) {
        return item.label;
      } else if (labelCount > 0 && item.dataIndex < labelCount) {
        return labels[item.dataIndex];
      }
    }
    return "";
  },
  afterTitle: noop,
  beforeBody: noop,
  beforeLabel: noop,
  label(tooltipItem) {
    if (this && this.options && this.options.mode === "dataset") {
      return tooltipItem.label + ": " + tooltipItem.formattedValue || tooltipItem.formattedValue;
    }
    let label = tooltipItem.dataset.label || "";
    if (label) {
      label += ": ";
    }
    const value = tooltipItem.formattedValue;
    if (!isNullOrUndef(value)) {
      label += value;
    }
    return label;
  },
  labelColor(tooltipItem) {
    const meta = tooltipItem.chart.getDatasetMeta(tooltipItem.datasetIndex);
    const options = meta.controller.getStyle(tooltipItem.dataIndex);
    return {
      borderColor: options.borderColor,
      backgroundColor: options.backgroundColor,
      borderWidth: options.borderWidth,
      borderDash: options.borderDash,
      borderDashOffset: options.borderDashOffset,
      borderRadius: 0
    };
  },
  labelTextColor() {
    return this.options.bodyColor;
  },
  labelPointStyle(tooltipItem) {
    const meta = tooltipItem.chart.getDatasetMeta(tooltipItem.datasetIndex);
    const options = meta.controller.getStyle(tooltipItem.dataIndex);
    return {
      pointStyle: options.pointStyle,
      rotation: options.rotation
    };
  },
  afterLabel: noop,
  afterBody: noop,
  beforeFooter: noop,
  footer: noop,
  afterFooter: noop
};
function invokeCallbackWithFallback(callbacks, name, ctx, arg) {
  const result = callbacks[name].call(ctx, arg);
  if (typeof result === "undefined") {
    return defaultCallbacks[name].call(ctx, arg);
  }
  return result;
}
__name(invokeCallbackWithFallback, "invokeCallbackWithFallback");
const _Tooltip = class _Tooltip extends Element {
  constructor(config) {
    super();
    this.opacity = 0;
    this._active = [];
    this._eventPosition = void 0;
    this._size = void 0;
    this._cachedAnimations = void 0;
    this._tooltipItems = [];
    this.$animations = void 0;
    this.$context = void 0;
    this.chart = config.chart;
    this.options = config.options;
    this.dataPoints = void 0;
    this.title = void 0;
    this.beforeBody = void 0;
    this.body = void 0;
    this.afterBody = void 0;
    this.footer = void 0;
    this.xAlign = void 0;
    this.yAlign = void 0;
    this.x = void 0;
    this.y = void 0;
    this.height = void 0;
    this.width = void 0;
    this.caretX = void 0;
    this.caretY = void 0;
    this.labelColors = void 0;
    this.labelPointStyles = void 0;
    this.labelTextColors = void 0;
  }
  initialize(options) {
    this.options = options;
    this._cachedAnimations = void 0;
    this.$context = void 0;
  }
  _resolveAnimations() {
    const cached = this._cachedAnimations;
    if (cached) {
      return cached;
    }
    const chart = this.chart;
    const options = this.options.setContext(this.getContext());
    const opts = options.enabled && chart.options.animation && options.animations;
    const animations = new Animations(this.chart, opts);
    if (opts._cacheable) {
      this._cachedAnimations = Object.freeze(animations);
    }
    return animations;
  }
  getContext() {
    return this.$context || (this.$context = createTooltipContext(this.chart.getContext(), this, this._tooltipItems));
  }
  getTitle(context, options) {
    const { callbacks } = options;
    const beforeTitle = invokeCallbackWithFallback(callbacks, "beforeTitle", this, context);
    const title = invokeCallbackWithFallback(callbacks, "title", this, context);
    const afterTitle = invokeCallbackWithFallback(callbacks, "afterTitle", this, context);
    let lines = [];
    lines = pushOrConcat(lines, splitNewlines(beforeTitle));
    lines = pushOrConcat(lines, splitNewlines(title));
    lines = pushOrConcat(lines, splitNewlines(afterTitle));
    return lines;
  }
  getBeforeBody(tooltipItems, options) {
    return getBeforeAfterBodyLines(invokeCallbackWithFallback(options.callbacks, "beforeBody", this, tooltipItems));
  }
  getBody(tooltipItems, options) {
    const { callbacks } = options;
    const bodyItems = [];
    each(tooltipItems, (context) => {
      const bodyItem = {
        before: [],
        lines: [],
        after: []
      };
      const scoped = overrideCallbacks(callbacks, context);
      pushOrConcat(bodyItem.before, splitNewlines(invokeCallbackWithFallback(scoped, "beforeLabel", this, context)));
      pushOrConcat(bodyItem.lines, invokeCallbackWithFallback(scoped, "label", this, context));
      pushOrConcat(bodyItem.after, splitNewlines(invokeCallbackWithFallback(scoped, "afterLabel", this, context)));
      bodyItems.push(bodyItem);
    });
    return bodyItems;
  }
  getAfterBody(tooltipItems, options) {
    return getBeforeAfterBodyLines(invokeCallbackWithFallback(options.callbacks, "afterBody", this, tooltipItems));
  }
  getFooter(tooltipItems, options) {
    const { callbacks } = options;
    const beforeFooter = invokeCallbackWithFallback(callbacks, "beforeFooter", this, tooltipItems);
    const footer = invokeCallbackWithFallback(callbacks, "footer", this, tooltipItems);
    const afterFooter = invokeCallbackWithFallback(callbacks, "afterFooter", this, tooltipItems);
    let lines = [];
    lines = pushOrConcat(lines, splitNewlines(beforeFooter));
    lines = pushOrConcat(lines, splitNewlines(footer));
    lines = pushOrConcat(lines, splitNewlines(afterFooter));
    return lines;
  }
  _createItems(options) {
    const active = this._active;
    const data = this.chart.data;
    const labelColors = [];
    const labelPointStyles = [];
    const labelTextColors = [];
    let tooltipItems = [];
    let i2, len;
    for (i2 = 0, len = active.length; i2 < len; ++i2) {
      tooltipItems.push(createTooltipItem(this.chart, active[i2]));
    }
    if (options.filter) {
      tooltipItems = tooltipItems.filter((element, index2, array) => options.filter(element, index2, array, data));
    }
    if (options.itemSort) {
      tooltipItems = tooltipItems.sort((a2, b2) => options.itemSort(a2, b2, data));
    }
    each(tooltipItems, (context) => {
      const scoped = overrideCallbacks(options.callbacks, context);
      labelColors.push(invokeCallbackWithFallback(scoped, "labelColor", this, context));
      labelPointStyles.push(invokeCallbackWithFallback(scoped, "labelPointStyle", this, context));
      labelTextColors.push(invokeCallbackWithFallback(scoped, "labelTextColor", this, context));
    });
    this.labelColors = labelColors;
    this.labelPointStyles = labelPointStyles;
    this.labelTextColors = labelTextColors;
    this.dataPoints = tooltipItems;
    return tooltipItems;
  }
  update(changed, replay) {
    const options = this.options.setContext(this.getContext());
    const active = this._active;
    let properties;
    let tooltipItems = [];
    if (!active.length) {
      if (this.opacity !== 0) {
        properties = {
          opacity: 0
        };
      }
    } else {
      const position = positioners[options.position].call(this, active, this._eventPosition);
      tooltipItems = this._createItems(options);
      this.title = this.getTitle(tooltipItems, options);
      this.beforeBody = this.getBeforeBody(tooltipItems, options);
      this.body = this.getBody(tooltipItems, options);
      this.afterBody = this.getAfterBody(tooltipItems, options);
      this.footer = this.getFooter(tooltipItems, options);
      const size = this._size = getTooltipSize(this, options);
      const positionAndSize = Object.assign({}, position, size);
      const alignment = determineAlignment(this.chart, options, positionAndSize);
      const backgroundPoint = getBackgroundPoint(options, positionAndSize, alignment, this.chart);
      this.xAlign = alignment.xAlign;
      this.yAlign = alignment.yAlign;
      properties = {
        opacity: 1,
        x: backgroundPoint.x,
        y: backgroundPoint.y,
        width: size.width,
        height: size.height,
        caretX: position.x,
        caretY: position.y
      };
    }
    this._tooltipItems = tooltipItems;
    this.$context = void 0;
    if (properties) {
      this._resolveAnimations().update(this, properties);
    }
    if (changed && options.external) {
      options.external.call(this, {
        chart: this.chart,
        tooltip: this,
        replay
      });
    }
  }
  drawCaret(tooltipPoint, ctx, size, options) {
    const caretPosition = this.getCaretPosition(tooltipPoint, size, options);
    ctx.lineTo(caretPosition.x1, caretPosition.y1);
    ctx.lineTo(caretPosition.x2, caretPosition.y2);
    ctx.lineTo(caretPosition.x3, caretPosition.y3);
  }
  getCaretPosition(tooltipPoint, size, options) {
    const { xAlign, yAlign } = this;
    const { caretSize, cornerRadius } = options;
    const { topLeft, topRight, bottomLeft, bottomRight } = toTRBLCorners(cornerRadius);
    const { x: ptX, y: ptY } = tooltipPoint;
    const { width, height } = size;
    let x1, x2, x3, y1, y2, y3;
    if (yAlign === "center") {
      y2 = ptY + height / 2;
      if (xAlign === "left") {
        x1 = ptX;
        x2 = x1 - caretSize;
        y1 = y2 + caretSize;
        y3 = y2 - caretSize;
      } else {
        x1 = ptX + width;
        x2 = x1 + caretSize;
        y1 = y2 - caretSize;
        y3 = y2 + caretSize;
      }
      x3 = x1;
    } else {
      if (xAlign === "left") {
        x2 = ptX + Math.max(topLeft, bottomLeft) + caretSize;
      } else if (xAlign === "right") {
        x2 = ptX + width - Math.max(topRight, bottomRight) - caretSize;
      } else {
        x2 = this.caretX;
      }
      if (yAlign === "top") {
        y1 = ptY;
        y2 = y1 - caretSize;
        x1 = x2 - caretSize;
        x3 = x2 + caretSize;
      } else {
        y1 = ptY + height;
        y2 = y1 + caretSize;
        x1 = x2 + caretSize;
        x3 = x2 - caretSize;
      }
      y3 = y1;
    }
    return {
      x1,
      x2,
      x3,
      y1,
      y2,
      y3
    };
  }
  drawTitle(pt2, ctx, options) {
    const title = this.title;
    const length = title.length;
    let titleFont, titleSpacing, i2;
    if (length) {
      const rtlHelper = getRtlAdapter(options.rtl, this.x, this.width);
      pt2.x = getAlignedX(this, options.titleAlign, options);
      ctx.textAlign = rtlHelper.textAlign(options.titleAlign);
      ctx.textBaseline = "middle";
      titleFont = toFont(options.titleFont);
      titleSpacing = options.titleSpacing;
      ctx.fillStyle = options.titleColor;
      ctx.font = titleFont.string;
      for (i2 = 0; i2 < length; ++i2) {
        ctx.fillText(title[i2], rtlHelper.x(pt2.x), pt2.y + titleFont.lineHeight / 2);
        pt2.y += titleFont.lineHeight + titleSpacing;
        if (i2 + 1 === length) {
          pt2.y += options.titleMarginBottom - titleSpacing;
        }
      }
    }
  }
  _drawColorBox(ctx, pt2, i2, rtlHelper, options) {
    const labelColor = this.labelColors[i2];
    const labelPointStyle = this.labelPointStyles[i2];
    const { boxHeight, boxWidth } = options;
    const bodyFont = toFont(options.bodyFont);
    const colorX = getAlignedX(this, "left", options);
    const rtlColorX = rtlHelper.x(colorX);
    const yOffSet = boxHeight < bodyFont.lineHeight ? (bodyFont.lineHeight - boxHeight) / 2 : 0;
    const colorY = pt2.y + yOffSet;
    if (options.usePointStyle) {
      const drawOptions = {
        radius: Math.min(boxWidth, boxHeight) / 2,
        pointStyle: labelPointStyle.pointStyle,
        rotation: labelPointStyle.rotation,
        borderWidth: 1
      };
      const centerX = rtlHelper.leftForLtr(rtlColorX, boxWidth) + boxWidth / 2;
      const centerY = colorY + boxHeight / 2;
      ctx.strokeStyle = options.multiKeyBackground;
      ctx.fillStyle = options.multiKeyBackground;
      drawPoint(ctx, drawOptions, centerX, centerY);
      ctx.strokeStyle = labelColor.borderColor;
      ctx.fillStyle = labelColor.backgroundColor;
      drawPoint(ctx, drawOptions, centerX, centerY);
    } else {
      ctx.lineWidth = isObject(labelColor.borderWidth) ? Math.max(...Object.values(labelColor.borderWidth)) : labelColor.borderWidth || 1;
      ctx.strokeStyle = labelColor.borderColor;
      ctx.setLineDash(labelColor.borderDash || []);
      ctx.lineDashOffset = labelColor.borderDashOffset || 0;
      const outerX = rtlHelper.leftForLtr(rtlColorX, boxWidth);
      const innerX = rtlHelper.leftForLtr(rtlHelper.xPlus(rtlColorX, 1), boxWidth - 2);
      const borderRadius = toTRBLCorners(labelColor.borderRadius);
      if (Object.values(borderRadius).some((v2) => v2 !== 0)) {
        ctx.beginPath();
        ctx.fillStyle = options.multiKeyBackground;
        addRoundedRectPath(ctx, {
          x: outerX,
          y: colorY,
          w: boxWidth,
          h: boxHeight,
          radius: borderRadius
        });
        ctx.fill();
        ctx.stroke();
        ctx.fillStyle = labelColor.backgroundColor;
        ctx.beginPath();
        addRoundedRectPath(ctx, {
          x: innerX,
          y: colorY + 1,
          w: boxWidth - 2,
          h: boxHeight - 2,
          radius: borderRadius
        });
        ctx.fill();
      } else {
        ctx.fillStyle = options.multiKeyBackground;
        ctx.fillRect(outerX, colorY, boxWidth, boxHeight);
        ctx.strokeRect(outerX, colorY, boxWidth, boxHeight);
        ctx.fillStyle = labelColor.backgroundColor;
        ctx.fillRect(innerX, colorY + 1, boxWidth - 2, boxHeight - 2);
      }
    }
    ctx.fillStyle = this.labelTextColors[i2];
  }
  drawBody(pt2, ctx, options) {
    const { body } = this;
    const { bodySpacing, bodyAlign, displayColors, boxHeight, boxWidth, boxPadding } = options;
    const bodyFont = toFont(options.bodyFont);
    let bodyLineHeight = bodyFont.lineHeight;
    let xLinePadding = 0;
    const rtlHelper = getRtlAdapter(options.rtl, this.x, this.width);
    const fillLineOfText = /* @__PURE__ */ __name(function(line) {
      ctx.fillText(line, rtlHelper.x(pt2.x + xLinePadding), pt2.y + bodyLineHeight / 2);
      pt2.y += bodyLineHeight + bodySpacing;
    }, "fillLineOfText");
    const bodyAlignForCalculation = rtlHelper.textAlign(bodyAlign);
    let bodyItem, textColor, lines, i2, j2, ilen, jlen;
    ctx.textAlign = bodyAlign;
    ctx.textBaseline = "middle";
    ctx.font = bodyFont.string;
    pt2.x = getAlignedX(this, bodyAlignForCalculation, options);
    ctx.fillStyle = options.bodyColor;
    each(this.beforeBody, fillLineOfText);
    xLinePadding = displayColors && bodyAlignForCalculation !== "right" ? bodyAlign === "center" ? boxWidth / 2 + boxPadding : boxWidth + 2 + boxPadding : 0;
    for (i2 = 0, ilen = body.length; i2 < ilen; ++i2) {
      bodyItem = body[i2];
      textColor = this.labelTextColors[i2];
      ctx.fillStyle = textColor;
      each(bodyItem.before, fillLineOfText);
      lines = bodyItem.lines;
      if (displayColors && lines.length) {
        this._drawColorBox(ctx, pt2, i2, rtlHelper, options);
        bodyLineHeight = Math.max(bodyFont.lineHeight, boxHeight);
      }
      for (j2 = 0, jlen = lines.length; j2 < jlen; ++j2) {
        fillLineOfText(lines[j2]);
        bodyLineHeight = bodyFont.lineHeight;
      }
      each(bodyItem.after, fillLineOfText);
    }
    xLinePadding = 0;
    bodyLineHeight = bodyFont.lineHeight;
    each(this.afterBody, fillLineOfText);
    pt2.y -= bodySpacing;
  }
  drawFooter(pt2, ctx, options) {
    const footer = this.footer;
    const length = footer.length;
    let footerFont, i2;
    if (length) {
      const rtlHelper = getRtlAdapter(options.rtl, this.x, this.width);
      pt2.x = getAlignedX(this, options.footerAlign, options);
      pt2.y += options.footerMarginTop;
      ctx.textAlign = rtlHelper.textAlign(options.footerAlign);
      ctx.textBaseline = "middle";
      footerFont = toFont(options.footerFont);
      ctx.fillStyle = options.footerColor;
      ctx.font = footerFont.string;
      for (i2 = 0; i2 < length; ++i2) {
        ctx.fillText(footer[i2], rtlHelper.x(pt2.x), pt2.y + footerFont.lineHeight / 2);
        pt2.y += footerFont.lineHeight + options.footerSpacing;
      }
    }
  }
  drawBackground(pt2, ctx, tooltipSize, options) {
    const { xAlign, yAlign } = this;
    const { x: x2, y: y2 } = pt2;
    const { width, height } = tooltipSize;
    const { topLeft, topRight, bottomLeft, bottomRight } = toTRBLCorners(options.cornerRadius);
    ctx.fillStyle = options.backgroundColor;
    ctx.strokeStyle = options.borderColor;
    ctx.lineWidth = options.borderWidth;
    ctx.beginPath();
    ctx.moveTo(x2 + topLeft, y2);
    if (yAlign === "top") {
      this.drawCaret(pt2, ctx, tooltipSize, options);
    }
    ctx.lineTo(x2 + width - topRight, y2);
    ctx.quadraticCurveTo(x2 + width, y2, x2 + width, y2 + topRight);
    if (yAlign === "center" && xAlign === "right") {
      this.drawCaret(pt2, ctx, tooltipSize, options);
    }
    ctx.lineTo(x2 + width, y2 + height - bottomRight);
    ctx.quadraticCurveTo(x2 + width, y2 + height, x2 + width - bottomRight, y2 + height);
    if (yAlign === "bottom") {
      this.drawCaret(pt2, ctx, tooltipSize, options);
    }
    ctx.lineTo(x2 + bottomLeft, y2 + height);
    ctx.quadraticCurveTo(x2, y2 + height, x2, y2 + height - bottomLeft);
    if (yAlign === "center" && xAlign === "left") {
      this.drawCaret(pt2, ctx, tooltipSize, options);
    }
    ctx.lineTo(x2, y2 + topLeft);
    ctx.quadraticCurveTo(x2, y2, x2 + topLeft, y2);
    ctx.closePath();
    ctx.fill();
    if (options.borderWidth > 0) {
      ctx.stroke();
    }
  }
  _updateAnimationTarget(options) {
    const chart = this.chart;
    const anims = this.$animations;
    const animX = anims && anims.x;
    const animY = anims && anims.y;
    if (animX || animY) {
      const position = positioners[options.position].call(this, this._active, this._eventPosition);
      if (!position) {
        return;
      }
      const size = this._size = getTooltipSize(this, options);
      const positionAndSize = Object.assign({}, position, this._size);
      const alignment = determineAlignment(chart, options, positionAndSize);
      const point = getBackgroundPoint(options, positionAndSize, alignment, chart);
      if (animX._to !== point.x || animY._to !== point.y) {
        this.xAlign = alignment.xAlign;
        this.yAlign = alignment.yAlign;
        this.width = size.width;
        this.height = size.height;
        this.caretX = position.x;
        this.caretY = position.y;
        this._resolveAnimations().update(this, point);
      }
    }
  }
  _willRender() {
    return !!this.opacity;
  }
  draw(ctx) {
    const options = this.options.setContext(this.getContext());
    let opacity = this.opacity;
    if (!opacity) {
      return;
    }
    this._updateAnimationTarget(options);
    const tooltipSize = {
      width: this.width,
      height: this.height
    };
    const pt2 = {
      x: this.x,
      y: this.y
    };
    opacity = Math.abs(opacity) < 1e-3 ? 0 : opacity;
    const padding = toPadding(options.padding);
    const hasTooltipContent = this.title.length || this.beforeBody.length || this.body.length || this.afterBody.length || this.footer.length;
    if (options.enabled && hasTooltipContent) {
      ctx.save();
      ctx.globalAlpha = opacity;
      this.drawBackground(pt2, ctx, tooltipSize, options);
      overrideTextDirection(ctx, options.textDirection);
      pt2.y += padding.top;
      this.drawTitle(pt2, ctx, options);
      this.drawBody(pt2, ctx, options);
      this.drawFooter(pt2, ctx, options);
      restoreTextDirection(ctx, options.textDirection);
      ctx.restore();
    }
  }
  getActiveElements() {
    return this._active || [];
  }
  setActiveElements(activeElements, eventPosition) {
    const lastActive = this._active;
    const active = activeElements.map(({ datasetIndex, index: index2 }) => {
      const meta = this.chart.getDatasetMeta(datasetIndex);
      if (!meta) {
        throw new Error("Cannot find a dataset at index " + datasetIndex);
      }
      return {
        datasetIndex,
        element: meta.data[index2],
        index: index2
      };
    });
    const changed = !_elementsEqual(lastActive, active);
    const positionChanged = this._positionChanged(active, eventPosition);
    if (changed || positionChanged) {
      this._active = active;
      this._eventPosition = eventPosition;
      this._ignoreReplayEvents = true;
      this.update(true);
    }
  }
  handleEvent(e, replay, inChartArea = true) {
    if (replay && this._ignoreReplayEvents) {
      return false;
    }
    this._ignoreReplayEvents = false;
    const options = this.options;
    const lastActive = this._active || [];
    const active = this._getActiveElements(e, lastActive, replay, inChartArea);
    const positionChanged = this._positionChanged(active, e);
    const changed = replay || !_elementsEqual(active, lastActive) || positionChanged;
    if (changed) {
      this._active = active;
      if (options.enabled || options.external) {
        this._eventPosition = {
          x: e.x,
          y: e.y
        };
        this.update(true, replay);
      }
    }
    return changed;
  }
  _getActiveElements(e, lastActive, replay, inChartArea) {
    const options = this.options;
    if (e.type === "mouseout") {
      return [];
    }
    if (!inChartArea) {
      return lastActive.filter((i2) => this.chart.data.datasets[i2.datasetIndex] && this.chart.getDatasetMeta(i2.datasetIndex).controller.getParsed(i2.index) !== void 0);
    }
    const active = this.chart.getElementsAtEventForMode(e, options.mode, options, replay);
    if (options.reverse) {
      active.reverse();
    }
    return active;
  }
  _positionChanged(active, e) {
    const { caretX, caretY, options } = this;
    const position = positioners[options.position].call(this, active, e);
    return position !== false && (caretX !== position.x || caretY !== position.y);
  }
};
__name(_Tooltip, "Tooltip");
__publicField(_Tooltip, "positioners", positioners);
let Tooltip = _Tooltip;
var plugin_tooltip = {
  id: "tooltip",
  _element: Tooltip,
  positioners,
  afterInit(chart, _args, options) {
    if (options) {
      chart.tooltip = new Tooltip({
        chart,
        options
      });
    }
  },
  beforeUpdate(chart, _args, options) {
    if (chart.tooltip) {
      chart.tooltip.initialize(options);
    }
  },
  reset(chart, _args, options) {
    if (chart.tooltip) {
      chart.tooltip.initialize(options);
    }
  },
  afterDraw(chart) {
    const tooltip = chart.tooltip;
    if (tooltip && tooltip._willRender()) {
      const args = {
        tooltip
      };
      if (chart.notifyPlugins("beforeTooltipDraw", {
        ...args,
        cancelable: true
      }) === false) {
        return;
      }
      tooltip.draw(chart.ctx);
      chart.notifyPlugins("afterTooltipDraw", args);
    }
  },
  afterEvent(chart, args) {
    if (chart.tooltip) {
      const useFinalPosition = args.replay;
      if (chart.tooltip.handleEvent(args.event, useFinalPosition, args.inChartArea)) {
        args.changed = true;
      }
    }
  },
  defaults: {
    enabled: true,
    external: null,
    position: "average",
    backgroundColor: "rgba(0,0,0,0.8)",
    titleColor: "#fff",
    titleFont: {
      weight: "bold"
    },
    titleSpacing: 2,
    titleMarginBottom: 6,
    titleAlign: "left",
    bodyColor: "#fff",
    bodySpacing: 2,
    bodyFont: {},
    bodyAlign: "left",
    footerColor: "#fff",
    footerSpacing: 2,
    footerMarginTop: 6,
    footerFont: {
      weight: "bold"
    },
    footerAlign: "left",
    padding: 6,
    caretPadding: 2,
    caretSize: 5,
    cornerRadius: 6,
    boxHeight: (ctx, opts) => opts.bodyFont.size,
    boxWidth: (ctx, opts) => opts.bodyFont.size,
    multiKeyBackground: "#fff",
    displayColors: true,
    boxPadding: 0,
    borderColor: "rgba(0,0,0,0)",
    borderWidth: 0,
    animation: {
      duration: 400,
      easing: "easeOutQuart"
    },
    animations: {
      numbers: {
        type: "number",
        properties: [
          "x",
          "y",
          "width",
          "height",
          "caretX",
          "caretY"
        ]
      },
      opacity: {
        easing: "linear",
        duration: 200
      }
    },
    callbacks: defaultCallbacks
  },
  defaultRoutes: {
    bodyFont: "font",
    footerFont: "font",
    titleFont: "font"
  },
  descriptors: {
    _scriptable: (name) => name !== "filter" && name !== "itemSort" && name !== "external",
    _indexable: false,
    callbacks: {
      _scriptable: false,
      _indexable: false
    },
    animation: {
      _fallback: false
    },
    animations: {
      _fallback: "animation"
    }
  },
  additionalOptionScopes: [
    "interaction"
  ]
};
const addIfString = /* @__PURE__ */ __name((labels, raw, index2, addedLabels) => {
  if (typeof raw === "string") {
    index2 = labels.push(raw) - 1;
    addedLabels.unshift({
      index: index2,
      label: raw
    });
  } else if (isNaN(raw)) {
    index2 = null;
  }
  return index2;
}, "addIfString");
function findOrAddLabel(labels, raw, index2, addedLabels) {
  const first = labels.indexOf(raw);
  if (first === -1) {
    return addIfString(labels, raw, index2, addedLabels);
  }
  const last = labels.lastIndexOf(raw);
  return first !== last ? index2 : first;
}
__name(findOrAddLabel, "findOrAddLabel");
const validIndex = /* @__PURE__ */ __name((index2, max2) => index2 === null ? null : _limitValue(Math.round(index2), 0, max2), "validIndex");
function _getLabelForValue(value) {
  const labels = this.getLabels();
  if (value >= 0 && value < labels.length) {
    return labels[value];
  }
  return value;
}
__name(_getLabelForValue, "_getLabelForValue");
const _CategoryScale = class _CategoryScale extends Scale {
  constructor(cfg) {
    super(cfg);
    this._startValue = void 0;
    this._valueRange = 0;
    this._addedLabels = [];
  }
  init(scaleOptions) {
    const added = this._addedLabels;
    if (added.length) {
      const labels = this.getLabels();
      for (const { index: index2, label } of added) {
        if (labels[index2] === label) {
          labels.splice(index2, 1);
        }
      }
      this._addedLabels = [];
    }
    super.init(scaleOptions);
  }
  parse(raw, index2) {
    if (isNullOrUndef(raw)) {
      return null;
    }
    const labels = this.getLabels();
    index2 = isFinite(index2) && labels[index2] === raw ? index2 : findOrAddLabel(labels, raw, valueOrDefault(index2, raw), this._addedLabels);
    return validIndex(index2, labels.length - 1);
  }
  determineDataLimits() {
    const { minDefined, maxDefined } = this.getUserBounds();
    let { min, max: max2 } = this.getMinMax(true);
    if (this.options.bounds === "ticks") {
      if (!minDefined) {
        min = 0;
      }
      if (!maxDefined) {
        max2 = this.getLabels().length - 1;
      }
    }
    this.min = min;
    this.max = max2;
  }
  buildTicks() {
    const min = this.min;
    const max2 = this.max;
    const offset = this.options.offset;
    const ticks = [];
    let labels = this.getLabels();
    labels = min === 0 && max2 === labels.length - 1 ? labels : labels.slice(min, max2 + 1);
    this._valueRange = Math.max(labels.length - (offset ? 0 : 1), 1);
    this._startValue = this.min - (offset ? 0.5 : 0);
    for (let value = min; value <= max2; value++) {
      ticks.push({
        value
      });
    }
    return ticks;
  }
  getLabelForValue(value) {
    return _getLabelForValue.call(this, value);
  }
  configure() {
    super.configure();
    if (!this.isHorizontal()) {
      this._reversePixels = !this._reversePixels;
    }
  }
  getPixelForValue(value) {
    if (typeof value !== "number") {
      value = this.parse(value);
    }
    return value === null ? NaN : this.getPixelForDecimal((value - this._startValue) / this._valueRange);
  }
  getPixelForTick(index2) {
    const ticks = this.ticks;
    if (index2 < 0 || index2 > ticks.length - 1) {
      return null;
    }
    return this.getPixelForValue(ticks[index2].value);
  }
  getValueForPixel(pixel) {
    return Math.round(this._startValue + this.getDecimalForPixel(pixel) * this._valueRange);
  }
  getBasePixel() {
    return this.bottom;
  }
};
__name(_CategoryScale, "CategoryScale");
__publicField(_CategoryScale, "id", "category");
__publicField(_CategoryScale, "defaults", {
  ticks: {
    callback: _getLabelForValue
  }
});
let CategoryScale = _CategoryScale;
function generateTicks$1(generationOptions, dataRange) {
  const ticks = [];
  const MIN_SPACING = 1e-14;
  const { bounds, step, min, max: max2, precision, count, maxTicks, maxDigits, includeBounds } = generationOptions;
  const unit = step || 1;
  const maxSpaces = maxTicks - 1;
  const { min: rmin, max: rmax } = dataRange;
  const minDefined = !isNullOrUndef(min);
  const maxDefined = !isNullOrUndef(max2);
  const countDefined = !isNullOrUndef(count);
  const minSpacing = (rmax - rmin) / (maxDigits + 1);
  let spacing = niceNum((rmax - rmin) / maxSpaces / unit) * unit;
  let factor, niceMin, niceMax, numSpaces;
  if (spacing < MIN_SPACING && !minDefined && !maxDefined) {
    return [
      {
        value: rmin
      },
      {
        value: rmax
      }
    ];
  }
  numSpaces = Math.ceil(rmax / spacing) - Math.floor(rmin / spacing);
  if (numSpaces > maxSpaces) {
    spacing = niceNum(numSpaces * spacing / maxSpaces / unit) * unit;
  }
  if (!isNullOrUndef(precision)) {
    factor = Math.pow(10, precision);
    spacing = Math.ceil(spacing * factor) / factor;
  }
  if (bounds === "ticks") {
    niceMin = Math.floor(rmin / spacing) * spacing;
    niceMax = Math.ceil(rmax / spacing) * spacing;
  } else {
    niceMin = rmin;
    niceMax = rmax;
  }
  if (minDefined && maxDefined && step && almostWhole((max2 - min) / step, spacing / 1e3)) {
    numSpaces = Math.round(Math.min((max2 - min) / spacing, maxTicks));
    spacing = (max2 - min) / numSpaces;
    niceMin = min;
    niceMax = max2;
  } else if (countDefined) {
    niceMin = minDefined ? min : niceMin;
    niceMax = maxDefined ? max2 : niceMax;
    numSpaces = count - 1;
    spacing = (niceMax - niceMin) / numSpaces;
  } else {
    numSpaces = (niceMax - niceMin) / spacing;
    if (almostEquals(numSpaces, Math.round(numSpaces), spacing / 1e3)) {
      numSpaces = Math.round(numSpaces);
    } else {
      numSpaces = Math.ceil(numSpaces);
    }
  }
  const decimalPlaces = Math.max(_decimalPlaces(spacing), _decimalPlaces(niceMin));
  factor = Math.pow(10, isNullOrUndef(precision) ? decimalPlaces : precision);
  niceMin = Math.round(niceMin * factor) / factor;
  niceMax = Math.round(niceMax * factor) / factor;
  let j2 = 0;
  if (minDefined) {
    if (includeBounds && niceMin !== min) {
      ticks.push({
        value: min
      });
      if (niceMin < min) {
        j2++;
      }
      if (almostEquals(Math.round((niceMin + j2 * spacing) * factor) / factor, min, relativeLabelSize(min, minSpacing, generationOptions))) {
        j2++;
      }
    } else if (niceMin < min) {
      j2++;
    }
  }
  for (; j2 < numSpaces; ++j2) {
    const tickValue = Math.round((niceMin + j2 * spacing) * factor) / factor;
    if (maxDefined && tickValue > max2) {
      break;
    }
    ticks.push({
      value: tickValue
    });
  }
  if (maxDefined && includeBounds && niceMax !== max2) {
    if (ticks.length && almostEquals(ticks[ticks.length - 1].value, max2, relativeLabelSize(max2, minSpacing, generationOptions))) {
      ticks[ticks.length - 1].value = max2;
    } else {
      ticks.push({
        value: max2
      });
    }
  } else if (!maxDefined || niceMax === max2) {
    ticks.push({
      value: niceMax
    });
  }
  return ticks;
}
__name(generateTicks$1, "generateTicks$1");
function relativeLabelSize(value, minSpacing, { horizontal, minRotation }) {
  const rad = toRadians(minRotation);
  const ratio = (horizontal ? Math.sin(rad) : Math.cos(rad)) || 1e-3;
  const length = 0.75 * minSpacing * ("" + value).length;
  return Math.min(minSpacing / ratio, length);
}
__name(relativeLabelSize, "relativeLabelSize");
const _LinearScaleBase = class _LinearScaleBase extends Scale {
  constructor(cfg) {
    super(cfg);
    this.start = void 0;
    this.end = void 0;
    this._startValue = void 0;
    this._endValue = void 0;
    this._valueRange = 0;
  }
  parse(raw, index2) {
    if (isNullOrUndef(raw)) {
      return null;
    }
    if ((typeof raw === "number" || raw instanceof Number) && !isFinite(+raw)) {
      return null;
    }
    return +raw;
  }
  handleTickRangeOptions() {
    const { beginAtZero } = this.options;
    const { minDefined, maxDefined } = this.getUserBounds();
    let { min, max: max2 } = this;
    const setMin = /* @__PURE__ */ __name((v2) => min = minDefined ? min : v2, "setMin");
    const setMax = /* @__PURE__ */ __name((v2) => max2 = maxDefined ? max2 : v2, "setMax");
    if (beginAtZero) {
      const minSign = sign(min);
      const maxSign = sign(max2);
      if (minSign < 0 && maxSign < 0) {
        setMax(0);
      } else if (minSign > 0 && maxSign > 0) {
        setMin(0);
      }
    }
    if (min === max2) {
      let offset = max2 === 0 ? 1 : Math.abs(max2 * 0.05);
      setMax(max2 + offset);
      if (!beginAtZero) {
        setMin(min - offset);
      }
    }
    this.min = min;
    this.max = max2;
  }
  getTickLimit() {
    const tickOpts = this.options.ticks;
    let { maxTicksLimit, stepSize } = tickOpts;
    let maxTicks;
    if (stepSize) {
      maxTicks = Math.ceil(this.max / stepSize) - Math.floor(this.min / stepSize) + 1;
      if (maxTicks > 1e3) {
        console.warn(`scales.${this.id}.ticks.stepSize: ${stepSize} would result generating up to ${maxTicks} ticks. Limiting to 1000.`);
        maxTicks = 1e3;
      }
    } else {
      maxTicks = this.computeTickLimit();
      maxTicksLimit = maxTicksLimit || 11;
    }
    if (maxTicksLimit) {
      maxTicks = Math.min(maxTicksLimit, maxTicks);
    }
    return maxTicks;
  }
  computeTickLimit() {
    return Number.POSITIVE_INFINITY;
  }
  buildTicks() {
    const opts = this.options;
    const tickOpts = opts.ticks;
    let maxTicks = this.getTickLimit();
    maxTicks = Math.max(2, maxTicks);
    const numericGeneratorOptions = {
      maxTicks,
      bounds: opts.bounds,
      min: opts.min,
      max: opts.max,
      precision: tickOpts.precision,
      step: tickOpts.stepSize,
      count: tickOpts.count,
      maxDigits: this._maxDigits(),
      horizontal: this.isHorizontal(),
      minRotation: tickOpts.minRotation || 0,
      includeBounds: tickOpts.includeBounds !== false
    };
    const dataRange = this._range || this;
    const ticks = generateTicks$1(numericGeneratorOptions, dataRange);
    if (opts.bounds === "ticks") {
      _setMinAndMaxByKey(ticks, this, "value");
    }
    if (opts.reverse) {
      ticks.reverse();
      this.start = this.max;
      this.end = this.min;
    } else {
      this.start = this.min;
      this.end = this.max;
    }
    return ticks;
  }
  configure() {
    const ticks = this.ticks;
    let start = this.min;
    let end = this.max;
    super.configure();
    if (this.options.offset && ticks.length) {
      const offset = (end - start) / Math.max(ticks.length - 1, 1) / 2;
      start -= offset;
      end += offset;
    }
    this._startValue = start;
    this._endValue = end;
    this._valueRange = end - start;
  }
  getLabelForValue(value) {
    return formatNumber(value, this.chart.options.locale, this.options.ticks.format);
  }
};
__name(_LinearScaleBase, "LinearScaleBase");
let LinearScaleBase = _LinearScaleBase;
const _LinearScale = class _LinearScale extends LinearScaleBase {
  determineDataLimits() {
    const { min, max: max2 } = this.getMinMax(true);
    this.min = isNumberFinite(min) ? min : 0;
    this.max = isNumberFinite(max2) ? max2 : 1;
    this.handleTickRangeOptions();
  }
  computeTickLimit() {
    const horizontal = this.isHorizontal();
    const length = horizontal ? this.width : this.height;
    const minRotation = toRadians(this.options.ticks.minRotation);
    const ratio = (horizontal ? Math.sin(minRotation) : Math.cos(minRotation)) || 1e-3;
    const tickFont = this._resolveTickFontOptions(0);
    return Math.ceil(length / Math.min(40, tickFont.lineHeight / ratio));
  }
  getPixelForValue(value) {
    return value === null ? NaN : this.getPixelForDecimal((value - this._startValue) / this._valueRange);
  }
  getValueForPixel(pixel) {
    return this._startValue + this.getDecimalForPixel(pixel) * this._valueRange;
  }
};
__name(_LinearScale, "LinearScale");
__publicField(_LinearScale, "id", "linear");
__publicField(_LinearScale, "defaults", {
  ticks: {
    callback: Ticks.formatters.numeric
  }
});
let LinearScale = _LinearScale;
const log10Floor = /* @__PURE__ */ __name((v2) => Math.floor(log10(v2)), "log10Floor");
const changeExponent = /* @__PURE__ */ __name((v2, m2) => Math.pow(10, log10Floor(v2) + m2), "changeExponent");
function isMajor(tickVal) {
  const remain = tickVal / Math.pow(10, log10Floor(tickVal));
  return remain === 1;
}
__name(isMajor, "isMajor");
function steps(min, max2, rangeExp) {
  const rangeStep = Math.pow(10, rangeExp);
  const start = Math.floor(min / rangeStep);
  const end = Math.ceil(max2 / rangeStep);
  return end - start;
}
__name(steps, "steps");
function startExp(min, max2) {
  const range = max2 - min;
  let rangeExp = log10Floor(range);
  while (steps(min, max2, rangeExp) > 10) {
    rangeExp++;
  }
  while (steps(min, max2, rangeExp) < 10) {
    rangeExp--;
  }
  return Math.min(rangeExp, log10Floor(min));
}
__name(startExp, "startExp");
function generateTicks(generationOptions, { min, max: max2 }) {
  min = finiteOrDefault(generationOptions.min, min);
  const ticks = [];
  const minExp = log10Floor(min);
  let exp = startExp(min, max2);
  let precision = exp < 0 ? Math.pow(10, Math.abs(exp)) : 1;
  const stepSize = Math.pow(10, exp);
  const base = minExp > exp ? Math.pow(10, minExp) : 0;
  const start = Math.round((min - base) * precision) / precision;
  const offset = Math.floor((min - base) / stepSize / 10) * stepSize * 10;
  let significand = Math.floor((start - offset) / Math.pow(10, exp));
  let value = finiteOrDefault(generationOptions.min, Math.round((base + offset + significand * Math.pow(10, exp)) * precision) / precision);
  while (value < max2) {
    ticks.push({
      value,
      major: isMajor(value),
      significand
    });
    if (significand >= 10) {
      significand = significand < 15 ? 15 : 20;
    } else {
      significand++;
    }
    if (significand >= 20) {
      exp++;
      significand = 2;
      precision = exp >= 0 ? 1 : precision;
    }
    value = Math.round((base + offset + significand * Math.pow(10, exp)) * precision) / precision;
  }
  const lastTick = finiteOrDefault(generationOptions.max, value);
  ticks.push({
    value: lastTick,
    major: isMajor(lastTick),
    significand
  });
  return ticks;
}
__name(generateTicks, "generateTicks");
const _LogarithmicScale = class _LogarithmicScale extends Scale {
  constructor(cfg) {
    super(cfg);
    this.start = void 0;
    this.end = void 0;
    this._startValue = void 0;
    this._valueRange = 0;
  }
  parse(raw, index2) {
    const value = LinearScaleBase.prototype.parse.apply(this, [
      raw,
      index2
    ]);
    if (value === 0) {
      this._zero = true;
      return void 0;
    }
    return isNumberFinite(value) && value > 0 ? value : null;
  }
  determineDataLimits() {
    const { min, max: max2 } = this.getMinMax(true);
    this.min = isNumberFinite(min) ? Math.max(0, min) : null;
    this.max = isNumberFinite(max2) ? Math.max(0, max2) : null;
    if (this.options.beginAtZero) {
      this._zero = true;
    }
    if (this._zero && this.min !== this._suggestedMin && !isNumberFinite(this._userMin)) {
      this.min = min === changeExponent(this.min, 0) ? changeExponent(this.min, -1) : changeExponent(this.min, 0);
    }
    this.handleTickRangeOptions();
  }
  handleTickRangeOptions() {
    const { minDefined, maxDefined } = this.getUserBounds();
    let min = this.min;
    let max2 = this.max;
    const setMin = /* @__PURE__ */ __name((v2) => min = minDefined ? min : v2, "setMin");
    const setMax = /* @__PURE__ */ __name((v2) => max2 = maxDefined ? max2 : v2, "setMax");
    if (min === max2) {
      if (min <= 0) {
        setMin(1);
        setMax(10);
      } else {
        setMin(changeExponent(min, -1));
        setMax(changeExponent(max2, 1));
      }
    }
    if (min <= 0) {
      setMin(changeExponent(max2, -1));
    }
    if (max2 <= 0) {
      setMax(changeExponent(min, 1));
    }
    this.min = min;
    this.max = max2;
  }
  buildTicks() {
    const opts = this.options;
    const generationOptions = {
      min: this._userMin,
      max: this._userMax
    };
    const ticks = generateTicks(generationOptions, this);
    if (opts.bounds === "ticks") {
      _setMinAndMaxByKey(ticks, this, "value");
    }
    if (opts.reverse) {
      ticks.reverse();
      this.start = this.max;
      this.end = this.min;
    } else {
      this.start = this.min;
      this.end = this.max;
    }
    return ticks;
  }
  getLabelForValue(value) {
    return value === void 0 ? "0" : formatNumber(value, this.chart.options.locale, this.options.ticks.format);
  }
  configure() {
    const start = this.min;
    super.configure();
    this._startValue = log10(start);
    this._valueRange = log10(this.max) - log10(start);
  }
  getPixelForValue(value) {
    if (value === void 0 || value === 0) {
      value = this.min;
    }
    if (value === null || isNaN(value)) {
      return NaN;
    }
    return this.getPixelForDecimal(value === this.min ? 0 : (log10(value) - this._startValue) / this._valueRange);
  }
  getValueForPixel(pixel) {
    const decimal = this.getDecimalForPixel(pixel);
    return Math.pow(10, this._startValue + decimal * this._valueRange);
  }
};
__name(_LogarithmicScale, "LogarithmicScale");
__publicField(_LogarithmicScale, "id", "logarithmic");
__publicField(_LogarithmicScale, "defaults", {
  ticks: {
    callback: Ticks.formatters.logarithmic,
    major: {
      enabled: true
    }
  }
});
let LogarithmicScale = _LogarithmicScale;
function getTickBackdropHeight(opts) {
  const tickOpts = opts.ticks;
  if (tickOpts.display && opts.display) {
    const padding = toPadding(tickOpts.backdropPadding);
    return valueOrDefault(tickOpts.font && tickOpts.font.size, defaults.font.size) + padding.height;
  }
  return 0;
}
__name(getTickBackdropHeight, "getTickBackdropHeight");
function measureLabelSize(ctx, font, label) {
  label = isArray(label) ? label : [
    label
  ];
  return {
    w: _longestText(ctx, font.string, label),
    h: label.length * font.lineHeight
  };
}
__name(measureLabelSize, "measureLabelSize");
function determineLimits(angle, pos, size, min, max2) {
  if (angle === min || angle === max2) {
    return {
      start: pos - size / 2,
      end: pos + size / 2
    };
  } else if (angle < min || angle > max2) {
    return {
      start: pos - size,
      end: pos
    };
  }
  return {
    start: pos,
    end: pos + size
  };
}
__name(determineLimits, "determineLimits");
function fitWithPointLabels(scale) {
  const orig = {
    l: scale.left + scale._padding.left,
    r: scale.right - scale._padding.right,
    t: scale.top + scale._padding.top,
    b: scale.bottom - scale._padding.bottom
  };
  const limits = Object.assign({}, orig);
  const labelSizes = [];
  const padding = [];
  const valueCount = scale._pointLabels.length;
  const pointLabelOpts = scale.options.pointLabels;
  const additionalAngle = pointLabelOpts.centerPointLabels ? PI / valueCount : 0;
  for (let i2 = 0; i2 < valueCount; i2++) {
    const opts = pointLabelOpts.setContext(scale.getPointLabelContext(i2));
    padding[i2] = opts.padding;
    const pointPosition = scale.getPointPosition(i2, scale.drawingArea + padding[i2], additionalAngle);
    const plFont = toFont(opts.font);
    const textSize = measureLabelSize(scale.ctx, plFont, scale._pointLabels[i2]);
    labelSizes[i2] = textSize;
    const angleRadians = _normalizeAngle(scale.getIndexAngle(i2) + additionalAngle);
    const angle = Math.round(toDegrees(angleRadians));
    const hLimits = determineLimits(angle, pointPosition.x, textSize.w, 0, 180);
    const vLimits = determineLimits(angle, pointPosition.y, textSize.h, 90, 270);
    updateLimits(limits, orig, angleRadians, hLimits, vLimits);
  }
  scale.setCenterPoint(orig.l - limits.l, limits.r - orig.r, orig.t - limits.t, limits.b - orig.b);
  scale._pointLabelItems = buildPointLabelItems(scale, labelSizes, padding);
}
__name(fitWithPointLabels, "fitWithPointLabels");
function updateLimits(limits, orig, angle, hLimits, vLimits) {
  const sin = Math.abs(Math.sin(angle));
  const cos = Math.abs(Math.cos(angle));
  let x2 = 0;
  let y2 = 0;
  if (hLimits.start < orig.l) {
    x2 = (orig.l - hLimits.start) / sin;
    limits.l = Math.min(limits.l, orig.l - x2);
  } else if (hLimits.end > orig.r) {
    x2 = (hLimits.end - orig.r) / sin;
    limits.r = Math.max(limits.r, orig.r + x2);
  }
  if (vLimits.start < orig.t) {
    y2 = (orig.t - vLimits.start) / cos;
    limits.t = Math.min(limits.t, orig.t - y2);
  } else if (vLimits.end > orig.b) {
    y2 = (vLimits.end - orig.b) / cos;
    limits.b = Math.max(limits.b, orig.b + y2);
  }
}
__name(updateLimits, "updateLimits");
function createPointLabelItem(scale, index2, itemOpts) {
  const outerDistance = scale.drawingArea;
  const { extra, additionalAngle, padding, size } = itemOpts;
  const pointLabelPosition = scale.getPointPosition(index2, outerDistance + extra + padding, additionalAngle);
  const angle = Math.round(toDegrees(_normalizeAngle(pointLabelPosition.angle + HALF_PI)));
  const y2 = yForAngle(pointLabelPosition.y, size.h, angle);
  const textAlign = getTextAlignForAngle(angle);
  const left = leftForTextAlign(pointLabelPosition.x, size.w, textAlign);
  return {
    visible: true,
    x: pointLabelPosition.x,
    y: y2,
    textAlign,
    left,
    top: y2,
    right: left + size.w,
    bottom: y2 + size.h
  };
}
__name(createPointLabelItem, "createPointLabelItem");
function isNotOverlapped(item, area) {
  if (!area) {
    return true;
  }
  const { left, top, right, bottom } = item;
  const apexesInArea = _isPointInArea({
    x: left,
    y: top
  }, area) || _isPointInArea({
    x: left,
    y: bottom
  }, area) || _isPointInArea({
    x: right,
    y: top
  }, area) || _isPointInArea({
    x: right,
    y: bottom
  }, area);
  return !apexesInArea;
}
__name(isNotOverlapped, "isNotOverlapped");
function buildPointLabelItems(scale, labelSizes, padding) {
  const items = [];
  const valueCount = scale._pointLabels.length;
  const opts = scale.options;
  const { centerPointLabels, display } = opts.pointLabels;
  const itemOpts = {
    extra: getTickBackdropHeight(opts) / 2,
    additionalAngle: centerPointLabels ? PI / valueCount : 0
  };
  let area;
  for (let i2 = 0; i2 < valueCount; i2++) {
    itemOpts.padding = padding[i2];
    itemOpts.size = labelSizes[i2];
    const item = createPointLabelItem(scale, i2, itemOpts);
    items.push(item);
    if (display === "auto") {
      item.visible = isNotOverlapped(item, area);
      if (item.visible) {
        area = item;
      }
    }
  }
  return items;
}
__name(buildPointLabelItems, "buildPointLabelItems");
function getTextAlignForAngle(angle) {
  if (angle === 0 || angle === 180) {
    return "center";
  } else if (angle < 180) {
    return "left";
  }
  return "right";
}
__name(getTextAlignForAngle, "getTextAlignForAngle");
function leftForTextAlign(x2, w2, align) {
  if (align === "right") {
    x2 -= w2;
  } else if (align === "center") {
    x2 -= w2 / 2;
  }
  return x2;
}
__name(leftForTextAlign, "leftForTextAlign");
function yForAngle(y2, h3, angle) {
  if (angle === 90 || angle === 270) {
    y2 -= h3 / 2;
  } else if (angle > 270 || angle < 90) {
    y2 -= h3;
  }
  return y2;
}
__name(yForAngle, "yForAngle");
function drawPointLabelBox(ctx, opts, item) {
  const { left, top, right, bottom } = item;
  const { backdropColor } = opts;
  if (!isNullOrUndef(backdropColor)) {
    const borderRadius = toTRBLCorners(opts.borderRadius);
    const padding = toPadding(opts.backdropPadding);
    ctx.fillStyle = backdropColor;
    const backdropLeft = left - padding.left;
    const backdropTop = top - padding.top;
    const backdropWidth = right - left + padding.width;
    const backdropHeight = bottom - top + padding.height;
    if (Object.values(borderRadius).some((v2) => v2 !== 0)) {
      ctx.beginPath();
      addRoundedRectPath(ctx, {
        x: backdropLeft,
        y: backdropTop,
        w: backdropWidth,
        h: backdropHeight,
        radius: borderRadius
      });
      ctx.fill();
    } else {
      ctx.fillRect(backdropLeft, backdropTop, backdropWidth, backdropHeight);
    }
  }
}
__name(drawPointLabelBox, "drawPointLabelBox");
function drawPointLabels(scale, labelCount) {
  const { ctx, options: { pointLabels } } = scale;
  for (let i2 = labelCount - 1; i2 >= 0; i2--) {
    const item = scale._pointLabelItems[i2];
    if (!item.visible) {
      continue;
    }
    const optsAtIndex = pointLabels.setContext(scale.getPointLabelContext(i2));
    drawPointLabelBox(ctx, optsAtIndex, item);
    const plFont = toFont(optsAtIndex.font);
    const { x: x2, y: y2, textAlign } = item;
    renderText(ctx, scale._pointLabels[i2], x2, y2 + plFont.lineHeight / 2, plFont, {
      color: optsAtIndex.color,
      textAlign,
      textBaseline: "middle"
    });
  }
}
__name(drawPointLabels, "drawPointLabels");
function pathRadiusLine(scale, radius, circular, labelCount) {
  const { ctx } = scale;
  if (circular) {
    ctx.arc(scale.xCenter, scale.yCenter, radius, 0, TAU);
  } else {
    let pointPosition = scale.getPointPosition(0, radius);
    ctx.moveTo(pointPosition.x, pointPosition.y);
    for (let i2 = 1; i2 < labelCount; i2++) {
      pointPosition = scale.getPointPosition(i2, radius);
      ctx.lineTo(pointPosition.x, pointPosition.y);
    }
  }
}
__name(pathRadiusLine, "pathRadiusLine");
function drawRadiusLine(scale, gridLineOpts, radius, labelCount, borderOpts) {
  const ctx = scale.ctx;
  const circular = gridLineOpts.circular;
  const { color: color2, lineWidth } = gridLineOpts;
  if (!circular && !labelCount || !color2 || !lineWidth || radius < 0) {
    return;
  }
  ctx.save();
  ctx.strokeStyle = color2;
  ctx.lineWidth = lineWidth;
  ctx.setLineDash(borderOpts.dash || []);
  ctx.lineDashOffset = borderOpts.dashOffset;
  ctx.beginPath();
  pathRadiusLine(scale, radius, circular, labelCount);
  ctx.closePath();
  ctx.stroke();
  ctx.restore();
}
__name(drawRadiusLine, "drawRadiusLine");
function createPointLabelContext(parent, index2, label) {
  return createContext(parent, {
    label,
    index: index2,
    type: "pointLabel"
  });
}
__name(createPointLabelContext, "createPointLabelContext");
const _RadialLinearScale = class _RadialLinearScale extends LinearScaleBase {
  constructor(cfg) {
    super(cfg);
    this.xCenter = void 0;
    this.yCenter = void 0;
    this.drawingArea = void 0;
    this._pointLabels = [];
    this._pointLabelItems = [];
  }
  setDimensions() {
    const padding = this._padding = toPadding(getTickBackdropHeight(this.options) / 2);
    const w2 = this.width = this.maxWidth - padding.width;
    const h3 = this.height = this.maxHeight - padding.height;
    this.xCenter = Math.floor(this.left + w2 / 2 + padding.left);
    this.yCenter = Math.floor(this.top + h3 / 2 + padding.top);
    this.drawingArea = Math.floor(Math.min(w2, h3) / 2);
  }
  determineDataLimits() {
    const { min, max: max2 } = this.getMinMax(false);
    this.min = isNumberFinite(min) && !isNaN(min) ? min : 0;
    this.max = isNumberFinite(max2) && !isNaN(max2) ? max2 : 0;
    this.handleTickRangeOptions();
  }
  computeTickLimit() {
    return Math.ceil(this.drawingArea / getTickBackdropHeight(this.options));
  }
  generateTickLabels(ticks) {
    LinearScaleBase.prototype.generateTickLabels.call(this, ticks);
    this._pointLabels = this.getLabels().map((value, index2) => {
      const label = callback(this.options.pointLabels.callback, [
        value,
        index2
      ], this);
      return label || label === 0 ? label : "";
    }).filter((v2, i2) => this.chart.getDataVisibility(i2));
  }
  fit() {
    const opts = this.options;
    if (opts.display && opts.pointLabels.display) {
      fitWithPointLabels(this);
    } else {
      this.setCenterPoint(0, 0, 0, 0);
    }
  }
  setCenterPoint(leftMovement, rightMovement, topMovement, bottomMovement) {
    this.xCenter += Math.floor((leftMovement - rightMovement) / 2);
    this.yCenter += Math.floor((topMovement - bottomMovement) / 2);
    this.drawingArea -= Math.min(this.drawingArea / 2, Math.max(leftMovement, rightMovement, topMovement, bottomMovement));
  }
  getIndexAngle(index2) {
    const angleMultiplier = TAU / (this._pointLabels.length || 1);
    const startAngle = this.options.startAngle || 0;
    return _normalizeAngle(index2 * angleMultiplier + toRadians(startAngle));
  }
  getDistanceFromCenterForValue(value) {
    if (isNullOrUndef(value)) {
      return NaN;
    }
    const scalingFactor = this.drawingArea / (this.max - this.min);
    if (this.options.reverse) {
      return (this.max - value) * scalingFactor;
    }
    return (value - this.min) * scalingFactor;
  }
  getValueForDistanceFromCenter(distance) {
    if (isNullOrUndef(distance)) {
      return NaN;
    }
    const scaledDistance = distance / (this.drawingArea / (this.max - this.min));
    return this.options.reverse ? this.max - scaledDistance : this.min + scaledDistance;
  }
  getPointLabelContext(index2) {
    const pointLabels = this._pointLabels || [];
    if (index2 >= 0 && index2 < pointLabels.length) {
      const pointLabel = pointLabels[index2];
      return createPointLabelContext(this.getContext(), index2, pointLabel);
    }
  }
  getPointPosition(index2, distanceFromCenter, additionalAngle = 0) {
    const angle = this.getIndexAngle(index2) - HALF_PI + additionalAngle;
    return {
      x: Math.cos(angle) * distanceFromCenter + this.xCenter,
      y: Math.sin(angle) * distanceFromCenter + this.yCenter,
      angle
    };
  }
  getPointPositionForValue(index2, value) {
    return this.getPointPosition(index2, this.getDistanceFromCenterForValue(value));
  }
  getBasePosition(index2) {
    return this.getPointPositionForValue(index2 || 0, this.getBaseValue());
  }
  getPointLabelPosition(index2) {
    const { left, top, right, bottom } = this._pointLabelItems[index2];
    return {
      left,
      top,
      right,
      bottom
    };
  }
  drawBackground() {
    const { backgroundColor, grid: { circular } } = this.options;
    if (backgroundColor) {
      const ctx = this.ctx;
      ctx.save();
      ctx.beginPath();
      pathRadiusLine(this, this.getDistanceFromCenterForValue(this._endValue), circular, this._pointLabels.length);
      ctx.closePath();
      ctx.fillStyle = backgroundColor;
      ctx.fill();
      ctx.restore();
    }
  }
  drawGrid() {
    const ctx = this.ctx;
    const opts = this.options;
    const { angleLines, grid, border } = opts;
    const labelCount = this._pointLabels.length;
    let i2, offset, position;
    if (opts.pointLabels.display) {
      drawPointLabels(this, labelCount);
    }
    if (grid.display) {
      this.ticks.forEach((tick, index2) => {
        if (index2 !== 0 || index2 === 0 && this.min < 0) {
          offset = this.getDistanceFromCenterForValue(tick.value);
          const context = this.getContext(index2);
          const optsAtIndex = grid.setContext(context);
          const optsAtIndexBorder = border.setContext(context);
          drawRadiusLine(this, optsAtIndex, offset, labelCount, optsAtIndexBorder);
        }
      });
    }
    if (angleLines.display) {
      ctx.save();
      for (i2 = labelCount - 1; i2 >= 0; i2--) {
        const optsAtIndex = angleLines.setContext(this.getPointLabelContext(i2));
        const { color: color2, lineWidth } = optsAtIndex;
        if (!lineWidth || !color2) {
          continue;
        }
        ctx.lineWidth = lineWidth;
        ctx.strokeStyle = color2;
        ctx.setLineDash(optsAtIndex.borderDash);
        ctx.lineDashOffset = optsAtIndex.borderDashOffset;
        offset = this.getDistanceFromCenterForValue(opts.reverse ? this.min : this.max);
        position = this.getPointPosition(i2, offset);
        ctx.beginPath();
        ctx.moveTo(this.xCenter, this.yCenter);
        ctx.lineTo(position.x, position.y);
        ctx.stroke();
      }
      ctx.restore();
    }
  }
  drawBorder() {
  }
  drawLabels() {
    const ctx = this.ctx;
    const opts = this.options;
    const tickOpts = opts.ticks;
    if (!tickOpts.display) {
      return;
    }
    const startAngle = this.getIndexAngle(0);
    let offset, width;
    ctx.save();
    ctx.translate(this.xCenter, this.yCenter);
    ctx.rotate(startAngle);
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    this.ticks.forEach((tick, index2) => {
      if (index2 === 0 && this.min >= 0 && !opts.reverse) {
        return;
      }
      const optsAtIndex = tickOpts.setContext(this.getContext(index2));
      const tickFont = toFont(optsAtIndex.font);
      offset = this.getDistanceFromCenterForValue(this.ticks[index2].value);
      if (optsAtIndex.showLabelBackdrop) {
        ctx.font = tickFont.string;
        width = ctx.measureText(tick.label).width;
        ctx.fillStyle = optsAtIndex.backdropColor;
        const padding = toPadding(optsAtIndex.backdropPadding);
        ctx.fillRect(-width / 2 - padding.left, -offset - tickFont.size / 2 - padding.top, width + padding.width, tickFont.size + padding.height);
      }
      renderText(ctx, tick.label, 0, -offset, tickFont, {
        color: optsAtIndex.color,
        strokeColor: optsAtIndex.textStrokeColor,
        strokeWidth: optsAtIndex.textStrokeWidth
      });
    });
    ctx.restore();
  }
  drawTitle() {
  }
};
__name(_RadialLinearScale, "RadialLinearScale");
__publicField(_RadialLinearScale, "id", "radialLinear");
__publicField(_RadialLinearScale, "defaults", {
  display: true,
  animate: true,
  position: "chartArea",
  angleLines: {
    display: true,
    lineWidth: 1,
    borderDash: [],
    borderDashOffset: 0
  },
  grid: {
    circular: false
  },
  startAngle: 0,
  ticks: {
    showLabelBackdrop: true,
    callback: Ticks.formatters.numeric
  },
  pointLabels: {
    backdropColor: void 0,
    backdropPadding: 2,
    display: true,
    font: {
      size: 10
    },
    callback(label) {
      return label;
    },
    padding: 5,
    centerPointLabels: false
  }
});
__publicField(_RadialLinearScale, "defaultRoutes", {
  "angleLines.color": "borderColor",
  "pointLabels.color": "color",
  "ticks.color": "color"
});
__publicField(_RadialLinearScale, "descriptors", {
  angleLines: {
    _fallback: "grid"
  }
});
let RadialLinearScale = _RadialLinearScale;
const INTERVALS = {
  millisecond: {
    common: true,
    size: 1,
    steps: 1e3
  },
  second: {
    common: true,
    size: 1e3,
    steps: 60
  },
  minute: {
    common: true,
    size: 6e4,
    steps: 60
  },
  hour: {
    common: true,
    size: 36e5,
    steps: 24
  },
  day: {
    common: true,
    size: 864e5,
    steps: 30
  },
  week: {
    common: false,
    size: 6048e5,
    steps: 4
  },
  month: {
    common: true,
    size: 2628e6,
    steps: 12
  },
  quarter: {
    common: false,
    size: 7884e6,
    steps: 4
  },
  year: {
    common: true,
    size: 3154e7
  }
};
const UNITS = /* @__PURE__ */ Object.keys(INTERVALS);
function sorter(a2, b2) {
  return a2 - b2;
}
__name(sorter, "sorter");
function parse(scale, input) {
  if (isNullOrUndef(input)) {
    return null;
  }
  const adapter = scale._adapter;
  const { parser, round: round2, isoWeekday } = scale._parseOpts;
  let value = input;
  if (typeof parser === "function") {
    value = parser(value);
  }
  if (!isNumberFinite(value)) {
    value = typeof parser === "string" ? adapter.parse(value, parser) : adapter.parse(value);
  }
  if (value === null) {
    return null;
  }
  if (round2) {
    value = round2 === "week" && (isNumber(isoWeekday) || isoWeekday === true) ? adapter.startOf(value, "isoWeek", isoWeekday) : adapter.startOf(value, round2);
  }
  return +value;
}
__name(parse, "parse");
function determineUnitForAutoTicks(minUnit, min, max2, capacity) {
  const ilen = UNITS.length;
  for (let i2 = UNITS.indexOf(minUnit); i2 < ilen - 1; ++i2) {
    const interval = INTERVALS[UNITS[i2]];
    const factor = interval.steps ? interval.steps : Number.MAX_SAFE_INTEGER;
    if (interval.common && Math.ceil((max2 - min) / (factor * interval.size)) <= capacity) {
      return UNITS[i2];
    }
  }
  return UNITS[ilen - 1];
}
__name(determineUnitForAutoTicks, "determineUnitForAutoTicks");
function determineUnitForFormatting(scale, numTicks, minUnit, min, max2) {
  for (let i2 = UNITS.length - 1; i2 >= UNITS.indexOf(minUnit); i2--) {
    const unit = UNITS[i2];
    if (INTERVALS[unit].common && scale._adapter.diff(max2, min, unit) >= numTicks - 1) {
      return unit;
    }
  }
  return UNITS[minUnit ? UNITS.indexOf(minUnit) : 0];
}
__name(determineUnitForFormatting, "determineUnitForFormatting");
function determineMajorUnit(unit) {
  for (let i2 = UNITS.indexOf(unit) + 1, ilen = UNITS.length; i2 < ilen; ++i2) {
    if (INTERVALS[UNITS[i2]].common) {
      return UNITS[i2];
    }
  }
}
__name(determineMajorUnit, "determineMajorUnit");
function addTick(ticks, time, timestamps) {
  if (!timestamps) {
    ticks[time] = true;
  } else if (timestamps.length) {
    const { lo, hi } = _lookup(timestamps, time);
    const timestamp = timestamps[lo] >= time ? timestamps[lo] : timestamps[hi];
    ticks[timestamp] = true;
  }
}
__name(addTick, "addTick");
function setMajorTicks(scale, ticks, map2, majorUnit) {
  const adapter = scale._adapter;
  const first = +adapter.startOf(ticks[0].value, majorUnit);
  const last = ticks[ticks.length - 1].value;
  let major, index2;
  for (major = first; major <= last; major = +adapter.add(major, 1, majorUnit)) {
    index2 = map2[major];
    if (index2 >= 0) {
      ticks[index2].major = true;
    }
  }
  return ticks;
}
__name(setMajorTicks, "setMajorTicks");
function ticksFromTimestamps(scale, values, majorUnit) {
  const ticks = [];
  const map2 = {};
  const ilen = values.length;
  let i2, value;
  for (i2 = 0; i2 < ilen; ++i2) {
    value = values[i2];
    map2[value] = i2;
    ticks.push({
      value,
      major: false
    });
  }
  return ilen === 0 || !majorUnit ? ticks : setMajorTicks(scale, ticks, map2, majorUnit);
}
__name(ticksFromTimestamps, "ticksFromTimestamps");
const _TimeScale = class _TimeScale extends Scale {
  constructor(props) {
    super(props);
    this._cache = {
      data: [],
      labels: [],
      all: []
    };
    this._unit = "day";
    this._majorUnit = void 0;
    this._offsets = {};
    this._normalized = false;
    this._parseOpts = void 0;
  }
  init(scaleOpts, opts = {}) {
    const time = scaleOpts.time || (scaleOpts.time = {});
    const adapter = this._adapter = new adapters._date(scaleOpts.adapters.date);
    adapter.init(opts);
    mergeIf(time.displayFormats, adapter.formats());
    this._parseOpts = {
      parser: time.parser,
      round: time.round,
      isoWeekday: time.isoWeekday
    };
    super.init(scaleOpts);
    this._normalized = opts.normalized;
  }
  parse(raw, index2) {
    if (raw === void 0) {
      return null;
    }
    return parse(this, raw);
  }
  beforeLayout() {
    super.beforeLayout();
    this._cache = {
      data: [],
      labels: [],
      all: []
    };
  }
  determineDataLimits() {
    const options = this.options;
    const adapter = this._adapter;
    const unit = options.time.unit || "day";
    let { min, max: max2, minDefined, maxDefined } = this.getUserBounds();
    function _applyBounds(bounds) {
      if (!minDefined && !isNaN(bounds.min)) {
        min = Math.min(min, bounds.min);
      }
      if (!maxDefined && !isNaN(bounds.max)) {
        max2 = Math.max(max2, bounds.max);
      }
    }
    __name(_applyBounds, "_applyBounds");
    if (!minDefined || !maxDefined) {
      _applyBounds(this._getLabelBounds());
      if (options.bounds !== "ticks" || options.ticks.source !== "labels") {
        _applyBounds(this.getMinMax(false));
      }
    }
    min = isNumberFinite(min) && !isNaN(min) ? min : +adapter.startOf(Date.now(), unit);
    max2 = isNumberFinite(max2) && !isNaN(max2) ? max2 : +adapter.endOf(Date.now(), unit) + 1;
    this.min = Math.min(min, max2 - 1);
    this.max = Math.max(min + 1, max2);
  }
  _getLabelBounds() {
    const arr = this.getLabelTimestamps();
    let min = Number.POSITIVE_INFINITY;
    let max2 = Number.NEGATIVE_INFINITY;
    if (arr.length) {
      min = arr[0];
      max2 = arr[arr.length - 1];
    }
    return {
      min,
      max: max2
    };
  }
  buildTicks() {
    const options = this.options;
    const timeOpts = options.time;
    const tickOpts = options.ticks;
    const timestamps = tickOpts.source === "labels" ? this.getLabelTimestamps() : this._generate();
    if (options.bounds === "ticks" && timestamps.length) {
      this.min = this._userMin || timestamps[0];
      this.max = this._userMax || timestamps[timestamps.length - 1];
    }
    const min = this.min;
    const max2 = this.max;
    const ticks = _filterBetween(timestamps, min, max2);
    this._unit = timeOpts.unit || (tickOpts.autoSkip ? determineUnitForAutoTicks(timeOpts.minUnit, this.min, this.max, this._getLabelCapacity(min)) : determineUnitForFormatting(this, ticks.length, timeOpts.minUnit, this.min, this.max));
    this._majorUnit = !tickOpts.major.enabled || this._unit === "year" ? void 0 : determineMajorUnit(this._unit);
    this.initOffsets(timestamps);
    if (options.reverse) {
      ticks.reverse();
    }
    return ticksFromTimestamps(this, ticks, this._majorUnit);
  }
  afterAutoSkip() {
    if (this.options.offsetAfterAutoskip) {
      this.initOffsets(this.ticks.map((tick) => +tick.value));
    }
  }
  initOffsets(timestamps = []) {
    let start = 0;
    let end = 0;
    let first, last;
    if (this.options.offset && timestamps.length) {
      first = this.getDecimalForValue(timestamps[0]);
      if (timestamps.length === 1) {
        start = 1 - first;
      } else {
        start = (this.getDecimalForValue(timestamps[1]) - first) / 2;
      }
      last = this.getDecimalForValue(timestamps[timestamps.length - 1]);
      if (timestamps.length === 1) {
        end = last;
      } else {
        end = (last - this.getDecimalForValue(timestamps[timestamps.length - 2])) / 2;
      }
    }
    const limit = timestamps.length < 3 ? 0.5 : 0.25;
    start = _limitValue(start, 0, limit);
    end = _limitValue(end, 0, limit);
    this._offsets = {
      start,
      end,
      factor: 1 / (start + 1 + end)
    };
  }
  _generate() {
    const adapter = this._adapter;
    const min = this.min;
    const max2 = this.max;
    const options = this.options;
    const timeOpts = options.time;
    const minor = timeOpts.unit || determineUnitForAutoTicks(timeOpts.minUnit, min, max2, this._getLabelCapacity(min));
    const stepSize = valueOrDefault(options.ticks.stepSize, 1);
    const weekday = minor === "week" ? timeOpts.isoWeekday : false;
    const hasWeekday = isNumber(weekday) || weekday === true;
    const ticks = {};
    let first = min;
    let time, count;
    if (hasWeekday) {
      first = +adapter.startOf(first, "isoWeek", weekday);
    }
    first = +adapter.startOf(first, hasWeekday ? "day" : minor);
    if (adapter.diff(max2, min, minor) > 1e5 * stepSize) {
      throw new Error(min + " and " + max2 + " are too far apart with stepSize of " + stepSize + " " + minor);
    }
    const timestamps = options.ticks.source === "data" && this.getDataTimestamps();
    for (time = first, count = 0; time < max2; time = +adapter.add(time, stepSize, minor), count++) {
      addTick(ticks, time, timestamps);
    }
    if (time === max2 || options.bounds === "ticks" || count === 1) {
      addTick(ticks, time, timestamps);
    }
    return Object.keys(ticks).sort(sorter).map((x2) => +x2);
  }
  getLabelForValue(value) {
    const adapter = this._adapter;
    const timeOpts = this.options.time;
    if (timeOpts.tooltipFormat) {
      return adapter.format(value, timeOpts.tooltipFormat);
    }
    return adapter.format(value, timeOpts.displayFormats.datetime);
  }
  format(value, format) {
    const options = this.options;
    const formats = options.time.displayFormats;
    const unit = this._unit;
    const fmt = format || formats[unit];
    return this._adapter.format(value, fmt);
  }
  _tickFormatFunction(time, index2, ticks, format) {
    const options = this.options;
    const formatter = options.ticks.callback;
    if (formatter) {
      return callback(formatter, [
        time,
        index2,
        ticks
      ], this);
    }
    const formats = options.time.displayFormats;
    const unit = this._unit;
    const majorUnit = this._majorUnit;
    const minorFormat = unit && formats[unit];
    const majorFormat = majorUnit && formats[majorUnit];
    const tick = ticks[index2];
    const major = majorUnit && majorFormat && tick && tick.major;
    return this._adapter.format(time, format || (major ? majorFormat : minorFormat));
  }
  generateTickLabels(ticks) {
    let i2, ilen, tick;
    for (i2 = 0, ilen = ticks.length; i2 < ilen; ++i2) {
      tick = ticks[i2];
      tick.label = this._tickFormatFunction(tick.value, i2, ticks);
    }
  }
  getDecimalForValue(value) {
    return value === null ? NaN : (value - this.min) / (this.max - this.min);
  }
  getPixelForValue(value) {
    const offsets = this._offsets;
    const pos = this.getDecimalForValue(value);
    return this.getPixelForDecimal((offsets.start + pos) * offsets.factor);
  }
  getValueForPixel(pixel) {
    const offsets = this._offsets;
    const pos = this.getDecimalForPixel(pixel) / offsets.factor - offsets.end;
    return this.min + pos * (this.max - this.min);
  }
  _getLabelSize(label) {
    const ticksOpts = this.options.ticks;
    const tickLabelWidth = this.ctx.measureText(label).width;
    const angle = toRadians(this.isHorizontal() ? ticksOpts.maxRotation : ticksOpts.minRotation);
    const cosRotation = Math.cos(angle);
    const sinRotation = Math.sin(angle);
    const tickFontSize = this._resolveTickFontOptions(0).size;
    return {
      w: tickLabelWidth * cosRotation + tickFontSize * sinRotation,
      h: tickLabelWidth * sinRotation + tickFontSize * cosRotation
    };
  }
  _getLabelCapacity(exampleTime) {
    const timeOpts = this.options.time;
    const displayFormats = timeOpts.displayFormats;
    const format = displayFormats[timeOpts.unit] || displayFormats.millisecond;
    const exampleLabel = this._tickFormatFunction(exampleTime, 0, ticksFromTimestamps(this, [
      exampleTime
    ], this._majorUnit), format);
    const size = this._getLabelSize(exampleLabel);
    const capacity = Math.floor(this.isHorizontal() ? this.width / size.w : this.height / size.h) - 1;
    return capacity > 0 ? capacity : 1;
  }
  getDataTimestamps() {
    let timestamps = this._cache.data || [];
    let i2, ilen;
    if (timestamps.length) {
      return timestamps;
    }
    const metas = this.getMatchingVisibleMetas();
    if (this._normalized && metas.length) {
      return this._cache.data = metas[0].controller.getAllParsedValues(this);
    }
    for (i2 = 0, ilen = metas.length; i2 < ilen; ++i2) {
      timestamps = timestamps.concat(metas[i2].controller.getAllParsedValues(this));
    }
    return this._cache.data = this.normalize(timestamps);
  }
  getLabelTimestamps() {
    const timestamps = this._cache.labels || [];
    let i2, ilen;
    if (timestamps.length) {
      return timestamps;
    }
    const labels = this.getLabels();
    for (i2 = 0, ilen = labels.length; i2 < ilen; ++i2) {
      timestamps.push(parse(this, labels[i2]));
    }
    return this._cache.labels = this._normalized ? timestamps : this.normalize(timestamps);
  }
  normalize(values) {
    return _arrayUnique(values.sort(sorter));
  }
};
__name(_TimeScale, "TimeScale");
__publicField(_TimeScale, "id", "time");
__publicField(_TimeScale, "defaults", {
  bounds: "data",
  adapters: {},
  time: {
    parser: false,
    unit: false,
    round: false,
    isoWeekday: false,
    minUnit: "millisecond",
    displayFormats: {}
  },
  ticks: {
    source: "auto",
    callback: false,
    major: {
      enabled: false
    }
  }
});
let TimeScale = _TimeScale;
function interpolate(table, val, reverse) {
  let lo = 0;
  let hi = table.length - 1;
  let prevSource, nextSource, prevTarget, nextTarget;
  if (reverse) {
    if (val >= table[lo].pos && val <= table[hi].pos) {
      ({ lo, hi } = _lookupByKey(table, "pos", val));
    }
    ({ pos: prevSource, time: prevTarget } = table[lo]);
    ({ pos: nextSource, time: nextTarget } = table[hi]);
  } else {
    if (val >= table[lo].time && val <= table[hi].time) {
      ({ lo, hi } = _lookupByKey(table, "time", val));
    }
    ({ time: prevSource, pos: prevTarget } = table[lo]);
    ({ time: nextSource, pos: nextTarget } = table[hi]);
  }
  const span = nextSource - prevSource;
  return span ? prevTarget + (nextTarget - prevTarget) * (val - prevSource) / span : prevTarget;
}
__name(interpolate, "interpolate");
const _TimeSeriesScale = class _TimeSeriesScale extends TimeScale {
  constructor(props) {
    super(props);
    this._table = [];
    this._minPos = void 0;
    this._tableRange = void 0;
  }
  initOffsets() {
    const timestamps = this._getTimestampsForTable();
    const table = this._table = this.buildLookupTable(timestamps);
    this._minPos = interpolate(table, this.min);
    this._tableRange = interpolate(table, this.max) - this._minPos;
    super.initOffsets(timestamps);
  }
  buildLookupTable(timestamps) {
    const { min, max: max2 } = this;
    const items = [];
    const table = [];
    let i2, ilen, prev, curr, next;
    for (i2 = 0, ilen = timestamps.length; i2 < ilen; ++i2) {
      curr = timestamps[i2];
      if (curr >= min && curr <= max2) {
        items.push(curr);
      }
    }
    if (items.length < 2) {
      return [
        {
          time: min,
          pos: 0
        },
        {
          time: max2,
          pos: 1
        }
      ];
    }
    for (i2 = 0, ilen = items.length; i2 < ilen; ++i2) {
      next = items[i2 + 1];
      prev = items[i2 - 1];
      curr = items[i2];
      if (Math.round((next + prev) / 2) !== curr) {
        table.push({
          time: curr,
          pos: i2 / (ilen - 1)
        });
      }
    }
    return table;
  }
  _generate() {
    const min = this.min;
    const max2 = this.max;
    let timestamps = super.getDataTimestamps();
    if (!timestamps.includes(min) || !timestamps.length) {
      timestamps.splice(0, 0, min);
    }
    if (!timestamps.includes(max2) || timestamps.length === 1) {
      timestamps.push(max2);
    }
    return timestamps.sort((a2, b2) => a2 - b2);
  }
  _getTimestampsForTable() {
    let timestamps = this._cache.all || [];
    if (timestamps.length) {
      return timestamps;
    }
    const data = this.getDataTimestamps();
    const label = this.getLabelTimestamps();
    if (data.length && label.length) {
      timestamps = this.normalize(data.concat(label));
    } else {
      timestamps = data.length ? data : label;
    }
    timestamps = this._cache.all = timestamps;
    return timestamps;
  }
  getDecimalForValue(value) {
    return (interpolate(this._table, value) - this._minPos) / this._tableRange;
  }
  getValueForPixel(pixel) {
    const offsets = this._offsets;
    const decimal = this.getDecimalForPixel(pixel) / offsets.factor - offsets.end;
    return interpolate(this._table, decimal * this._tableRange + this._minPos, true);
  }
};
__name(_TimeSeriesScale, "TimeSeriesScale");
__publicField(_TimeSeriesScale, "id", "timeseries");
__publicField(_TimeSeriesScale, "defaults", TimeScale.defaults);
let TimeSeriesScale = _TimeSeriesScale;
const defaultDatasetIdKey = "label";
function reforwardRef(ref, value) {
  if (typeof ref === "function") {
    ref(value);
  } else if (ref) {
    ref.current = value;
  }
}
__name(reforwardRef, "reforwardRef");
function setOptions(chart, nextOptions) {
  const options = chart.options;
  if (options && nextOptions) {
    Object.assign(options, nextOptions);
  }
}
__name(setOptions, "setOptions");
function setLabels(currentData, nextLabels) {
  currentData.labels = nextLabels;
}
__name(setLabels, "setLabels");
function setDatasets(currentData, nextDatasets, datasetIdKey = defaultDatasetIdKey) {
  const addedDatasets = [];
  currentData.datasets = nextDatasets.map((nextDataset) => {
    const currentDataset = currentData.datasets.find((dataset) => dataset[datasetIdKey] === nextDataset[datasetIdKey]);
    if (!currentDataset || !nextDataset.data || addedDatasets.includes(currentDataset)) {
      return {
        ...nextDataset
      };
    }
    addedDatasets.push(currentDataset);
    Object.assign(currentDataset, nextDataset);
    return currentDataset;
  });
}
__name(setDatasets, "setDatasets");
function cloneData(data, datasetIdKey = defaultDatasetIdKey) {
  const nextData = {
    labels: [],
    datasets: []
  };
  setLabels(nextData, data.labels);
  setDatasets(nextData, data.datasets, datasetIdKey);
  return nextData;
}
__name(cloneData, "cloneData");
function ChartComponent(props, ref) {
  const { height = 150, width = 300, redraw = false, datasetIdKey, type, data, options, plugins = [], fallbackContent, updateMode, ...canvasProps } = props;
  const canvasRef = reactExports.useRef(null);
  const chartRef = reactExports.useRef(null);
  const renderChart = /* @__PURE__ */ __name(() => {
    if (!canvasRef.current)
      return;
    chartRef.current = new Chart$1(canvasRef.current, {
      type,
      data: cloneData(data, datasetIdKey),
      options: options && {
        ...options
      },
      plugins
    });
    reforwardRef(ref, chartRef.current);
  }, "renderChart");
  const destroyChart = /* @__PURE__ */ __name(() => {
    reforwardRef(ref, null);
    if (chartRef.current) {
      chartRef.current.destroy();
      chartRef.current = null;
    }
  }, "destroyChart");
  reactExports.useEffect(() => {
    if (!redraw && chartRef.current && options) {
      setOptions(chartRef.current, options);
    }
  }, [
    redraw,
    options
  ]);
  reactExports.useEffect(() => {
    if (!redraw && chartRef.current) {
      setLabels(chartRef.current.config.data, data.labels);
    }
  }, [
    redraw,
    data.labels
  ]);
  reactExports.useEffect(() => {
    if (!redraw && chartRef.current && data.datasets) {
      setDatasets(chartRef.current.config.data, data.datasets, datasetIdKey);
    }
  }, [
    redraw,
    data.datasets
  ]);
  reactExports.useEffect(() => {
    if (!chartRef.current)
      return;
    if (redraw) {
      destroyChart();
      setTimeout(renderChart);
    } else {
      chartRef.current.update(updateMode);
    }
  }, [
    redraw,
    options,
    data.labels,
    data.datasets,
    updateMode
  ]);
  reactExports.useEffect(() => {
    if (!chartRef.current)
      return;
    destroyChart();
    setTimeout(renderChart);
  }, [
    type
  ]);
  reactExports.useEffect(() => {
    renderChart();
    return () => destroyChart();
  }, []);
  return /* @__PURE__ */ jsxRuntimeExports.jsx("canvas", {
    ref: canvasRef,
    role: "img",
    height,
    width,
    ...canvasProps,
    children: fallbackContent
  });
}
__name(ChartComponent, "ChartComponent");
const Chart = /* @__PURE__ */ reactExports.forwardRef(ChartComponent);
function createTypedChart(type, registerables) {
  Chart$1.register(registerables);
  return /* @__PURE__ */ reactExports.forwardRef((props, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(Chart, {
    ...props,
    ref,
    type
  }));
}
__name(createTypedChart, "createTypedChart");
const Line = /* @__PURE__ */ createTypedChart("line", LineController);
const Bar = /* @__PURE__ */ createTypedChart("bar", BarController);
const Radar = /* @__PURE__ */ createTypedChart("radar", RadarController);
const Doughnut = /* @__PURE__ */ createTypedChart("doughnut", DoughnutController);
Chart$1.register(
  CategoryScale,
  LinearScale,
  PointElement,
  LineElement,
  BarElement,
  plugin_title,
  plugin_tooltip,
  plugin_legend,
  ArcElement
);
function Dashboard() {
  const { query } = useDatabase();
  const { user } = useAuth();
  const [stats, setStats] = reactExports.useState({
    companies: 0,
    statements: 0,
    inconsistencies: 0,
    recentActivity: []
  });
  const [chartData, setChartData] = reactExports.useState({
    revenue: null,
    inconsistencies: null,
    companies: null
  });
  reactExports.useEffect(() => {
    loadDashboardData();
  }, []);
  const loadDashboardData = /* @__PURE__ */ __name(async () => {
    var _a3, _b2, _c, _d, _e, _f;
    try {
      const companiesResult = await query("SELECT COUNT(*) as count FROM companies");
      const statementsResult = await query("SELECT COUNT(*) as count FROM financial_statements");
      const inconsistenciesResult = await query("SELECT COUNT(*) as count FROM inconsistencies WHERE severity = $1", ["high"]);
      const activityResult = await query(`
        SELECT 
          fs.id,
          c.name as company_name,
          fs.statement_type,
          fs.year,
          fs.quarter,
          fs.processed_at
        FROM financial_statements fs
        JOIN companies c ON fs.company_id = c.id
        ORDER BY fs.processed_at DESC
        LIMIT 5
      `);
      setStats({
        companies: ((_b2 = (_a3 = companiesResult.data) == null ? void 0 : _a3[0]) == null ? void 0 : _b2.count) || 0,
        statements: ((_d = (_c = statementsResult.data) == null ? void 0 : _c[0]) == null ? void 0 : _d.count) || 0,
        inconsistencies: ((_f = (_e = inconsistenciesResult.data) == null ? void 0 : _e[0]) == null ? void 0 : _f.count) || 0,
        recentActivity: activityResult.data || []
      });
      loadChartData();
    } catch (error) {
      console.error("Error loading dashboard data:", error);
    }
  }, "loadDashboardData");
  const loadChartData = /* @__PURE__ */ __name(async () => {
    var _a3, _b2, _c, _d, _e, _f;
    try {
      const revenueResult = await query(`
        SELECT 
          c.name as company,
          fm.metric_value as revenue,
          fs.year
        FROM financial_metrics fm
        JOIN financial_statements fs ON fm.statement_id = fs.id
        JOIN companies c ON fs.company_id = c.id
        WHERE fm.metric_name = 'total_revenue'
        ORDER BY fs.year DESC
        LIMIT 20
      `);
      const inconsistencyResult = await query(`
        SELECT severity, COUNT(*) as count
        FROM inconsistencies
        GROUP BY severity
      `);
      const industryResult = await query(`
        SELECT industry, COUNT(*) as count
        FROM companies
        WHERE industry IS NOT NULL
        GROUP BY industry
      `);
      setChartData({
        revenue: {
          labels: ((_a3 = revenueResult.data) == null ? void 0 : _a3.map((d2) => `${d2.company} (${d2.year})`)) || [],
          datasets: [{
            label: "Revenue (Millions)",
            data: ((_b2 = revenueResult.data) == null ? void 0 : _b2.map((d2) => parseFloat(d2.revenue) / 1e6)) || [],
            borderColor: "rgb(59, 130, 246)",
            backgroundColor: "rgba(59, 130, 246, 0.1)",
            tension: 0.1
          }]
        },
        inconsistencies: {
          labels: ((_c = inconsistencyResult.data) == null ? void 0 : _c.map((d2) => d2.severity)) || [],
          datasets: [{
            data: ((_d = inconsistencyResult.data) == null ? void 0 : _d.map((d2) => parseInt(d2.count))) || [],
            backgroundColor: [
              "rgba(239, 68, 68, 0.8)",
              "rgba(245, 158, 11, 0.8)",
              "rgba(34, 197, 94, 0.8)"
            ]
          }]
        },
        companies: {
          labels: ((_e = industryResult.data) == null ? void 0 : _e.map((d2) => d2.industry)) || [],
          datasets: [{
            label: "Companies",
            data: ((_f = industryResult.data) == null ? void 0 : _f.map((d2) => parseInt(d2.count))) || [],
            backgroundColor: "rgba(59, 130, 246, 0.8)"
          }]
        }
      });
    } catch (error) {
      console.error("Error loading chart data:", error);
    }
  }, "loadChartData");
  const StatCard = /* @__PURE__ */ __name(({ title, value, icon: Icon, color: color2 = "blue" }) => /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "card p-6", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `p-3 rounded-lg bg-${color2}-100 dark:bg-${color2}-900/20`, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { className: `h-6 w-6 text-${color2}-600` }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "ml-4", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-sm font-medium text-gray-600 dark:text-gray-400", children: title }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-2xl font-semibold text-gray-900 dark:text-white", children: value })
    ] })
  ] }) }), "StatCard");
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-8", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h1", { className: "text-3xl font-bold text-gray-900 dark:text-white", children: "Dashboard" }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: "mt-2 text-gray-600 dark:text-gray-400", children: [
        "Welcome back, ",
        user == null ? void 0 : user.email,
        ". Here's your financial analysis overview."
      ] })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-6", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        StatCard,
        {
          title: "Companies",
          value: stats.companies,
          icon: Building2,
          color: "blue"
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        StatCard,
        {
          title: "Statements",
          value: stats.statements,
          icon: FileText,
          color: "green"
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        StatCard,
        {
          title: "High Priority Issues",
          value: stats.inconsistencies,
          icon: AlertTriangle,
          color: "red"
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        StatCard,
        {
          title: "Analysis Score",
          value: "94%",
          icon: TrendingUp,
          color: "purple"
        }
      )
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-1 lg:grid-cols-2 gap-6", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "card p-6", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "text-lg font-semibold text-gray-900 dark:text-white mb-4", children: "Revenue Trends" }),
        chartData.revenue ? /* @__PURE__ */ jsxRuntimeExports.jsx(
          Line,
          {
            data: chartData.revenue,
            options: {
              responsive: true,
              plugins: {
                legend: {
                  position: "top"
                }
              },
              scales: {
                y: {
                  beginAtZero: true,
                  title: {
                    display: true,
                    text: "Revenue (Millions USD)"
                  }
                }
              }
            }
          }
        ) : /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "h-64 flex items-center justify-center text-gray-500", children: "No revenue data available" })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "card p-6", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "text-lg font-semibold text-gray-900 dark:text-white mb-4", children: "Issues by Severity" }),
        chartData.inconsistencies ? /* @__PURE__ */ jsxRuntimeExports.jsx(
          Doughnut,
          {
            data: chartData.inconsistencies,
            options: {
              responsive: true,
              plugins: {
                legend: {
                  position: "bottom"
                }
              }
            }
          }
        ) : /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "h-64 flex items-center justify-center text-gray-500", children: "No inconsistency data available" })
      ] })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-1 lg:grid-cols-2 gap-6", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "card p-6", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "text-lg font-semibold text-gray-900 dark:text-white mb-4", children: "Recent Activity" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "space-y-4", children: stats.recentActivity.length > 0 ? stats.recentActivity.map((activity, index2) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center space-x-3 p-3 bg-gray-50 dark:bg-gray-700 rounded-lg", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(FileText, { className: "h-5 w-5 text-gray-400" }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex-1", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: "text-sm font-medium text-gray-900 dark:text-white", children: [
              activity.company_name,
              " - ",
              activity.statement_type
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: "text-xs text-gray-500 dark:text-gray-400", children: [
              "Q",
              activity.quarter,
              " ",
              activity.year,
              "  ",
              new Date(activity.processed_at).toLocaleDateString()
            ] })
          ] })
        ] }, index2)) : /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-gray-500 dark:text-gray-400 text-center py-8", children: "No recent activity" }) })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "card p-6", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "text-lg font-semibold text-gray-900 dark:text-white mb-4", children: "Companies by Industry" }),
        chartData.companies ? /* @__PURE__ */ jsxRuntimeExports.jsx(
          Bar,
          {
            data: chartData.companies,
            options: {
              responsive: true,
              plugins: {
                legend: {
                  display: false
                }
              },
              scales: {
                y: {
                  beginAtZero: true,
                  title: {
                    display: true,
                    text: "Number of Companies"
                  }
                }
              }
            }
          }
        ) : /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "h-64 flex items-center justify-center text-gray-500", children: "No company data available" })
      ] })
    ] })
  ] });
}
__name(Dashboard, "Dashboard");
function Companies() {
  const { query } = useDatabase();
  const { user } = useAuth();
  const [companies, setCompanies] = reactExports.useState([]);
  const [loading, setLoading] = reactExports.useState(true);
  const [searchTerm, setSearchTerm] = reactExports.useState("");
  const [showAddModal, setShowAddModal] = reactExports.useState(false);
  const [editingCompany, setEditingCompany] = reactExports.useState(null);
  const [formData, setFormData] = reactExports.useState({
    name: "",
    industry: ""
  });
  reactExports.useEffect(() => {
    loadCompanies();
  }, []);
  const loadCompanies = /* @__PURE__ */ __name(async () => {
    try {
      const result = await query(`
        SELECT 
          c.*,
          COUNT(fs.id) as statement_count
        FROM companies c
        LEFT JOIN financial_statements fs ON c.id = fs.company_id
        GROUP BY c.id, c.name, c.industry, c.created_at, c.team_id
        ORDER BY c.name
      `);
      setCompanies(result.data || []);
    } catch (error) {
      console.error("Error loading companies:", error);
    } finally {
      setLoading(false);
    }
  }, "loadCompanies");
  const handleSubmit = /* @__PURE__ */ __name(async (e) => {
    e.preventDefault();
    try {
      if (editingCompany) {
        await query(
          "UPDATE companies SET name = $1, industry = $2 WHERE id = $3",
          [formData.name, formData.industry, editingCompany.id]
        );
      } else {
        await query(
          "INSERT INTO companies (name, industry, team_id) VALUES ($1, $2, $3)",
          [formData.name, formData.industry, user == null ? void 0 : user.team_id]
        );
      }
      setFormData({ name: "", industry: "" });
      setShowAddModal(false);
      setEditingCompany(null);
      loadCompanies();
    } catch (error) {
      console.error("Error saving company:", error);
    }
  }, "handleSubmit");
  const handleEdit = /* @__PURE__ */ __name((company) => {
    setEditingCompany(company);
    setFormData({
      name: company.name,
      industry: company.industry || ""
    });
    setShowAddModal(true);
  }, "handleEdit");
  const handleDelete = /* @__PURE__ */ __name(async (companyId) => {
    if (window.confirm("Are you sure you want to delete this company? This will also delete all associated financial statements.")) {
      try {
        await query("DELETE FROM companies WHERE id = $1", [companyId]);
        loadCompanies();
      } catch (error) {
        console.error("Error deleting company:", error);
      }
    }
  }, "handleDelete");
  const filteredCompanies = companies.filter(
    (company) => company.name.toLowerCase().includes(searchTerm.toLowerCase()) || company.industry && company.industry.toLowerCase().includes(searchTerm.toLowerCase())
  );
  if (loading) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex items-center justify-center h-64", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "animate-spin rounded-full h-32 w-32 border-b-2 border-primary-600" }) });
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-6", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex justify-between items-center", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h1", { className: "text-3xl font-bold text-gray-900 dark:text-white", children: "Companies" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "mt-2 text-gray-600 dark:text-gray-400", children: "Manage companies and their financial statements" })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(
        "button",
        {
          onClick: () => {
            setEditingCompany(null);
            setFormData({ name: "", industry: "" });
            setShowAddModal(true);
          },
          className: "btn-primary flex items-center space-x-2",
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(Plus, { className: "h-4 w-4" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "Add Company" })
          ]
        }
      )
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "relative", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Search, { className: "absolute left-3 top-1/2 transform -translate-y-1/2 h-4 w-4 text-gray-400" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "input",
        {
          type: "text",
          placeholder: "Search companies...",
          value: searchTerm,
          onChange: (e) => setSearchTerm(e.target.value),
          className: "input-field pl-10"
        }
      )
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6", children: filteredCompanies.map((company) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "card p-6", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-start justify-between", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center space-x-3", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "p-2 bg-primary-100 dark:bg-primary-900/20 rounded-lg", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Building2, { className: "h-6 w-6 text-primary-600" }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "text-lg font-semibold text-gray-900 dark:text-white", children: company.name }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-sm text-gray-600 dark:text-gray-400", children: company.industry || "No industry specified" })
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex space-x-2", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "button",
            {
              onClick: () => handleEdit(company),
              className: "p-2 text-gray-400 hover:text-gray-600 dark:hover:text-gray-300",
              children: /* @__PURE__ */ jsxRuntimeExports.jsx(PenSquare, { className: "h-4 w-4" })
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "button",
            {
              onClick: () => handleDelete(company.id),
              className: "p-2 text-gray-400 hover:text-red-600",
              children: /* @__PURE__ */ jsxRuntimeExports.jsx(Trash2, { className: "h-4 w-4" })
            }
          )
        ] })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mt-4 pt-4 border-t border-gray-200 dark:border-gray-700", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex justify-between text-sm", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-gray-600 dark:text-gray-400", children: "Statements:" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "font-medium text-gray-900 dark:text-white", children: company.statement_count })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex justify-between text-sm mt-1", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-gray-600 dark:text-gray-400", children: "Added:" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-gray-900 dark:text-white", children: new Date(company.created_at).toLocaleDateString() })
        ] })
      ] })
    ] }, company.id)) }),
    filteredCompanies.length === 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "text-center py-12", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Building2, { className: "mx-auto h-12 w-12 text-gray-400" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "mt-2 text-sm font-medium text-gray-900 dark:text-white", children: "No companies" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "mt-1 text-sm text-gray-500 dark:text-gray-400", children: "Get started by adding a new company." })
    ] }),
    showAddModal && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center p-4 z-50", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-white dark:bg-gray-800 rounded-lg p-6 w-full max-w-md", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: "text-lg font-semibold text-gray-900 dark:text-white mb-4", children: editingCompany ? "Edit Company" : "Add New Company" }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("form", { onSubmit: handleSubmit, className: "space-y-4", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1", children: "Company Name" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "input",
            {
              type: "text",
              required: true,
              value: formData.name,
              onChange: (e) => setFormData({ ...formData, name: e.target.value }),
              className: "input-field",
              placeholder: "Enter company name"
            }
          )
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1", children: "Industry" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "input",
            {
              type: "text",
              value: formData.industry,
              onChange: (e) => setFormData({ ...formData, industry: e.target.value }),
              className: "input-field",
              placeholder: "e.g., Technology, Healthcare"
            }
          )
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex space-x-3 pt-4", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "button",
            {
              type: "button",
              onClick: () => {
                setShowAddModal(false);
                setEditingCompany(null);
                setFormData({ name: "", industry: "" });
              },
              className: "btn-secondary flex-1",
              children: "Cancel"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("button", { type: "submit", className: "btn-primary flex-1", children: [
            editingCompany ? "Update" : "Add",
            " Company"
          ] })
        ] })
      ] })
    ] }) })
  ] });
}
__name(Companies, "Companies");
function commonjsRequire(path) {
  throw new Error('Could not dynamically require "' + path + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
__name(commonjsRequire, "commonjsRequire");
var pdf = { exports: {} };
const __viteBrowserExternal = {};
const __viteBrowserExternal$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: __viteBrowserExternal
}, Symbol.toStringTag, { value: "Module" }));
const require$$5 = /* @__PURE__ */ getAugmentedNamespace(__viteBrowserExternal$1);
(function(module, exports) {
  (/* @__PURE__ */ __name(function webpackUniversalModuleDefinition(root, factory) {
    module.exports = root.pdfjsLib = factory();
  }, "webpackUniversalModuleDefinition"))(globalThis, () => {
    return (
      /******/
      (() => {
        var __webpack_modules__ = [
          ,
          /* 1 */
          /***/
          (__unused_webpack_module2, exports2) => {
            var _settled;
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            exports2.VerbosityLevel = exports2.Util = exports2.UnknownErrorException = exports2.UnexpectedResponseException = exports2.TextRenderingMode = exports2.RenderingIntentFlag = exports2.PromiseCapability = exports2.PermissionFlag = exports2.PasswordResponses = exports2.PasswordException = exports2.PageActionEventType = exports2.OPS = exports2.MissingPDFException = exports2.MAX_IMAGE_SIZE_TO_CACHE = exports2.LINE_FACTOR = exports2.LINE_DESCENT_FACTOR = exports2.InvalidPDFException = exports2.ImageKind = exports2.IDENTITY_MATRIX = exports2.FormatError = exports2.FeatureTest = exports2.FONT_IDENTITY_MATRIX = exports2.DocumentActionEventType = exports2.CMapCompressionType = exports2.BaseException = exports2.BASELINE_FACTOR = exports2.AnnotationType = exports2.AnnotationReplyType = exports2.AnnotationPrefix = exports2.AnnotationMode = exports2.AnnotationFlag = exports2.AnnotationFieldFlag = exports2.AnnotationEditorType = exports2.AnnotationEditorPrefix = exports2.AnnotationEditorParamsType = exports2.AnnotationBorderStyleType = exports2.AnnotationActionEventType = exports2.AbortException = void 0;
            exports2.assert = assert;
            exports2.bytesToString = bytesToString;
            exports2.createValidAbsoluteUrl = createValidAbsoluteUrl;
            exports2.getModificationDate = getModificationDate;
            exports2.getUuid = getUuid;
            exports2.getVerbosityLevel = getVerbosityLevel;
            exports2.info = info;
            exports2.isArrayBuffer = isArrayBuffer;
            exports2.isArrayEqual = isArrayEqual;
            exports2.isNodeJS = void 0;
            exports2.normalizeUnicode = normalizeUnicode;
            exports2.objectFromMap = objectFromMap;
            exports2.objectSize = objectSize;
            exports2.setVerbosityLevel = setVerbosityLevel;
            exports2.shadow = shadow;
            exports2.string32 = string32;
            exports2.stringToBytes = stringToBytes;
            exports2.stringToPDFString = stringToPDFString;
            exports2.stringToUTF8String = stringToUTF8String;
            exports2.unreachable = unreachable;
            exports2.utf8StringToString = utf8StringToString;
            exports2.warn = warn;
            const isNodeJS = typeof process === "object" && process + "" === "[object process]" && !process.versions.nw && !(process.versions.electron && process.type && process.type !== "browser");
            exports2.isNodeJS = isNodeJS;
            const IDENTITY_MATRIX = [1, 0, 0, 1, 0, 0];
            exports2.IDENTITY_MATRIX = IDENTITY_MATRIX;
            const FONT_IDENTITY_MATRIX = [1e-3, 0, 0, 1e-3, 0, 0];
            exports2.FONT_IDENTITY_MATRIX = FONT_IDENTITY_MATRIX;
            const MAX_IMAGE_SIZE_TO_CACHE = 1e7;
            exports2.MAX_IMAGE_SIZE_TO_CACHE = MAX_IMAGE_SIZE_TO_CACHE;
            const LINE_FACTOR = 1.35;
            exports2.LINE_FACTOR = LINE_FACTOR;
            const LINE_DESCENT_FACTOR = 0.35;
            exports2.LINE_DESCENT_FACTOR = LINE_DESCENT_FACTOR;
            const BASELINE_FACTOR = LINE_DESCENT_FACTOR / LINE_FACTOR;
            exports2.BASELINE_FACTOR = BASELINE_FACTOR;
            const RenderingIntentFlag = {
              ANY: 1,
              DISPLAY: 2,
              PRINT: 4,
              SAVE: 8,
              ANNOTATIONS_FORMS: 16,
              ANNOTATIONS_STORAGE: 32,
              ANNOTATIONS_DISABLE: 64,
              OPLIST: 256
            };
            exports2.RenderingIntentFlag = RenderingIntentFlag;
            const AnnotationMode = {
              DISABLE: 0,
              ENABLE: 1,
              ENABLE_FORMS: 2,
              ENABLE_STORAGE: 3
            };
            exports2.AnnotationMode = AnnotationMode;
            const AnnotationEditorPrefix = "pdfjs_internal_editor_";
            exports2.AnnotationEditorPrefix = AnnotationEditorPrefix;
            const AnnotationEditorType = {
              DISABLE: -1,
              NONE: 0,
              FREETEXT: 3,
              STAMP: 13,
              INK: 15
            };
            exports2.AnnotationEditorType = AnnotationEditorType;
            const AnnotationEditorParamsType = {
              RESIZE: 1,
              CREATE: 2,
              FREETEXT_SIZE: 11,
              FREETEXT_COLOR: 12,
              FREETEXT_OPACITY: 13,
              INK_COLOR: 21,
              INK_THICKNESS: 22,
              INK_OPACITY: 23
            };
            exports2.AnnotationEditorParamsType = AnnotationEditorParamsType;
            const PermissionFlag = {
              PRINT: 4,
              MODIFY_CONTENTS: 8,
              COPY: 16,
              MODIFY_ANNOTATIONS: 32,
              FILL_INTERACTIVE_FORMS: 256,
              COPY_FOR_ACCESSIBILITY: 512,
              ASSEMBLE: 1024,
              PRINT_HIGH_QUALITY: 2048
            };
            exports2.PermissionFlag = PermissionFlag;
            const TextRenderingMode = {
              FILL: 0,
              STROKE: 1,
              FILL_STROKE: 2,
              INVISIBLE: 3,
              FILL_ADD_TO_PATH: 4,
              STROKE_ADD_TO_PATH: 5,
              FILL_STROKE_ADD_TO_PATH: 6,
              ADD_TO_PATH: 7,
              FILL_STROKE_MASK: 3,
              ADD_TO_PATH_FLAG: 4
            };
            exports2.TextRenderingMode = TextRenderingMode;
            const ImageKind = {
              GRAYSCALE_1BPP: 1,
              RGB_24BPP: 2,
              RGBA_32BPP: 3
            };
            exports2.ImageKind = ImageKind;
            const AnnotationType = {
              TEXT: 1,
              LINK: 2,
              FREETEXT: 3,
              LINE: 4,
              SQUARE: 5,
              CIRCLE: 6,
              POLYGON: 7,
              POLYLINE: 8,
              HIGHLIGHT: 9,
              UNDERLINE: 10,
              SQUIGGLY: 11,
              STRIKEOUT: 12,
              STAMP: 13,
              CARET: 14,
              INK: 15,
              POPUP: 16,
              FILEATTACHMENT: 17,
              SOUND: 18,
              MOVIE: 19,
              WIDGET: 20,
              SCREEN: 21,
              PRINTERMARK: 22,
              TRAPNET: 23,
              WATERMARK: 24,
              THREED: 25,
              REDACT: 26
            };
            exports2.AnnotationType = AnnotationType;
            const AnnotationReplyType = {
              GROUP: "Group",
              REPLY: "R"
            };
            exports2.AnnotationReplyType = AnnotationReplyType;
            const AnnotationFlag = {
              INVISIBLE: 1,
              HIDDEN: 2,
              PRINT: 4,
              NOZOOM: 8,
              NOROTATE: 16,
              NOVIEW: 32,
              READONLY: 64,
              LOCKED: 128,
              TOGGLENOVIEW: 256,
              LOCKEDCONTENTS: 512
            };
            exports2.AnnotationFlag = AnnotationFlag;
            const AnnotationFieldFlag = {
              READONLY: 1,
              REQUIRED: 2,
              NOEXPORT: 4,
              MULTILINE: 4096,
              PASSWORD: 8192,
              NOTOGGLETOOFF: 16384,
              RADIO: 32768,
              PUSHBUTTON: 65536,
              COMBO: 131072,
              EDIT: 262144,
              SORT: 524288,
              FILESELECT: 1048576,
              MULTISELECT: 2097152,
              DONOTSPELLCHECK: 4194304,
              DONOTSCROLL: 8388608,
              COMB: 16777216,
              RICHTEXT: 33554432,
              RADIOSINUNISON: 33554432,
              COMMITONSELCHANGE: 67108864
            };
            exports2.AnnotationFieldFlag = AnnotationFieldFlag;
            const AnnotationBorderStyleType = {
              SOLID: 1,
              DASHED: 2,
              BEVELED: 3,
              INSET: 4,
              UNDERLINE: 5
            };
            exports2.AnnotationBorderStyleType = AnnotationBorderStyleType;
            const AnnotationActionEventType = {
              E: "Mouse Enter",
              X: "Mouse Exit",
              D: "Mouse Down",
              U: "Mouse Up",
              Fo: "Focus",
              Bl: "Blur",
              PO: "PageOpen",
              PC: "PageClose",
              PV: "PageVisible",
              PI: "PageInvisible",
              K: "Keystroke",
              F: "Format",
              V: "Validate",
              C: "Calculate"
            };
            exports2.AnnotationActionEventType = AnnotationActionEventType;
            const DocumentActionEventType = {
              WC: "WillClose",
              WS: "WillSave",
              DS: "DidSave",
              WP: "WillPrint",
              DP: "DidPrint"
            };
            exports2.DocumentActionEventType = DocumentActionEventType;
            const PageActionEventType = {
              O: "PageOpen",
              C: "PageClose"
            };
            exports2.PageActionEventType = PageActionEventType;
            const VerbosityLevel = {
              ERRORS: 0,
              WARNINGS: 1,
              INFOS: 5
            };
            exports2.VerbosityLevel = VerbosityLevel;
            const CMapCompressionType = {
              NONE: 0,
              BINARY: 1
            };
            exports2.CMapCompressionType = CMapCompressionType;
            const OPS = {
              dependency: 1,
              setLineWidth: 2,
              setLineCap: 3,
              setLineJoin: 4,
              setMiterLimit: 5,
              setDash: 6,
              setRenderingIntent: 7,
              setFlatness: 8,
              setGState: 9,
              save: 10,
              restore: 11,
              transform: 12,
              moveTo: 13,
              lineTo: 14,
              curveTo: 15,
              curveTo2: 16,
              curveTo3: 17,
              closePath: 18,
              rectangle: 19,
              stroke: 20,
              closeStroke: 21,
              fill: 22,
              eoFill: 23,
              fillStroke: 24,
              eoFillStroke: 25,
              closeFillStroke: 26,
              closeEOFillStroke: 27,
              endPath: 28,
              clip: 29,
              eoClip: 30,
              beginText: 31,
              endText: 32,
              setCharSpacing: 33,
              setWordSpacing: 34,
              setHScale: 35,
              setLeading: 36,
              setFont: 37,
              setTextRenderingMode: 38,
              setTextRise: 39,
              moveText: 40,
              setLeadingMoveText: 41,
              setTextMatrix: 42,
              nextLine: 43,
              showText: 44,
              showSpacedText: 45,
              nextLineShowText: 46,
              nextLineSetSpacingShowText: 47,
              setCharWidth: 48,
              setCharWidthAndBounds: 49,
              setStrokeColorSpace: 50,
              setFillColorSpace: 51,
              setStrokeColor: 52,
              setStrokeColorN: 53,
              setFillColor: 54,
              setFillColorN: 55,
              setStrokeGray: 56,
              setFillGray: 57,
              setStrokeRGBColor: 58,
              setFillRGBColor: 59,
              setStrokeCMYKColor: 60,
              setFillCMYKColor: 61,
              shadingFill: 62,
              beginInlineImage: 63,
              beginImageData: 64,
              endInlineImage: 65,
              paintXObject: 66,
              markPoint: 67,
              markPointProps: 68,
              beginMarkedContent: 69,
              beginMarkedContentProps: 70,
              endMarkedContent: 71,
              beginCompat: 72,
              endCompat: 73,
              paintFormXObjectBegin: 74,
              paintFormXObjectEnd: 75,
              beginGroup: 76,
              endGroup: 77,
              beginAnnotation: 80,
              endAnnotation: 81,
              paintImageMaskXObject: 83,
              paintImageMaskXObjectGroup: 84,
              paintImageXObject: 85,
              paintInlineImageXObject: 86,
              paintInlineImageXObjectGroup: 87,
              paintImageXObjectRepeat: 88,
              paintImageMaskXObjectRepeat: 89,
              paintSolidColorImageMask: 90,
              constructPath: 91
            };
            exports2.OPS = OPS;
            const PasswordResponses = {
              NEED_PASSWORD: 1,
              INCORRECT_PASSWORD: 2
            };
            exports2.PasswordResponses = PasswordResponses;
            let verbosity = VerbosityLevel.WARNINGS;
            function setVerbosityLevel(level) {
              if (Number.isInteger(level)) {
                verbosity = level;
              }
            }
            __name(setVerbosityLevel, "setVerbosityLevel");
            function getVerbosityLevel() {
              return verbosity;
            }
            __name(getVerbosityLevel, "getVerbosityLevel");
            function info(msg) {
              if (verbosity >= VerbosityLevel.INFOS) {
                console.log(`Info: ${msg}`);
              }
            }
            __name(info, "info");
            function warn(msg) {
              if (verbosity >= VerbosityLevel.WARNINGS) {
                console.log(`Warning: ${msg}`);
              }
            }
            __name(warn, "warn");
            function unreachable(msg) {
              throw new Error(msg);
            }
            __name(unreachable, "unreachable");
            function assert(cond, msg) {
              if (!cond) {
                unreachable(msg);
              }
            }
            __name(assert, "assert");
            function _isValidProtocol(url) {
              switch (url == null ? void 0 : url.protocol) {
                case "http:":
                case "https:":
                case "ftp:":
                case "mailto:":
                case "tel:":
                  return true;
                default:
                  return false;
              }
            }
            __name(_isValidProtocol, "_isValidProtocol");
            function createValidAbsoluteUrl(url, baseUrl = null, options = null) {
              if (!url) {
                return null;
              }
              try {
                if (options && typeof url === "string") {
                  if (options.addDefaultProtocol && url.startsWith("www.")) {
                    const dots = url.match(/\./g);
                    if ((dots == null ? void 0 : dots.length) >= 2) {
                      url = `http://${url}`;
                    }
                  }
                  if (options.tryConvertEncoding) {
                    try {
                      url = stringToUTF8String(url);
                    } catch {
                    }
                  }
                }
                const absoluteUrl = baseUrl ? new URL(url, baseUrl) : new URL(url);
                if (_isValidProtocol(absoluteUrl)) {
                  return absoluteUrl;
                }
              } catch {
              }
              return null;
            }
            __name(createValidAbsoluteUrl, "createValidAbsoluteUrl");
            function shadow(obj, prop, value, nonSerializable = false) {
              Object.defineProperty(obj, prop, {
                value,
                enumerable: !nonSerializable,
                configurable: true,
                writable: false
              });
              return value;
            }
            __name(shadow, "shadow");
            const BaseException = (/* @__PURE__ */ __name(function BaseExceptionClosure() {
              function BaseException2(message, name) {
                if (this.constructor === BaseException2) {
                  unreachable("Cannot initialize BaseException.");
                }
                this.message = message;
                this.name = name;
              }
              __name(BaseException2, "BaseException");
              BaseException2.prototype = new Error();
              BaseException2.constructor = BaseException2;
              return BaseException2;
            }, "BaseExceptionClosure"))();
            exports2.BaseException = BaseException;
            const _PasswordException = class _PasswordException extends BaseException {
              constructor(msg, code) {
                super(msg, "PasswordException");
                this.code = code;
              }
            };
            __name(_PasswordException, "PasswordException");
            let PasswordException = _PasswordException;
            exports2.PasswordException = PasswordException;
            const _UnknownErrorException = class _UnknownErrorException extends BaseException {
              constructor(msg, details) {
                super(msg, "UnknownErrorException");
                this.details = details;
              }
            };
            __name(_UnknownErrorException, "UnknownErrorException");
            let UnknownErrorException = _UnknownErrorException;
            exports2.UnknownErrorException = UnknownErrorException;
            const _InvalidPDFException = class _InvalidPDFException extends BaseException {
              constructor(msg) {
                super(msg, "InvalidPDFException");
              }
            };
            __name(_InvalidPDFException, "InvalidPDFException");
            let InvalidPDFException = _InvalidPDFException;
            exports2.InvalidPDFException = InvalidPDFException;
            const _MissingPDFException = class _MissingPDFException extends BaseException {
              constructor(msg) {
                super(msg, "MissingPDFException");
              }
            };
            __name(_MissingPDFException, "MissingPDFException");
            let MissingPDFException = _MissingPDFException;
            exports2.MissingPDFException = MissingPDFException;
            const _UnexpectedResponseException = class _UnexpectedResponseException extends BaseException {
              constructor(msg, status) {
                super(msg, "UnexpectedResponseException");
                this.status = status;
              }
            };
            __name(_UnexpectedResponseException, "UnexpectedResponseException");
            let UnexpectedResponseException = _UnexpectedResponseException;
            exports2.UnexpectedResponseException = UnexpectedResponseException;
            const _FormatError = class _FormatError extends BaseException {
              constructor(msg) {
                super(msg, "FormatError");
              }
            };
            __name(_FormatError, "FormatError");
            let FormatError = _FormatError;
            exports2.FormatError = FormatError;
            const _AbortException = class _AbortException extends BaseException {
              constructor(msg) {
                super(msg, "AbortException");
              }
            };
            __name(_AbortException, "AbortException");
            let AbortException = _AbortException;
            exports2.AbortException = AbortException;
            function bytesToString(bytes) {
              if (typeof bytes !== "object" || (bytes == null ? void 0 : bytes.length) === void 0) {
                unreachable("Invalid argument for bytesToString");
              }
              const length = bytes.length;
              const MAX_ARGUMENT_COUNT = 8192;
              if (length < MAX_ARGUMENT_COUNT) {
                return String.fromCharCode.apply(null, bytes);
              }
              const strBuf = [];
              for (let i2 = 0; i2 < length; i2 += MAX_ARGUMENT_COUNT) {
                const chunkEnd = Math.min(i2 + MAX_ARGUMENT_COUNT, length);
                const chunk = bytes.subarray(i2, chunkEnd);
                strBuf.push(String.fromCharCode.apply(null, chunk));
              }
              return strBuf.join("");
            }
            __name(bytesToString, "bytesToString");
            function stringToBytes(str) {
              if (typeof str !== "string") {
                unreachable("Invalid argument for stringToBytes");
              }
              const length = str.length;
              const bytes = new Uint8Array(length);
              for (let i2 = 0; i2 < length; ++i2) {
                bytes[i2] = str.charCodeAt(i2) & 255;
              }
              return bytes;
            }
            __name(stringToBytes, "stringToBytes");
            function string32(value) {
              return String.fromCharCode(value >> 24 & 255, value >> 16 & 255, value >> 8 & 255, value & 255);
            }
            __name(string32, "string32");
            function objectSize(obj) {
              return Object.keys(obj).length;
            }
            __name(objectSize, "objectSize");
            function objectFromMap(map2) {
              const obj = /* @__PURE__ */ Object.create(null);
              for (const [key, value] of map2) {
                obj[key] = value;
              }
              return obj;
            }
            __name(objectFromMap, "objectFromMap");
            function isLittleEndian() {
              const buffer8 = new Uint8Array(4);
              buffer8[0] = 1;
              const view32 = new Uint32Array(buffer8.buffer, 0, 1);
              return view32[0] === 1;
            }
            __name(isLittleEndian, "isLittleEndian");
            function isEvalSupported() {
              try {
                new Function("");
                return true;
              } catch {
                return false;
              }
            }
            __name(isEvalSupported, "isEvalSupported");
            const _FeatureTest = class _FeatureTest {
              static get isLittleEndian() {
                return shadow(this, "isLittleEndian", isLittleEndian());
              }
              static get isEvalSupported() {
                return shadow(this, "isEvalSupported", isEvalSupported());
              }
              static get isOffscreenCanvasSupported() {
                return shadow(this, "isOffscreenCanvasSupported", typeof OffscreenCanvas !== "undefined");
              }
              static get platform() {
                if (typeof navigator === "undefined") {
                  return shadow(this, "platform", {
                    isWin: false,
                    isMac: false
                  });
                }
                return shadow(this, "platform", {
                  isWin: navigator.platform.includes("Win"),
                  isMac: navigator.platform.includes("Mac")
                });
              }
              static get isCSSRoundSupported() {
                var _a3, _b2;
                return shadow(this, "isCSSRoundSupported", (_b2 = (_a3 = globalThis.CSS) == null ? void 0 : _a3.supports) == null ? void 0 : _b2.call(_a3, "width: round(1.5px, 1px)"));
              }
            };
            __name(_FeatureTest, "FeatureTest");
            let FeatureTest = _FeatureTest;
            exports2.FeatureTest = FeatureTest;
            const hexNumbers = [...Array(256).keys()].map((n2) => n2.toString(16).padStart(2, "0"));
            const _Util = class _Util {
              static makeHexColor(r, g2, b2) {
                return `#${hexNumbers[r]}${hexNumbers[g2]}${hexNumbers[b2]}`;
              }
              static scaleMinMax(transform, minMax) {
                let temp;
                if (transform[0]) {
                  if (transform[0] < 0) {
                    temp = minMax[0];
                    minMax[0] = minMax[1];
                    minMax[1] = temp;
                  }
                  minMax[0] *= transform[0];
                  minMax[1] *= transform[0];
                  if (transform[3] < 0) {
                    temp = minMax[2];
                    minMax[2] = minMax[3];
                    minMax[3] = temp;
                  }
                  minMax[2] *= transform[3];
                  minMax[3] *= transform[3];
                } else {
                  temp = minMax[0];
                  minMax[0] = minMax[2];
                  minMax[2] = temp;
                  temp = minMax[1];
                  minMax[1] = minMax[3];
                  minMax[3] = temp;
                  if (transform[1] < 0) {
                    temp = minMax[2];
                    minMax[2] = minMax[3];
                    minMax[3] = temp;
                  }
                  minMax[2] *= transform[1];
                  minMax[3] *= transform[1];
                  if (transform[2] < 0) {
                    temp = minMax[0];
                    minMax[0] = minMax[1];
                    minMax[1] = temp;
                  }
                  minMax[0] *= transform[2];
                  minMax[1] *= transform[2];
                }
                minMax[0] += transform[4];
                minMax[1] += transform[4];
                minMax[2] += transform[5];
                minMax[3] += transform[5];
              }
              static transform(m1, m2) {
                return [m1[0] * m2[0] + m1[2] * m2[1], m1[1] * m2[0] + m1[3] * m2[1], m1[0] * m2[2] + m1[2] * m2[3], m1[1] * m2[2] + m1[3] * m2[3], m1[0] * m2[4] + m1[2] * m2[5] + m1[4], m1[1] * m2[4] + m1[3] * m2[5] + m1[5]];
              }
              static applyTransform(p2, m2) {
                const xt2 = p2[0] * m2[0] + p2[1] * m2[2] + m2[4];
                const yt2 = p2[0] * m2[1] + p2[1] * m2[3] + m2[5];
                return [xt2, yt2];
              }
              static applyInverseTransform(p2, m2) {
                const d2 = m2[0] * m2[3] - m2[1] * m2[2];
                const xt2 = (p2[0] * m2[3] - p2[1] * m2[2] + m2[2] * m2[5] - m2[4] * m2[3]) / d2;
                const yt2 = (-p2[0] * m2[1] + p2[1] * m2[0] + m2[4] * m2[1] - m2[5] * m2[0]) / d2;
                return [xt2, yt2];
              }
              static getAxialAlignedBoundingBox(r, m2) {
                const p1 = this.applyTransform(r, m2);
                const p2 = this.applyTransform(r.slice(2, 4), m2);
                const p3 = this.applyTransform([r[0], r[3]], m2);
                const p4 = this.applyTransform([r[2], r[1]], m2);
                return [Math.min(p1[0], p2[0], p3[0], p4[0]), Math.min(p1[1], p2[1], p3[1], p4[1]), Math.max(p1[0], p2[0], p3[0], p4[0]), Math.max(p1[1], p2[1], p3[1], p4[1])];
              }
              static inverseTransform(m2) {
                const d2 = m2[0] * m2[3] - m2[1] * m2[2];
                return [m2[3] / d2, -m2[1] / d2, -m2[2] / d2, m2[0] / d2, (m2[2] * m2[5] - m2[4] * m2[3]) / d2, (m2[4] * m2[1] - m2[5] * m2[0]) / d2];
              }
              static singularValueDecompose2dScale(m2) {
                const transpose = [m2[0], m2[2], m2[1], m2[3]];
                const a2 = m2[0] * transpose[0] + m2[1] * transpose[2];
                const b2 = m2[0] * transpose[1] + m2[1] * transpose[3];
                const c2 = m2[2] * transpose[0] + m2[3] * transpose[2];
                const d2 = m2[2] * transpose[1] + m2[3] * transpose[3];
                const first = (a2 + d2) / 2;
                const second = Math.sqrt((a2 + d2) ** 2 - 4 * (a2 * d2 - c2 * b2)) / 2;
                const sx = first + second || 1;
                const sy = first - second || 1;
                return [Math.sqrt(sx), Math.sqrt(sy)];
              }
              static normalizeRect(rect) {
                const r = rect.slice(0);
                if (rect[0] > rect[2]) {
                  r[0] = rect[2];
                  r[2] = rect[0];
                }
                if (rect[1] > rect[3]) {
                  r[1] = rect[3];
                  r[3] = rect[1];
                }
                return r;
              }
              static intersect(rect1, rect2) {
                const xLow = Math.max(Math.min(rect1[0], rect1[2]), Math.min(rect2[0], rect2[2]));
                const xHigh = Math.min(Math.max(rect1[0], rect1[2]), Math.max(rect2[0], rect2[2]));
                if (xLow > xHigh) {
                  return null;
                }
                const yLow = Math.max(Math.min(rect1[1], rect1[3]), Math.min(rect2[1], rect2[3]));
                const yHigh = Math.min(Math.max(rect1[1], rect1[3]), Math.max(rect2[1], rect2[3]));
                if (yLow > yHigh) {
                  return null;
                }
                return [xLow, yLow, xHigh, yHigh];
              }
              static bezierBoundingBox(x0, y0, x1, y1, x2, y2, x3, y3) {
                const tvalues = [], bounds = [[], []];
                let a2, b2, c2, t2, t1, t22, b2ac, sqrtb2ac;
                for (let i2 = 0; i2 < 2; ++i2) {
                  if (i2 === 0) {
                    b2 = 6 * x0 - 12 * x1 + 6 * x2;
                    a2 = -3 * x0 + 9 * x1 - 9 * x2 + 3 * x3;
                    c2 = 3 * x1 - 3 * x0;
                  } else {
                    b2 = 6 * y0 - 12 * y1 + 6 * y2;
                    a2 = -3 * y0 + 9 * y1 - 9 * y2 + 3 * y3;
                    c2 = 3 * y1 - 3 * y0;
                  }
                  if (Math.abs(a2) < 1e-12) {
                    if (Math.abs(b2) < 1e-12) {
                      continue;
                    }
                    t2 = -c2 / b2;
                    if (0 < t2 && t2 < 1) {
                      tvalues.push(t2);
                    }
                    continue;
                  }
                  b2ac = b2 * b2 - 4 * c2 * a2;
                  sqrtb2ac = Math.sqrt(b2ac);
                  if (b2ac < 0) {
                    continue;
                  }
                  t1 = (-b2 + sqrtb2ac) / (2 * a2);
                  if (0 < t1 && t1 < 1) {
                    tvalues.push(t1);
                  }
                  t22 = (-b2 - sqrtb2ac) / (2 * a2);
                  if (0 < t22 && t22 < 1) {
                    tvalues.push(t22);
                  }
                }
                let j2 = tvalues.length, mt2;
                const jlen = j2;
                while (j2--) {
                  t2 = tvalues[j2];
                  mt2 = 1 - t2;
                  bounds[0][j2] = mt2 * mt2 * mt2 * x0 + 3 * mt2 * mt2 * t2 * x1 + 3 * mt2 * t2 * t2 * x2 + t2 * t2 * t2 * x3;
                  bounds[1][j2] = mt2 * mt2 * mt2 * y0 + 3 * mt2 * mt2 * t2 * y1 + 3 * mt2 * t2 * t2 * y2 + t2 * t2 * t2 * y3;
                }
                bounds[0][jlen] = x0;
                bounds[1][jlen] = y0;
                bounds[0][jlen + 1] = x3;
                bounds[1][jlen + 1] = y3;
                bounds[0].length = bounds[1].length = jlen + 2;
                return [Math.min(...bounds[0]), Math.min(...bounds[1]), Math.max(...bounds[0]), Math.max(...bounds[1])];
              }
            };
            __name(_Util, "Util");
            let Util = _Util;
            exports2.Util = Util;
            const PDFStringTranslateTable = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 728, 711, 710, 729, 733, 731, 730, 732, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8226, 8224, 8225, 8230, 8212, 8211, 402, 8260, 8249, 8250, 8722, 8240, 8222, 8220, 8221, 8216, 8217, 8218, 8482, 64257, 64258, 321, 338, 352, 376, 381, 305, 322, 339, 353, 382, 0, 8364];
            function stringToPDFString(str) {
              if (str[0] >= "") {
                let encoding;
                if (str[0] === "" && str[1] === "") {
                  encoding = "utf-16be";
                } else if (str[0] === "" && str[1] === "") {
                  encoding = "utf-16le";
                } else if (str[0] === "" && str[1] === "" && str[2] === "") {
                  encoding = "utf-8";
                }
                if (encoding) {
                  try {
                    const decoder = new TextDecoder(encoding, {
                      fatal: true
                    });
                    const buffer = stringToBytes(str);
                    return decoder.decode(buffer);
                  } catch (ex) {
                    warn(`stringToPDFString: "${ex}".`);
                  }
                }
              }
              const strBuf = [];
              for (let i2 = 0, ii = str.length; i2 < ii; i2++) {
                const code = PDFStringTranslateTable[str.charCodeAt(i2)];
                strBuf.push(code ? String.fromCharCode(code) : str.charAt(i2));
              }
              return strBuf.join("");
            }
            __name(stringToPDFString, "stringToPDFString");
            function stringToUTF8String(str) {
              return decodeURIComponent(escape(str));
            }
            __name(stringToUTF8String, "stringToUTF8String");
            function utf8StringToString(str) {
              return unescape(encodeURIComponent(str));
            }
            __name(utf8StringToString, "utf8StringToString");
            function isArrayBuffer(v2) {
              return typeof v2 === "object" && (v2 == null ? void 0 : v2.byteLength) !== void 0;
            }
            __name(isArrayBuffer, "isArrayBuffer");
            function isArrayEqual(arr1, arr2) {
              if (arr1.length !== arr2.length) {
                return false;
              }
              for (let i2 = 0, ii = arr1.length; i2 < ii; i2++) {
                if (arr1[i2] !== arr2[i2]) {
                  return false;
                }
              }
              return true;
            }
            __name(isArrayEqual, "isArrayEqual");
            function getModificationDate(date = /* @__PURE__ */ new Date()) {
              const buffer = [date.getUTCFullYear().toString(), (date.getUTCMonth() + 1).toString().padStart(2, "0"), date.getUTCDate().toString().padStart(2, "0"), date.getUTCHours().toString().padStart(2, "0"), date.getUTCMinutes().toString().padStart(2, "0"), date.getUTCSeconds().toString().padStart(2, "0")];
              return buffer.join("");
            }
            __name(getModificationDate, "getModificationDate");
            const _PromiseCapability = class _PromiseCapability {
              constructor() {
                __privateAdd(this, _settled, false);
                this.promise = new Promise((resolve2, reject) => {
                  this.resolve = (data) => {
                    __privateSet(this, _settled, true);
                    resolve2(data);
                  };
                  this.reject = (reason) => {
                    __privateSet(this, _settled, true);
                    reject(reason);
                  };
                });
              }
              get settled() {
                return __privateGet(this, _settled);
              }
            };
            _settled = new WeakMap();
            __name(_PromiseCapability, "PromiseCapability");
            let PromiseCapability = _PromiseCapability;
            exports2.PromiseCapability = PromiseCapability;
            let NormalizeRegex = null;
            let NormalizationMap = null;
            function normalizeUnicode(str) {
              if (!NormalizeRegex) {
                NormalizeRegex = /([\u00a0\u00b5\u037e\u0eb3\u2000-\u200a\u202f\u2126\ufb00-\ufb04\ufb06\ufb20-\ufb36\ufb38-\ufb3c\ufb3e\ufb40-\ufb41\ufb43-\ufb44\ufb46-\ufba1\ufba4-\ufba9\ufbae-\ufbb1\ufbd3-\ufbdc\ufbde-\ufbe7\ufbea-\ufbf8\ufbfc-\ufbfd\ufc00-\ufc5d\ufc64-\ufcf1\ufcf5-\ufd3d\ufd88\ufdf4\ufdfa-\ufdfb\ufe71\ufe77\ufe79\ufe7b\ufe7d]+)|(\ufb05+)/gu;
                NormalizationMap = /* @__PURE__ */ new Map([["", "t"]]);
              }
              return str.replaceAll(NormalizeRegex, (_2, p1, p2) => {
                return p1 ? p1.normalize("NFKC") : NormalizationMap.get(p2);
              });
            }
            __name(normalizeUnicode, "normalizeUnicode");
            function getUuid() {
              if (typeof crypto !== "undefined" && typeof (crypto == null ? void 0 : crypto.randomUUID) === "function") {
                return crypto.randomUUID();
              }
              const buf = new Uint8Array(32);
              if (typeof crypto !== "undefined" && typeof (crypto == null ? void 0 : crypto.getRandomValues) === "function") {
                crypto.getRandomValues(buf);
              } else {
                for (let i2 = 0; i2 < 32; i2++) {
                  buf[i2] = Math.floor(Math.random() * 255);
                }
              }
              return bytesToString(buf);
            }
            __name(getUuid, "getUuid");
            const AnnotationPrefix = "pdfjs_internal_id_";
            exports2.AnnotationPrefix = AnnotationPrefix;
          },
          /* 2 */
          /***/
          (__unused_webpack_module, exports, __w_pdfjs_require__) => {
            var _docId, _delayedCleanupTimeout, _pendingCleanup, _tryCleanup, tryCleanup_fn, _abortDelayedCleanup, abortDelayedCleanup_fn, _listeners, _deferred, _a3, _workerPorts, _methodPromises, _pageCache, _pagePromises, _passwordCapability, _cacheSimpleMethod, cacheSimpleMethod_fn, _objs, _ensureObj, ensureObj_fn, _internalRenderTask, _canvasInUse;
            Object.defineProperty(exports, "__esModule", {
              value: true
            });
            exports.RenderTask = exports.PDFWorkerUtil = exports.PDFWorker = exports.PDFPageProxy = exports.PDFDocumentProxy = exports.PDFDocumentLoadingTask = exports.PDFDataRangeTransport = exports.LoopbackPort = exports.DefaultStandardFontDataFactory = exports.DefaultFilterFactory = exports.DefaultCanvasFactory = exports.DefaultCMapReaderFactory = void 0;
            Object.defineProperty(exports, "SVGGraphics", {
              enumerable: true,
              get: function() {
                return _displaySvg.SVGGraphics;
              }
            });
            exports.build = void 0;
            exports.getDocument = getDocument;
            exports.version = void 0;
            var _util = __w_pdfjs_require__(1);
            var _annotation_storage = __w_pdfjs_require__(3);
            var _display_utils = __w_pdfjs_require__(6);
            var _font_loader = __w_pdfjs_require__(9);
            var _displayNode_utils = __w_pdfjs_require__(10);
            var _canvas = __w_pdfjs_require__(11);
            var _worker_options = __w_pdfjs_require__(14);
            var _message_handler = __w_pdfjs_require__(15);
            var _metadata = __w_pdfjs_require__(16);
            var _optional_content_config = __w_pdfjs_require__(17);
            var _transport_stream = __w_pdfjs_require__(18);
            var _displayFetch_stream = __w_pdfjs_require__(19);
            var _displayNetwork = __w_pdfjs_require__(22);
            var _displayNode_stream = __w_pdfjs_require__(23);
            var _displaySvg = __w_pdfjs_require__(24);
            var _xfa_text = __w_pdfjs_require__(25);
            const DEFAULT_RANGE_CHUNK_SIZE = 65536;
            const RENDERING_CANCELLED_TIMEOUT = 100;
            const DELAYED_CLEANUP_TIMEOUT = 5e3;
            const DefaultCanvasFactory = _util.isNodeJS ? _displayNode_utils.NodeCanvasFactory : _display_utils.DOMCanvasFactory;
            exports.DefaultCanvasFactory = DefaultCanvasFactory;
            const DefaultCMapReaderFactory = _util.isNodeJS ? _displayNode_utils.NodeCMapReaderFactory : _display_utils.DOMCMapReaderFactory;
            exports.DefaultCMapReaderFactory = DefaultCMapReaderFactory;
            const DefaultFilterFactory = _util.isNodeJS ? _displayNode_utils.NodeFilterFactory : _display_utils.DOMFilterFactory;
            exports.DefaultFilterFactory = DefaultFilterFactory;
            const DefaultStandardFontDataFactory = _util.isNodeJS ? _displayNode_utils.NodeStandardFontDataFactory : _display_utils.DOMStandardFontDataFactory;
            exports.DefaultStandardFontDataFactory = DefaultStandardFontDataFactory;
            function getDocument(src) {
              if (typeof src === "string" || src instanceof URL) {
                src = {
                  url: src
                };
              } else if ((0, _util.isArrayBuffer)(src)) {
                src = {
                  data: src
                };
              }
              if (typeof src !== "object") {
                throw new Error("Invalid parameter in getDocument, need parameter object.");
              }
              if (!src.url && !src.data && !src.range) {
                throw new Error("Invalid parameter object: need either .data, .range or .url");
              }
              const task = new PDFDocumentLoadingTask();
              const {
                docId
              } = task;
              const url = src.url ? getUrlProp(src.url) : null;
              const data = src.data ? getDataProp(src.data) : null;
              const httpHeaders = src.httpHeaders || null;
              const withCredentials = src.withCredentials === true;
              const password = src.password ?? null;
              const rangeTransport = src.range instanceof PDFDataRangeTransport ? src.range : null;
              const rangeChunkSize = Number.isInteger(src.rangeChunkSize) && src.rangeChunkSize > 0 ? src.rangeChunkSize : DEFAULT_RANGE_CHUNK_SIZE;
              let worker2 = src.worker instanceof PDFWorker ? src.worker : null;
              const verbosity = src.verbosity;
              const docBaseUrl = typeof src.docBaseUrl === "string" && !(0, _display_utils.isDataScheme)(src.docBaseUrl) ? src.docBaseUrl : null;
              const cMapUrl = typeof src.cMapUrl === "string" ? src.cMapUrl : null;
              const cMapPacked = src.cMapPacked !== false;
              const CMapReaderFactory = src.CMapReaderFactory || DefaultCMapReaderFactory;
              const standardFontDataUrl = typeof src.standardFontDataUrl === "string" ? src.standardFontDataUrl : null;
              const StandardFontDataFactory = src.StandardFontDataFactory || DefaultStandardFontDataFactory;
              const ignoreErrors = src.stopAtErrors !== true;
              const maxImageSize = Number.isInteger(src.maxImageSize) && src.maxImageSize > -1 ? src.maxImageSize : -1;
              const isEvalSupported = src.isEvalSupported !== false;
              const isOffscreenCanvasSupported = typeof src.isOffscreenCanvasSupported === "boolean" ? src.isOffscreenCanvasSupported : !_util.isNodeJS;
              const canvasMaxAreaInBytes = Number.isInteger(src.canvasMaxAreaInBytes) ? src.canvasMaxAreaInBytes : -1;
              const disableFontFace = typeof src.disableFontFace === "boolean" ? src.disableFontFace : _util.isNodeJS;
              const fontExtraProperties = src.fontExtraProperties === true;
              const enableXfa = src.enableXfa === true;
              const ownerDocument = src.ownerDocument || globalThis.document;
              const disableRange = src.disableRange === true;
              const disableStream = src.disableStream === true;
              const disableAutoFetch = src.disableAutoFetch === true;
              const pdfBug = src.pdfBug === true;
              const length = rangeTransport ? rangeTransport.length : src.length ?? NaN;
              const useSystemFonts = typeof src.useSystemFonts === "boolean" ? src.useSystemFonts : !_util.isNodeJS && !disableFontFace;
              const useWorkerFetch = typeof src.useWorkerFetch === "boolean" ? src.useWorkerFetch : CMapReaderFactory === _display_utils.DOMCMapReaderFactory && StandardFontDataFactory === _display_utils.DOMStandardFontDataFactory && cMapUrl && standardFontDataUrl && (0, _display_utils.isValidFetchUrl)(cMapUrl, document.baseURI) && (0, _display_utils.isValidFetchUrl)(standardFontDataUrl, document.baseURI);
              const canvasFactory = src.canvasFactory || new DefaultCanvasFactory({
                ownerDocument
              });
              const filterFactory = src.filterFactory || new DefaultFilterFactory({
                docId,
                ownerDocument
              });
              const styleElement = null;
              (0, _util.setVerbosityLevel)(verbosity);
              const transportFactory = {
                canvasFactory,
                filterFactory
              };
              if (!useWorkerFetch) {
                transportFactory.cMapReaderFactory = new CMapReaderFactory({
                  baseUrl: cMapUrl,
                  isCompressed: cMapPacked
                });
                transportFactory.standardFontDataFactory = new StandardFontDataFactory({
                  baseUrl: standardFontDataUrl
                });
              }
              if (!worker2) {
                const workerParams = {
                  verbosity,
                  port: _worker_options.GlobalWorkerOptions.workerPort
                };
                worker2 = workerParams.port ? PDFWorker.fromPort(workerParams) : new PDFWorker(workerParams);
                task._worker = worker2;
              }
              const fetchDocParams = {
                docId,
                apiVersion: "3.11.174",
                data,
                password,
                disableAutoFetch,
                rangeChunkSize,
                length,
                docBaseUrl,
                enableXfa,
                evaluatorOptions: {
                  maxImageSize,
                  disableFontFace,
                  ignoreErrors,
                  isEvalSupported,
                  isOffscreenCanvasSupported,
                  canvasMaxAreaInBytes,
                  fontExtraProperties,
                  useSystemFonts,
                  cMapUrl: useWorkerFetch ? cMapUrl : null,
                  standardFontDataUrl: useWorkerFetch ? standardFontDataUrl : null
                }
              };
              const transportParams = {
                ignoreErrors,
                isEvalSupported,
                disableFontFace,
                fontExtraProperties,
                enableXfa,
                ownerDocument,
                disableAutoFetch,
                pdfBug,
                styleElement
              };
              worker2.promise.then(function() {
                if (task.destroyed) {
                  throw new Error("Loading aborted");
                }
                const workerIdPromise = _fetchDocument(worker2, fetchDocParams);
                const networkStreamPromise = new Promise(function(resolve2) {
                  let networkStream;
                  if (rangeTransport) {
                    networkStream = new _transport_stream.PDFDataTransportStream({
                      length,
                      initialData: rangeTransport.initialData,
                      progressiveDone: rangeTransport.progressiveDone,
                      contentDispositionFilename: rangeTransport.contentDispositionFilename,
                      disableRange,
                      disableStream
                    }, rangeTransport);
                  } else if (!data) {
                    const createPDFNetworkStream = /* @__PURE__ */ __name((params) => {
                      if (_util.isNodeJS) {
                        return new _displayNode_stream.PDFNodeStream(params);
                      }
                      return (0, _display_utils.isValidFetchUrl)(params.url) ? new _displayFetch_stream.PDFFetchStream(params) : new _displayNetwork.PDFNetworkStream(params);
                    }, "createPDFNetworkStream");
                    networkStream = createPDFNetworkStream({
                      url,
                      length,
                      httpHeaders,
                      withCredentials,
                      rangeChunkSize,
                      disableRange,
                      disableStream
                    });
                  }
                  resolve2(networkStream);
                });
                return Promise.all([workerIdPromise, networkStreamPromise]).then(function([workerId, networkStream]) {
                  if (task.destroyed) {
                    throw new Error("Loading aborted");
                  }
                  const messageHandler = new _message_handler.MessageHandler(docId, workerId, worker2.port);
                  const transport = new WorkerTransport(messageHandler, task, networkStream, transportParams, transportFactory);
                  task._transport = transport;
                  messageHandler.send("Ready", null);
                });
              }).catch(task._capability.reject);
              return task;
            }
            __name(getDocument, "getDocument");
            async function _fetchDocument(worker2, source) {
              if (worker2.destroyed) {
                throw new Error("Worker was destroyed");
              }
              const workerId = await worker2.messageHandler.sendWithPromise("GetDocRequest", source, source.data ? [source.data.buffer] : null);
              if (worker2.destroyed) {
                throw new Error("Worker was destroyed");
              }
              return workerId;
            }
            __name(_fetchDocument, "_fetchDocument");
            function getUrlProp(val) {
              if (val instanceof URL) {
                return val.href;
              }
              try {
                return new URL(val, window.location).href;
              } catch {
                if (_util.isNodeJS && typeof val === "string") {
                  return val;
                }
              }
              throw new Error("Invalid PDF url data: either string or URL-object is expected in the url property.");
            }
            __name(getUrlProp, "getUrlProp");
            function getDataProp(val) {
              if (_util.isNodeJS && typeof Buffer !== "undefined" && val instanceof Buffer) {
                throw new Error("Please provide binary data as `Uint8Array`, rather than `Buffer`.");
              }
              if (val instanceof Uint8Array && val.byteLength === val.buffer.byteLength) {
                return val;
              }
              if (typeof val === "string") {
                return (0, _util.stringToBytes)(val);
              }
              if (typeof val === "object" && !isNaN(val == null ? void 0 : val.length) || (0, _util.isArrayBuffer)(val)) {
                return new Uint8Array(val);
              }
              throw new Error("Invalid PDF binary data: either TypedArray, string, or array-like object is expected in the data property.");
            }
            __name(getDataProp, "getDataProp");
            const _PDFDocumentLoadingTask = class _PDFDocumentLoadingTask {
              constructor() {
                this._capability = new _util.PromiseCapability();
                this._transport = null;
                this._worker = null;
                this.docId = `d${__privateWrapper(_PDFDocumentLoadingTask, _docId)._++}`;
                this.destroyed = false;
                this.onPassword = null;
                this.onProgress = null;
              }
              get promise() {
                return this._capability.promise;
              }
              async destroy() {
                var _a4, _b2, _c;
                this.destroyed = true;
                try {
                  if ((_a4 = this._worker) == null ? void 0 : _a4.port) {
                    this._worker._pendingDestroy = true;
                  }
                  await ((_b2 = this._transport) == null ? void 0 : _b2.destroy());
                } catch (ex) {
                  if ((_c = this._worker) == null ? void 0 : _c.port) {
                    delete this._worker._pendingDestroy;
                  }
                  throw ex;
                }
                this._transport = null;
                if (this._worker) {
                  this._worker.destroy();
                  this._worker = null;
                }
              }
            };
            _docId = new WeakMap();
            __name(_PDFDocumentLoadingTask, "PDFDocumentLoadingTask");
            __privateAdd(_PDFDocumentLoadingTask, _docId, 0);
            let PDFDocumentLoadingTask = _PDFDocumentLoadingTask;
            exports.PDFDocumentLoadingTask = PDFDocumentLoadingTask;
            const _PDFDataRangeTransport = class _PDFDataRangeTransport {
              constructor(length, initialData, progressiveDone = false, contentDispositionFilename = null) {
                this.length = length;
                this.initialData = initialData;
                this.progressiveDone = progressiveDone;
                this.contentDispositionFilename = contentDispositionFilename;
                this._rangeListeners = [];
                this._progressListeners = [];
                this._progressiveReadListeners = [];
                this._progressiveDoneListeners = [];
                this._readyCapability = new _util.PromiseCapability();
              }
              addRangeListener(listener) {
                this._rangeListeners.push(listener);
              }
              addProgressListener(listener) {
                this._progressListeners.push(listener);
              }
              addProgressiveReadListener(listener) {
                this._progressiveReadListeners.push(listener);
              }
              addProgressiveDoneListener(listener) {
                this._progressiveDoneListeners.push(listener);
              }
              onDataRange(begin, chunk) {
                for (const listener of this._rangeListeners) {
                  listener(begin, chunk);
                }
              }
              onDataProgress(loaded, total) {
                this._readyCapability.promise.then(() => {
                  for (const listener of this._progressListeners) {
                    listener(loaded, total);
                  }
                });
              }
              onDataProgressiveRead(chunk) {
                this._readyCapability.promise.then(() => {
                  for (const listener of this._progressiveReadListeners) {
                    listener(chunk);
                  }
                });
              }
              onDataProgressiveDone() {
                this._readyCapability.promise.then(() => {
                  for (const listener of this._progressiveDoneListeners) {
                    listener();
                  }
                });
              }
              transportReady() {
                this._readyCapability.resolve();
              }
              requestDataRange(begin, end) {
                (0, _util.unreachable)("Abstract method PDFDataRangeTransport.requestDataRange");
              }
              abort() {
              }
            };
            __name(_PDFDataRangeTransport, "PDFDataRangeTransport");
            let PDFDataRangeTransport = _PDFDataRangeTransport;
            exports.PDFDataRangeTransport = PDFDataRangeTransport;
            const _PDFDocumentProxy = class _PDFDocumentProxy {
              constructor(pdfInfo, transport) {
                this._pdfInfo = pdfInfo;
                this._transport = transport;
                Object.defineProperty(this, "getJavaScript", {
                  value: () => {
                    (0, _display_utils.deprecated)("`PDFDocumentProxy.getJavaScript`, please use `PDFDocumentProxy.getJSActions` instead.");
                    return this.getJSActions().then((js) => {
                      if (!js) {
                        return js;
                      }
                      const jsArr = [];
                      for (const name in js) {
                        jsArr.push(...js[name]);
                      }
                      return jsArr;
                    });
                  }
                });
              }
              get annotationStorage() {
                return this._transport.annotationStorage;
              }
              get filterFactory() {
                return this._transport.filterFactory;
              }
              get numPages() {
                return this._pdfInfo.numPages;
              }
              get fingerprints() {
                return this._pdfInfo.fingerprints;
              }
              get isPureXfa() {
                return (0, _util.shadow)(this, "isPureXfa", !!this._transport._htmlForXfa);
              }
              get allXfaHtml() {
                return this._transport._htmlForXfa;
              }
              getPage(pageNumber) {
                return this._transport.getPage(pageNumber);
              }
              getPageIndex(ref) {
                return this._transport.getPageIndex(ref);
              }
              getDestinations() {
                return this._transport.getDestinations();
              }
              getDestination(id) {
                return this._transport.getDestination(id);
              }
              getPageLabels() {
                return this._transport.getPageLabels();
              }
              getPageLayout() {
                return this._transport.getPageLayout();
              }
              getPageMode() {
                return this._transport.getPageMode();
              }
              getViewerPreferences() {
                return this._transport.getViewerPreferences();
              }
              getOpenAction() {
                return this._transport.getOpenAction();
              }
              getAttachments() {
                return this._transport.getAttachments();
              }
              getJSActions() {
                return this._transport.getDocJSActions();
              }
              getOutline() {
                return this._transport.getOutline();
              }
              getOptionalContentConfig() {
                return this._transport.getOptionalContentConfig();
              }
              getPermissions() {
                return this._transport.getPermissions();
              }
              getMetadata() {
                return this._transport.getMetadata();
              }
              getMarkInfo() {
                return this._transport.getMarkInfo();
              }
              getData() {
                return this._transport.getData();
              }
              saveDocument() {
                return this._transport.saveDocument();
              }
              getDownloadInfo() {
                return this._transport.downloadInfoCapability.promise;
              }
              cleanup(keepLoadedFonts = false) {
                return this._transport.startCleanup(keepLoadedFonts || this.isPureXfa);
              }
              destroy() {
                return this.loadingTask.destroy();
              }
              get loadingParams() {
                return this._transport.loadingParams;
              }
              get loadingTask() {
                return this._transport.loadingTask;
              }
              getFieldObjects() {
                return this._transport.getFieldObjects();
              }
              hasJSActions() {
                return this._transport.hasJSActions();
              }
              getCalculationOrderIds() {
                return this._transport.getCalculationOrderIds();
              }
            };
            __name(_PDFDocumentProxy, "PDFDocumentProxy");
            let PDFDocumentProxy = _PDFDocumentProxy;
            exports.PDFDocumentProxy = PDFDocumentProxy;
            const _PDFPageProxy = class _PDFPageProxy {
              constructor(pageIndex, pageInfo, transport, pdfBug = false) {
                __privateAdd(this, _tryCleanup);
                __privateAdd(this, _abortDelayedCleanup);
                __privateAdd(this, _delayedCleanupTimeout, null);
                __privateAdd(this, _pendingCleanup, false);
                this._pageIndex = pageIndex;
                this._pageInfo = pageInfo;
                this._transport = transport;
                this._stats = pdfBug ? new _display_utils.StatTimer() : null;
                this._pdfBug = pdfBug;
                this.commonObjs = transport.commonObjs;
                this.objs = new PDFObjects();
                this._maybeCleanupAfterRender = false;
                this._intentStates = /* @__PURE__ */ new Map();
                this.destroyed = false;
              }
              get pageNumber() {
                return this._pageIndex + 1;
              }
              get rotate() {
                return this._pageInfo.rotate;
              }
              get ref() {
                return this._pageInfo.ref;
              }
              get userUnit() {
                return this._pageInfo.userUnit;
              }
              get view() {
                return this._pageInfo.view;
              }
              getViewport({
                scale,
                rotation = this.rotate,
                offsetX = 0,
                offsetY = 0,
                dontFlip = false
              } = {}) {
                return new _display_utils.PageViewport({
                  viewBox: this.view,
                  scale,
                  rotation,
                  offsetX,
                  offsetY,
                  dontFlip
                });
              }
              getAnnotations({
                intent = "display"
              } = {}) {
                const intentArgs = this._transport.getRenderingIntent(intent);
                return this._transport.getAnnotations(this._pageIndex, intentArgs.renderingIntent);
              }
              getJSActions() {
                return this._transport.getPageJSActions(this._pageIndex);
              }
              get filterFactory() {
                return this._transport.filterFactory;
              }
              get isPureXfa() {
                return (0, _util.shadow)(this, "isPureXfa", !!this._transport._htmlForXfa);
              }
              async getXfa() {
                var _a4;
                return ((_a4 = this._transport._htmlForXfa) == null ? void 0 : _a4.children[this._pageIndex]) || null;
              }
              render({
                canvasContext,
                viewport,
                intent = "display",
                annotationMode = _util.AnnotationMode.ENABLE,
                transform = null,
                background = null,
                optionalContentConfigPromise = null,
                annotationCanvasMap = null,
                pageColors = null,
                printAnnotationStorage = null
              }) {
                var _a4, _b2;
                (_a4 = this._stats) == null ? void 0 : _a4.time("Overall");
                const intentArgs = this._transport.getRenderingIntent(intent, annotationMode, printAnnotationStorage);
                __privateSet(this, _pendingCleanup, false);
                __privateMethod(this, _abortDelayedCleanup, abortDelayedCleanup_fn).call(this);
                if (!optionalContentConfigPromise) {
                  optionalContentConfigPromise = this._transport.getOptionalContentConfig();
                }
                let intentState = this._intentStates.get(intentArgs.cacheKey);
                if (!intentState) {
                  intentState = /* @__PURE__ */ Object.create(null);
                  this._intentStates.set(intentArgs.cacheKey, intentState);
                }
                if (intentState.streamReaderCancelTimeout) {
                  clearTimeout(intentState.streamReaderCancelTimeout);
                  intentState.streamReaderCancelTimeout = null;
                }
                const intentPrint = !!(intentArgs.renderingIntent & _util.RenderingIntentFlag.PRINT);
                if (!intentState.displayReadyCapability) {
                  intentState.displayReadyCapability = new _util.PromiseCapability();
                  intentState.operatorList = {
                    fnArray: [],
                    argsArray: [],
                    lastChunk: false,
                    separateAnnots: null
                  };
                  (_b2 = this._stats) == null ? void 0 : _b2.time("Page Request");
                  this._pumpOperatorList(intentArgs);
                }
                const complete = /* @__PURE__ */ __name((error) => {
                  var _a5, _b3;
                  intentState.renderTasks.delete(internalRenderTask);
                  if (this._maybeCleanupAfterRender || intentPrint) {
                    __privateSet(this, _pendingCleanup, true);
                  }
                  __privateMethod(this, _tryCleanup, tryCleanup_fn).call(this, !intentPrint);
                  if (error) {
                    internalRenderTask.capability.reject(error);
                    this._abortOperatorList({
                      intentState,
                      reason: error instanceof Error ? error : new Error(error)
                    });
                  } else {
                    internalRenderTask.capability.resolve();
                  }
                  (_a5 = this._stats) == null ? void 0 : _a5.timeEnd("Rendering");
                  (_b3 = this._stats) == null ? void 0 : _b3.timeEnd("Overall");
                }, "complete");
                const internalRenderTask = new InternalRenderTask({
                  callback: complete,
                  params: {
                    canvasContext,
                    viewport,
                    transform,
                    background
                  },
                  objs: this.objs,
                  commonObjs: this.commonObjs,
                  annotationCanvasMap,
                  operatorList: intentState.operatorList,
                  pageIndex: this._pageIndex,
                  canvasFactory: this._transport.canvasFactory,
                  filterFactory: this._transport.filterFactory,
                  useRequestAnimationFrame: !intentPrint,
                  pdfBug: this._pdfBug,
                  pageColors
                });
                (intentState.renderTasks || (intentState.renderTasks = /* @__PURE__ */ new Set())).add(internalRenderTask);
                const renderTask = internalRenderTask.task;
                Promise.all([intentState.displayReadyCapability.promise, optionalContentConfigPromise]).then(([transparency, optionalContentConfig]) => {
                  var _a5;
                  if (this.destroyed) {
                    complete();
                    return;
                  }
                  (_a5 = this._stats) == null ? void 0 : _a5.time("Rendering");
                  internalRenderTask.initializeGraphics({
                    transparency,
                    optionalContentConfig
                  });
                  internalRenderTask.operatorListChanged();
                }).catch(complete);
                return renderTask;
              }
              getOperatorList({
                intent = "display",
                annotationMode = _util.AnnotationMode.ENABLE,
                printAnnotationStorage = null
              } = {}) {
                var _a4;
                function operatorListChanged() {
                  if (intentState.operatorList.lastChunk) {
                    intentState.opListReadCapability.resolve(intentState.operatorList);
                    intentState.renderTasks.delete(opListTask);
                  }
                }
                __name(operatorListChanged, "operatorListChanged");
                const intentArgs = this._transport.getRenderingIntent(intent, annotationMode, printAnnotationStorage, true);
                let intentState = this._intentStates.get(intentArgs.cacheKey);
                if (!intentState) {
                  intentState = /* @__PURE__ */ Object.create(null);
                  this._intentStates.set(intentArgs.cacheKey, intentState);
                }
                let opListTask;
                if (!intentState.opListReadCapability) {
                  opListTask = /* @__PURE__ */ Object.create(null);
                  opListTask.operatorListChanged = operatorListChanged;
                  intentState.opListReadCapability = new _util.PromiseCapability();
                  (intentState.renderTasks || (intentState.renderTasks = /* @__PURE__ */ new Set())).add(opListTask);
                  intentState.operatorList = {
                    fnArray: [],
                    argsArray: [],
                    lastChunk: false,
                    separateAnnots: null
                  };
                  (_a4 = this._stats) == null ? void 0 : _a4.time("Page Request");
                  this._pumpOperatorList(intentArgs);
                }
                return intentState.opListReadCapability.promise;
              }
              streamTextContent({
                includeMarkedContent = false,
                disableNormalization = false
              } = {}) {
                const TEXT_CONTENT_CHUNK_SIZE = 100;
                return this._transport.messageHandler.sendWithStream("GetTextContent", {
                  pageIndex: this._pageIndex,
                  includeMarkedContent: includeMarkedContent === true,
                  disableNormalization: disableNormalization === true
                }, {
                  highWaterMark: TEXT_CONTENT_CHUNK_SIZE,
                  size(textContent) {
                    return textContent.items.length;
                  }
                });
              }
              getTextContent(params = {}) {
                if (this._transport._htmlForXfa) {
                  return this.getXfa().then((xfa) => {
                    return _xfa_text.XfaText.textContent(xfa);
                  });
                }
                const readableStream = this.streamTextContent(params);
                return new Promise(function(resolve2, reject) {
                  function pump() {
                    reader.read().then(function({
                      value,
                      done
                    }) {
                      if (done) {
                        resolve2(textContent);
                        return;
                      }
                      Object.assign(textContent.styles, value.styles);
                      textContent.items.push(...value.items);
                      pump();
                    }, reject);
                  }
                  __name(pump, "pump");
                  const reader = readableStream.getReader();
                  const textContent = {
                    items: [],
                    styles: /* @__PURE__ */ Object.create(null)
                  };
                  pump();
                });
              }
              getStructTree() {
                return this._transport.getStructTree(this._pageIndex);
              }
              _destroy() {
                this.destroyed = true;
                const waitOn = [];
                for (const intentState of this._intentStates.values()) {
                  this._abortOperatorList({
                    intentState,
                    reason: new Error("Page was destroyed."),
                    force: true
                  });
                  if (intentState.opListReadCapability) {
                    continue;
                  }
                  for (const internalRenderTask of intentState.renderTasks) {
                    waitOn.push(internalRenderTask.completed);
                    internalRenderTask.cancel();
                  }
                }
                this.objs.clear();
                __privateSet(this, _pendingCleanup, false);
                __privateMethod(this, _abortDelayedCleanup, abortDelayedCleanup_fn).call(this);
                return Promise.all(waitOn);
              }
              cleanup(resetStats = false) {
                __privateSet(this, _pendingCleanup, true);
                const success = __privateMethod(this, _tryCleanup, tryCleanup_fn).call(this, false);
                if (resetStats && success) {
                  this._stats && (this._stats = new _display_utils.StatTimer());
                }
                return success;
              }
              _startRenderPage(transparency, cacheKey) {
                var _a4, _b2;
                const intentState = this._intentStates.get(cacheKey);
                if (!intentState) {
                  return;
                }
                (_a4 = this._stats) == null ? void 0 : _a4.timeEnd("Page Request");
                (_b2 = intentState.displayReadyCapability) == null ? void 0 : _b2.resolve(transparency);
              }
              _renderPageChunk(operatorListChunk, intentState) {
                for (let i2 = 0, ii = operatorListChunk.length; i2 < ii; i2++) {
                  intentState.operatorList.fnArray.push(operatorListChunk.fnArray[i2]);
                  intentState.operatorList.argsArray.push(operatorListChunk.argsArray[i2]);
                }
                intentState.operatorList.lastChunk = operatorListChunk.lastChunk;
                intentState.operatorList.separateAnnots = operatorListChunk.separateAnnots;
                for (const internalRenderTask of intentState.renderTasks) {
                  internalRenderTask.operatorListChanged();
                }
                if (operatorListChunk.lastChunk) {
                  __privateMethod(this, _tryCleanup, tryCleanup_fn).call(this, true);
                }
              }
              _pumpOperatorList({
                renderingIntent,
                cacheKey,
                annotationStorageSerializable
              }) {
                const {
                  map: map2,
                  transfers
                } = annotationStorageSerializable;
                const readableStream = this._transport.messageHandler.sendWithStream("GetOperatorList", {
                  pageIndex: this._pageIndex,
                  intent: renderingIntent,
                  cacheKey,
                  annotationStorage: map2
                }, transfers);
                const reader = readableStream.getReader();
                const intentState = this._intentStates.get(cacheKey);
                intentState.streamReader = reader;
                const pump = /* @__PURE__ */ __name(() => {
                  reader.read().then(({
                    value,
                    done
                  }) => {
                    if (done) {
                      intentState.streamReader = null;
                      return;
                    }
                    if (this._transport.destroyed) {
                      return;
                    }
                    this._renderPageChunk(value, intentState);
                    pump();
                  }, (reason) => {
                    intentState.streamReader = null;
                    if (this._transport.destroyed) {
                      return;
                    }
                    if (intentState.operatorList) {
                      intentState.operatorList.lastChunk = true;
                      for (const internalRenderTask of intentState.renderTasks) {
                        internalRenderTask.operatorListChanged();
                      }
                      __privateMethod(this, _tryCleanup, tryCleanup_fn).call(this, true);
                    }
                    if (intentState.displayReadyCapability) {
                      intentState.displayReadyCapability.reject(reason);
                    } else if (intentState.opListReadCapability) {
                      intentState.opListReadCapability.reject(reason);
                    } else {
                      throw reason;
                    }
                  });
                }, "pump");
                pump();
              }
              _abortOperatorList({
                intentState,
                reason,
                force = false
              }) {
                if (!intentState.streamReader) {
                  return;
                }
                if (intentState.streamReaderCancelTimeout) {
                  clearTimeout(intentState.streamReaderCancelTimeout);
                  intentState.streamReaderCancelTimeout = null;
                }
                if (!force) {
                  if (intentState.renderTasks.size > 0) {
                    return;
                  }
                  if (reason instanceof _display_utils.RenderingCancelledException) {
                    let delay = RENDERING_CANCELLED_TIMEOUT;
                    if (reason.extraDelay > 0 && reason.extraDelay < 1e3) {
                      delay += reason.extraDelay;
                    }
                    intentState.streamReaderCancelTimeout = setTimeout(() => {
                      intentState.streamReaderCancelTimeout = null;
                      this._abortOperatorList({
                        intentState,
                        reason,
                        force: true
                      });
                    }, delay);
                    return;
                  }
                }
                intentState.streamReader.cancel(new _util.AbortException(reason.message)).catch(() => {
                });
                intentState.streamReader = null;
                if (this._transport.destroyed) {
                  return;
                }
                for (const [curCacheKey, curIntentState] of this._intentStates) {
                  if (curIntentState === intentState) {
                    this._intentStates.delete(curCacheKey);
                    break;
                  }
                }
                this.cleanup();
              }
              get stats() {
                return this._stats;
              }
            };
            _delayedCleanupTimeout = new WeakMap();
            _pendingCleanup = new WeakMap();
            _tryCleanup = new WeakSet();
            tryCleanup_fn = /* @__PURE__ */ __name(function(delayed = false) {
              __privateMethod(this, _abortDelayedCleanup, abortDelayedCleanup_fn).call(this);
              if (!__privateGet(this, _pendingCleanup) || this.destroyed) {
                return false;
              }
              if (delayed) {
                __privateSet(this, _delayedCleanupTimeout, setTimeout(() => {
                  __privateSet(this, _delayedCleanupTimeout, null);
                  __privateMethod(this, _tryCleanup, tryCleanup_fn).call(this, false);
                }, DELAYED_CLEANUP_TIMEOUT));
                return false;
              }
              for (const {
                renderTasks,
                operatorList
              } of this._intentStates.values()) {
                if (renderTasks.size > 0 || !operatorList.lastChunk) {
                  return false;
                }
              }
              this._intentStates.clear();
              this.objs.clear();
              __privateSet(this, _pendingCleanup, false);
              return true;
            }, "#tryCleanup");
            _abortDelayedCleanup = new WeakSet();
            abortDelayedCleanup_fn = /* @__PURE__ */ __name(function() {
              if (__privateGet(this, _delayedCleanupTimeout)) {
                clearTimeout(__privateGet(this, _delayedCleanupTimeout));
                __privateSet(this, _delayedCleanupTimeout, null);
              }
            }, "#abortDelayedCleanup");
            __name(_PDFPageProxy, "PDFPageProxy");
            let PDFPageProxy = _PDFPageProxy;
            exports.PDFPageProxy = PDFPageProxy;
            const _LoopbackPort = class _LoopbackPort {
              constructor() {
                __privateAdd(this, _listeners, /* @__PURE__ */ new Set());
                __privateAdd(this, _deferred, Promise.resolve());
              }
              postMessage(obj, transfer) {
                const event = {
                  data: structuredClone(obj, transfer ? {
                    transfer
                  } : null)
                };
                __privateGet(this, _deferred).then(() => {
                  for (const listener of __privateGet(this, _listeners)) {
                    listener.call(this, event);
                  }
                });
              }
              addEventListener(name, listener) {
                __privateGet(this, _listeners).add(listener);
              }
              removeEventListener(name, listener) {
                __privateGet(this, _listeners).delete(listener);
              }
              terminate() {
                __privateGet(this, _listeners).clear();
              }
            };
            _listeners = new WeakMap();
            _deferred = new WeakMap();
            __name(_LoopbackPort, "LoopbackPort");
            let LoopbackPort = _LoopbackPort;
            exports.LoopbackPort = LoopbackPort;
            const PDFWorkerUtil = {
              isWorkerDisabled: false,
              fallbackWorkerSrc: null,
              fakeWorkerId: 0
            };
            exports.PDFWorkerUtil = PDFWorkerUtil;
            {
              if (_util.isNodeJS && typeof commonjsRequire === "function") {
                PDFWorkerUtil.isWorkerDisabled = true;
                PDFWorkerUtil.fallbackWorkerSrc = "./pdf.worker.js";
              } else if (typeof document === "object") {
                const pdfjsFilePath = (_a3 = document == null ? void 0 : document.currentScript) == null ? void 0 : _a3.src;
                if (pdfjsFilePath) {
                  PDFWorkerUtil.fallbackWorkerSrc = pdfjsFilePath.replace(/(\.(?:min\.)?js)(\?.*)?$/i, ".worker$1$2");
                }
              }
              PDFWorkerUtil.isSameOrigin = function(baseUrl, otherUrl) {
                let base;
                try {
                  base = new URL(baseUrl);
                  if (!base.origin || base.origin === "null") {
                    return false;
                  }
                } catch {
                  return false;
                }
                const other = new URL(otherUrl, base);
                return base.origin === other.origin;
              };
              PDFWorkerUtil.createCDNWrapper = function(url) {
                const wrapper = `importScripts("${url}");`;
                return URL.createObjectURL(new Blob([wrapper]));
              };
            }
            const _PDFWorker = class _PDFWorker {
              constructor({
                name = null,
                port = null,
                verbosity = (0, _util.getVerbosityLevel)()
              } = {}) {
                var _a4;
                this.name = name;
                this.destroyed = false;
                this.verbosity = verbosity;
                this._readyCapability = new _util.PromiseCapability();
                this._port = null;
                this._webWorker = null;
                this._messageHandler = null;
                if (port) {
                  if ((_a4 = __privateGet(_PDFWorker, _workerPorts)) == null ? void 0 : _a4.has(port)) {
                    throw new Error("Cannot use more than one PDFWorker per port.");
                  }
                  (__privateGet(_PDFWorker, _workerPorts) || __privateSet(_PDFWorker, _workerPorts, /* @__PURE__ */ new WeakMap())).set(port, this);
                  this._initializeFromPort(port);
                  return;
                }
                this._initialize();
              }
              get promise() {
                return this._readyCapability.promise;
              }
              get port() {
                return this._port;
              }
              get messageHandler() {
                return this._messageHandler;
              }
              _initializeFromPort(port) {
                this._port = port;
                this._messageHandler = new _message_handler.MessageHandler("main", "worker", port);
                this._messageHandler.on("ready", function() {
                });
                this._readyCapability.resolve();
                this._messageHandler.send("configure", {
                  verbosity: this.verbosity
                });
              }
              _initialize() {
                if (!PDFWorkerUtil.isWorkerDisabled && !_PDFWorker._mainThreadWorkerMessageHandler) {
                  let {
                    workerSrc
                  } = _PDFWorker;
                  try {
                    if (!PDFWorkerUtil.isSameOrigin(window.location.href, workerSrc)) {
                      workerSrc = PDFWorkerUtil.createCDNWrapper(new URL(workerSrc, window.location).href);
                    }
                    const worker2 = new Worker(workerSrc);
                    const messageHandler = new _message_handler.MessageHandler("main", "worker", worker2);
                    const terminateEarly = /* @__PURE__ */ __name(() => {
                      worker2.removeEventListener("error", onWorkerError);
                      messageHandler.destroy();
                      worker2.terminate();
                      if (this.destroyed) {
                        this._readyCapability.reject(new Error("Worker was destroyed"));
                      } else {
                        this._setupFakeWorker();
                      }
                    }, "terminateEarly");
                    const onWorkerError = /* @__PURE__ */ __name(() => {
                      if (!this._webWorker) {
                        terminateEarly();
                      }
                    }, "onWorkerError");
                    worker2.addEventListener("error", onWorkerError);
                    messageHandler.on("test", (data) => {
                      worker2.removeEventListener("error", onWorkerError);
                      if (this.destroyed) {
                        terminateEarly();
                        return;
                      }
                      if (data) {
                        this._messageHandler = messageHandler;
                        this._port = worker2;
                        this._webWorker = worker2;
                        this._readyCapability.resolve();
                        messageHandler.send("configure", {
                          verbosity: this.verbosity
                        });
                      } else {
                        this._setupFakeWorker();
                        messageHandler.destroy();
                        worker2.terminate();
                      }
                    });
                    messageHandler.on("ready", (data) => {
                      worker2.removeEventListener("error", onWorkerError);
                      if (this.destroyed) {
                        terminateEarly();
                        return;
                      }
                      try {
                        sendTest();
                      } catch {
                        this._setupFakeWorker();
                      }
                    });
                    const sendTest = /* @__PURE__ */ __name(() => {
                      const testObj = new Uint8Array();
                      messageHandler.send("test", testObj, [testObj.buffer]);
                    }, "sendTest");
                    sendTest();
                    return;
                  } catch {
                    (0, _util.info)("The worker has been disabled.");
                  }
                }
                this._setupFakeWorker();
              }
              _setupFakeWorker() {
                if (!PDFWorkerUtil.isWorkerDisabled) {
                  (0, _util.warn)("Setting up fake worker.");
                  PDFWorkerUtil.isWorkerDisabled = true;
                }
                _PDFWorker._setupFakeWorkerGlobal.then((WorkerMessageHandler) => {
                  if (this.destroyed) {
                    this._readyCapability.reject(new Error("Worker was destroyed"));
                    return;
                  }
                  const port = new LoopbackPort();
                  this._port = port;
                  const id = `fake${PDFWorkerUtil.fakeWorkerId++}`;
                  const workerHandler = new _message_handler.MessageHandler(id + "_worker", id, port);
                  WorkerMessageHandler.setup(workerHandler, port);
                  const messageHandler = new _message_handler.MessageHandler(id, id + "_worker", port);
                  this._messageHandler = messageHandler;
                  this._readyCapability.resolve();
                  messageHandler.send("configure", {
                    verbosity: this.verbosity
                  });
                }).catch((reason) => {
                  this._readyCapability.reject(new Error(`Setting up fake worker failed: "${reason.message}".`));
                });
              }
              destroy() {
                var _a4;
                this.destroyed = true;
                if (this._webWorker) {
                  this._webWorker.terminate();
                  this._webWorker = null;
                }
                (_a4 = __privateGet(_PDFWorker, _workerPorts)) == null ? void 0 : _a4.delete(this._port);
                this._port = null;
                if (this._messageHandler) {
                  this._messageHandler.destroy();
                  this._messageHandler = null;
                }
              }
              static fromPort(params) {
                var _a4;
                if (!(params == null ? void 0 : params.port)) {
                  throw new Error("PDFWorker.fromPort - invalid method signature.");
                }
                const cachedPort = (_a4 = __privateGet(this, _workerPorts)) == null ? void 0 : _a4.get(params.port);
                if (cachedPort) {
                  if (cachedPort._pendingDestroy) {
                    throw new Error("PDFWorker.fromPort - the worker is being destroyed.\nPlease remember to await `PDFDocumentLoadingTask.destroy()`-calls.");
                  }
                  return cachedPort;
                }
                return new _PDFWorker(params);
              }
              static get workerSrc() {
                if (_worker_options.GlobalWorkerOptions.workerSrc) {
                  return _worker_options.GlobalWorkerOptions.workerSrc;
                }
                if (PDFWorkerUtil.fallbackWorkerSrc !== null) {
                  if (!_util.isNodeJS) {
                    (0, _display_utils.deprecated)('No "GlobalWorkerOptions.workerSrc" specified.');
                  }
                  return PDFWorkerUtil.fallbackWorkerSrc;
                }
                throw new Error('No "GlobalWorkerOptions.workerSrc" specified.');
              }
              static get _mainThreadWorkerMessageHandler() {
                var _a4;
                try {
                  return ((_a4 = globalThis.pdfjsWorker) == null ? void 0 : _a4.WorkerMessageHandler) || null;
                } catch {
                  return null;
                }
              }
              static get _setupFakeWorkerGlobal() {
                const loader = /* @__PURE__ */ __name(async () => {
                  const mainWorkerMessageHandler = this._mainThreadWorkerMessageHandler;
                  if (mainWorkerMessageHandler) {
                    return mainWorkerMessageHandler;
                  }
                  if (_util.isNodeJS && typeof commonjsRequire === "function") {
                    const worker = eval("require")(this.workerSrc);
                    return worker.WorkerMessageHandler;
                  }
                  await (0, _display_utils.loadScript)(this.workerSrc);
                  return window.pdfjsWorker.WorkerMessageHandler;
                }, "loader");
                return (0, _util.shadow)(this, "_setupFakeWorkerGlobal", loader());
              }
            };
            _workerPorts = new WeakMap();
            __name(_PDFWorker, "PDFWorker");
            __privateAdd(_PDFWorker, _workerPorts, void 0);
            let PDFWorker = _PDFWorker;
            exports.PDFWorker = PDFWorker;
            const _WorkerTransport = class _WorkerTransport {
              constructor(messageHandler, loadingTask, networkStream, params, factory) {
                __privateAdd(this, _cacheSimpleMethod);
                __privateAdd(this, _methodPromises, /* @__PURE__ */ new Map());
                __privateAdd(this, _pageCache, /* @__PURE__ */ new Map());
                __privateAdd(this, _pagePromises, /* @__PURE__ */ new Map());
                __privateAdd(this, _passwordCapability, null);
                this.messageHandler = messageHandler;
                this.loadingTask = loadingTask;
                this.commonObjs = new PDFObjects();
                this.fontLoader = new _font_loader.FontLoader({
                  ownerDocument: params.ownerDocument,
                  styleElement: params.styleElement
                });
                this._params = params;
                this.canvasFactory = factory.canvasFactory;
                this.filterFactory = factory.filterFactory;
                this.cMapReaderFactory = factory.cMapReaderFactory;
                this.standardFontDataFactory = factory.standardFontDataFactory;
                this.destroyed = false;
                this.destroyCapability = null;
                this._networkStream = networkStream;
                this._fullReader = null;
                this._lastProgress = null;
                this.downloadInfoCapability = new _util.PromiseCapability();
                this.setupMessageHandler();
              }
              get annotationStorage() {
                return (0, _util.shadow)(this, "annotationStorage", new _annotation_storage.AnnotationStorage());
              }
              getRenderingIntent(intent, annotationMode = _util.AnnotationMode.ENABLE, printAnnotationStorage = null, isOpList = false) {
                let renderingIntent = _util.RenderingIntentFlag.DISPLAY;
                let annotationStorageSerializable = _annotation_storage.SerializableEmpty;
                switch (intent) {
                  case "any":
                    renderingIntent = _util.RenderingIntentFlag.ANY;
                    break;
                  case "display":
                    break;
                  case "print":
                    renderingIntent = _util.RenderingIntentFlag.PRINT;
                    break;
                  default:
                    (0, _util.warn)(`getRenderingIntent - invalid intent: ${intent}`);
                }
                switch (annotationMode) {
                  case _util.AnnotationMode.DISABLE:
                    renderingIntent += _util.RenderingIntentFlag.ANNOTATIONS_DISABLE;
                    break;
                  case _util.AnnotationMode.ENABLE:
                    break;
                  case _util.AnnotationMode.ENABLE_FORMS:
                    renderingIntent += _util.RenderingIntentFlag.ANNOTATIONS_FORMS;
                    break;
                  case _util.AnnotationMode.ENABLE_STORAGE:
                    renderingIntent += _util.RenderingIntentFlag.ANNOTATIONS_STORAGE;
                    const annotationStorage = renderingIntent & _util.RenderingIntentFlag.PRINT && printAnnotationStorage instanceof _annotation_storage.PrintAnnotationStorage ? printAnnotationStorage : this.annotationStorage;
                    annotationStorageSerializable = annotationStorage.serializable;
                    break;
                  default:
                    (0, _util.warn)(`getRenderingIntent - invalid annotationMode: ${annotationMode}`);
                }
                if (isOpList) {
                  renderingIntent += _util.RenderingIntentFlag.OPLIST;
                }
                return {
                  renderingIntent,
                  cacheKey: `${renderingIntent}_${annotationStorageSerializable.hash}`,
                  annotationStorageSerializable
                };
              }
              destroy() {
                var _a4;
                if (this.destroyCapability) {
                  return this.destroyCapability.promise;
                }
                this.destroyed = true;
                this.destroyCapability = new _util.PromiseCapability();
                (_a4 = __privateGet(this, _passwordCapability)) == null ? void 0 : _a4.reject(new Error("Worker was destroyed during onPassword callback"));
                const waitOn = [];
                for (const page of __privateGet(this, _pageCache).values()) {
                  waitOn.push(page._destroy());
                }
                __privateGet(this, _pageCache).clear();
                __privateGet(this, _pagePromises).clear();
                if (this.hasOwnProperty("annotationStorage")) {
                  this.annotationStorage.resetModified();
                }
                const terminated = this.messageHandler.sendWithPromise("Terminate", null);
                waitOn.push(terminated);
                Promise.all(waitOn).then(() => {
                  var _a5;
                  this.commonObjs.clear();
                  this.fontLoader.clear();
                  __privateGet(this, _methodPromises).clear();
                  this.filterFactory.destroy();
                  (_a5 = this._networkStream) == null ? void 0 : _a5.cancelAllRequests(new _util.AbortException("Worker was terminated."));
                  if (this.messageHandler) {
                    this.messageHandler.destroy();
                    this.messageHandler = null;
                  }
                  this.destroyCapability.resolve();
                }, this.destroyCapability.reject);
                return this.destroyCapability.promise;
              }
              setupMessageHandler() {
                const {
                  messageHandler,
                  loadingTask
                } = this;
                messageHandler.on("GetReader", (data, sink) => {
                  (0, _util.assert)(this._networkStream, "GetReader - no `IPDFStream` instance available.");
                  this._fullReader = this._networkStream.getFullReader();
                  this._fullReader.onProgress = (evt) => {
                    this._lastProgress = {
                      loaded: evt.loaded,
                      total: evt.total
                    };
                  };
                  sink.onPull = () => {
                    this._fullReader.read().then(function({
                      value,
                      done
                    }) {
                      if (done) {
                        sink.close();
                        return;
                      }
                      (0, _util.assert)(value instanceof ArrayBuffer, "GetReader - expected an ArrayBuffer.");
                      sink.enqueue(new Uint8Array(value), 1, [value]);
                    }).catch((reason) => {
                      sink.error(reason);
                    });
                  };
                  sink.onCancel = (reason) => {
                    this._fullReader.cancel(reason);
                    sink.ready.catch((readyReason) => {
                      if (this.destroyed) {
                        return;
                      }
                      throw readyReason;
                    });
                  };
                });
                messageHandler.on("ReaderHeadersReady", (data) => {
                  const headersCapability = new _util.PromiseCapability();
                  const fullReader = this._fullReader;
                  fullReader.headersReady.then(() => {
                    var _a4;
                    if (!fullReader.isStreamingSupported || !fullReader.isRangeSupported) {
                      if (this._lastProgress) {
                        (_a4 = loadingTask.onProgress) == null ? void 0 : _a4.call(loadingTask, this._lastProgress);
                      }
                      fullReader.onProgress = (evt) => {
                        var _a5;
                        (_a5 = loadingTask.onProgress) == null ? void 0 : _a5.call(loadingTask, {
                          loaded: evt.loaded,
                          total: evt.total
                        });
                      };
                    }
                    headersCapability.resolve({
                      isStreamingSupported: fullReader.isStreamingSupported,
                      isRangeSupported: fullReader.isRangeSupported,
                      contentLength: fullReader.contentLength
                    });
                  }, headersCapability.reject);
                  return headersCapability.promise;
                });
                messageHandler.on("GetRangeReader", (data, sink) => {
                  (0, _util.assert)(this._networkStream, "GetRangeReader - no `IPDFStream` instance available.");
                  const rangeReader = this._networkStream.getRangeReader(data.begin, data.end);
                  if (!rangeReader) {
                    sink.close();
                    return;
                  }
                  sink.onPull = () => {
                    rangeReader.read().then(function({
                      value,
                      done
                    }) {
                      if (done) {
                        sink.close();
                        return;
                      }
                      (0, _util.assert)(value instanceof ArrayBuffer, "GetRangeReader - expected an ArrayBuffer.");
                      sink.enqueue(new Uint8Array(value), 1, [value]);
                    }).catch((reason) => {
                      sink.error(reason);
                    });
                  };
                  sink.onCancel = (reason) => {
                    rangeReader.cancel(reason);
                    sink.ready.catch((readyReason) => {
                      if (this.destroyed) {
                        return;
                      }
                      throw readyReason;
                    });
                  };
                });
                messageHandler.on("GetDoc", ({
                  pdfInfo
                }) => {
                  this._numPages = pdfInfo.numPages;
                  this._htmlForXfa = pdfInfo.htmlForXfa;
                  delete pdfInfo.htmlForXfa;
                  loadingTask._capability.resolve(new PDFDocumentProxy(pdfInfo, this));
                });
                messageHandler.on("DocException", function(ex) {
                  let reason;
                  switch (ex.name) {
                    case "PasswordException":
                      reason = new _util.PasswordException(ex.message, ex.code);
                      break;
                    case "InvalidPDFException":
                      reason = new _util.InvalidPDFException(ex.message);
                      break;
                    case "MissingPDFException":
                      reason = new _util.MissingPDFException(ex.message);
                      break;
                    case "UnexpectedResponseException":
                      reason = new _util.UnexpectedResponseException(ex.message, ex.status);
                      break;
                    case "UnknownErrorException":
                      reason = new _util.UnknownErrorException(ex.message, ex.details);
                      break;
                    default:
                      (0, _util.unreachable)("DocException - expected a valid Error.");
                  }
                  loadingTask._capability.reject(reason);
                });
                messageHandler.on("PasswordRequest", (exception) => {
                  __privateSet(this, _passwordCapability, new _util.PromiseCapability());
                  if (loadingTask.onPassword) {
                    const updatePassword = /* @__PURE__ */ __name((password) => {
                      if (password instanceof Error) {
                        __privateGet(this, _passwordCapability).reject(password);
                      } else {
                        __privateGet(this, _passwordCapability).resolve({
                          password
                        });
                      }
                    }, "updatePassword");
                    try {
                      loadingTask.onPassword(updatePassword, exception.code);
                    } catch (ex) {
                      __privateGet(this, _passwordCapability).reject(ex);
                    }
                  } else {
                    __privateGet(this, _passwordCapability).reject(new _util.PasswordException(exception.message, exception.code));
                  }
                  return __privateGet(this, _passwordCapability).promise;
                });
                messageHandler.on("DataLoaded", (data) => {
                  var _a4;
                  (_a4 = loadingTask.onProgress) == null ? void 0 : _a4.call(loadingTask, {
                    loaded: data.length,
                    total: data.length
                  });
                  this.downloadInfoCapability.resolve(data);
                });
                messageHandler.on("StartRenderPage", (data) => {
                  if (this.destroyed) {
                    return;
                  }
                  const page = __privateGet(this, _pageCache).get(data.pageIndex);
                  page._startRenderPage(data.transparency, data.cacheKey);
                });
                messageHandler.on("commonobj", ([id, type, exportedData]) => {
                  var _a4;
                  if (this.destroyed) {
                    return;
                  }
                  if (this.commonObjs.has(id)) {
                    return;
                  }
                  switch (type) {
                    case "Font":
                      const params = this._params;
                      if ("error" in exportedData) {
                        const exportedError = exportedData.error;
                        (0, _util.warn)(`Error during font loading: ${exportedError}`);
                        this.commonObjs.resolve(id, exportedError);
                        break;
                      }
                      const inspectFont = params.pdfBug && ((_a4 = globalThis.FontInspector) == null ? void 0 : _a4.enabled) ? (font2, url) => globalThis.FontInspector.fontAdded(font2, url) : null;
                      const font = new _font_loader.FontFaceObject(exportedData, {
                        isEvalSupported: params.isEvalSupported,
                        disableFontFace: params.disableFontFace,
                        ignoreErrors: params.ignoreErrors,
                        inspectFont
                      });
                      this.fontLoader.bind(font).catch((reason) => {
                        return messageHandler.sendWithPromise("FontFallback", {
                          id
                        });
                      }).finally(() => {
                        if (!params.fontExtraProperties && font.data) {
                          font.data = null;
                        }
                        this.commonObjs.resolve(id, font);
                      });
                      break;
                    case "FontPath":
                    case "Image":
                    case "Pattern":
                      this.commonObjs.resolve(id, exportedData);
                      break;
                    default:
                      throw new Error(`Got unknown common object type ${type}`);
                  }
                });
                messageHandler.on("obj", ([id, pageIndex, type, imageData]) => {
                  var _a4;
                  if (this.destroyed) {
                    return;
                  }
                  const pageProxy = __privateGet(this, _pageCache).get(pageIndex);
                  if (pageProxy.objs.has(id)) {
                    return;
                  }
                  switch (type) {
                    case "Image":
                      pageProxy.objs.resolve(id, imageData);
                      if (imageData) {
                        let length;
                        if (imageData.bitmap) {
                          const {
                            width,
                            height
                          } = imageData;
                          length = width * height * 4;
                        } else {
                          length = ((_a4 = imageData.data) == null ? void 0 : _a4.length) || 0;
                        }
                        if (length > _util.MAX_IMAGE_SIZE_TO_CACHE) {
                          pageProxy._maybeCleanupAfterRender = true;
                        }
                      }
                      break;
                    case "Pattern":
                      pageProxy.objs.resolve(id, imageData);
                      break;
                    default:
                      throw new Error(`Got unknown object type ${type}`);
                  }
                });
                messageHandler.on("DocProgress", (data) => {
                  var _a4;
                  if (this.destroyed) {
                    return;
                  }
                  (_a4 = loadingTask.onProgress) == null ? void 0 : _a4.call(loadingTask, {
                    loaded: data.loaded,
                    total: data.total
                  });
                });
                messageHandler.on("FetchBuiltInCMap", (data) => {
                  if (this.destroyed) {
                    return Promise.reject(new Error("Worker was destroyed."));
                  }
                  if (!this.cMapReaderFactory) {
                    return Promise.reject(new Error("CMapReaderFactory not initialized, see the `useWorkerFetch` parameter."));
                  }
                  return this.cMapReaderFactory.fetch(data);
                });
                messageHandler.on("FetchStandardFontData", (data) => {
                  if (this.destroyed) {
                    return Promise.reject(new Error("Worker was destroyed."));
                  }
                  if (!this.standardFontDataFactory) {
                    return Promise.reject(new Error("StandardFontDataFactory not initialized, see the `useWorkerFetch` parameter."));
                  }
                  return this.standardFontDataFactory.fetch(data);
                });
              }
              getData() {
                return this.messageHandler.sendWithPromise("GetData", null);
              }
              saveDocument() {
                var _a4;
                if (this.annotationStorage.size <= 0) {
                  (0, _util.warn)("saveDocument called while `annotationStorage` is empty, please use the getData-method instead.");
                }
                const {
                  map: map2,
                  transfers
                } = this.annotationStorage.serializable;
                return this.messageHandler.sendWithPromise("SaveDocument", {
                  isPureXfa: !!this._htmlForXfa,
                  numPages: this._numPages,
                  annotationStorage: map2,
                  filename: ((_a4 = this._fullReader) == null ? void 0 : _a4.filename) ?? null
                }, transfers).finally(() => {
                  this.annotationStorage.resetModified();
                });
              }
              getPage(pageNumber) {
                if (!Number.isInteger(pageNumber) || pageNumber <= 0 || pageNumber > this._numPages) {
                  return Promise.reject(new Error("Invalid page request."));
                }
                const pageIndex = pageNumber - 1, cachedPromise = __privateGet(this, _pagePromises).get(pageIndex);
                if (cachedPromise) {
                  return cachedPromise;
                }
                const promise = this.messageHandler.sendWithPromise("GetPage", {
                  pageIndex
                }).then((pageInfo) => {
                  if (this.destroyed) {
                    throw new Error("Transport destroyed");
                  }
                  const page = new PDFPageProxy(pageIndex, pageInfo, this, this._params.pdfBug);
                  __privateGet(this, _pageCache).set(pageIndex, page);
                  return page;
                });
                __privateGet(this, _pagePromises).set(pageIndex, promise);
                return promise;
              }
              getPageIndex(ref) {
                if (typeof ref !== "object" || ref === null || !Number.isInteger(ref.num) || ref.num < 0 || !Number.isInteger(ref.gen) || ref.gen < 0) {
                  return Promise.reject(new Error("Invalid pageIndex request."));
                }
                return this.messageHandler.sendWithPromise("GetPageIndex", {
                  num: ref.num,
                  gen: ref.gen
                });
              }
              getAnnotations(pageIndex, intent) {
                return this.messageHandler.sendWithPromise("GetAnnotations", {
                  pageIndex,
                  intent
                });
              }
              getFieldObjects() {
                return __privateMethod(this, _cacheSimpleMethod, cacheSimpleMethod_fn).call(this, "GetFieldObjects");
              }
              hasJSActions() {
                return __privateMethod(this, _cacheSimpleMethod, cacheSimpleMethod_fn).call(this, "HasJSActions");
              }
              getCalculationOrderIds() {
                return this.messageHandler.sendWithPromise("GetCalculationOrderIds", null);
              }
              getDestinations() {
                return this.messageHandler.sendWithPromise("GetDestinations", null);
              }
              getDestination(id) {
                if (typeof id !== "string") {
                  return Promise.reject(new Error("Invalid destination request."));
                }
                return this.messageHandler.sendWithPromise("GetDestination", {
                  id
                });
              }
              getPageLabels() {
                return this.messageHandler.sendWithPromise("GetPageLabels", null);
              }
              getPageLayout() {
                return this.messageHandler.sendWithPromise("GetPageLayout", null);
              }
              getPageMode() {
                return this.messageHandler.sendWithPromise("GetPageMode", null);
              }
              getViewerPreferences() {
                return this.messageHandler.sendWithPromise("GetViewerPreferences", null);
              }
              getOpenAction() {
                return this.messageHandler.sendWithPromise("GetOpenAction", null);
              }
              getAttachments() {
                return this.messageHandler.sendWithPromise("GetAttachments", null);
              }
              getDocJSActions() {
                return __privateMethod(this, _cacheSimpleMethod, cacheSimpleMethod_fn).call(this, "GetDocJSActions");
              }
              getPageJSActions(pageIndex) {
                return this.messageHandler.sendWithPromise("GetPageJSActions", {
                  pageIndex
                });
              }
              getStructTree(pageIndex) {
                return this.messageHandler.sendWithPromise("GetStructTree", {
                  pageIndex
                });
              }
              getOutline() {
                return this.messageHandler.sendWithPromise("GetOutline", null);
              }
              getOptionalContentConfig() {
                return this.messageHandler.sendWithPromise("GetOptionalContentConfig", null).then((results) => {
                  return new _optional_content_config.OptionalContentConfig(results);
                });
              }
              getPermissions() {
                return this.messageHandler.sendWithPromise("GetPermissions", null);
              }
              getMetadata() {
                const name = "GetMetadata", cachedPromise = __privateGet(this, _methodPromises).get(name);
                if (cachedPromise) {
                  return cachedPromise;
                }
                const promise = this.messageHandler.sendWithPromise(name, null).then((results) => {
                  var _a4, _b2;
                  return {
                    info: results[0],
                    metadata: results[1] ? new _metadata.Metadata(results[1]) : null,
                    contentDispositionFilename: ((_a4 = this._fullReader) == null ? void 0 : _a4.filename) ?? null,
                    contentLength: ((_b2 = this._fullReader) == null ? void 0 : _b2.contentLength) ?? null
                  };
                });
                __privateGet(this, _methodPromises).set(name, promise);
                return promise;
              }
              getMarkInfo() {
                return this.messageHandler.sendWithPromise("GetMarkInfo", null);
              }
              async startCleanup(keepLoadedFonts = false) {
                if (this.destroyed) {
                  return;
                }
                await this.messageHandler.sendWithPromise("Cleanup", null);
                for (const page of __privateGet(this, _pageCache).values()) {
                  const cleanupSuccessful = page.cleanup();
                  if (!cleanupSuccessful) {
                    throw new Error(`startCleanup: Page ${page.pageNumber} is currently rendering.`);
                  }
                }
                this.commonObjs.clear();
                if (!keepLoadedFonts) {
                  this.fontLoader.clear();
                }
                __privateGet(this, _methodPromises).clear();
                this.filterFactory.destroy(true);
              }
              get loadingParams() {
                const {
                  disableAutoFetch,
                  enableXfa
                } = this._params;
                return (0, _util.shadow)(this, "loadingParams", {
                  disableAutoFetch,
                  enableXfa
                });
              }
            };
            _methodPromises = new WeakMap();
            _pageCache = new WeakMap();
            _pagePromises = new WeakMap();
            _passwordCapability = new WeakMap();
            _cacheSimpleMethod = new WeakSet();
            cacheSimpleMethod_fn = /* @__PURE__ */ __name(function(name, data = null) {
              const cachedPromise = __privateGet(this, _methodPromises).get(name);
              if (cachedPromise) {
                return cachedPromise;
              }
              const promise = this.messageHandler.sendWithPromise(name, data);
              __privateGet(this, _methodPromises).set(name, promise);
              return promise;
            }, "#cacheSimpleMethod");
            __name(_WorkerTransport, "WorkerTransport");
            let WorkerTransport = _WorkerTransport;
            const _PDFObjects = class _PDFObjects {
              constructor() {
                __privateAdd(this, _ensureObj);
                __privateAdd(this, _objs, /* @__PURE__ */ Object.create(null));
              }
              get(objId, callback2 = null) {
                if (callback2) {
                  const obj2 = __privateMethod(this, _ensureObj, ensureObj_fn).call(this, objId);
                  obj2.capability.promise.then(() => callback2(obj2.data));
                  return null;
                }
                const obj = __privateGet(this, _objs)[objId];
                if (!(obj == null ? void 0 : obj.capability.settled)) {
                  throw new Error(`Requesting object that isn't resolved yet ${objId}.`);
                }
                return obj.data;
              }
              has(objId) {
                const obj = __privateGet(this, _objs)[objId];
                return (obj == null ? void 0 : obj.capability.settled) || false;
              }
              resolve(objId, data = null) {
                const obj = __privateMethod(this, _ensureObj, ensureObj_fn).call(this, objId);
                obj.data = data;
                obj.capability.resolve();
              }
              clear() {
                var _a4;
                for (const objId in __privateGet(this, _objs)) {
                  const {
                    data
                  } = __privateGet(this, _objs)[objId];
                  (_a4 = data == null ? void 0 : data.bitmap) == null ? void 0 : _a4.close();
                }
                __privateSet(this, _objs, /* @__PURE__ */ Object.create(null));
              }
            };
            _objs = new WeakMap();
            _ensureObj = new WeakSet();
            ensureObj_fn = /* @__PURE__ */ __name(function(objId) {
              var _a4;
              return (_a4 = __privateGet(this, _objs))[objId] || (_a4[objId] = {
                capability: new _util.PromiseCapability(),
                data: null
              });
            }, "#ensureObj");
            __name(_PDFObjects, "PDFObjects");
            let PDFObjects = _PDFObjects;
            const _RenderTask = class _RenderTask {
              constructor(internalRenderTask) {
                __privateAdd(this, _internalRenderTask, null);
                __privateSet(this, _internalRenderTask, internalRenderTask);
                this.onContinue = null;
              }
              get promise() {
                return __privateGet(this, _internalRenderTask).capability.promise;
              }
              cancel(extraDelay = 0) {
                __privateGet(this, _internalRenderTask).cancel(null, extraDelay);
              }
              get separateAnnots() {
                const {
                  separateAnnots
                } = __privateGet(this, _internalRenderTask).operatorList;
                if (!separateAnnots) {
                  return false;
                }
                const {
                  annotationCanvasMap
                } = __privateGet(this, _internalRenderTask);
                return separateAnnots.form || separateAnnots.canvas && (annotationCanvasMap == null ? void 0 : annotationCanvasMap.size) > 0;
              }
            };
            _internalRenderTask = new WeakMap();
            __name(_RenderTask, "RenderTask");
            let RenderTask = _RenderTask;
            exports.RenderTask = RenderTask;
            const _InternalRenderTask = class _InternalRenderTask {
              constructor({
                callback: callback2,
                params,
                objs,
                commonObjs,
                annotationCanvasMap,
                operatorList,
                pageIndex,
                canvasFactory,
                filterFactory,
                useRequestAnimationFrame = false,
                pdfBug = false,
                pageColors = null
              }) {
                this.callback = callback2;
                this.params = params;
                this.objs = objs;
                this.commonObjs = commonObjs;
                this.annotationCanvasMap = annotationCanvasMap;
                this.operatorListIdx = null;
                this.operatorList = operatorList;
                this._pageIndex = pageIndex;
                this.canvasFactory = canvasFactory;
                this.filterFactory = filterFactory;
                this._pdfBug = pdfBug;
                this.pageColors = pageColors;
                this.running = false;
                this.graphicsReadyCallback = null;
                this.graphicsReady = false;
                this._useRequestAnimationFrame = useRequestAnimationFrame === true && typeof window !== "undefined";
                this.cancelled = false;
                this.capability = new _util.PromiseCapability();
                this.task = new RenderTask(this);
                this._cancelBound = this.cancel.bind(this);
                this._continueBound = this._continue.bind(this);
                this._scheduleNextBound = this._scheduleNext.bind(this);
                this._nextBound = this._next.bind(this);
                this._canvas = params.canvasContext.canvas;
              }
              get completed() {
                return this.capability.promise.catch(function() {
                });
              }
              initializeGraphics({
                transparency = false,
                optionalContentConfig
              }) {
                var _a4, _b2;
                if (this.cancelled) {
                  return;
                }
                if (this._canvas) {
                  if (__privateGet(_InternalRenderTask, _canvasInUse).has(this._canvas)) {
                    throw new Error("Cannot use the same canvas during multiple render() operations. Use different canvas or ensure previous operations were cancelled or completed.");
                  }
                  __privateGet(_InternalRenderTask, _canvasInUse).add(this._canvas);
                }
                if (this._pdfBug && ((_a4 = globalThis.StepperManager) == null ? void 0 : _a4.enabled)) {
                  this.stepper = globalThis.StepperManager.create(this._pageIndex);
                  this.stepper.init(this.operatorList);
                  this.stepper.nextBreakPoint = this.stepper.getNextBreakPoint();
                }
                const {
                  canvasContext,
                  viewport,
                  transform,
                  background
                } = this.params;
                this.gfx = new _canvas.CanvasGraphics(canvasContext, this.commonObjs, this.objs, this.canvasFactory, this.filterFactory, {
                  optionalContentConfig
                }, this.annotationCanvasMap, this.pageColors);
                this.gfx.beginDrawing({
                  transform,
                  viewport,
                  transparency,
                  background
                });
                this.operatorListIdx = 0;
                this.graphicsReady = true;
                (_b2 = this.graphicsReadyCallback) == null ? void 0 : _b2.call(this);
              }
              cancel(error = null, extraDelay = 0) {
                var _a4;
                this.running = false;
                this.cancelled = true;
                (_a4 = this.gfx) == null ? void 0 : _a4.endDrawing();
                __privateGet(_InternalRenderTask, _canvasInUse).delete(this._canvas);
                this.callback(error || new _display_utils.RenderingCancelledException(`Rendering cancelled, page ${this._pageIndex + 1}`, extraDelay));
              }
              operatorListChanged() {
                var _a4;
                if (!this.graphicsReady) {
                  this.graphicsReadyCallback || (this.graphicsReadyCallback = this._continueBound);
                  return;
                }
                (_a4 = this.stepper) == null ? void 0 : _a4.updateOperatorList(this.operatorList);
                if (this.running) {
                  return;
                }
                this._continue();
              }
              _continue() {
                this.running = true;
                if (this.cancelled) {
                  return;
                }
                if (this.task.onContinue) {
                  this.task.onContinue(this._scheduleNextBound);
                } else {
                  this._scheduleNext();
                }
              }
              _scheduleNext() {
                if (this._useRequestAnimationFrame) {
                  window.requestAnimationFrame(() => {
                    this._nextBound().catch(this._cancelBound);
                  });
                } else {
                  Promise.resolve().then(this._nextBound).catch(this._cancelBound);
                }
              }
              async _next() {
                if (this.cancelled) {
                  return;
                }
                this.operatorListIdx = this.gfx.executeOperatorList(this.operatorList, this.operatorListIdx, this._continueBound, this.stepper);
                if (this.operatorListIdx === this.operatorList.argsArray.length) {
                  this.running = false;
                  if (this.operatorList.lastChunk) {
                    this.gfx.endDrawing();
                    __privateGet(_InternalRenderTask, _canvasInUse).delete(this._canvas);
                    this.callback();
                  }
                }
              }
            };
            _canvasInUse = new WeakMap();
            __name(_InternalRenderTask, "InternalRenderTask");
            __privateAdd(_InternalRenderTask, _canvasInUse, /* @__PURE__ */ new WeakSet());
            let InternalRenderTask = _InternalRenderTask;
            const version = "3.11.174";
            exports.version = version;
            const build = "ce8716743";
            exports.build = build;
          },
          /* 3 */
          /***/
          (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
            var _modified, _storage, _setModified, setModified_fn, _serializable;
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            exports2.SerializableEmpty = exports2.PrintAnnotationStorage = exports2.AnnotationStorage = void 0;
            var _util2 = __w_pdfjs_require__2(1);
            var _editor = __w_pdfjs_require__2(4);
            var _murmurhash = __w_pdfjs_require__2(8);
            const SerializableEmpty = Object.freeze({
              map: null,
              hash: "",
              transfers: void 0
            });
            exports2.SerializableEmpty = SerializableEmpty;
            const _AnnotationStorage = class _AnnotationStorage {
              constructor() {
                __privateAdd(this, _setModified);
                __privateAdd(this, _modified, false);
                __privateAdd(this, _storage, /* @__PURE__ */ new Map());
                this.onSetModified = null;
                this.onResetModified = null;
                this.onAnnotationEditor = null;
              }
              getValue(key, defaultValue) {
                const value = __privateGet(this, _storage).get(key);
                if (value === void 0) {
                  return defaultValue;
                }
                return Object.assign(defaultValue, value);
              }
              getRawValue(key) {
                return __privateGet(this, _storage).get(key);
              }
              remove(key) {
                __privateGet(this, _storage).delete(key);
                if (__privateGet(this, _storage).size === 0) {
                  this.resetModified();
                }
                if (typeof this.onAnnotationEditor === "function") {
                  for (const value of __privateGet(this, _storage).values()) {
                    if (value instanceof _editor.AnnotationEditor) {
                      return;
                    }
                  }
                  this.onAnnotationEditor(null);
                }
              }
              setValue(key, value) {
                const obj = __privateGet(this, _storage).get(key);
                let modified = false;
                if (obj !== void 0) {
                  for (const [entry, val] of Object.entries(value)) {
                    if (obj[entry] !== val) {
                      modified = true;
                      obj[entry] = val;
                    }
                  }
                } else {
                  modified = true;
                  __privateGet(this, _storage).set(key, value);
                }
                if (modified) {
                  __privateMethod(this, _setModified, setModified_fn).call(this);
                }
                if (value instanceof _editor.AnnotationEditor && typeof this.onAnnotationEditor === "function") {
                  this.onAnnotationEditor(value.constructor._type);
                }
              }
              has(key) {
                return __privateGet(this, _storage).has(key);
              }
              getAll() {
                return __privateGet(this, _storage).size > 0 ? (0, _util2.objectFromMap)(__privateGet(this, _storage)) : null;
              }
              setAll(obj) {
                for (const [key, val] of Object.entries(obj)) {
                  this.setValue(key, val);
                }
              }
              get size() {
                return __privateGet(this, _storage).size;
              }
              resetModified() {
                if (__privateGet(this, _modified)) {
                  __privateSet(this, _modified, false);
                  if (typeof this.onResetModified === "function") {
                    this.onResetModified();
                  }
                }
              }
              get print() {
                return new PrintAnnotationStorage(this);
              }
              get serializable() {
                if (__privateGet(this, _storage).size === 0) {
                  return SerializableEmpty;
                }
                const map2 = /* @__PURE__ */ new Map(), hash = new _murmurhash.MurmurHash3_64(), transfers = [];
                const context = /* @__PURE__ */ Object.create(null);
                let hasBitmap = false;
                for (const [key, val] of __privateGet(this, _storage)) {
                  const serialized = val instanceof _editor.AnnotationEditor ? val.serialize(false, context) : val;
                  if (serialized) {
                    map2.set(key, serialized);
                    hash.update(`${key}:${JSON.stringify(serialized)}`);
                    hasBitmap || (hasBitmap = !!serialized.bitmap);
                  }
                }
                if (hasBitmap) {
                  for (const value of map2.values()) {
                    if (value.bitmap) {
                      transfers.push(value.bitmap);
                    }
                  }
                }
                return map2.size > 0 ? {
                  map: map2,
                  hash: hash.hexdigest(),
                  transfers
                } : SerializableEmpty;
              }
            };
            _modified = new WeakMap();
            _storage = new WeakMap();
            _setModified = new WeakSet();
            setModified_fn = /* @__PURE__ */ __name(function() {
              if (!__privateGet(this, _modified)) {
                __privateSet(this, _modified, true);
                if (typeof this.onSetModified === "function") {
                  this.onSetModified();
                }
              }
            }, "#setModified");
            __name(_AnnotationStorage, "AnnotationStorage");
            let AnnotationStorage = _AnnotationStorage;
            exports2.AnnotationStorage = AnnotationStorage;
            const _PrintAnnotationStorage = class _PrintAnnotationStorage extends AnnotationStorage {
              constructor(parent) {
                super();
                __privateAdd(this, _serializable, void 0);
                const {
                  map: map2,
                  hash,
                  transfers
                } = parent.serializable;
                const clone2 = structuredClone(map2, transfers ? {
                  transfer: transfers
                } : null);
                __privateSet(this, _serializable, {
                  map: clone2,
                  hash,
                  transfers
                });
              }
              get print() {
                (0, _util2.unreachable)("Should not call PrintAnnotationStorage.print");
              }
              get serializable() {
                return __privateGet(this, _serializable);
              }
            };
            _serializable = new WeakMap();
            __name(_PrintAnnotationStorage, "PrintAnnotationStorage");
            let PrintAnnotationStorage = _PrintAnnotationStorage;
            exports2.PrintAnnotationStorage = PrintAnnotationStorage;
          },
          /* 4 */
          /***/
          (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
            var _altText, _altTextDecorative, _altTextButton, _altTextTooltip, _altTextTooltipTimeout, _keepAspectRatio, _resizersDiv, _boundFocusin, _boundFocusout, _hasBeenClicked, _isEditing, _isInEditMode, _isDraggable, _zIndex, _translate, translate_fn, _getBaseTranslation, getBaseTranslation_fn, _rotatePoint, rotatePoint_fn, _getRotationMatrix, getRotationMatrix_fn, _createResizers, createResizers_fn, _resizerPointerdown, resizerPointerdown_fn, _resizerPointermove, resizerPointermove_fn, _setAltTextButtonState, setAltTextButtonState_fn, _setUpDragSession, setUpDragSession_fn;
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            exports2.AnnotationEditor = void 0;
            var _tools = __w_pdfjs_require__2(5);
            var _util2 = __w_pdfjs_require__2(1);
            var _display_utils2 = __w_pdfjs_require__2(6);
            const _AnnotationEditor = class _AnnotationEditor {
              constructor(parameters) {
                __privateAdd(this, _translate);
                __privateAdd(this, _getBaseTranslation);
                __privateAdd(this, _getRotationMatrix);
                __privateAdd(this, _createResizers);
                __privateAdd(this, _resizerPointerdown);
                __privateAdd(this, _resizerPointermove);
                __privateAdd(this, _setAltTextButtonState);
                __privateAdd(this, _setUpDragSession);
                __privateAdd(this, _altText, "");
                __privateAdd(this, _altTextDecorative, false);
                __privateAdd(this, _altTextButton, null);
                __privateAdd(this, _altTextTooltip, null);
                __privateAdd(this, _altTextTooltipTimeout, null);
                __privateAdd(this, _keepAspectRatio, false);
                __privateAdd(this, _resizersDiv, null);
                __privateAdd(this, _boundFocusin, this.focusin.bind(this));
                __privateAdd(this, _boundFocusout, this.focusout.bind(this));
                __privateAdd(this, _hasBeenClicked, false);
                __privateAdd(this, _isEditing, false);
                __privateAdd(this, _isInEditMode, false);
                __publicField(this, "_initialOptions", /* @__PURE__ */ Object.create(null));
                __publicField(this, "_uiManager", null);
                __publicField(this, "_focusEventsAllowed", true);
                __publicField(this, "_l10nPromise", null);
                __privateAdd(this, _isDraggable, false);
                __privateAdd(this, _zIndex, _AnnotationEditor._zIndex++);
                if (this.constructor === _AnnotationEditor) {
                  (0, _util2.unreachable)("Cannot initialize AnnotationEditor.");
                }
                this.parent = parameters.parent;
                this.id = parameters.id;
                this.width = this.height = null;
                this.pageIndex = parameters.parent.pageIndex;
                this.name = parameters.name;
                this.div = null;
                this._uiManager = parameters.uiManager;
                this.annotationElementId = null;
                this._willKeepAspectRatio = false;
                this._initialOptions.isCentered = parameters.isCentered;
                this._structTreeParentId = null;
                const {
                  rotation,
                  rawDims: {
                    pageWidth,
                    pageHeight,
                    pageX,
                    pageY
                  }
                } = this.parent.viewport;
                this.rotation = rotation;
                this.pageRotation = (360 + rotation - this._uiManager.viewParameters.rotation) % 360;
                this.pageDimensions = [pageWidth, pageHeight];
                this.pageTranslation = [pageX, pageY];
                const [width, height] = this.parentDimensions;
                this.x = parameters.x / width;
                this.y = parameters.y / height;
                this.isAttachedToDOM = false;
                this.deleted = false;
              }
              get editorType() {
                return Object.getPrototypeOf(this).constructor._type;
              }
              static get _defaultLineColor() {
                return (0, _util2.shadow)(this, "_defaultLineColor", this._colorManager.getHexCode("CanvasText"));
              }
              static deleteAnnotationElement(editor) {
                const fakeEditor = new FakeEditor({
                  id: editor.parent.getNextId(),
                  parent: editor.parent,
                  uiManager: editor._uiManager
                });
                fakeEditor.annotationElementId = editor.annotationElementId;
                fakeEditor.deleted = true;
                fakeEditor._uiManager.addToAnnotationStorage(fakeEditor);
              }
              static initialize(l10n, options = null) {
                _AnnotationEditor._l10nPromise || (_AnnotationEditor._l10nPromise = new Map(["editor_alt_text_button_label", "editor_alt_text_edit_button_label", "editor_alt_text_decorative_tooltip"].map((str) => [str, l10n.get(str)])));
                if (options == null ? void 0 : options.strings) {
                  for (const str of options.strings) {
                    _AnnotationEditor._l10nPromise.set(str, l10n.get(str));
                  }
                }
                if (_AnnotationEditor._borderLineWidth !== -1) {
                  return;
                }
                const style = getComputedStyle(document.documentElement);
                _AnnotationEditor._borderLineWidth = parseFloat(style.getPropertyValue("--outline-width")) || 0;
              }
              static updateDefaultParams(_type, _value) {
              }
              static get defaultPropertiesToUpdate() {
                return [];
              }
              static isHandlingMimeForPasting(mime) {
                return false;
              }
              static paste(item, parent) {
                (0, _util2.unreachable)("Not implemented");
              }
              get propertiesToUpdate() {
                return [];
              }
              get _isDraggable() {
                return __privateGet(this, _isDraggable);
              }
              set _isDraggable(value) {
                var _a3;
                __privateSet(this, _isDraggable, value);
                (_a3 = this.div) == null ? void 0 : _a3.classList.toggle("draggable", value);
              }
              center() {
                const [pageWidth, pageHeight] = this.pageDimensions;
                switch (this.parentRotation) {
                  case 90:
                    this.x -= this.height * pageHeight / (pageWidth * 2);
                    this.y += this.width * pageWidth / (pageHeight * 2);
                    break;
                  case 180:
                    this.x += this.width / 2;
                    this.y += this.height / 2;
                    break;
                  case 270:
                    this.x += this.height * pageHeight / (pageWidth * 2);
                    this.y -= this.width * pageWidth / (pageHeight * 2);
                    break;
                  default:
                    this.x -= this.width / 2;
                    this.y -= this.height / 2;
                    break;
                }
                this.fixAndSetPosition();
              }
              addCommands(params) {
                this._uiManager.addCommands(params);
              }
              get currentLayer() {
                return this._uiManager.currentLayer;
              }
              setInBackground() {
                this.div.style.zIndex = 0;
              }
              setInForeground() {
                this.div.style.zIndex = __privateGet(this, _zIndex);
              }
              setParent(parent) {
                if (parent !== null) {
                  this.pageIndex = parent.pageIndex;
                  this.pageDimensions = parent.pageDimensions;
                }
                this.parent = parent;
              }
              focusin(event) {
                if (!this._focusEventsAllowed) {
                  return;
                }
                if (!__privateGet(this, _hasBeenClicked)) {
                  this.parent.setSelected(this);
                } else {
                  __privateSet(this, _hasBeenClicked, false);
                }
              }
              focusout(event) {
                var _a3;
                if (!this._focusEventsAllowed) {
                  return;
                }
                if (!this.isAttachedToDOM) {
                  return;
                }
                const target = event.relatedTarget;
                if (target == null ? void 0 : target.closest(`#${this.id}`)) {
                  return;
                }
                event.preventDefault();
                if (!((_a3 = this.parent) == null ? void 0 : _a3.isMultipleSelection)) {
                  this.commitOrRemove();
                }
              }
              commitOrRemove() {
                if (this.isEmpty()) {
                  this.remove();
                } else {
                  this.commit();
                }
              }
              commit() {
                this.addToAnnotationStorage();
              }
              addToAnnotationStorage() {
                this._uiManager.addToAnnotationStorage(this);
              }
              setAt(x2, y2, tx, ty) {
                const [width, height] = this.parentDimensions;
                [tx, ty] = this.screenToPageTranslation(tx, ty);
                this.x = (x2 + tx) / width;
                this.y = (y2 + ty) / height;
                this.fixAndSetPosition();
              }
              translate(x2, y2) {
                __privateMethod(this, _translate, translate_fn).call(this, this.parentDimensions, x2, y2);
              }
              translateInPage(x2, y2) {
                __privateMethod(this, _translate, translate_fn).call(this, this.pageDimensions, x2, y2);
                this.div.scrollIntoView({
                  block: "nearest"
                });
              }
              drag(tx, ty) {
                const [parentWidth, parentHeight] = this.parentDimensions;
                this.x += tx / parentWidth;
                this.y += ty / parentHeight;
                if (this.parent && (this.x < 0 || this.x > 1 || this.y < 0 || this.y > 1)) {
                  const {
                    x: x3,
                    y: y3
                  } = this.div.getBoundingClientRect();
                  if (this.parent.findNewParent(this, x3, y3)) {
                    this.x -= Math.floor(this.x);
                    this.y -= Math.floor(this.y);
                  }
                }
                let {
                  x: x2,
                  y: y2
                } = this;
                const [bx, by] = __privateMethod(this, _getBaseTranslation, getBaseTranslation_fn).call(this);
                x2 += bx;
                y2 += by;
                this.div.style.left = `${(100 * x2).toFixed(2)}%`;
                this.div.style.top = `${(100 * y2).toFixed(2)}%`;
                this.div.scrollIntoView({
                  block: "nearest"
                });
              }
              fixAndSetPosition() {
                const [pageWidth, pageHeight] = this.pageDimensions;
                let {
                  x: x2,
                  y: y2,
                  width,
                  height
                } = this;
                width *= pageWidth;
                height *= pageHeight;
                x2 *= pageWidth;
                y2 *= pageHeight;
                switch (this.rotation) {
                  case 0:
                    x2 = Math.max(0, Math.min(pageWidth - width, x2));
                    y2 = Math.max(0, Math.min(pageHeight - height, y2));
                    break;
                  case 90:
                    x2 = Math.max(0, Math.min(pageWidth - height, x2));
                    y2 = Math.min(pageHeight, Math.max(width, y2));
                    break;
                  case 180:
                    x2 = Math.min(pageWidth, Math.max(width, x2));
                    y2 = Math.min(pageHeight, Math.max(height, y2));
                    break;
                  case 270:
                    x2 = Math.min(pageWidth, Math.max(height, x2));
                    y2 = Math.max(0, Math.min(pageHeight - width, y2));
                    break;
                }
                this.x = x2 /= pageWidth;
                this.y = y2 /= pageHeight;
                const [bx, by] = __privateMethod(this, _getBaseTranslation, getBaseTranslation_fn).call(this);
                x2 += bx;
                y2 += by;
                const {
                  style
                } = this.div;
                style.left = `${(100 * x2).toFixed(2)}%`;
                style.top = `${(100 * y2).toFixed(2)}%`;
                this.moveInDOM();
              }
              screenToPageTranslation(x2, y2) {
                var _a3;
                return __privateMethod(_a3 = _AnnotationEditor, _rotatePoint, rotatePoint_fn).call(_a3, x2, y2, this.parentRotation);
              }
              pageTranslationToScreen(x2, y2) {
                var _a3;
                return __privateMethod(_a3 = _AnnotationEditor, _rotatePoint, rotatePoint_fn).call(_a3, x2, y2, 360 - this.parentRotation);
              }
              get parentScale() {
                return this._uiManager.viewParameters.realScale;
              }
              get parentRotation() {
                return (this._uiManager.viewParameters.rotation + this.pageRotation) % 360;
              }
              get parentDimensions() {
                const {
                  parentScale,
                  pageDimensions: [pageWidth, pageHeight]
                } = this;
                const scaledWidth = pageWidth * parentScale;
                const scaledHeight = pageHeight * parentScale;
                return _util2.FeatureTest.isCSSRoundSupported ? [Math.round(scaledWidth), Math.round(scaledHeight)] : [scaledWidth, scaledHeight];
              }
              setDims(width, height) {
                var _a3;
                const [parentWidth, parentHeight] = this.parentDimensions;
                this.div.style.width = `${(100 * width / parentWidth).toFixed(2)}%`;
                if (!__privateGet(this, _keepAspectRatio)) {
                  this.div.style.height = `${(100 * height / parentHeight).toFixed(2)}%`;
                }
                (_a3 = __privateGet(this, _altTextButton)) == null ? void 0 : _a3.classList.toggle("small", width < _AnnotationEditor.SMALL_EDITOR_SIZE || height < _AnnotationEditor.SMALL_EDITOR_SIZE);
              }
              fixDims() {
                const {
                  style
                } = this.div;
                const {
                  height,
                  width
                } = style;
                const widthPercent = width.endsWith("%");
                const heightPercent = !__privateGet(this, _keepAspectRatio) && height.endsWith("%");
                if (widthPercent && heightPercent) {
                  return;
                }
                const [parentWidth, parentHeight] = this.parentDimensions;
                if (!widthPercent) {
                  style.width = `${(100 * parseFloat(width) / parentWidth).toFixed(2)}%`;
                }
                if (!__privateGet(this, _keepAspectRatio) && !heightPercent) {
                  style.height = `${(100 * parseFloat(height) / parentHeight).toFixed(2)}%`;
                }
              }
              getInitialTranslation() {
                return [0, 0];
              }
              async addAltTextButton() {
                if (__privateGet(this, _altTextButton)) {
                  return;
                }
                const altText = __privateSet(this, _altTextButton, document.createElement("button"));
                altText.className = "altText";
                const msg = await _AnnotationEditor._l10nPromise.get("editor_alt_text_button_label");
                altText.textContent = msg;
                altText.setAttribute("aria-label", msg);
                altText.tabIndex = "0";
                altText.addEventListener("contextmenu", _display_utils2.noContextMenu);
                altText.addEventListener("pointerdown", (event) => event.stopPropagation());
                altText.addEventListener("click", (event) => {
                  event.preventDefault();
                  this._uiManager.editAltText(this);
                }, {
                  capture: true
                });
                altText.addEventListener("keydown", (event) => {
                  if (event.target === altText && event.key === "Enter") {
                    event.preventDefault();
                    this._uiManager.editAltText(this);
                  }
                });
                __privateMethod(this, _setAltTextButtonState, setAltTextButtonState_fn).call(this);
                this.div.append(altText);
                if (!_AnnotationEditor.SMALL_EDITOR_SIZE) {
                  const PERCENT = 40;
                  _AnnotationEditor.SMALL_EDITOR_SIZE = Math.min(128, Math.round(altText.getBoundingClientRect().width * (1 + PERCENT / 100)));
                }
              }
              getClientDimensions() {
                return this.div.getBoundingClientRect();
              }
              get altTextData() {
                return {
                  altText: __privateGet(this, _altText),
                  decorative: __privateGet(this, _altTextDecorative)
                };
              }
              set altTextData({
                altText,
                decorative
              }) {
                if (__privateGet(this, _altText) === altText && __privateGet(this, _altTextDecorative) === decorative) {
                  return;
                }
                __privateSet(this, _altText, altText);
                __privateSet(this, _altTextDecorative, decorative);
                __privateMethod(this, _setAltTextButtonState, setAltTextButtonState_fn).call(this);
              }
              render() {
                this.div = document.createElement("div");
                this.div.setAttribute("data-editor-rotation", (360 - this.rotation) % 360);
                this.div.className = this.name;
                this.div.setAttribute("id", this.id);
                this.div.setAttribute("tabIndex", 0);
                this.setInForeground();
                this.div.addEventListener("focusin", __privateGet(this, _boundFocusin));
                this.div.addEventListener("focusout", __privateGet(this, _boundFocusout));
                const [parentWidth, parentHeight] = this.parentDimensions;
                if (this.parentRotation % 180 !== 0) {
                  this.div.style.maxWidth = `${(100 * parentHeight / parentWidth).toFixed(2)}%`;
                  this.div.style.maxHeight = `${(100 * parentWidth / parentHeight).toFixed(2)}%`;
                }
                const [tx, ty] = this.getInitialTranslation();
                this.translate(tx, ty);
                (0, _tools.bindEvents)(this, this.div, ["pointerdown"]);
                return this.div;
              }
              pointerdown(event) {
                const {
                  isMac
                } = _util2.FeatureTest.platform;
                if (event.button !== 0 || event.ctrlKey && isMac) {
                  event.preventDefault();
                  return;
                }
                __privateSet(this, _hasBeenClicked, true);
                __privateMethod(this, _setUpDragSession, setUpDragSession_fn).call(this, event);
              }
              moveInDOM() {
                var _a3;
                (_a3 = this.parent) == null ? void 0 : _a3.moveEditorInDOM(this);
              }
              _setParentAndPosition(parent, x2, y2) {
                parent.changeParent(this);
                this.x = x2;
                this.y = y2;
                this.fixAndSetPosition();
              }
              getRect(tx, ty) {
                const scale = this.parentScale;
                const [pageWidth, pageHeight] = this.pageDimensions;
                const [pageX, pageY] = this.pageTranslation;
                const shiftX = tx / scale;
                const shiftY = ty / scale;
                const x2 = this.x * pageWidth;
                const y2 = this.y * pageHeight;
                const width = this.width * pageWidth;
                const height = this.height * pageHeight;
                switch (this.rotation) {
                  case 0:
                    return [x2 + shiftX + pageX, pageHeight - y2 - shiftY - height + pageY, x2 + shiftX + width + pageX, pageHeight - y2 - shiftY + pageY];
                  case 90:
                    return [x2 + shiftY + pageX, pageHeight - y2 + shiftX + pageY, x2 + shiftY + height + pageX, pageHeight - y2 + shiftX + width + pageY];
                  case 180:
                    return [x2 - shiftX - width + pageX, pageHeight - y2 + shiftY + pageY, x2 - shiftX + pageX, pageHeight - y2 + shiftY + height + pageY];
                  case 270:
                    return [x2 - shiftY - height + pageX, pageHeight - y2 - shiftX - width + pageY, x2 - shiftY + pageX, pageHeight - y2 - shiftX + pageY];
                  default:
                    throw new Error("Invalid rotation");
                }
              }
              getRectInCurrentCoords(rect, pageHeight) {
                const [x1, y1, x2, y2] = rect;
                const width = x2 - x1;
                const height = y2 - y1;
                switch (this.rotation) {
                  case 0:
                    return [x1, pageHeight - y2, width, height];
                  case 90:
                    return [x1, pageHeight - y1, height, width];
                  case 180:
                    return [x2, pageHeight - y1, width, height];
                  case 270:
                    return [x2, pageHeight - y2, height, width];
                  default:
                    throw new Error("Invalid rotation");
                }
              }
              onceAdded() {
              }
              isEmpty() {
                return false;
              }
              enableEditMode() {
                __privateSet(this, _isInEditMode, true);
              }
              disableEditMode() {
                __privateSet(this, _isInEditMode, false);
              }
              isInEditMode() {
                return __privateGet(this, _isInEditMode);
              }
              shouldGetKeyboardEvents() {
                return false;
              }
              needsToBeRebuilt() {
                return this.div && !this.isAttachedToDOM;
              }
              rebuild() {
                var _a3, _b2;
                (_a3 = this.div) == null ? void 0 : _a3.addEventListener("focusin", __privateGet(this, _boundFocusin));
                (_b2 = this.div) == null ? void 0 : _b2.addEventListener("focusout", __privateGet(this, _boundFocusout));
              }
              serialize(isForCopying = false, context = null) {
                (0, _util2.unreachable)("An editor must be serializable");
              }
              static deserialize(data, parent, uiManager) {
                const editor = new this.prototype.constructor({
                  parent,
                  id: parent.getNextId(),
                  uiManager
                });
                editor.rotation = data.rotation;
                const [pageWidth, pageHeight] = editor.pageDimensions;
                const [x2, y2, width, height] = editor.getRectInCurrentCoords(data.rect, pageHeight);
                editor.x = x2 / pageWidth;
                editor.y = y2 / pageHeight;
                editor.width = width / pageWidth;
                editor.height = height / pageHeight;
                return editor;
              }
              remove() {
                var _a3;
                this.div.removeEventListener("focusin", __privateGet(this, _boundFocusin));
                this.div.removeEventListener("focusout", __privateGet(this, _boundFocusout));
                if (!this.isEmpty()) {
                  this.commit();
                }
                if (this.parent) {
                  this.parent.remove(this);
                } else {
                  this._uiManager.removeEditor(this);
                }
                (_a3 = __privateGet(this, _altTextButton)) == null ? void 0 : _a3.remove();
                __privateSet(this, _altTextButton, null);
                __privateSet(this, _altTextTooltip, null);
              }
              get isResizable() {
                return false;
              }
              makeResizable() {
                if (this.isResizable) {
                  __privateMethod(this, _createResizers, createResizers_fn).call(this);
                  __privateGet(this, _resizersDiv).classList.remove("hidden");
                }
              }
              select() {
                var _a3;
                this.makeResizable();
                (_a3 = this.div) == null ? void 0 : _a3.classList.add("selectedEditor");
              }
              unselect() {
                var _a3, _b2, _c;
                (_a3 = __privateGet(this, _resizersDiv)) == null ? void 0 : _a3.classList.add("hidden");
                (_b2 = this.div) == null ? void 0 : _b2.classList.remove("selectedEditor");
                if ((_c = this.div) == null ? void 0 : _c.contains(document.activeElement)) {
                  this._uiManager.currentLayer.div.focus();
                }
              }
              updateParams(type, value) {
              }
              disableEditing() {
                if (__privateGet(this, _altTextButton)) {
                  __privateGet(this, _altTextButton).hidden = true;
                }
              }
              enableEditing() {
                if (__privateGet(this, _altTextButton)) {
                  __privateGet(this, _altTextButton).hidden = false;
                }
              }
              enterInEditMode() {
              }
              get contentDiv() {
                return this.div;
              }
              get isEditing() {
                return __privateGet(this, _isEditing);
              }
              set isEditing(value) {
                __privateSet(this, _isEditing, value);
                if (!this.parent) {
                  return;
                }
                if (value) {
                  this.parent.setSelected(this);
                  this.parent.setActiveEditor(this);
                } else {
                  this.parent.setActiveEditor(null);
                }
              }
              setAspectRatio(width, height) {
                __privateSet(this, _keepAspectRatio, true);
                const aspectRatio = width / height;
                const {
                  style
                } = this.div;
                style.aspectRatio = aspectRatio;
                style.height = "auto";
              }
              static get MIN_SIZE() {
                return 16;
              }
            };
            _altText = new WeakMap();
            _altTextDecorative = new WeakMap();
            _altTextButton = new WeakMap();
            _altTextTooltip = new WeakMap();
            _altTextTooltipTimeout = new WeakMap();
            _keepAspectRatio = new WeakMap();
            _resizersDiv = new WeakMap();
            _boundFocusin = new WeakMap();
            _boundFocusout = new WeakMap();
            _hasBeenClicked = new WeakMap();
            _isEditing = new WeakMap();
            _isInEditMode = new WeakMap();
            _isDraggable = new WeakMap();
            _zIndex = new WeakMap();
            _translate = new WeakSet();
            translate_fn = /* @__PURE__ */ __name(function([width, height], x2, y2) {
              [x2, y2] = this.screenToPageTranslation(x2, y2);
              this.x += x2 / width;
              this.y += y2 / height;
              this.fixAndSetPosition();
            }, "#translate");
            _getBaseTranslation = new WeakSet();
            getBaseTranslation_fn = /* @__PURE__ */ __name(function() {
              const [parentWidth, parentHeight] = this.parentDimensions;
              const {
                _borderLineWidth
              } = _AnnotationEditor;
              const x2 = _borderLineWidth / parentWidth;
              const y2 = _borderLineWidth / parentHeight;
              switch (this.rotation) {
                case 90:
                  return [-x2, y2];
                case 180:
                  return [x2, y2];
                case 270:
                  return [x2, -y2];
                default:
                  return [-x2, -y2];
              }
            }, "#getBaseTranslation");
            _rotatePoint = new WeakSet();
            rotatePoint_fn = /* @__PURE__ */ __name(function(x2, y2, angle) {
              switch (angle) {
                case 90:
                  return [y2, -x2];
                case 180:
                  return [-x2, -y2];
                case 270:
                  return [-y2, x2];
                default:
                  return [x2, y2];
              }
            }, "#rotatePoint");
            _getRotationMatrix = new WeakSet();
            getRotationMatrix_fn = /* @__PURE__ */ __name(function(rotation) {
              switch (rotation) {
                case 90: {
                  const [pageWidth, pageHeight] = this.pageDimensions;
                  return [0, -pageWidth / pageHeight, pageHeight / pageWidth, 0];
                }
                case 180:
                  return [-1, 0, 0, -1];
                case 270: {
                  const [pageWidth, pageHeight] = this.pageDimensions;
                  return [0, pageWidth / pageHeight, -pageHeight / pageWidth, 0];
                }
                default:
                  return [1, 0, 0, 1];
              }
            }, "#getRotationMatrix");
            _createResizers = new WeakSet();
            createResizers_fn = /* @__PURE__ */ __name(function() {
              if (__privateGet(this, _resizersDiv)) {
                return;
              }
              __privateSet(this, _resizersDiv, document.createElement("div"));
              __privateGet(this, _resizersDiv).classList.add("resizers");
              const classes = ["topLeft", "topRight", "bottomRight", "bottomLeft"];
              if (!this._willKeepAspectRatio) {
                classes.push("topMiddle", "middleRight", "bottomMiddle", "middleLeft");
              }
              for (const name of classes) {
                const div = document.createElement("div");
                __privateGet(this, _resizersDiv).append(div);
                div.classList.add("resizer", name);
                div.addEventListener("pointerdown", __privateMethod(this, _resizerPointerdown, resizerPointerdown_fn).bind(this, name));
                div.addEventListener("contextmenu", _display_utils2.noContextMenu);
              }
              this.div.prepend(__privateGet(this, _resizersDiv));
            }, "#createResizers");
            _resizerPointerdown = new WeakSet();
            resizerPointerdown_fn = /* @__PURE__ */ __name(function(name, event) {
              event.preventDefault();
              const {
                isMac
              } = _util2.FeatureTest.platform;
              if (event.button !== 0 || event.ctrlKey && isMac) {
                return;
              }
              const boundResizerPointermove = __privateMethod(this, _resizerPointermove, resizerPointermove_fn).bind(this, name);
              const savedDraggable = this._isDraggable;
              this._isDraggable = false;
              const pointerMoveOptions = {
                passive: true,
                capture: true
              };
              window.addEventListener("pointermove", boundResizerPointermove, pointerMoveOptions);
              const savedX = this.x;
              const savedY = this.y;
              const savedWidth = this.width;
              const savedHeight = this.height;
              const savedParentCursor = this.parent.div.style.cursor;
              const savedCursor = this.div.style.cursor;
              this.div.style.cursor = this.parent.div.style.cursor = window.getComputedStyle(event.target).cursor;
              const pointerUpCallback = /* @__PURE__ */ __name(() => {
                this._isDraggable = savedDraggable;
                window.removeEventListener("pointerup", pointerUpCallback);
                window.removeEventListener("blur", pointerUpCallback);
                window.removeEventListener("pointermove", boundResizerPointermove, pointerMoveOptions);
                this.parent.div.style.cursor = savedParentCursor;
                this.div.style.cursor = savedCursor;
                const newX = this.x;
                const newY = this.y;
                const newWidth = this.width;
                const newHeight = this.height;
                if (newX === savedX && newY === savedY && newWidth === savedWidth && newHeight === savedHeight) {
                  return;
                }
                this.addCommands({
                  cmd: () => {
                    this.width = newWidth;
                    this.height = newHeight;
                    this.x = newX;
                    this.y = newY;
                    const [parentWidth, parentHeight] = this.parentDimensions;
                    this.setDims(parentWidth * newWidth, parentHeight * newHeight);
                    this.fixAndSetPosition();
                  },
                  undo: () => {
                    this.width = savedWidth;
                    this.height = savedHeight;
                    this.x = savedX;
                    this.y = savedY;
                    const [parentWidth, parentHeight] = this.parentDimensions;
                    this.setDims(parentWidth * savedWidth, parentHeight * savedHeight);
                    this.fixAndSetPosition();
                  },
                  mustExec: true
                });
              }, "pointerUpCallback");
              window.addEventListener("pointerup", pointerUpCallback);
              window.addEventListener("blur", pointerUpCallback);
            }, "#resizerPointerdown");
            _resizerPointermove = new WeakSet();
            resizerPointermove_fn = /* @__PURE__ */ __name(function(name, event) {
              const [parentWidth, parentHeight] = this.parentDimensions;
              const savedX = this.x;
              const savedY = this.y;
              const savedWidth = this.width;
              const savedHeight = this.height;
              const minWidth = _AnnotationEditor.MIN_SIZE / parentWidth;
              const minHeight = _AnnotationEditor.MIN_SIZE / parentHeight;
              const round2 = /* @__PURE__ */ __name((x2) => Math.round(x2 * 1e4) / 1e4, "round");
              const rotationMatrix = __privateMethod(this, _getRotationMatrix, getRotationMatrix_fn).call(this, this.rotation);
              const transf = /* @__PURE__ */ __name((x2, y2) => [rotationMatrix[0] * x2 + rotationMatrix[2] * y2, rotationMatrix[1] * x2 + rotationMatrix[3] * y2], "transf");
              const invRotationMatrix = __privateMethod(this, _getRotationMatrix, getRotationMatrix_fn).call(this, 360 - this.rotation);
              const invTransf = /* @__PURE__ */ __name((x2, y2) => [invRotationMatrix[0] * x2 + invRotationMatrix[2] * y2, invRotationMatrix[1] * x2 + invRotationMatrix[3] * y2], "invTransf");
              let getPoint2;
              let getOpposite;
              let isDiagonal = false;
              let isHorizontal = false;
              switch (name) {
                case "topLeft":
                  isDiagonal = true;
                  getPoint2 = /* @__PURE__ */ __name((w2, h3) => [0, 0], "getPoint");
                  getOpposite = /* @__PURE__ */ __name((w2, h3) => [w2, h3], "getOpposite");
                  break;
                case "topMiddle":
                  getPoint2 = /* @__PURE__ */ __name((w2, h3) => [w2 / 2, 0], "getPoint");
                  getOpposite = /* @__PURE__ */ __name((w2, h3) => [w2 / 2, h3], "getOpposite");
                  break;
                case "topRight":
                  isDiagonal = true;
                  getPoint2 = /* @__PURE__ */ __name((w2, h3) => [w2, 0], "getPoint");
                  getOpposite = /* @__PURE__ */ __name((w2, h3) => [0, h3], "getOpposite");
                  break;
                case "middleRight":
                  isHorizontal = true;
                  getPoint2 = /* @__PURE__ */ __name((w2, h3) => [w2, h3 / 2], "getPoint");
                  getOpposite = /* @__PURE__ */ __name((w2, h3) => [0, h3 / 2], "getOpposite");
                  break;
                case "bottomRight":
                  isDiagonal = true;
                  getPoint2 = /* @__PURE__ */ __name((w2, h3) => [w2, h3], "getPoint");
                  getOpposite = /* @__PURE__ */ __name((w2, h3) => [0, 0], "getOpposite");
                  break;
                case "bottomMiddle":
                  getPoint2 = /* @__PURE__ */ __name((w2, h3) => [w2 / 2, h3], "getPoint");
                  getOpposite = /* @__PURE__ */ __name((w2, h3) => [w2 / 2, 0], "getOpposite");
                  break;
                case "bottomLeft":
                  isDiagonal = true;
                  getPoint2 = /* @__PURE__ */ __name((w2, h3) => [0, h3], "getPoint");
                  getOpposite = /* @__PURE__ */ __name((w2, h3) => [w2, 0], "getOpposite");
                  break;
                case "middleLeft":
                  isHorizontal = true;
                  getPoint2 = /* @__PURE__ */ __name((w2, h3) => [0, h3 / 2], "getPoint");
                  getOpposite = /* @__PURE__ */ __name((w2, h3) => [w2, h3 / 2], "getOpposite");
                  break;
              }
              const point = getPoint2(savedWidth, savedHeight);
              const oppositePoint = getOpposite(savedWidth, savedHeight);
              let transfOppositePoint = transf(...oppositePoint);
              const oppositeX = round2(savedX + transfOppositePoint[0]);
              const oppositeY = round2(savedY + transfOppositePoint[1]);
              let ratioX = 1;
              let ratioY = 1;
              let [deltaX, deltaY] = this.screenToPageTranslation(event.movementX, event.movementY);
              [deltaX, deltaY] = invTransf(deltaX / parentWidth, deltaY / parentHeight);
              if (isDiagonal) {
                const oldDiag = Math.hypot(savedWidth, savedHeight);
                ratioX = ratioY = Math.max(Math.min(Math.hypot(oppositePoint[0] - point[0] - deltaX, oppositePoint[1] - point[1] - deltaY) / oldDiag, 1 / savedWidth, 1 / savedHeight), minWidth / savedWidth, minHeight / savedHeight);
              } else if (isHorizontal) {
                ratioX = Math.max(minWidth, Math.min(1, Math.abs(oppositePoint[0] - point[0] - deltaX))) / savedWidth;
              } else {
                ratioY = Math.max(minHeight, Math.min(1, Math.abs(oppositePoint[1] - point[1] - deltaY))) / savedHeight;
              }
              const newWidth = round2(savedWidth * ratioX);
              const newHeight = round2(savedHeight * ratioY);
              transfOppositePoint = transf(...getOpposite(newWidth, newHeight));
              const newX = oppositeX - transfOppositePoint[0];
              const newY = oppositeY - transfOppositePoint[1];
              this.width = newWidth;
              this.height = newHeight;
              this.x = newX;
              this.y = newY;
              this.setDims(parentWidth * newWidth, parentHeight * newHeight);
              this.fixAndSetPosition();
            }, "#resizerPointermove");
            _setAltTextButtonState = new WeakSet();
            setAltTextButtonState_fn = /* @__PURE__ */ __name(async function() {
              var _a3;
              const button = __privateGet(this, _altTextButton);
              if (!button) {
                return;
              }
              if (!__privateGet(this, _altText) && !__privateGet(this, _altTextDecorative)) {
                button.classList.remove("done");
                (_a3 = __privateGet(this, _altTextTooltip)) == null ? void 0 : _a3.remove();
                return;
              }
              _AnnotationEditor._l10nPromise.get("editor_alt_text_edit_button_label").then((msg) => {
                button.setAttribute("aria-label", msg);
              });
              let tooltip = __privateGet(this, _altTextTooltip);
              if (!tooltip) {
                __privateSet(this, _altTextTooltip, tooltip = document.createElement("span"));
                tooltip.className = "tooltip";
                tooltip.setAttribute("role", "tooltip");
                const id = tooltip.id = `alt-text-tooltip-${this.id}`;
                button.setAttribute("aria-describedby", id);
                const DELAY_TO_SHOW_TOOLTIP = 100;
                button.addEventListener("mouseenter", () => {
                  __privateSet(this, _altTextTooltipTimeout, setTimeout(() => {
                    __privateSet(this, _altTextTooltipTimeout, null);
                    __privateGet(this, _altTextTooltip).classList.add("show");
                    this._uiManager._eventBus.dispatch("reporttelemetry", {
                      source: this,
                      details: {
                        type: "editing",
                        subtype: this.editorType,
                        data: {
                          action: "alt_text_tooltip"
                        }
                      }
                    });
                  }, DELAY_TO_SHOW_TOOLTIP));
                });
                button.addEventListener("mouseleave", () => {
                  var _a4;
                  clearTimeout(__privateGet(this, _altTextTooltipTimeout));
                  __privateSet(this, _altTextTooltipTimeout, null);
                  (_a4 = __privateGet(this, _altTextTooltip)) == null ? void 0 : _a4.classList.remove("show");
                });
              }
              button.classList.add("done");
              tooltip.innerText = __privateGet(this, _altTextDecorative) ? await _AnnotationEditor._l10nPromise.get("editor_alt_text_decorative_tooltip") : __privateGet(this, _altText);
              if (!tooltip.parentNode) {
                button.append(tooltip);
              }
            }, "#setAltTextButtonState");
            _setUpDragSession = new WeakSet();
            setUpDragSession_fn = /* @__PURE__ */ __name(function(event) {
              if (!this._isDraggable) {
                return;
              }
              const isSelected = this._uiManager.isSelected(this);
              this._uiManager.setUpDragSession();
              let pointerMoveOptions, pointerMoveCallback;
              if (isSelected) {
                pointerMoveOptions = {
                  passive: true,
                  capture: true
                };
                pointerMoveCallback = /* @__PURE__ */ __name((e) => {
                  const [tx, ty] = this.screenToPageTranslation(e.movementX, e.movementY);
                  this._uiManager.dragSelectedEditors(tx, ty);
                }, "pointerMoveCallback");
                window.addEventListener("pointermove", pointerMoveCallback, pointerMoveOptions);
              }
              const pointerUpCallback = /* @__PURE__ */ __name(() => {
                window.removeEventListener("pointerup", pointerUpCallback);
                window.removeEventListener("blur", pointerUpCallback);
                if (isSelected) {
                  window.removeEventListener("pointermove", pointerMoveCallback, pointerMoveOptions);
                }
                __privateSet(this, _hasBeenClicked, false);
                if (!this._uiManager.endDragSession()) {
                  const {
                    isMac
                  } = _util2.FeatureTest.platform;
                  if (event.ctrlKey && !isMac || event.shiftKey || event.metaKey && isMac) {
                    this.parent.toggleSelected(this);
                  } else {
                    this.parent.setSelected(this);
                  }
                }
              }, "pointerUpCallback");
              window.addEventListener("pointerup", pointerUpCallback);
              window.addEventListener("blur", pointerUpCallback);
            }, "#setUpDragSession");
            __privateAdd(_AnnotationEditor, _rotatePoint);
            __name(_AnnotationEditor, "AnnotationEditor");
            __publicField(_AnnotationEditor, "_borderLineWidth", -1);
            __publicField(_AnnotationEditor, "_colorManager", new _tools.ColorManager());
            __publicField(_AnnotationEditor, "_zIndex", 1);
            __publicField(_AnnotationEditor, "SMALL_EDITOR_SIZE", 0);
            let AnnotationEditor = _AnnotationEditor;
            exports2.AnnotationEditor = AnnotationEditor;
            const _FakeEditor = class _FakeEditor extends AnnotationEditor {
              constructor(params) {
                super(params);
                this.annotationElementId = params.annotationElementId;
                this.deleted = true;
              }
              serialize() {
                return {
                  id: this.annotationElementId,
                  deleted: true,
                  pageIndex: this.pageIndex
                };
              }
            };
            __name(_FakeEditor, "FakeEditor");
            let FakeEditor = _FakeEditor;
          },
          /* 5 */
          /***/
          (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
            var _id, _baseId, _id2, _cache, _get, get_fn, _commands, _locked, _maxSize, _position, _serialize, serialize_fn, _activeEditor, _allEditors, _allLayers, _altTextManager, _annotationStorage, _commandManager, _currentPageIndex, _deletedAnnotationsElementIds, _draggingEditors, _editorTypes, _editorsToRescale, _filterFactory, _idManager, _isEnabled, _isWaiting, _lastActiveElement, _mode, _selectedEditors, _pageColors, _boundBlur, _boundFocus, _boundCopy, _boundCut, _boundPaste, _boundKeydown, _boundOnEditingAction, _boundOnPageChanging, _boundOnScaleChanging, _boundOnRotationChanging, _previousStates, _translation, _translationTimeoutId, _container, _viewer, _addFocusManager, addFocusManager_fn, _removeFocusManager, removeFocusManager_fn, _addKeyboardManager, addKeyboardManager_fn, _removeKeyboardManager, removeKeyboardManager_fn, _addCopyPasteListeners, addCopyPasteListeners_fn, _removeCopyPasteListeners, removeCopyPasteListeners_fn, _dispatchUpdateStates, dispatchUpdateStates_fn, _dispatchUpdateUI, dispatchUpdateUI_fn, _enableAll, enableAll_fn, _disableAll, disableAll_fn, _addEditorToLayer, addEditorToLayer_fn, _isEmpty, isEmpty_fn, _selectEditors, selectEditors_fn;
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            exports2.KeyboardManager = exports2.CommandManager = exports2.ColorManager = exports2.AnnotationEditorUIManager = void 0;
            exports2.bindEvents = bindEvents;
            exports2.opacityToHex = opacityToHex;
            var _util2 = __w_pdfjs_require__2(1);
            var _display_utils2 = __w_pdfjs_require__2(6);
            function bindEvents(obj, element, names2) {
              for (const name of names2) {
                element.addEventListener(name, obj[name].bind(obj));
              }
            }
            __name(bindEvents, "bindEvents");
            function opacityToHex(opacity) {
              return Math.round(Math.min(255, Math.max(1, 255 * opacity))).toString(16).padStart(2, "0");
            }
            __name(opacityToHex, "opacityToHex");
            const _IdManager = class _IdManager {
              constructor() {
                __privateAdd(this, _id, 0);
              }
              getId() {
                return `${_util2.AnnotationEditorPrefix}${__privateWrapper(this, _id)._++}`;
              }
            };
            _id = new WeakMap();
            __name(_IdManager, "IdManager");
            let IdManager = _IdManager;
            const _ImageManager = class _ImageManager {
              constructor() {
                __privateAdd(this, _get);
                __privateAdd(this, _baseId, (0, _util2.getUuid)());
                __privateAdd(this, _id2, 0);
                __privateAdd(this, _cache, null);
              }
              static get _isSVGFittingCanvas() {
                const svg = `data:image/svg+xml;charset=UTF-8,<svg viewBox="0 0 1 1" width="1" height="1" xmlns="http://www.w3.org/2000/svg"><rect width="1" height="1" style="fill:red;"/></svg>`;
                const canvas = new OffscreenCanvas(1, 3);
                const ctx = canvas.getContext("2d");
                const image = new Image();
                image.src = svg;
                const promise = image.decode().then(() => {
                  ctx.drawImage(image, 0, 0, 1, 1, 0, 0, 1, 3);
                  return new Uint32Array(ctx.getImageData(0, 0, 1, 1).data.buffer)[0] === 0;
                });
                return (0, _util2.shadow)(this, "_isSVGFittingCanvas", promise);
              }
              async getFromFile(file) {
                const {
                  lastModified,
                  name,
                  size,
                  type
                } = file;
                return __privateMethod(this, _get, get_fn).call(this, `${lastModified}_${name}_${size}_${type}`, file);
              }
              async getFromUrl(url) {
                return __privateMethod(this, _get, get_fn).call(this, url, url);
              }
              async getFromId(id) {
                __privateGet(this, _cache) || __privateSet(this, _cache, /* @__PURE__ */ new Map());
                const data = __privateGet(this, _cache).get(id);
                if (!data) {
                  return null;
                }
                if (data.bitmap) {
                  data.refCounter += 1;
                  return data;
                }
                if (data.file) {
                  return this.getFromFile(data.file);
                }
                return this.getFromUrl(data.url);
              }
              getSvgUrl(id) {
                const data = __privateGet(this, _cache).get(id);
                if (!(data == null ? void 0 : data.isSvg)) {
                  return null;
                }
                return data.svgUrl;
              }
              deleteId(id) {
                __privateGet(this, _cache) || __privateSet(this, _cache, /* @__PURE__ */ new Map());
                const data = __privateGet(this, _cache).get(id);
                if (!data) {
                  return;
                }
                data.refCounter -= 1;
                if (data.refCounter !== 0) {
                  return;
                }
                data.bitmap = null;
              }
              isValidId(id) {
                return id.startsWith(`image_${__privateGet(this, _baseId)}_`);
              }
            };
            _baseId = new WeakMap();
            _id2 = new WeakMap();
            _cache = new WeakMap();
            _get = new WeakSet();
            get_fn = /* @__PURE__ */ __name(async function(key, rawData) {
              __privateGet(this, _cache) || __privateSet(this, _cache, /* @__PURE__ */ new Map());
              let data = __privateGet(this, _cache).get(key);
              if (data === null) {
                return null;
              }
              if (data == null ? void 0 : data.bitmap) {
                data.refCounter += 1;
                return data;
              }
              try {
                data || (data = {
                  bitmap: null,
                  id: `image_${__privateGet(this, _baseId)}_${__privateWrapper(this, _id2)._++}`,
                  refCounter: 0,
                  isSvg: false
                });
                let image;
                if (typeof rawData === "string") {
                  data.url = rawData;
                  const response = await fetch(rawData);
                  if (!response.ok) {
                    throw new Error(response.statusText);
                  }
                  image = await response.blob();
                } else {
                  image = data.file = rawData;
                }
                if (image.type === "image/svg+xml") {
                  const mustRemoveAspectRatioPromise = _ImageManager._isSVGFittingCanvas;
                  const fileReader = new FileReader();
                  const imageElement = new Image();
                  const imagePromise = new Promise((resolve2, reject) => {
                    imageElement.onload = () => {
                      data.bitmap = imageElement;
                      data.isSvg = true;
                      resolve2();
                    };
                    fileReader.onload = async () => {
                      const url = data.svgUrl = fileReader.result;
                      imageElement.src = await mustRemoveAspectRatioPromise ? `${url}#svgView(preserveAspectRatio(none))` : url;
                    };
                    imageElement.onerror = fileReader.onerror = reject;
                  });
                  fileReader.readAsDataURL(image);
                  await imagePromise;
                } else {
                  data.bitmap = await createImageBitmap(image);
                }
                data.refCounter = 1;
              } catch (e) {
                console.error(e);
                data = null;
              }
              __privateGet(this, _cache).set(key, data);
              if (data) {
                __privateGet(this, _cache).set(data.id, data);
              }
              return data;
            }, "#get");
            __name(_ImageManager, "ImageManager");
            let ImageManager = _ImageManager;
            const _CommandManager = class _CommandManager {
              constructor(maxSize = 128) {
                __privateAdd(this, _commands, []);
                __privateAdd(this, _locked, false);
                __privateAdd(this, _maxSize, void 0);
                __privateAdd(this, _position, -1);
                __privateSet(this, _maxSize, maxSize);
              }
              add({
                cmd,
                undo,
                mustExec,
                type = NaN,
                overwriteIfSameType = false,
                keepUndo = false
              }) {
                if (mustExec) {
                  cmd();
                }
                if (__privateGet(this, _locked)) {
                  return;
                }
                const save = {
                  cmd,
                  undo,
                  type
                };
                if (__privateGet(this, _position) === -1) {
                  if (__privateGet(this, _commands).length > 0) {
                    __privateGet(this, _commands).length = 0;
                  }
                  __privateSet(this, _position, 0);
                  __privateGet(this, _commands).push(save);
                  return;
                }
                if (overwriteIfSameType && __privateGet(this, _commands)[__privateGet(this, _position)].type === type) {
                  if (keepUndo) {
                    save.undo = __privateGet(this, _commands)[__privateGet(this, _position)].undo;
                  }
                  __privateGet(this, _commands)[__privateGet(this, _position)] = save;
                  return;
                }
                const next = __privateGet(this, _position) + 1;
                if (next === __privateGet(this, _maxSize)) {
                  __privateGet(this, _commands).splice(0, 1);
                } else {
                  __privateSet(this, _position, next);
                  if (next < __privateGet(this, _commands).length) {
                    __privateGet(this, _commands).splice(next);
                  }
                }
                __privateGet(this, _commands).push(save);
              }
              undo() {
                if (__privateGet(this, _position) === -1) {
                  return;
                }
                __privateSet(this, _locked, true);
                __privateGet(this, _commands)[__privateGet(this, _position)].undo();
                __privateSet(this, _locked, false);
                __privateSet(this, _position, __privateGet(this, _position) - 1);
              }
              redo() {
                if (__privateGet(this, _position) < __privateGet(this, _commands).length - 1) {
                  __privateSet(this, _position, __privateGet(this, _position) + 1);
                  __privateSet(this, _locked, true);
                  __privateGet(this, _commands)[__privateGet(this, _position)].cmd();
                  __privateSet(this, _locked, false);
                }
              }
              hasSomethingToUndo() {
                return __privateGet(this, _position) !== -1;
              }
              hasSomethingToRedo() {
                return __privateGet(this, _position) < __privateGet(this, _commands).length - 1;
              }
              destroy() {
                __privateSet(this, _commands, null);
              }
            };
            _commands = new WeakMap();
            _locked = new WeakMap();
            _maxSize = new WeakMap();
            _position = new WeakMap();
            __name(_CommandManager, "CommandManager");
            let CommandManager = _CommandManager;
            exports2.CommandManager = CommandManager;
            const _KeyboardManager = class _KeyboardManager {
              constructor(callbacks) {
                __privateAdd(this, _serialize);
                this.buffer = [];
                this.callbacks = /* @__PURE__ */ new Map();
                this.allKeys = /* @__PURE__ */ new Set();
                const {
                  isMac
                } = _util2.FeatureTest.platform;
                for (const [keys2, callback2, options = {}] of callbacks) {
                  for (const key of keys2) {
                    const isMacKey = key.startsWith("mac+");
                    if (isMac && isMacKey) {
                      this.callbacks.set(key.slice(4), {
                        callback: callback2,
                        options
                      });
                      this.allKeys.add(key.split("+").at(-1));
                    } else if (!isMac && !isMacKey) {
                      this.callbacks.set(key, {
                        callback: callback2,
                        options
                      });
                      this.allKeys.add(key.split("+").at(-1));
                    }
                  }
                }
              }
              exec(self2, event) {
                if (!this.allKeys.has(event.key)) {
                  return;
                }
                const info = this.callbacks.get(__privateMethod(this, _serialize, serialize_fn).call(this, event));
                if (!info) {
                  return;
                }
                const {
                  callback: callback2,
                  options: {
                    bubbles = false,
                    args = [],
                    checker = null
                  }
                } = info;
                if (checker && !checker(self2, event)) {
                  return;
                }
                callback2.bind(self2, ...args)();
                if (!bubbles) {
                  event.stopPropagation();
                  event.preventDefault();
                }
              }
            };
            _serialize = new WeakSet();
            serialize_fn = /* @__PURE__ */ __name(function(event) {
              if (event.altKey) {
                this.buffer.push("alt");
              }
              if (event.ctrlKey) {
                this.buffer.push("ctrl");
              }
              if (event.metaKey) {
                this.buffer.push("meta");
              }
              if (event.shiftKey) {
                this.buffer.push("shift");
              }
              this.buffer.push(event.key);
              const str = this.buffer.join("+");
              this.buffer.length = 0;
              return str;
            }, "#serialize");
            __name(_KeyboardManager, "KeyboardManager");
            let KeyboardManager = _KeyboardManager;
            exports2.KeyboardManager = KeyboardManager;
            const _ColorManager = class _ColorManager {
              get _colors() {
                const colors2 = /* @__PURE__ */ new Map([["CanvasText", null], ["Canvas", null]]);
                (0, _display_utils2.getColorValues)(colors2);
                return (0, _util2.shadow)(this, "_colors", colors2);
              }
              convert(color2) {
                const rgb = (0, _display_utils2.getRGB)(color2);
                if (!window.matchMedia("(forced-colors: active)").matches) {
                  return rgb;
                }
                for (const [name, RGB] of this._colors) {
                  if (RGB.every((x2, i2) => x2 === rgb[i2])) {
                    return _ColorManager._colorsMapping.get(name);
                  }
                }
                return rgb;
              }
              getHexCode(name) {
                const rgb = this._colors.get(name);
                if (!rgb) {
                  return name;
                }
                return _util2.Util.makeHexColor(...rgb);
              }
            };
            __name(_ColorManager, "ColorManager");
            __publicField(_ColorManager, "_colorsMapping", /* @__PURE__ */ new Map([["CanvasText", [0, 0, 0]], ["Canvas", [255, 255, 255]]]));
            let ColorManager = _ColorManager;
            exports2.ColorManager = ColorManager;
            const _AnnotationEditorUIManager = class _AnnotationEditorUIManager {
              constructor(container, viewer, altTextManager, eventBus, pdfDocument, pageColors) {
                __privateAdd(this, _addFocusManager);
                __privateAdd(this, _removeFocusManager);
                __privateAdd(this, _addKeyboardManager);
                __privateAdd(this, _removeKeyboardManager);
                __privateAdd(this, _addCopyPasteListeners);
                __privateAdd(this, _removeCopyPasteListeners);
                __privateAdd(this, _dispatchUpdateStates);
                __privateAdd(this, _dispatchUpdateUI);
                __privateAdd(this, _enableAll);
                __privateAdd(this, _disableAll);
                __privateAdd(this, _addEditorToLayer);
                __privateAdd(this, _isEmpty);
                __privateAdd(this, _selectEditors);
                __privateAdd(this, _activeEditor, null);
                __privateAdd(this, _allEditors, /* @__PURE__ */ new Map());
                __privateAdd(this, _allLayers, /* @__PURE__ */ new Map());
                __privateAdd(this, _altTextManager, null);
                __privateAdd(this, _annotationStorage, null);
                __privateAdd(this, _commandManager, new CommandManager());
                __privateAdd(this, _currentPageIndex, 0);
                __privateAdd(this, _deletedAnnotationsElementIds, /* @__PURE__ */ new Set());
                __privateAdd(this, _draggingEditors, null);
                __privateAdd(this, _editorTypes, null);
                __privateAdd(this, _editorsToRescale, /* @__PURE__ */ new Set());
                __privateAdd(this, _filterFactory, null);
                __privateAdd(this, _idManager, new IdManager());
                __privateAdd(this, _isEnabled, false);
                __privateAdd(this, _isWaiting, false);
                __privateAdd(this, _lastActiveElement, null);
                __privateAdd(this, _mode, _util2.AnnotationEditorType.NONE);
                __privateAdd(this, _selectedEditors, /* @__PURE__ */ new Set());
                __privateAdd(this, _pageColors, null);
                __privateAdd(this, _boundBlur, this.blur.bind(this));
                __privateAdd(this, _boundFocus, this.focus.bind(this));
                __privateAdd(this, _boundCopy, this.copy.bind(this));
                __privateAdd(this, _boundCut, this.cut.bind(this));
                __privateAdd(this, _boundPaste, this.paste.bind(this));
                __privateAdd(this, _boundKeydown, this.keydown.bind(this));
                __privateAdd(this, _boundOnEditingAction, this.onEditingAction.bind(this));
                __privateAdd(this, _boundOnPageChanging, this.onPageChanging.bind(this));
                __privateAdd(this, _boundOnScaleChanging, this.onScaleChanging.bind(this));
                __privateAdd(this, _boundOnRotationChanging, this.onRotationChanging.bind(this));
                __privateAdd(this, _previousStates, {
                  isEditing: false,
                  isEmpty: true,
                  hasSomethingToUndo: false,
                  hasSomethingToRedo: false,
                  hasSelectedEditor: false
                });
                __privateAdd(this, _translation, [0, 0]);
                __privateAdd(this, _translationTimeoutId, null);
                __privateAdd(this, _container, null);
                __privateAdd(this, _viewer, null);
                __privateSet(this, _container, container);
                __privateSet(this, _viewer, viewer);
                __privateSet(this, _altTextManager, altTextManager);
                this._eventBus = eventBus;
                this._eventBus._on("editingaction", __privateGet(this, _boundOnEditingAction));
                this._eventBus._on("pagechanging", __privateGet(this, _boundOnPageChanging));
                this._eventBus._on("scalechanging", __privateGet(this, _boundOnScaleChanging));
                this._eventBus._on("rotationchanging", __privateGet(this, _boundOnRotationChanging));
                __privateSet(this, _annotationStorage, pdfDocument.annotationStorage);
                __privateSet(this, _filterFactory, pdfDocument.filterFactory);
                __privateSet(this, _pageColors, pageColors);
                this.viewParameters = {
                  realScale: _display_utils2.PixelsPerInch.PDF_TO_CSS_UNITS,
                  rotation: 0
                };
              }
              static get _keyboardManager() {
                const proto = _AnnotationEditorUIManager.prototype;
                const arrowChecker = /* @__PURE__ */ __name((self2) => {
                  const {
                    activeElement
                  } = document;
                  return activeElement && __privateGet(self2, _container).contains(activeElement) && self2.hasSomethingToControl();
                }, "arrowChecker");
                const small = this.TRANSLATE_SMALL;
                const big = this.TRANSLATE_BIG;
                return (0, _util2.shadow)(this, "_keyboardManager", new KeyboardManager([[["ctrl+a", "mac+meta+a"], proto.selectAll], [["ctrl+z", "mac+meta+z"], proto.undo], [["ctrl+y", "ctrl+shift+z", "mac+meta+shift+z", "ctrl+shift+Z", "mac+meta+shift+Z"], proto.redo], [["Backspace", "alt+Backspace", "ctrl+Backspace", "shift+Backspace", "mac+Backspace", "mac+alt+Backspace", "mac+ctrl+Backspace", "Delete", "ctrl+Delete", "shift+Delete", "mac+Delete"], proto.delete], [["Escape", "mac+Escape"], proto.unselectAll], [["ArrowLeft", "mac+ArrowLeft"], proto.translateSelectedEditors, {
                  args: [-small, 0],
                  checker: arrowChecker
                }], [["ctrl+ArrowLeft", "mac+shift+ArrowLeft"], proto.translateSelectedEditors, {
                  args: [-big, 0],
                  checker: arrowChecker
                }], [["ArrowRight", "mac+ArrowRight"], proto.translateSelectedEditors, {
                  args: [small, 0],
                  checker: arrowChecker
                }], [["ctrl+ArrowRight", "mac+shift+ArrowRight"], proto.translateSelectedEditors, {
                  args: [big, 0],
                  checker: arrowChecker
                }], [["ArrowUp", "mac+ArrowUp"], proto.translateSelectedEditors, {
                  args: [0, -small],
                  checker: arrowChecker
                }], [["ctrl+ArrowUp", "mac+shift+ArrowUp"], proto.translateSelectedEditors, {
                  args: [0, -big],
                  checker: arrowChecker
                }], [["ArrowDown", "mac+ArrowDown"], proto.translateSelectedEditors, {
                  args: [0, small],
                  checker: arrowChecker
                }], [["ctrl+ArrowDown", "mac+shift+ArrowDown"], proto.translateSelectedEditors, {
                  args: [0, big],
                  checker: arrowChecker
                }]]));
              }
              destroy() {
                __privateMethod(this, _removeKeyboardManager, removeKeyboardManager_fn).call(this);
                __privateMethod(this, _removeFocusManager, removeFocusManager_fn).call(this);
                this._eventBus._off("editingaction", __privateGet(this, _boundOnEditingAction));
                this._eventBus._off("pagechanging", __privateGet(this, _boundOnPageChanging));
                this._eventBus._off("scalechanging", __privateGet(this, _boundOnScaleChanging));
                this._eventBus._off("rotationchanging", __privateGet(this, _boundOnRotationChanging));
                for (const layer of __privateGet(this, _allLayers).values()) {
                  layer.destroy();
                }
                __privateGet(this, _allLayers).clear();
                __privateGet(this, _allEditors).clear();
                __privateGet(this, _editorsToRescale).clear();
                __privateSet(this, _activeEditor, null);
                __privateGet(this, _selectedEditors).clear();
                __privateGet(this, _commandManager).destroy();
                __privateGet(this, _altTextManager).destroy();
              }
              get hcmFilter() {
                return (0, _util2.shadow)(this, "hcmFilter", __privateGet(this, _pageColors) ? __privateGet(this, _filterFactory).addHCMFilter(__privateGet(this, _pageColors).foreground, __privateGet(this, _pageColors).background) : "none");
              }
              get direction() {
                return (0, _util2.shadow)(this, "direction", getComputedStyle(__privateGet(this, _container)).direction);
              }
              editAltText(editor) {
                var _a3;
                (_a3 = __privateGet(this, _altTextManager)) == null ? void 0 : _a3.editAltText(this, editor);
              }
              onPageChanging({
                pageNumber
              }) {
                __privateSet(this, _currentPageIndex, pageNumber - 1);
              }
              focusMainContainer() {
                __privateGet(this, _container).focus();
              }
              findParent(x2, y2) {
                for (const layer of __privateGet(this, _allLayers).values()) {
                  const {
                    x: layerX,
                    y: layerY,
                    width,
                    height
                  } = layer.div.getBoundingClientRect();
                  if (x2 >= layerX && x2 <= layerX + width && y2 >= layerY && y2 <= layerY + height) {
                    return layer;
                  }
                }
                return null;
              }
              disableUserSelect(value = false) {
                __privateGet(this, _viewer).classList.toggle("noUserSelect", value);
              }
              addShouldRescale(editor) {
                __privateGet(this, _editorsToRescale).add(editor);
              }
              removeShouldRescale(editor) {
                __privateGet(this, _editorsToRescale).delete(editor);
              }
              onScaleChanging({
                scale
              }) {
                this.commitOrRemove();
                this.viewParameters.realScale = scale * _display_utils2.PixelsPerInch.PDF_TO_CSS_UNITS;
                for (const editor of __privateGet(this, _editorsToRescale)) {
                  editor.onScaleChanging();
                }
              }
              onRotationChanging({
                pagesRotation
              }) {
                this.commitOrRemove();
                this.viewParameters.rotation = pagesRotation;
              }
              addToAnnotationStorage(editor) {
                if (!editor.isEmpty() && __privateGet(this, _annotationStorage) && !__privateGet(this, _annotationStorage).has(editor.id)) {
                  __privateGet(this, _annotationStorage).setValue(editor.id, editor);
                }
              }
              blur() {
                if (!this.hasSelection) {
                  return;
                }
                const {
                  activeElement
                } = document;
                for (const editor of __privateGet(this, _selectedEditors)) {
                  if (editor.div.contains(activeElement)) {
                    __privateSet(this, _lastActiveElement, [editor, activeElement]);
                    editor._focusEventsAllowed = false;
                    break;
                  }
                }
              }
              focus() {
                if (!__privateGet(this, _lastActiveElement)) {
                  return;
                }
                const [lastEditor, lastActiveElement] = __privateGet(this, _lastActiveElement);
                __privateSet(this, _lastActiveElement, null);
                lastActiveElement.addEventListener("focusin", () => {
                  lastEditor._focusEventsAllowed = true;
                }, {
                  once: true
                });
                lastActiveElement.focus();
              }
              addEditListeners() {
                __privateMethod(this, _addKeyboardManager, addKeyboardManager_fn).call(this);
                __privateMethod(this, _addCopyPasteListeners, addCopyPasteListeners_fn).call(this);
              }
              removeEditListeners() {
                __privateMethod(this, _removeKeyboardManager, removeKeyboardManager_fn).call(this);
                __privateMethod(this, _removeCopyPasteListeners, removeCopyPasteListeners_fn).call(this);
              }
              copy(event) {
                var _a3;
                event.preventDefault();
                (_a3 = __privateGet(this, _activeEditor)) == null ? void 0 : _a3.commitOrRemove();
                if (!this.hasSelection) {
                  return;
                }
                const editors = [];
                for (const editor of __privateGet(this, _selectedEditors)) {
                  const serialized = editor.serialize(true);
                  if (serialized) {
                    editors.push(serialized);
                  }
                }
                if (editors.length === 0) {
                  return;
                }
                event.clipboardData.setData("application/pdfjs", JSON.stringify(editors));
              }
              cut(event) {
                this.copy(event);
                this.delete();
              }
              paste(event) {
                event.preventDefault();
                const {
                  clipboardData
                } = event;
                for (const item of clipboardData.items) {
                  for (const editorType of __privateGet(this, _editorTypes)) {
                    if (editorType.isHandlingMimeForPasting(item.type)) {
                      editorType.paste(item, this.currentLayer);
                      return;
                    }
                  }
                }
                let data = clipboardData.getData("application/pdfjs");
                if (!data) {
                  return;
                }
                try {
                  data = JSON.parse(data);
                } catch (ex) {
                  (0, _util2.warn)(`paste: "${ex.message}".`);
                  return;
                }
                if (!Array.isArray(data)) {
                  return;
                }
                this.unselectAll();
                const layer = this.currentLayer;
                try {
                  const newEditors = [];
                  for (const editor of data) {
                    const deserializedEditor = layer.deserialize(editor);
                    if (!deserializedEditor) {
                      return;
                    }
                    newEditors.push(deserializedEditor);
                  }
                  const cmd = /* @__PURE__ */ __name(() => {
                    for (const editor of newEditors) {
                      __privateMethod(this, _addEditorToLayer, addEditorToLayer_fn).call(this, editor);
                    }
                    __privateMethod(this, _selectEditors, selectEditors_fn).call(this, newEditors);
                  }, "cmd");
                  const undo = /* @__PURE__ */ __name(() => {
                    for (const editor of newEditors) {
                      editor.remove();
                    }
                  }, "undo");
                  this.addCommands({
                    cmd,
                    undo,
                    mustExec: true
                  });
                } catch (ex) {
                  (0, _util2.warn)(`paste: "${ex.message}".`);
                }
              }
              keydown(event) {
                var _a3;
                if (!((_a3 = this.getActive()) == null ? void 0 : _a3.shouldGetKeyboardEvents())) {
                  _AnnotationEditorUIManager._keyboardManager.exec(this, event);
                }
              }
              onEditingAction(details) {
                if (["undo", "redo", "delete", "selectAll"].includes(details.name)) {
                  this[details.name]();
                }
              }
              setEditingState(isEditing) {
                if (isEditing) {
                  __privateMethod(this, _addFocusManager, addFocusManager_fn).call(this);
                  __privateMethod(this, _addKeyboardManager, addKeyboardManager_fn).call(this);
                  __privateMethod(this, _addCopyPasteListeners, addCopyPasteListeners_fn).call(this);
                  __privateMethod(this, _dispatchUpdateStates, dispatchUpdateStates_fn).call(this, {
                    isEditing: __privateGet(this, _mode) !== _util2.AnnotationEditorType.NONE,
                    isEmpty: __privateMethod(this, _isEmpty, isEmpty_fn).call(this),
                    hasSomethingToUndo: __privateGet(this, _commandManager).hasSomethingToUndo(),
                    hasSomethingToRedo: __privateGet(this, _commandManager).hasSomethingToRedo(),
                    hasSelectedEditor: false
                  });
                } else {
                  __privateMethod(this, _removeFocusManager, removeFocusManager_fn).call(this);
                  __privateMethod(this, _removeKeyboardManager, removeKeyboardManager_fn).call(this);
                  __privateMethod(this, _removeCopyPasteListeners, removeCopyPasteListeners_fn).call(this);
                  __privateMethod(this, _dispatchUpdateStates, dispatchUpdateStates_fn).call(this, {
                    isEditing: false
                  });
                  this.disableUserSelect(false);
                }
              }
              registerEditorTypes(types) {
                if (__privateGet(this, _editorTypes)) {
                  return;
                }
                __privateSet(this, _editorTypes, types);
                for (const editorType of __privateGet(this, _editorTypes)) {
                  __privateMethod(this, _dispatchUpdateUI, dispatchUpdateUI_fn).call(this, editorType.defaultPropertiesToUpdate);
                }
              }
              getId() {
                return __privateGet(this, _idManager).getId();
              }
              get currentLayer() {
                return __privateGet(this, _allLayers).get(__privateGet(this, _currentPageIndex));
              }
              getLayer(pageIndex) {
                return __privateGet(this, _allLayers).get(pageIndex);
              }
              get currentPageIndex() {
                return __privateGet(this, _currentPageIndex);
              }
              addLayer(layer) {
                __privateGet(this, _allLayers).set(layer.pageIndex, layer);
                if (__privateGet(this, _isEnabled)) {
                  layer.enable();
                } else {
                  layer.disable();
                }
              }
              removeLayer(layer) {
                __privateGet(this, _allLayers).delete(layer.pageIndex);
              }
              updateMode(mode, editId = null) {
                if (__privateGet(this, _mode) === mode) {
                  return;
                }
                __privateSet(this, _mode, mode);
                if (mode === _util2.AnnotationEditorType.NONE) {
                  this.setEditingState(false);
                  __privateMethod(this, _disableAll, disableAll_fn).call(this);
                  return;
                }
                this.setEditingState(true);
                __privateMethod(this, _enableAll, enableAll_fn).call(this);
                this.unselectAll();
                for (const layer of __privateGet(this, _allLayers).values()) {
                  layer.updateMode(mode);
                }
                if (!editId) {
                  return;
                }
                for (const editor of __privateGet(this, _allEditors).values()) {
                  if (editor.annotationElementId === editId) {
                    this.setSelected(editor);
                    editor.enterInEditMode();
                    break;
                  }
                }
              }
              updateToolbar(mode) {
                if (mode === __privateGet(this, _mode)) {
                  return;
                }
                this._eventBus.dispatch("switchannotationeditormode", {
                  source: this,
                  mode
                });
              }
              updateParams(type, value) {
                if (!__privateGet(this, _editorTypes)) {
                  return;
                }
                if (type === _util2.AnnotationEditorParamsType.CREATE) {
                  this.currentLayer.addNewEditor(type);
                  return;
                }
                for (const editor of __privateGet(this, _selectedEditors)) {
                  editor.updateParams(type, value);
                }
                for (const editorType of __privateGet(this, _editorTypes)) {
                  editorType.updateDefaultParams(type, value);
                }
              }
              enableWaiting(mustWait = false) {
                if (__privateGet(this, _isWaiting) === mustWait) {
                  return;
                }
                __privateSet(this, _isWaiting, mustWait);
                for (const layer of __privateGet(this, _allLayers).values()) {
                  if (mustWait) {
                    layer.disableClick();
                  } else {
                    layer.enableClick();
                  }
                  layer.div.classList.toggle("waiting", mustWait);
                }
              }
              getEditors(pageIndex) {
                const editors = [];
                for (const editor of __privateGet(this, _allEditors).values()) {
                  if (editor.pageIndex === pageIndex) {
                    editors.push(editor);
                  }
                }
                return editors;
              }
              getEditor(id) {
                return __privateGet(this, _allEditors).get(id);
              }
              addEditor(editor) {
                __privateGet(this, _allEditors).set(editor.id, editor);
              }
              removeEditor(editor) {
                var _a3;
                __privateGet(this, _allEditors).delete(editor.id);
                this.unselect(editor);
                if (!editor.annotationElementId || !__privateGet(this, _deletedAnnotationsElementIds).has(editor.annotationElementId)) {
                  (_a3 = __privateGet(this, _annotationStorage)) == null ? void 0 : _a3.remove(editor.id);
                }
              }
              addDeletedAnnotationElement(editor) {
                __privateGet(this, _deletedAnnotationsElementIds).add(editor.annotationElementId);
                editor.deleted = true;
              }
              isDeletedAnnotationElement(annotationElementId) {
                return __privateGet(this, _deletedAnnotationsElementIds).has(annotationElementId);
              }
              removeDeletedAnnotationElement(editor) {
                __privateGet(this, _deletedAnnotationsElementIds).delete(editor.annotationElementId);
                editor.deleted = false;
              }
              setActiveEditor(editor) {
                if (__privateGet(this, _activeEditor) === editor) {
                  return;
                }
                __privateSet(this, _activeEditor, editor);
                if (editor) {
                  __privateMethod(this, _dispatchUpdateUI, dispatchUpdateUI_fn).call(this, editor.propertiesToUpdate);
                }
              }
              toggleSelected(editor) {
                if (__privateGet(this, _selectedEditors).has(editor)) {
                  __privateGet(this, _selectedEditors).delete(editor);
                  editor.unselect();
                  __privateMethod(this, _dispatchUpdateStates, dispatchUpdateStates_fn).call(this, {
                    hasSelectedEditor: this.hasSelection
                  });
                  return;
                }
                __privateGet(this, _selectedEditors).add(editor);
                editor.select();
                __privateMethod(this, _dispatchUpdateUI, dispatchUpdateUI_fn).call(this, editor.propertiesToUpdate);
                __privateMethod(this, _dispatchUpdateStates, dispatchUpdateStates_fn).call(this, {
                  hasSelectedEditor: true
                });
              }
              setSelected(editor) {
                for (const ed of __privateGet(this, _selectedEditors)) {
                  if (ed !== editor) {
                    ed.unselect();
                  }
                }
                __privateGet(this, _selectedEditors).clear();
                __privateGet(this, _selectedEditors).add(editor);
                editor.select();
                __privateMethod(this, _dispatchUpdateUI, dispatchUpdateUI_fn).call(this, editor.propertiesToUpdate);
                __privateMethod(this, _dispatchUpdateStates, dispatchUpdateStates_fn).call(this, {
                  hasSelectedEditor: true
                });
              }
              isSelected(editor) {
                return __privateGet(this, _selectedEditors).has(editor);
              }
              unselect(editor) {
                editor.unselect();
                __privateGet(this, _selectedEditors).delete(editor);
                __privateMethod(this, _dispatchUpdateStates, dispatchUpdateStates_fn).call(this, {
                  hasSelectedEditor: this.hasSelection
                });
              }
              get hasSelection() {
                return __privateGet(this, _selectedEditors).size !== 0;
              }
              undo() {
                __privateGet(this, _commandManager).undo();
                __privateMethod(this, _dispatchUpdateStates, dispatchUpdateStates_fn).call(this, {
                  hasSomethingToUndo: __privateGet(this, _commandManager).hasSomethingToUndo(),
                  hasSomethingToRedo: true,
                  isEmpty: __privateMethod(this, _isEmpty, isEmpty_fn).call(this)
                });
              }
              redo() {
                __privateGet(this, _commandManager).redo();
                __privateMethod(this, _dispatchUpdateStates, dispatchUpdateStates_fn).call(this, {
                  hasSomethingToUndo: true,
                  hasSomethingToRedo: __privateGet(this, _commandManager).hasSomethingToRedo(),
                  isEmpty: __privateMethod(this, _isEmpty, isEmpty_fn).call(this)
                });
              }
              addCommands(params) {
                __privateGet(this, _commandManager).add(params);
                __privateMethod(this, _dispatchUpdateStates, dispatchUpdateStates_fn).call(this, {
                  hasSomethingToUndo: true,
                  hasSomethingToRedo: false,
                  isEmpty: __privateMethod(this, _isEmpty, isEmpty_fn).call(this)
                });
              }
              delete() {
                this.commitOrRemove();
                if (!this.hasSelection) {
                  return;
                }
                const editors = [...__privateGet(this, _selectedEditors)];
                const cmd = /* @__PURE__ */ __name(() => {
                  for (const editor of editors) {
                    editor.remove();
                  }
                }, "cmd");
                const undo = /* @__PURE__ */ __name(() => {
                  for (const editor of editors) {
                    __privateMethod(this, _addEditorToLayer, addEditorToLayer_fn).call(this, editor);
                  }
                }, "undo");
                this.addCommands({
                  cmd,
                  undo,
                  mustExec: true
                });
              }
              commitOrRemove() {
                var _a3;
                (_a3 = __privateGet(this, _activeEditor)) == null ? void 0 : _a3.commitOrRemove();
              }
              hasSomethingToControl() {
                return __privateGet(this, _activeEditor) || this.hasSelection;
              }
              selectAll() {
                for (const editor of __privateGet(this, _selectedEditors)) {
                  editor.commit();
                }
                __privateMethod(this, _selectEditors, selectEditors_fn).call(this, __privateGet(this, _allEditors).values());
              }
              unselectAll() {
                if (__privateGet(this, _activeEditor)) {
                  __privateGet(this, _activeEditor).commitOrRemove();
                  return;
                }
                if (!this.hasSelection) {
                  return;
                }
                for (const editor of __privateGet(this, _selectedEditors)) {
                  editor.unselect();
                }
                __privateGet(this, _selectedEditors).clear();
                __privateMethod(this, _dispatchUpdateStates, dispatchUpdateStates_fn).call(this, {
                  hasSelectedEditor: false
                });
              }
              translateSelectedEditors(x2, y2, noCommit = false) {
                if (!noCommit) {
                  this.commitOrRemove();
                }
                if (!this.hasSelection) {
                  return;
                }
                __privateGet(this, _translation)[0] += x2;
                __privateGet(this, _translation)[1] += y2;
                const [totalX, totalY] = __privateGet(this, _translation);
                const editors = [...__privateGet(this, _selectedEditors)];
                const TIME_TO_WAIT = 1e3;
                if (__privateGet(this, _translationTimeoutId)) {
                  clearTimeout(__privateGet(this, _translationTimeoutId));
                }
                __privateSet(this, _translationTimeoutId, setTimeout(() => {
                  __privateSet(this, _translationTimeoutId, null);
                  __privateGet(this, _translation)[0] = __privateGet(this, _translation)[1] = 0;
                  this.addCommands({
                    cmd: () => {
                      for (const editor of editors) {
                        if (__privateGet(this, _allEditors).has(editor.id)) {
                          editor.translateInPage(totalX, totalY);
                        }
                      }
                    },
                    undo: () => {
                      for (const editor of editors) {
                        if (__privateGet(this, _allEditors).has(editor.id)) {
                          editor.translateInPage(-totalX, -totalY);
                        }
                      }
                    },
                    mustExec: false
                  });
                }, TIME_TO_WAIT));
                for (const editor of editors) {
                  editor.translateInPage(x2, y2);
                }
              }
              setUpDragSession() {
                if (!this.hasSelection) {
                  return;
                }
                this.disableUserSelect(true);
                __privateSet(this, _draggingEditors, /* @__PURE__ */ new Map());
                for (const editor of __privateGet(this, _selectedEditors)) {
                  __privateGet(this, _draggingEditors).set(editor, {
                    savedX: editor.x,
                    savedY: editor.y,
                    savedPageIndex: editor.pageIndex,
                    newX: 0,
                    newY: 0,
                    newPageIndex: -1
                  });
                }
              }
              endDragSession() {
                if (!__privateGet(this, _draggingEditors)) {
                  return false;
                }
                this.disableUserSelect(false);
                const map2 = __privateGet(this, _draggingEditors);
                __privateSet(this, _draggingEditors, null);
                let mustBeAddedInUndoStack = false;
                for (const [{
                  x: x2,
                  y: y2,
                  pageIndex
                }, value] of map2) {
                  value.newX = x2;
                  value.newY = y2;
                  value.newPageIndex = pageIndex;
                  mustBeAddedInUndoStack || (mustBeAddedInUndoStack = x2 !== value.savedX || y2 !== value.savedY || pageIndex !== value.savedPageIndex);
                }
                if (!mustBeAddedInUndoStack) {
                  return false;
                }
                const move = /* @__PURE__ */ __name((editor, x2, y2, pageIndex) => {
                  if (__privateGet(this, _allEditors).has(editor.id)) {
                    const parent = __privateGet(this, _allLayers).get(pageIndex);
                    if (parent) {
                      editor._setParentAndPosition(parent, x2, y2);
                    } else {
                      editor.pageIndex = pageIndex;
                      editor.x = x2;
                      editor.y = y2;
                    }
                  }
                }, "move");
                this.addCommands({
                  cmd: () => {
                    for (const [editor, {
                      newX,
                      newY,
                      newPageIndex
                    }] of map2) {
                      move(editor, newX, newY, newPageIndex);
                    }
                  },
                  undo: () => {
                    for (const [editor, {
                      savedX,
                      savedY,
                      savedPageIndex
                    }] of map2) {
                      move(editor, savedX, savedY, savedPageIndex);
                    }
                  },
                  mustExec: true
                });
                return true;
              }
              dragSelectedEditors(tx, ty) {
                if (!__privateGet(this, _draggingEditors)) {
                  return;
                }
                for (const editor of __privateGet(this, _draggingEditors).keys()) {
                  editor.drag(tx, ty);
                }
              }
              rebuild(editor) {
                if (editor.parent === null) {
                  const parent = this.getLayer(editor.pageIndex);
                  if (parent) {
                    parent.changeParent(editor);
                    parent.addOrRebuild(editor);
                  } else {
                    this.addEditor(editor);
                    this.addToAnnotationStorage(editor);
                    editor.rebuild();
                  }
                } else {
                  editor.parent.addOrRebuild(editor);
                }
              }
              isActive(editor) {
                return __privateGet(this, _activeEditor) === editor;
              }
              getActive() {
                return __privateGet(this, _activeEditor);
              }
              getMode() {
                return __privateGet(this, _mode);
              }
              get imageManager() {
                return (0, _util2.shadow)(this, "imageManager", new ImageManager());
              }
            };
            _activeEditor = new WeakMap();
            _allEditors = new WeakMap();
            _allLayers = new WeakMap();
            _altTextManager = new WeakMap();
            _annotationStorage = new WeakMap();
            _commandManager = new WeakMap();
            _currentPageIndex = new WeakMap();
            _deletedAnnotationsElementIds = new WeakMap();
            _draggingEditors = new WeakMap();
            _editorTypes = new WeakMap();
            _editorsToRescale = new WeakMap();
            _filterFactory = new WeakMap();
            _idManager = new WeakMap();
            _isEnabled = new WeakMap();
            _isWaiting = new WeakMap();
            _lastActiveElement = new WeakMap();
            _mode = new WeakMap();
            _selectedEditors = new WeakMap();
            _pageColors = new WeakMap();
            _boundBlur = new WeakMap();
            _boundFocus = new WeakMap();
            _boundCopy = new WeakMap();
            _boundCut = new WeakMap();
            _boundPaste = new WeakMap();
            _boundKeydown = new WeakMap();
            _boundOnEditingAction = new WeakMap();
            _boundOnPageChanging = new WeakMap();
            _boundOnScaleChanging = new WeakMap();
            _boundOnRotationChanging = new WeakMap();
            _previousStates = new WeakMap();
            _translation = new WeakMap();
            _translationTimeoutId = new WeakMap();
            _container = new WeakMap();
            _viewer = new WeakMap();
            _addFocusManager = new WeakSet();
            addFocusManager_fn = /* @__PURE__ */ __name(function() {
              window.addEventListener("focus", __privateGet(this, _boundFocus));
              window.addEventListener("blur", __privateGet(this, _boundBlur));
            }, "#addFocusManager");
            _removeFocusManager = new WeakSet();
            removeFocusManager_fn = /* @__PURE__ */ __name(function() {
              window.removeEventListener("focus", __privateGet(this, _boundFocus));
              window.removeEventListener("blur", __privateGet(this, _boundBlur));
            }, "#removeFocusManager");
            _addKeyboardManager = new WeakSet();
            addKeyboardManager_fn = /* @__PURE__ */ __name(function() {
              window.addEventListener("keydown", __privateGet(this, _boundKeydown), {
                capture: true
              });
            }, "#addKeyboardManager");
            _removeKeyboardManager = new WeakSet();
            removeKeyboardManager_fn = /* @__PURE__ */ __name(function() {
              window.removeEventListener("keydown", __privateGet(this, _boundKeydown), {
                capture: true
              });
            }, "#removeKeyboardManager");
            _addCopyPasteListeners = new WeakSet();
            addCopyPasteListeners_fn = /* @__PURE__ */ __name(function() {
              document.addEventListener("copy", __privateGet(this, _boundCopy));
              document.addEventListener("cut", __privateGet(this, _boundCut));
              document.addEventListener("paste", __privateGet(this, _boundPaste));
            }, "#addCopyPasteListeners");
            _removeCopyPasteListeners = new WeakSet();
            removeCopyPasteListeners_fn = /* @__PURE__ */ __name(function() {
              document.removeEventListener("copy", __privateGet(this, _boundCopy));
              document.removeEventListener("cut", __privateGet(this, _boundCut));
              document.removeEventListener("paste", __privateGet(this, _boundPaste));
            }, "#removeCopyPasteListeners");
            _dispatchUpdateStates = new WeakSet();
            dispatchUpdateStates_fn = /* @__PURE__ */ __name(function(details) {
              const hasChanged = Object.entries(details).some(([key, value]) => __privateGet(this, _previousStates)[key] !== value);
              if (hasChanged) {
                this._eventBus.dispatch("annotationeditorstateschanged", {
                  source: this,
                  details: Object.assign(__privateGet(this, _previousStates), details)
                });
              }
            }, "#dispatchUpdateStates");
            _dispatchUpdateUI = new WeakSet();
            dispatchUpdateUI_fn = /* @__PURE__ */ __name(function(details) {
              this._eventBus.dispatch("annotationeditorparamschanged", {
                source: this,
                details
              });
            }, "#dispatchUpdateUI");
            _enableAll = new WeakSet();
            enableAll_fn = /* @__PURE__ */ __name(function() {
              if (!__privateGet(this, _isEnabled)) {
                __privateSet(this, _isEnabled, true);
                for (const layer of __privateGet(this, _allLayers).values()) {
                  layer.enable();
                }
              }
            }, "#enableAll");
            _disableAll = new WeakSet();
            disableAll_fn = /* @__PURE__ */ __name(function() {
              this.unselectAll();
              if (__privateGet(this, _isEnabled)) {
                __privateSet(this, _isEnabled, false);
                for (const layer of __privateGet(this, _allLayers).values()) {
                  layer.disable();
                }
              }
            }, "#disableAll");
            _addEditorToLayer = new WeakSet();
            addEditorToLayer_fn = /* @__PURE__ */ __name(function(editor) {
              const layer = __privateGet(this, _allLayers).get(editor.pageIndex);
              if (layer) {
                layer.addOrRebuild(editor);
              } else {
                this.addEditor(editor);
              }
            }, "#addEditorToLayer");
            _isEmpty = new WeakSet();
            isEmpty_fn = /* @__PURE__ */ __name(function() {
              if (__privateGet(this, _allEditors).size === 0) {
                return true;
              }
              if (__privateGet(this, _allEditors).size === 1) {
                for (const editor of __privateGet(this, _allEditors).values()) {
                  return editor.isEmpty();
                }
              }
              return false;
            }, "#isEmpty");
            _selectEditors = new WeakSet();
            selectEditors_fn = /* @__PURE__ */ __name(function(editors) {
              __privateGet(this, _selectedEditors).clear();
              for (const editor of editors) {
                if (editor.isEmpty()) {
                  continue;
                }
                __privateGet(this, _selectedEditors).add(editor);
                editor.select();
              }
              __privateMethod(this, _dispatchUpdateStates, dispatchUpdateStates_fn).call(this, {
                hasSelectedEditor: true
              });
            }, "#selectEditors");
            __name(_AnnotationEditorUIManager, "AnnotationEditorUIManager");
            __publicField(_AnnotationEditorUIManager, "TRANSLATE_SMALL", 1);
            __publicField(_AnnotationEditorUIManager, "TRANSLATE_BIG", 10);
            let AnnotationEditorUIManager = _AnnotationEditorUIManager;
            exports2.AnnotationEditorUIManager = AnnotationEditorUIManager;
          },
          /* 6 */
          /***/
          (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
            var __cache, __defs, _docId, _document, _hcmFilter, _hcmKey, _hcmUrl, _hcmHighlightFilter, _hcmHighlightKey, _hcmHighlightUrl, _id, _cache, cache_get, _defs, defs_get, _addGrayConversion, addGrayConversion_fn, _createFilter, createFilter_fn, _appendFeFunc, appendFeFunc_fn, _addTransferMapConversion, addTransferMapConversion_fn, _getRGB, getRGB_fn;
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            exports2.StatTimer = exports2.RenderingCancelledException = exports2.PixelsPerInch = exports2.PageViewport = exports2.PDFDateString = exports2.DOMStandardFontDataFactory = exports2.DOMSVGFactory = exports2.DOMFilterFactory = exports2.DOMCanvasFactory = exports2.DOMCMapReaderFactory = void 0;
            exports2.deprecated = deprecated;
            exports2.getColorValues = getColorValues;
            exports2.getCurrentTransform = getCurrentTransform;
            exports2.getCurrentTransformInverse = getCurrentTransformInverse;
            exports2.getFilenameFromUrl = getFilenameFromUrl;
            exports2.getPdfFilenameFromUrl = getPdfFilenameFromUrl;
            exports2.getRGB = getRGB;
            exports2.getXfaPageViewport = getXfaPageViewport;
            exports2.isDataScheme = isDataScheme;
            exports2.isPdfFile = isPdfFile;
            exports2.isValidFetchUrl = isValidFetchUrl;
            exports2.loadScript = loadScript;
            exports2.noContextMenu = noContextMenu;
            exports2.setLayerDimensions = setLayerDimensions;
            var _base_factory = __w_pdfjs_require__2(7);
            var _util2 = __w_pdfjs_require__2(1);
            const SVG_NS = "http://www.w3.org/2000/svg";
            const _PixelsPerInch = class _PixelsPerInch {
            };
            __name(_PixelsPerInch, "PixelsPerInch");
            __publicField(_PixelsPerInch, "CSS", 96);
            __publicField(_PixelsPerInch, "PDF", 72);
            __publicField(_PixelsPerInch, "PDF_TO_CSS_UNITS", _PixelsPerInch.CSS / _PixelsPerInch.PDF);
            let PixelsPerInch = _PixelsPerInch;
            exports2.PixelsPerInch = PixelsPerInch;
            const _DOMFilterFactory = class _DOMFilterFactory extends _base_factory.BaseFilterFactory {
              constructor({
                docId,
                ownerDocument = globalThis.document
              } = {}) {
                super();
                __privateAdd(this, _cache);
                __privateAdd(this, _defs);
                __privateAdd(this, _addGrayConversion);
                __privateAdd(this, _createFilter);
                __privateAdd(this, _appendFeFunc);
                __privateAdd(this, _addTransferMapConversion);
                __privateAdd(this, _getRGB);
                __privateAdd(this, __cache, void 0);
                __privateAdd(this, __defs, void 0);
                __privateAdd(this, _docId, void 0);
                __privateAdd(this, _document, void 0);
                __privateAdd(this, _hcmFilter, void 0);
                __privateAdd(this, _hcmKey, void 0);
                __privateAdd(this, _hcmUrl, void 0);
                __privateAdd(this, _hcmHighlightFilter, void 0);
                __privateAdd(this, _hcmHighlightKey, void 0);
                __privateAdd(this, _hcmHighlightUrl, void 0);
                __privateAdd(this, _id, 0);
                __privateSet(this, _docId, docId);
                __privateSet(this, _document, ownerDocument);
              }
              addFilter(maps) {
                if (!maps) {
                  return "none";
                }
                let value = __privateGet(this, _cache, cache_get).get(maps);
                if (value) {
                  return value;
                }
                let tableR, tableG, tableB, key;
                if (maps.length === 1) {
                  const mapR = maps[0];
                  const buffer = new Array(256);
                  for (let i2 = 0; i2 < 256; i2++) {
                    buffer[i2] = mapR[i2] / 255;
                  }
                  key = tableR = tableG = tableB = buffer.join(",");
                } else {
                  const [mapR, mapG, mapB] = maps;
                  const bufferR = new Array(256);
                  const bufferG = new Array(256);
                  const bufferB = new Array(256);
                  for (let i2 = 0; i2 < 256; i2++) {
                    bufferR[i2] = mapR[i2] / 255;
                    bufferG[i2] = mapG[i2] / 255;
                    bufferB[i2] = mapB[i2] / 255;
                  }
                  tableR = bufferR.join(",");
                  tableG = bufferG.join(",");
                  tableB = bufferB.join(",");
                  key = `${tableR}${tableG}${tableB}`;
                }
                value = __privateGet(this, _cache, cache_get).get(key);
                if (value) {
                  __privateGet(this, _cache, cache_get).set(maps, value);
                  return value;
                }
                const id = `g_${__privateGet(this, _docId)}_transfer_map_${__privateWrapper(this, _id)._++}`;
                const url = `url(#${id})`;
                __privateGet(this, _cache, cache_get).set(maps, url);
                __privateGet(this, _cache, cache_get).set(key, url);
                const filter = __privateMethod(this, _createFilter, createFilter_fn).call(this, id);
                __privateMethod(this, _addTransferMapConversion, addTransferMapConversion_fn).call(this, tableR, tableG, tableB, filter);
                return url;
              }
              addHCMFilter(fgColor, bgColor) {
                var _a3;
                const key = `${fgColor}-${bgColor}`;
                if (__privateGet(this, _hcmKey) === key) {
                  return __privateGet(this, _hcmUrl);
                }
                __privateSet(this, _hcmKey, key);
                __privateSet(this, _hcmUrl, "none");
                (_a3 = __privateGet(this, _hcmFilter)) == null ? void 0 : _a3.remove();
                if (!fgColor || !bgColor) {
                  return __privateGet(this, _hcmUrl);
                }
                const fgRGB = __privateMethod(this, _getRGB, getRGB_fn).call(this, fgColor);
                fgColor = _util2.Util.makeHexColor(...fgRGB);
                const bgRGB = __privateMethod(this, _getRGB, getRGB_fn).call(this, bgColor);
                bgColor = _util2.Util.makeHexColor(...bgRGB);
                __privateGet(this, _defs, defs_get).style.color = "";
                if (fgColor === "#000000" && bgColor === "#ffffff" || fgColor === bgColor) {
                  return __privateGet(this, _hcmUrl);
                }
                const map2 = new Array(256);
                for (let i2 = 0; i2 <= 255; i2++) {
                  const x2 = i2 / 255;
                  map2[i2] = x2 <= 0.03928 ? x2 / 12.92 : ((x2 + 0.055) / 1.055) ** 2.4;
                }
                const table = map2.join(",");
                const id = `g_${__privateGet(this, _docId)}_hcm_filter`;
                const filter = __privateSet(this, _hcmHighlightFilter, __privateMethod(this, _createFilter, createFilter_fn).call(this, id));
                __privateMethod(this, _addTransferMapConversion, addTransferMapConversion_fn).call(this, table, table, table, filter);
                __privateMethod(this, _addGrayConversion, addGrayConversion_fn).call(this, filter);
                const getSteps = /* @__PURE__ */ __name((c2, n2) => {
                  const start = fgRGB[c2] / 255;
                  const end = bgRGB[c2] / 255;
                  const arr = new Array(n2 + 1);
                  for (let i2 = 0; i2 <= n2; i2++) {
                    arr[i2] = start + i2 / n2 * (end - start);
                  }
                  return arr.join(",");
                }, "getSteps");
                __privateMethod(this, _addTransferMapConversion, addTransferMapConversion_fn).call(this, getSteps(0, 5), getSteps(1, 5), getSteps(2, 5), filter);
                __privateSet(this, _hcmUrl, `url(#${id})`);
                return __privateGet(this, _hcmUrl);
              }
              addHighlightHCMFilter(fgColor, bgColor, newFgColor, newBgColor) {
                var _a3;
                const key = `${fgColor}-${bgColor}-${newFgColor}-${newBgColor}`;
                if (__privateGet(this, _hcmHighlightKey) === key) {
                  return __privateGet(this, _hcmHighlightUrl);
                }
                __privateSet(this, _hcmHighlightKey, key);
                __privateSet(this, _hcmHighlightUrl, "none");
                (_a3 = __privateGet(this, _hcmHighlightFilter)) == null ? void 0 : _a3.remove();
                if (!fgColor || !bgColor) {
                  return __privateGet(this, _hcmHighlightUrl);
                }
                const [fgRGB, bgRGB] = [fgColor, bgColor].map(__privateMethod(this, _getRGB, getRGB_fn).bind(this));
                let fgGray = Math.round(0.2126 * fgRGB[0] + 0.7152 * fgRGB[1] + 0.0722 * fgRGB[2]);
                let bgGray = Math.round(0.2126 * bgRGB[0] + 0.7152 * bgRGB[1] + 0.0722 * bgRGB[2]);
                let [newFgRGB, newBgRGB] = [newFgColor, newBgColor].map(__privateMethod(this, _getRGB, getRGB_fn).bind(this));
                if (bgGray < fgGray) {
                  [fgGray, bgGray, newFgRGB, newBgRGB] = [bgGray, fgGray, newBgRGB, newFgRGB];
                }
                __privateGet(this, _defs, defs_get).style.color = "";
                const getSteps = /* @__PURE__ */ __name((fg, bg, n2) => {
                  const arr = new Array(256);
                  const step = (bgGray - fgGray) / n2;
                  const newStart = fg / 255;
                  const newStep = (bg - fg) / (255 * n2);
                  let prev = 0;
                  for (let i2 = 0; i2 <= n2; i2++) {
                    const k2 = Math.round(fgGray + i2 * step);
                    const value = newStart + i2 * newStep;
                    for (let j2 = prev; j2 <= k2; j2++) {
                      arr[j2] = value;
                    }
                    prev = k2 + 1;
                  }
                  for (let i2 = prev; i2 < 256; i2++) {
                    arr[i2] = arr[prev - 1];
                  }
                  return arr.join(",");
                }, "getSteps");
                const id = `g_${__privateGet(this, _docId)}_hcm_highlight_filter`;
                const filter = __privateSet(this, _hcmHighlightFilter, __privateMethod(this, _createFilter, createFilter_fn).call(this, id));
                __privateMethod(this, _addGrayConversion, addGrayConversion_fn).call(this, filter);
                __privateMethod(this, _addTransferMapConversion, addTransferMapConversion_fn).call(this, getSteps(newFgRGB[0], newBgRGB[0], 5), getSteps(newFgRGB[1], newBgRGB[1], 5), getSteps(newFgRGB[2], newBgRGB[2], 5), filter);
                __privateSet(this, _hcmHighlightUrl, `url(#${id})`);
                return __privateGet(this, _hcmHighlightUrl);
              }
              destroy(keepHCM = false) {
                if (keepHCM && (__privateGet(this, _hcmUrl) || __privateGet(this, _hcmHighlightUrl))) {
                  return;
                }
                if (__privateGet(this, __defs)) {
                  __privateGet(this, __defs).parentNode.parentNode.remove();
                  __privateSet(this, __defs, null);
                }
                if (__privateGet(this, __cache)) {
                  __privateGet(this, __cache).clear();
                  __privateSet(this, __cache, null);
                }
                __privateSet(this, _id, 0);
              }
            };
            __cache = new WeakMap();
            __defs = new WeakMap();
            _docId = new WeakMap();
            _document = new WeakMap();
            _hcmFilter = new WeakMap();
            _hcmKey = new WeakMap();
            _hcmUrl = new WeakMap();
            _hcmHighlightFilter = new WeakMap();
            _hcmHighlightKey = new WeakMap();
            _hcmHighlightUrl = new WeakMap();
            _id = new WeakMap();
            _cache = new WeakSet();
            cache_get = /* @__PURE__ */ __name(function() {
              return __privateGet(this, __cache) || __privateSet(this, __cache, /* @__PURE__ */ new Map());
            }, "#cache");
            _defs = new WeakSet();
            defs_get = /* @__PURE__ */ __name(function() {
              if (!__privateGet(this, __defs)) {
                const div = __privateGet(this, _document).createElement("div");
                const {
                  style
                } = div;
                style.visibility = "hidden";
                style.contain = "strict";
                style.width = style.height = 0;
                style.position = "absolute";
                style.top = style.left = 0;
                style.zIndex = -1;
                const svg = __privateGet(this, _document).createElementNS(SVG_NS, "svg");
                svg.setAttribute("width", 0);
                svg.setAttribute("height", 0);
                __privateSet(this, __defs, __privateGet(this, _document).createElementNS(SVG_NS, "defs"));
                div.append(svg);
                svg.append(__privateGet(this, __defs));
                __privateGet(this, _document).body.append(div);
              }
              return __privateGet(this, __defs);
            }, "#defs");
            _addGrayConversion = new WeakSet();
            addGrayConversion_fn = /* @__PURE__ */ __name(function(filter) {
              const feColorMatrix = __privateGet(this, _document).createElementNS(SVG_NS, "feColorMatrix");
              feColorMatrix.setAttribute("type", "matrix");
              feColorMatrix.setAttribute("values", "0.2126 0.7152 0.0722 0 0 0.2126 0.7152 0.0722 0 0 0.2126 0.7152 0.0722 0 0 0 0 0 1 0");
              filter.append(feColorMatrix);
            }, "#addGrayConversion");
            _createFilter = new WeakSet();
            createFilter_fn = /* @__PURE__ */ __name(function(id) {
              const filter = __privateGet(this, _document).createElementNS(SVG_NS, "filter");
              filter.setAttribute("color-interpolation-filters", "sRGB");
              filter.setAttribute("id", id);
              __privateGet(this, _defs, defs_get).append(filter);
              return filter;
            }, "#createFilter");
            _appendFeFunc = new WeakSet();
            appendFeFunc_fn = /* @__PURE__ */ __name(function(feComponentTransfer, func, table) {
              const feFunc = __privateGet(this, _document).createElementNS(SVG_NS, func);
              feFunc.setAttribute("type", "discrete");
              feFunc.setAttribute("tableValues", table);
              feComponentTransfer.append(feFunc);
            }, "#appendFeFunc");
            _addTransferMapConversion = new WeakSet();
            addTransferMapConversion_fn = /* @__PURE__ */ __name(function(rTable, gTable, bTable, filter) {
              const feComponentTransfer = __privateGet(this, _document).createElementNS(SVG_NS, "feComponentTransfer");
              filter.append(feComponentTransfer);
              __privateMethod(this, _appendFeFunc, appendFeFunc_fn).call(this, feComponentTransfer, "feFuncR", rTable);
              __privateMethod(this, _appendFeFunc, appendFeFunc_fn).call(this, feComponentTransfer, "feFuncG", gTable);
              __privateMethod(this, _appendFeFunc, appendFeFunc_fn).call(this, feComponentTransfer, "feFuncB", bTable);
            }, "#addTransferMapConversion");
            _getRGB = new WeakSet();
            getRGB_fn = /* @__PURE__ */ __name(function(color2) {
              __privateGet(this, _defs, defs_get).style.color = color2;
              return getRGB(getComputedStyle(__privateGet(this, _defs, defs_get)).getPropertyValue("color"));
            }, "#getRGB");
            __name(_DOMFilterFactory, "DOMFilterFactory");
            let DOMFilterFactory = _DOMFilterFactory;
            exports2.DOMFilterFactory = DOMFilterFactory;
            const _DOMCanvasFactory = class _DOMCanvasFactory extends _base_factory.BaseCanvasFactory {
              constructor({
                ownerDocument = globalThis.document
              } = {}) {
                super();
                this._document = ownerDocument;
              }
              _createCanvas(width, height) {
                const canvas = this._document.createElement("canvas");
                canvas.width = width;
                canvas.height = height;
                return canvas;
              }
            };
            __name(_DOMCanvasFactory, "DOMCanvasFactory");
            let DOMCanvasFactory = _DOMCanvasFactory;
            exports2.DOMCanvasFactory = DOMCanvasFactory;
            async function fetchData(url, asTypedArray = false) {
              if (isValidFetchUrl(url, document.baseURI)) {
                const response = await fetch(url);
                if (!response.ok) {
                  throw new Error(response.statusText);
                }
                return asTypedArray ? new Uint8Array(await response.arrayBuffer()) : (0, _util2.stringToBytes)(await response.text());
              }
              return new Promise((resolve2, reject) => {
                const request = new XMLHttpRequest();
                request.open("GET", url, true);
                if (asTypedArray) {
                  request.responseType = "arraybuffer";
                }
                request.onreadystatechange = () => {
                  if (request.readyState !== XMLHttpRequest.DONE) {
                    return;
                  }
                  if (request.status === 200 || request.status === 0) {
                    let data;
                    if (asTypedArray && request.response) {
                      data = new Uint8Array(request.response);
                    } else if (!asTypedArray && request.responseText) {
                      data = (0, _util2.stringToBytes)(request.responseText);
                    }
                    if (data) {
                      resolve2(data);
                      return;
                    }
                  }
                  reject(new Error(request.statusText));
                };
                request.send(null);
              });
            }
            __name(fetchData, "fetchData");
            const _DOMCMapReaderFactory = class _DOMCMapReaderFactory extends _base_factory.BaseCMapReaderFactory {
              _fetchData(url, compressionType) {
                return fetchData(url, this.isCompressed).then((data) => {
                  return {
                    cMapData: data,
                    compressionType
                  };
                });
              }
            };
            __name(_DOMCMapReaderFactory, "DOMCMapReaderFactory");
            let DOMCMapReaderFactory = _DOMCMapReaderFactory;
            exports2.DOMCMapReaderFactory = DOMCMapReaderFactory;
            const _DOMStandardFontDataFactory = class _DOMStandardFontDataFactory extends _base_factory.BaseStandardFontDataFactory {
              _fetchData(url) {
                return fetchData(url, true);
              }
            };
            __name(_DOMStandardFontDataFactory, "DOMStandardFontDataFactory");
            let DOMStandardFontDataFactory = _DOMStandardFontDataFactory;
            exports2.DOMStandardFontDataFactory = DOMStandardFontDataFactory;
            const _DOMSVGFactory = class _DOMSVGFactory extends _base_factory.BaseSVGFactory {
              _createSVG(type) {
                return document.createElementNS(SVG_NS, type);
              }
            };
            __name(_DOMSVGFactory, "DOMSVGFactory");
            let DOMSVGFactory = _DOMSVGFactory;
            exports2.DOMSVGFactory = DOMSVGFactory;
            const _PageViewport = class _PageViewport {
              constructor({
                viewBox,
                scale,
                rotation,
                offsetX = 0,
                offsetY = 0,
                dontFlip = false
              }) {
                this.viewBox = viewBox;
                this.scale = scale;
                this.rotation = rotation;
                this.offsetX = offsetX;
                this.offsetY = offsetY;
                const centerX = (viewBox[2] + viewBox[0]) / 2;
                const centerY = (viewBox[3] + viewBox[1]) / 2;
                let rotateA, rotateB, rotateC, rotateD;
                rotation %= 360;
                if (rotation < 0) {
                  rotation += 360;
                }
                switch (rotation) {
                  case 180:
                    rotateA = -1;
                    rotateB = 0;
                    rotateC = 0;
                    rotateD = 1;
                    break;
                  case 90:
                    rotateA = 0;
                    rotateB = 1;
                    rotateC = 1;
                    rotateD = 0;
                    break;
                  case 270:
                    rotateA = 0;
                    rotateB = -1;
                    rotateC = -1;
                    rotateD = 0;
                    break;
                  case 0:
                    rotateA = 1;
                    rotateB = 0;
                    rotateC = 0;
                    rotateD = -1;
                    break;
                  default:
                    throw new Error("PageViewport: Invalid rotation, must be a multiple of 90 degrees.");
                }
                if (dontFlip) {
                  rotateC = -rotateC;
                  rotateD = -rotateD;
                }
                let offsetCanvasX, offsetCanvasY;
                let width, height;
                if (rotateA === 0) {
                  offsetCanvasX = Math.abs(centerY - viewBox[1]) * scale + offsetX;
                  offsetCanvasY = Math.abs(centerX - viewBox[0]) * scale + offsetY;
                  width = (viewBox[3] - viewBox[1]) * scale;
                  height = (viewBox[2] - viewBox[0]) * scale;
                } else {
                  offsetCanvasX = Math.abs(centerX - viewBox[0]) * scale + offsetX;
                  offsetCanvasY = Math.abs(centerY - viewBox[1]) * scale + offsetY;
                  width = (viewBox[2] - viewBox[0]) * scale;
                  height = (viewBox[3] - viewBox[1]) * scale;
                }
                this.transform = [rotateA * scale, rotateB * scale, rotateC * scale, rotateD * scale, offsetCanvasX - rotateA * scale * centerX - rotateC * scale * centerY, offsetCanvasY - rotateB * scale * centerX - rotateD * scale * centerY];
                this.width = width;
                this.height = height;
              }
              get rawDims() {
                const {
                  viewBox
                } = this;
                return (0, _util2.shadow)(this, "rawDims", {
                  pageWidth: viewBox[2] - viewBox[0],
                  pageHeight: viewBox[3] - viewBox[1],
                  pageX: viewBox[0],
                  pageY: viewBox[1]
                });
              }
              clone({
                scale = this.scale,
                rotation = this.rotation,
                offsetX = this.offsetX,
                offsetY = this.offsetY,
                dontFlip = false
              } = {}) {
                return new _PageViewport({
                  viewBox: this.viewBox.slice(),
                  scale,
                  rotation,
                  offsetX,
                  offsetY,
                  dontFlip
                });
              }
              convertToViewportPoint(x2, y2) {
                return _util2.Util.applyTransform([x2, y2], this.transform);
              }
              convertToViewportRectangle(rect) {
                const topLeft = _util2.Util.applyTransform([rect[0], rect[1]], this.transform);
                const bottomRight = _util2.Util.applyTransform([rect[2], rect[3]], this.transform);
                return [topLeft[0], topLeft[1], bottomRight[0], bottomRight[1]];
              }
              convertToPdfPoint(x2, y2) {
                return _util2.Util.applyInverseTransform([x2, y2], this.transform);
              }
            };
            __name(_PageViewport, "PageViewport");
            let PageViewport = _PageViewport;
            exports2.PageViewport = PageViewport;
            const _RenderingCancelledException = class _RenderingCancelledException extends _util2.BaseException {
              constructor(msg, extraDelay = 0) {
                super(msg, "RenderingCancelledException");
                this.extraDelay = extraDelay;
              }
            };
            __name(_RenderingCancelledException, "RenderingCancelledException");
            let RenderingCancelledException = _RenderingCancelledException;
            exports2.RenderingCancelledException = RenderingCancelledException;
            function isDataScheme(url) {
              const ii = url.length;
              let i2 = 0;
              while (i2 < ii && url[i2].trim() === "") {
                i2++;
              }
              return url.substring(i2, i2 + 5).toLowerCase() === "data:";
            }
            __name(isDataScheme, "isDataScheme");
            function isPdfFile(filename) {
              return typeof filename === "string" && /\.pdf$/i.test(filename);
            }
            __name(isPdfFile, "isPdfFile");
            function getFilenameFromUrl(url, onlyStripPath = false) {
              if (!onlyStripPath) {
                [url] = url.split(/[#?]/, 1);
              }
              return url.substring(url.lastIndexOf("/") + 1);
            }
            __name(getFilenameFromUrl, "getFilenameFromUrl");
            function getPdfFilenameFromUrl(url, defaultFilename = "document.pdf") {
              if (typeof url !== "string") {
                return defaultFilename;
              }
              if (isDataScheme(url)) {
                (0, _util2.warn)('getPdfFilenameFromUrl: ignore "data:"-URL for performance reasons.');
                return defaultFilename;
              }
              const reURI = /^(?:(?:[^:]+:)?\/\/[^/]+)?([^?#]*)(\?[^#]*)?(#.*)?$/;
              const reFilename = /[^/?#=]+\.pdf\b(?!.*\.pdf\b)/i;
              const splitURI = reURI.exec(url);
              let suggestedFilename = reFilename.exec(splitURI[1]) || reFilename.exec(splitURI[2]) || reFilename.exec(splitURI[3]);
              if (suggestedFilename) {
                suggestedFilename = suggestedFilename[0];
                if (suggestedFilename.includes("%")) {
                  try {
                    suggestedFilename = reFilename.exec(decodeURIComponent(suggestedFilename))[0];
                  } catch {
                  }
                }
              }
              return suggestedFilename || defaultFilename;
            }
            __name(getPdfFilenameFromUrl, "getPdfFilenameFromUrl");
            const _StatTimer = class _StatTimer {
              constructor() {
                __publicField(this, "started", /* @__PURE__ */ Object.create(null));
                __publicField(this, "times", []);
              }
              time(name) {
                if (name in this.started) {
                  (0, _util2.warn)(`Timer is already running for ${name}`);
                }
                this.started[name] = Date.now();
              }
              timeEnd(name) {
                if (!(name in this.started)) {
                  (0, _util2.warn)(`Timer has not been started for ${name}`);
                }
                this.times.push({
                  name,
                  start: this.started[name],
                  end: Date.now()
                });
                delete this.started[name];
              }
              toString() {
                const outBuf = [];
                let longest = 0;
                for (const {
                  name
                } of this.times) {
                  longest = Math.max(name.length, longest);
                }
                for (const {
                  name,
                  start,
                  end
                } of this.times) {
                  outBuf.push(`${name.padEnd(longest)} ${end - start}ms
`);
                }
                return outBuf.join("");
              }
            };
            __name(_StatTimer, "StatTimer");
            let StatTimer = _StatTimer;
            exports2.StatTimer = StatTimer;
            function isValidFetchUrl(url, baseUrl) {
              try {
                const {
                  protocol
                } = baseUrl ? new URL(url, baseUrl) : new URL(url);
                return protocol === "http:" || protocol === "https:";
              } catch {
                return false;
              }
            }
            __name(isValidFetchUrl, "isValidFetchUrl");
            function noContextMenu(e) {
              e.preventDefault();
            }
            __name(noContextMenu, "noContextMenu");
            function loadScript(src, removeScriptElement = false) {
              return new Promise((resolve2, reject) => {
                const script = document.createElement("script");
                script.src = src;
                script.onload = function(evt) {
                  if (removeScriptElement) {
                    script.remove();
                  }
                  resolve2(evt);
                };
                script.onerror = function() {
                  reject(new Error(`Cannot load script at: ${script.src}`));
                };
                (document.head || document.documentElement).append(script);
              });
            }
            __name(loadScript, "loadScript");
            function deprecated(details) {
              console.log("Deprecated API usage: " + details);
            }
            __name(deprecated, "deprecated");
            let pdfDateStringRegex;
            const _PDFDateString = class _PDFDateString {
              static toDateObject(input) {
                if (!input || typeof input !== "string") {
                  return null;
                }
                pdfDateStringRegex || (pdfDateStringRegex = new RegExp("^D:(\\d{4})(\\d{2})?(\\d{2})?(\\d{2})?(\\d{2})?(\\d{2})?([Z|+|-])?(\\d{2})?'?(\\d{2})?'?"));
                const matches = pdfDateStringRegex.exec(input);
                if (!matches) {
                  return null;
                }
                const year = parseInt(matches[1], 10);
                let month = parseInt(matches[2], 10);
                month = month >= 1 && month <= 12 ? month - 1 : 0;
                let day = parseInt(matches[3], 10);
                day = day >= 1 && day <= 31 ? day : 1;
                let hour = parseInt(matches[4], 10);
                hour = hour >= 0 && hour <= 23 ? hour : 0;
                let minute = parseInt(matches[5], 10);
                minute = minute >= 0 && minute <= 59 ? minute : 0;
                let second = parseInt(matches[6], 10);
                second = second >= 0 && second <= 59 ? second : 0;
                const universalTimeRelation = matches[7] || "Z";
                let offsetHour = parseInt(matches[8], 10);
                offsetHour = offsetHour >= 0 && offsetHour <= 23 ? offsetHour : 0;
                let offsetMinute = parseInt(matches[9], 10) || 0;
                offsetMinute = offsetMinute >= 0 && offsetMinute <= 59 ? offsetMinute : 0;
                if (universalTimeRelation === "-") {
                  hour += offsetHour;
                  minute += offsetMinute;
                } else if (universalTimeRelation === "+") {
                  hour -= offsetHour;
                  minute -= offsetMinute;
                }
                return new Date(Date.UTC(year, month, day, hour, minute, second));
              }
            };
            __name(_PDFDateString, "PDFDateString");
            let PDFDateString = _PDFDateString;
            exports2.PDFDateString = PDFDateString;
            function getXfaPageViewport(xfaPage, {
              scale = 1,
              rotation = 0
            }) {
              const {
                width,
                height
              } = xfaPage.attributes.style;
              const viewBox = [0, 0, parseInt(width), parseInt(height)];
              return new PageViewport({
                viewBox,
                scale,
                rotation
              });
            }
            __name(getXfaPageViewport, "getXfaPageViewport");
            function getRGB(color2) {
              if (color2.startsWith("#")) {
                const colorRGB = parseInt(color2.slice(1), 16);
                return [(colorRGB & 16711680) >> 16, (colorRGB & 65280) >> 8, colorRGB & 255];
              }
              if (color2.startsWith("rgb(")) {
                return color2.slice(4, -1).split(",").map((x2) => parseInt(x2));
              }
              if (color2.startsWith("rgba(")) {
                return color2.slice(5, -1).split(",").map((x2) => parseInt(x2)).slice(0, 3);
              }
              (0, _util2.warn)(`Not a valid color format: "${color2}"`);
              return [0, 0, 0];
            }
            __name(getRGB, "getRGB");
            function getColorValues(colors2) {
              const span = document.createElement("span");
              span.style.visibility = "hidden";
              document.body.append(span);
              for (const name of colors2.keys()) {
                span.style.color = name;
                const computedColor = window.getComputedStyle(span).color;
                colors2.set(name, getRGB(computedColor));
              }
              span.remove();
            }
            __name(getColorValues, "getColorValues");
            function getCurrentTransform(ctx) {
              const {
                a: a2,
                b: b2,
                c: c2,
                d: d2,
                e,
                f: f2
              } = ctx.getTransform();
              return [a2, b2, c2, d2, e, f2];
            }
            __name(getCurrentTransform, "getCurrentTransform");
            function getCurrentTransformInverse(ctx) {
              const {
                a: a2,
                b: b2,
                c: c2,
                d: d2,
                e,
                f: f2
              } = ctx.getTransform().invertSelf();
              return [a2, b2, c2, d2, e, f2];
            }
            __name(getCurrentTransformInverse, "getCurrentTransformInverse");
            function setLayerDimensions(div, viewport, mustFlip = false, mustRotate = true) {
              if (viewport instanceof PageViewport) {
                const {
                  pageWidth,
                  pageHeight
                } = viewport.rawDims;
                const {
                  style
                } = div;
                const useRound = _util2.FeatureTest.isCSSRoundSupported;
                const w2 = `var(--scale-factor) * ${pageWidth}px`, h3 = `var(--scale-factor) * ${pageHeight}px`;
                const widthStr = useRound ? `round(${w2}, 1px)` : `calc(${w2})`, heightStr = useRound ? `round(${h3}, 1px)` : `calc(${h3})`;
                if (!mustFlip || viewport.rotation % 180 === 0) {
                  style.width = widthStr;
                  style.height = heightStr;
                } else {
                  style.width = heightStr;
                  style.height = widthStr;
                }
              }
              if (mustRotate) {
                div.setAttribute("data-main-rotation", viewport.rotation);
              }
            }
            __name(setLayerDimensions, "setLayerDimensions");
          },
          /* 7 */
          /***/
          (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            exports2.BaseStandardFontDataFactory = exports2.BaseSVGFactory = exports2.BaseFilterFactory = exports2.BaseCanvasFactory = exports2.BaseCMapReaderFactory = void 0;
            var _util2 = __w_pdfjs_require__2(1);
            const _BaseFilterFactory = class _BaseFilterFactory {
              constructor() {
                if (this.constructor === _BaseFilterFactory) {
                  (0, _util2.unreachable)("Cannot initialize BaseFilterFactory.");
                }
              }
              addFilter(maps) {
                return "none";
              }
              addHCMFilter(fgColor, bgColor) {
                return "none";
              }
              addHighlightHCMFilter(fgColor, bgColor, newFgColor, newBgColor) {
                return "none";
              }
              destroy(keepHCM = false) {
              }
            };
            __name(_BaseFilterFactory, "BaseFilterFactory");
            let BaseFilterFactory = _BaseFilterFactory;
            exports2.BaseFilterFactory = BaseFilterFactory;
            const _BaseCanvasFactory = class _BaseCanvasFactory {
              constructor() {
                if (this.constructor === _BaseCanvasFactory) {
                  (0, _util2.unreachable)("Cannot initialize BaseCanvasFactory.");
                }
              }
              create(width, height) {
                if (width <= 0 || height <= 0) {
                  throw new Error("Invalid canvas size");
                }
                const canvas = this._createCanvas(width, height);
                return {
                  canvas,
                  context: canvas.getContext("2d")
                };
              }
              reset(canvasAndContext, width, height) {
                if (!canvasAndContext.canvas) {
                  throw new Error("Canvas is not specified");
                }
                if (width <= 0 || height <= 0) {
                  throw new Error("Invalid canvas size");
                }
                canvasAndContext.canvas.width = width;
                canvasAndContext.canvas.height = height;
              }
              destroy(canvasAndContext) {
                if (!canvasAndContext.canvas) {
                  throw new Error("Canvas is not specified");
                }
                canvasAndContext.canvas.width = 0;
                canvasAndContext.canvas.height = 0;
                canvasAndContext.canvas = null;
                canvasAndContext.context = null;
              }
              _createCanvas(width, height) {
                (0, _util2.unreachable)("Abstract method `_createCanvas` called.");
              }
            };
            __name(_BaseCanvasFactory, "BaseCanvasFactory");
            let BaseCanvasFactory = _BaseCanvasFactory;
            exports2.BaseCanvasFactory = BaseCanvasFactory;
            const _BaseCMapReaderFactory = class _BaseCMapReaderFactory {
              constructor({
                baseUrl = null,
                isCompressed = true
              }) {
                if (this.constructor === _BaseCMapReaderFactory) {
                  (0, _util2.unreachable)("Cannot initialize BaseCMapReaderFactory.");
                }
                this.baseUrl = baseUrl;
                this.isCompressed = isCompressed;
              }
              async fetch({
                name
              }) {
                if (!this.baseUrl) {
                  throw new Error('The CMap "baseUrl" parameter must be specified, ensure that the "cMapUrl" and "cMapPacked" API parameters are provided.');
                }
                if (!name) {
                  throw new Error("CMap name must be specified.");
                }
                const url = this.baseUrl + name + (this.isCompressed ? ".bcmap" : "");
                const compressionType = this.isCompressed ? _util2.CMapCompressionType.BINARY : _util2.CMapCompressionType.NONE;
                return this._fetchData(url, compressionType).catch((reason) => {
                  throw new Error(`Unable to load ${this.isCompressed ? "binary " : ""}CMap at: ${url}`);
                });
              }
              _fetchData(url, compressionType) {
                (0, _util2.unreachable)("Abstract method `_fetchData` called.");
              }
            };
            __name(_BaseCMapReaderFactory, "BaseCMapReaderFactory");
            let BaseCMapReaderFactory = _BaseCMapReaderFactory;
            exports2.BaseCMapReaderFactory = BaseCMapReaderFactory;
            const _BaseStandardFontDataFactory = class _BaseStandardFontDataFactory {
              constructor({
                baseUrl = null
              }) {
                if (this.constructor === _BaseStandardFontDataFactory) {
                  (0, _util2.unreachable)("Cannot initialize BaseStandardFontDataFactory.");
                }
                this.baseUrl = baseUrl;
              }
              async fetch({
                filename
              }) {
                if (!this.baseUrl) {
                  throw new Error('The standard font "baseUrl" parameter must be specified, ensure that the "standardFontDataUrl" API parameter is provided.');
                }
                if (!filename) {
                  throw new Error("Font filename must be specified.");
                }
                const url = `${this.baseUrl}${filename}`;
                return this._fetchData(url).catch((reason) => {
                  throw new Error(`Unable to load font data at: ${url}`);
                });
              }
              _fetchData(url) {
                (0, _util2.unreachable)("Abstract method `_fetchData` called.");
              }
            };
            __name(_BaseStandardFontDataFactory, "BaseStandardFontDataFactory");
            let BaseStandardFontDataFactory = _BaseStandardFontDataFactory;
            exports2.BaseStandardFontDataFactory = BaseStandardFontDataFactory;
            const _BaseSVGFactory = class _BaseSVGFactory {
              constructor() {
                if (this.constructor === _BaseSVGFactory) {
                  (0, _util2.unreachable)("Cannot initialize BaseSVGFactory.");
                }
              }
              create(width, height, skipDimensions = false) {
                if (width <= 0 || height <= 0) {
                  throw new Error("Invalid SVG dimensions");
                }
                const svg = this._createSVG("svg:svg");
                svg.setAttribute("version", "1.1");
                if (!skipDimensions) {
                  svg.setAttribute("width", `${width}px`);
                  svg.setAttribute("height", `${height}px`);
                }
                svg.setAttribute("preserveAspectRatio", "none");
                svg.setAttribute("viewBox", `0 0 ${width} ${height}`);
                return svg;
              }
              createElement(type) {
                if (typeof type !== "string") {
                  throw new Error("Invalid SVG element type");
                }
                return this._createSVG(type);
              }
              _createSVG(type) {
                (0, _util2.unreachable)("Abstract method `_createSVG` called.");
              }
            };
            __name(_BaseSVGFactory, "BaseSVGFactory");
            let BaseSVGFactory = _BaseSVGFactory;
            exports2.BaseSVGFactory = BaseSVGFactory;
          },
          /* 8 */
          /***/
          (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            exports2.MurmurHash3_64 = void 0;
            var _util2 = __w_pdfjs_require__2(1);
            const SEED = 3285377520;
            const MASK_HIGH = 4294901760;
            const MASK_LOW = 65535;
            const _MurmurHash3_64 = class _MurmurHash3_64 {
              constructor(seed) {
                this.h1 = seed ? seed & 4294967295 : SEED;
                this.h2 = seed ? seed & 4294967295 : SEED;
              }
              update(input) {
                let data, length;
                if (typeof input === "string") {
                  data = new Uint8Array(input.length * 2);
                  length = 0;
                  for (let i2 = 0, ii = input.length; i2 < ii; i2++) {
                    const code = input.charCodeAt(i2);
                    if (code <= 255) {
                      data[length++] = code;
                    } else {
                      data[length++] = code >>> 8;
                      data[length++] = code & 255;
                    }
                  }
                } else if ((0, _util2.isArrayBuffer)(input)) {
                  data = input.slice();
                  length = data.byteLength;
                } else {
                  throw new Error("Wrong data format in MurmurHash3_64_update. Input must be a string or array.");
                }
                const blockCounts = length >> 2;
                const tailLength = length - blockCounts * 4;
                const dataUint32 = new Uint32Array(data.buffer, 0, blockCounts);
                let k1 = 0, k2 = 0;
                let h12 = this.h1, h22 = this.h2;
                const C1 = 3432918353, C2 = 461845907;
                const C1_LOW = C1 & MASK_LOW, C2_LOW = C2 & MASK_LOW;
                for (let i2 = 0; i2 < blockCounts; i2++) {
                  if (i2 & 1) {
                    k1 = dataUint32[i2];
                    k1 = k1 * C1 & MASK_HIGH | k1 * C1_LOW & MASK_LOW;
                    k1 = k1 << 15 | k1 >>> 17;
                    k1 = k1 * C2 & MASK_HIGH | k1 * C2_LOW & MASK_LOW;
                    h12 ^= k1;
                    h12 = h12 << 13 | h12 >>> 19;
                    h12 = h12 * 5 + 3864292196;
                  } else {
                    k2 = dataUint32[i2];
                    k2 = k2 * C1 & MASK_HIGH | k2 * C1_LOW & MASK_LOW;
                    k2 = k2 << 15 | k2 >>> 17;
                    k2 = k2 * C2 & MASK_HIGH | k2 * C2_LOW & MASK_LOW;
                    h22 ^= k2;
                    h22 = h22 << 13 | h22 >>> 19;
                    h22 = h22 * 5 + 3864292196;
                  }
                }
                k1 = 0;
                switch (tailLength) {
                  case 3:
                    k1 ^= data[blockCounts * 4 + 2] << 16;
                  case 2:
                    k1 ^= data[blockCounts * 4 + 1] << 8;
                  case 1:
                    k1 ^= data[blockCounts * 4];
                    k1 = k1 * C1 & MASK_HIGH | k1 * C1_LOW & MASK_LOW;
                    k1 = k1 << 15 | k1 >>> 17;
                    k1 = k1 * C2 & MASK_HIGH | k1 * C2_LOW & MASK_LOW;
                    if (blockCounts & 1) {
                      h12 ^= k1;
                    } else {
                      h22 ^= k1;
                    }
                }
                this.h1 = h12;
                this.h2 = h22;
              }
              hexdigest() {
                let h12 = this.h1, h22 = this.h2;
                h12 ^= h22 >>> 1;
                h12 = h12 * 3981806797 & MASK_HIGH | h12 * 36045 & MASK_LOW;
                h22 = h22 * 4283543511 & MASK_HIGH | ((h22 << 16 | h12 >>> 16) * 2950163797 & MASK_HIGH) >>> 16;
                h12 ^= h22 >>> 1;
                h12 = h12 * 444984403 & MASK_HIGH | h12 * 60499 & MASK_LOW;
                h22 = h22 * 3301882366 & MASK_HIGH | ((h22 << 16 | h12 >>> 16) * 3120437893 & MASK_HIGH) >>> 16;
                h12 ^= h22 >>> 1;
                return (h12 >>> 0).toString(16).padStart(8, "0") + (h22 >>> 0).toString(16).padStart(8, "0");
              }
            };
            __name(_MurmurHash3_64, "MurmurHash3_64");
            let MurmurHash3_64 = _MurmurHash3_64;
            exports2.MurmurHash3_64 = MurmurHash3_64;
          },
          /* 9 */
          /***/
          (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
            var _systemFonts;
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            exports2.FontLoader = exports2.FontFaceObject = void 0;
            var _util2 = __w_pdfjs_require__2(1);
            const _FontLoader = class _FontLoader {
              constructor({
                ownerDocument = globalThis.document,
                styleElement = null
              }) {
                __privateAdd(this, _systemFonts, /* @__PURE__ */ new Set());
                this._document = ownerDocument;
                this.nativeFontFaces = /* @__PURE__ */ new Set();
                this.styleElement = null;
                this.loadingRequests = [];
                this.loadTestFontId = 0;
              }
              addNativeFontFace(nativeFontFace) {
                this.nativeFontFaces.add(nativeFontFace);
                this._document.fonts.add(nativeFontFace);
              }
              removeNativeFontFace(nativeFontFace) {
                this.nativeFontFaces.delete(nativeFontFace);
                this._document.fonts.delete(nativeFontFace);
              }
              insertRule(rule) {
                if (!this.styleElement) {
                  this.styleElement = this._document.createElement("style");
                  this._document.documentElement.getElementsByTagName("head")[0].append(this.styleElement);
                }
                const styleSheet = this.styleElement.sheet;
                styleSheet.insertRule(rule, styleSheet.cssRules.length);
              }
              clear() {
                for (const nativeFontFace of this.nativeFontFaces) {
                  this._document.fonts.delete(nativeFontFace);
                }
                this.nativeFontFaces.clear();
                __privateGet(this, _systemFonts).clear();
                if (this.styleElement) {
                  this.styleElement.remove();
                  this.styleElement = null;
                }
              }
              async loadSystemFont(info) {
                if (!info || __privateGet(this, _systemFonts).has(info.loadedName)) {
                  return;
                }
                (0, _util2.assert)(!this.disableFontFace, "loadSystemFont shouldn't be called when `disableFontFace` is set.");
                if (this.isFontLoadingAPISupported) {
                  const {
                    loadedName,
                    src,
                    style
                  } = info;
                  const fontFace = new FontFace(loadedName, src, style);
                  this.addNativeFontFace(fontFace);
                  try {
                    await fontFace.load();
                    __privateGet(this, _systemFonts).add(loadedName);
                  } catch {
                    (0, _util2.warn)(`Cannot load system font: ${info.baseFontName}, installing it could help to improve PDF rendering.`);
                    this.removeNativeFontFace(fontFace);
                  }
                  return;
                }
                (0, _util2.unreachable)("Not implemented: loadSystemFont without the Font Loading API.");
              }
              async bind(font) {
                if (font.attached || font.missingFile && !font.systemFontInfo) {
                  return;
                }
                font.attached = true;
                if (font.systemFontInfo) {
                  await this.loadSystemFont(font.systemFontInfo);
                  return;
                }
                if (this.isFontLoadingAPISupported) {
                  const nativeFontFace = font.createNativeFontFace();
                  if (nativeFontFace) {
                    this.addNativeFontFace(nativeFontFace);
                    try {
                      await nativeFontFace.loaded;
                    } catch (ex) {
                      (0, _util2.warn)(`Failed to load font '${nativeFontFace.family}': '${ex}'.`);
                      font.disableFontFace = true;
                      throw ex;
                    }
                  }
                  return;
                }
                const rule = font.createFontFaceRule();
                if (rule) {
                  this.insertRule(rule);
                  if (this.isSyncFontLoadingSupported) {
                    return;
                  }
                  await new Promise((resolve2) => {
                    const request = this._queueLoadingCallback(resolve2);
                    this._prepareFontLoadEvent(font, request);
                  });
                }
              }
              get isFontLoadingAPISupported() {
                var _a3;
                const hasFonts = !!((_a3 = this._document) == null ? void 0 : _a3.fonts);
                return (0, _util2.shadow)(this, "isFontLoadingAPISupported", hasFonts);
              }
              get isSyncFontLoadingSupported() {
                let supported = false;
                if (_util2.isNodeJS) {
                  supported = true;
                } else if (typeof navigator !== "undefined" && /Mozilla\/5.0.*?rv:\d+.*? Gecko/.test(navigator.userAgent)) {
                  supported = true;
                }
                return (0, _util2.shadow)(this, "isSyncFontLoadingSupported", supported);
              }
              _queueLoadingCallback(callback2) {
                function completeRequest() {
                  (0, _util2.assert)(!request.done, "completeRequest() cannot be called twice.");
                  request.done = true;
                  while (loadingRequests.length > 0 && loadingRequests[0].done) {
                    const otherRequest = loadingRequests.shift();
                    setTimeout(otherRequest.callback, 0);
                  }
                }
                __name(completeRequest, "completeRequest");
                const {
                  loadingRequests
                } = this;
                const request = {
                  done: false,
                  complete: completeRequest,
                  callback: callback2
                };
                loadingRequests.push(request);
                return request;
              }
              get _loadTestFont() {
                const testFont = atob("T1RUTwALAIAAAwAwQ0ZGIDHtZg4AAAOYAAAAgUZGVE1lkzZwAAAEHAAAABxHREVGABQAFQAABDgAAAAeT1MvMlYNYwkAAAEgAAAAYGNtYXABDQLUAAACNAAAAUJoZWFk/xVFDQAAALwAAAA2aGhlYQdkA+oAAAD0AAAAJGhtdHgD6AAAAAAEWAAAAAZtYXhwAAJQAAAAARgAAAAGbmFtZVjmdH4AAAGAAAAAsXBvc3T/hgAzAAADeAAAACAAAQAAAAEAALZRFsRfDzz1AAsD6AAAAADOBOTLAAAAAM4KHDwAAAAAA+gDIQAAAAgAAgAAAAAAAAABAAADIQAAAFoD6AAAAAAD6AABAAAAAAAAAAAAAAAAAAAAAQAAUAAAAgAAAAQD6AH0AAUAAAKKArwAAACMAooCvAAAAeAAMQECAAACAAYJAAAAAAAAAAAAAQAAAAAAAAAAAAAAAFBmRWQAwAAuAC4DIP84AFoDIQAAAAAAAQAAAAAAAAAAACAAIAABAAAADgCuAAEAAAAAAAAAAQAAAAEAAAAAAAEAAQAAAAEAAAAAAAIAAQAAAAEAAAAAAAMAAQAAAAEAAAAAAAQAAQAAAAEAAAAAAAUAAQAAAAEAAAAAAAYAAQAAAAMAAQQJAAAAAgABAAMAAQQJAAEAAgABAAMAAQQJAAIAAgABAAMAAQQJAAMAAgABAAMAAQQJAAQAAgABAAMAAQQJAAUAAgABAAMAAQQJAAYAAgABWABYAAAAAAAAAwAAAAMAAAAcAAEAAAAAADwAAwABAAAAHAAEACAAAAAEAAQAAQAAAC7//wAAAC7////TAAEAAAAAAAABBgAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMAAAAAAAD/gwAyAAAAAQAAAAAAAAAAAAAAAAAAAAABAAQEAAEBAQJYAAEBASH4DwD4GwHEAvgcA/gXBIwMAYuL+nz5tQXkD5j3CBLnEQACAQEBIVhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYAAABAQAADwACAQEEE/t3Dov6fAH6fAT+fPp8+nwHDosMCvm1Cvm1DAz6fBQAAAAAAAABAAAAAMmJbzEAAAAAzgTjFQAAAADOBOQpAAEAAAAAAAAADAAUAAQAAAABAAAAAgABAAAAAAAAAAAD6AAAAAAAAA==");
                return (0, _util2.shadow)(this, "_loadTestFont", testFont);
              }
              _prepareFontLoadEvent(font, request) {
                function int32(data2, offset) {
                  return data2.charCodeAt(offset) << 24 | data2.charCodeAt(offset + 1) << 16 | data2.charCodeAt(offset + 2) << 8 | data2.charCodeAt(offset + 3) & 255;
                }
                __name(int32, "int32");
                function spliceString(s2, offset, remove, insert) {
                  const chunk1 = s2.substring(0, offset);
                  const chunk2 = s2.substring(offset + remove);
                  return chunk1 + insert + chunk2;
                }
                __name(spliceString, "spliceString");
                let i2, ii;
                const canvas = this._document.createElement("canvas");
                canvas.width = 1;
                canvas.height = 1;
                const ctx = canvas.getContext("2d");
                let called = 0;
                function isFontReady(name, callback2) {
                  if (++called > 30) {
                    (0, _util2.warn)("Load test font never loaded.");
                    callback2();
                    return;
                  }
                  ctx.font = "30px " + name;
                  ctx.fillText(".", 0, 20);
                  const imageData = ctx.getImageData(0, 0, 1, 1);
                  if (imageData.data[3] > 0) {
                    callback2();
                    return;
                  }
                  setTimeout(isFontReady.bind(null, name, callback2));
                }
                __name(isFontReady, "isFontReady");
                const loadTestFontId = `lt${Date.now()}${this.loadTestFontId++}`;
                let data = this._loadTestFont;
                const COMMENT_OFFSET = 976;
                data = spliceString(data, COMMENT_OFFSET, loadTestFontId.length, loadTestFontId);
                const CFF_CHECKSUM_OFFSET = 16;
                const XXXX_VALUE = 1482184792;
                let checksum = int32(data, CFF_CHECKSUM_OFFSET);
                for (i2 = 0, ii = loadTestFontId.length - 3; i2 < ii; i2 += 4) {
                  checksum = checksum - XXXX_VALUE + int32(loadTestFontId, i2) | 0;
                }
                if (i2 < loadTestFontId.length) {
                  checksum = checksum - XXXX_VALUE + int32(loadTestFontId + "XXX", i2) | 0;
                }
                data = spliceString(data, CFF_CHECKSUM_OFFSET, 4, (0, _util2.string32)(checksum));
                const url = `url(data:font/opentype;base64,${btoa(data)});`;
                const rule = `@font-face {font-family:"${loadTestFontId}";src:${url}}`;
                this.insertRule(rule);
                const div = this._document.createElement("div");
                div.style.visibility = "hidden";
                div.style.width = div.style.height = "10px";
                div.style.position = "absolute";
                div.style.top = div.style.left = "0px";
                for (const name of [font.loadedName, loadTestFontId]) {
                  const span = this._document.createElement("span");
                  span.textContent = "Hi";
                  span.style.fontFamily = name;
                  div.append(span);
                }
                this._document.body.append(div);
                isFontReady(loadTestFontId, () => {
                  div.remove();
                  request.complete();
                });
              }
            };
            _systemFonts = new WeakMap();
            __name(_FontLoader, "FontLoader");
            let FontLoader = _FontLoader;
            exports2.FontLoader = FontLoader;
            const _FontFaceObject = class _FontFaceObject {
              constructor(translatedData, {
                isEvalSupported = true,
                disableFontFace = false,
                ignoreErrors = false,
                inspectFont = null
              }) {
                this.compiledGlyphs = /* @__PURE__ */ Object.create(null);
                for (const i2 in translatedData) {
                  this[i2] = translatedData[i2];
                }
                this.isEvalSupported = isEvalSupported !== false;
                this.disableFontFace = disableFontFace === true;
                this.ignoreErrors = ignoreErrors === true;
                this._inspectFont = inspectFont;
              }
              createNativeFontFace() {
                var _a3;
                if (!this.data || this.disableFontFace) {
                  return null;
                }
                let nativeFontFace;
                if (!this.cssFontInfo) {
                  nativeFontFace = new FontFace(this.loadedName, this.data, {});
                } else {
                  const css = {
                    weight: this.cssFontInfo.fontWeight
                  };
                  if (this.cssFontInfo.italicAngle) {
                    css.style = `oblique ${this.cssFontInfo.italicAngle}deg`;
                  }
                  nativeFontFace = new FontFace(this.cssFontInfo.fontFamily, this.data, css);
                }
                (_a3 = this._inspectFont) == null ? void 0 : _a3.call(this, this);
                return nativeFontFace;
              }
              createFontFaceRule() {
                var _a3;
                if (!this.data || this.disableFontFace) {
                  return null;
                }
                const data = (0, _util2.bytesToString)(this.data);
                const url = `url(data:${this.mimetype};base64,${btoa(data)});`;
                let rule;
                if (!this.cssFontInfo) {
                  rule = `@font-face {font-family:"${this.loadedName}";src:${url}}`;
                } else {
                  let css = `font-weight: ${this.cssFontInfo.fontWeight};`;
                  if (this.cssFontInfo.italicAngle) {
                    css += `font-style: oblique ${this.cssFontInfo.italicAngle}deg;`;
                  }
                  rule = `@font-face {font-family:"${this.cssFontInfo.fontFamily}";${css}src:${url}}`;
                }
                (_a3 = this._inspectFont) == null ? void 0 : _a3.call(this, this, url);
                return rule;
              }
              getPathGenerator(objs, character) {
                if (this.compiledGlyphs[character] !== void 0) {
                  return this.compiledGlyphs[character];
                }
                let cmds;
                try {
                  cmds = objs.get(this.loadedName + "_path_" + character);
                } catch (ex) {
                  if (!this.ignoreErrors) {
                    throw ex;
                  }
                  (0, _util2.warn)(`getPathGenerator - ignoring character: "${ex}".`);
                  return this.compiledGlyphs[character] = function(c2, size) {
                  };
                }
                if (this.isEvalSupported && _util2.FeatureTest.isEvalSupported) {
                  const jsBuf = [];
                  for (const current of cmds) {
                    const args = current.args !== void 0 ? current.args.join(",") : "";
                    jsBuf.push("c.", current.cmd, "(", args, ");\n");
                  }
                  return this.compiledGlyphs[character] = new Function("c", "size", jsBuf.join(""));
                }
                return this.compiledGlyphs[character] = function(c2, size) {
                  for (const current of cmds) {
                    if (current.cmd === "scale") {
                      current.args = [size, -size];
                    }
                    c2[current.cmd].apply(c2, current.args);
                  }
                };
              }
            };
            __name(_FontFaceObject, "FontFaceObject");
            let FontFaceObject = _FontFaceObject;
            exports2.FontFaceObject = FontFaceObject;
          },
          /* 10 */
          /***/
          (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            exports2.NodeStandardFontDataFactory = exports2.NodeFilterFactory = exports2.NodeCanvasFactory = exports2.NodeCMapReaderFactory = void 0;
            var _base_factory = __w_pdfjs_require__2(7);
            __w_pdfjs_require__2(1);
            const fetchData = /* @__PURE__ */ __name(function(url) {
              return new Promise((resolve2, reject) => {
                const fs = require$$5;
                fs.readFile(url, (error, data) => {
                  if (error || !data) {
                    reject(new Error(error));
                    return;
                  }
                  resolve2(new Uint8Array(data));
                });
              });
            }, "fetchData");
            const _NodeFilterFactory = class _NodeFilterFactory extends _base_factory.BaseFilterFactory {
            };
            __name(_NodeFilterFactory, "NodeFilterFactory");
            let NodeFilterFactory = _NodeFilterFactory;
            exports2.NodeFilterFactory = NodeFilterFactory;
            const _NodeCanvasFactory = class _NodeCanvasFactory extends _base_factory.BaseCanvasFactory {
              _createCanvas(width, height) {
                const Canvas = require$$5;
                return Canvas.createCanvas(width, height);
              }
            };
            __name(_NodeCanvasFactory, "NodeCanvasFactory");
            let NodeCanvasFactory = _NodeCanvasFactory;
            exports2.NodeCanvasFactory = NodeCanvasFactory;
            const _NodeCMapReaderFactory = class _NodeCMapReaderFactory extends _base_factory.BaseCMapReaderFactory {
              _fetchData(url, compressionType) {
                return fetchData(url).then((data) => {
                  return {
                    cMapData: data,
                    compressionType
                  };
                });
              }
            };
            __name(_NodeCMapReaderFactory, "NodeCMapReaderFactory");
            let NodeCMapReaderFactory = _NodeCMapReaderFactory;
            exports2.NodeCMapReaderFactory = NodeCMapReaderFactory;
            const _NodeStandardFontDataFactory = class _NodeStandardFontDataFactory extends _base_factory.BaseStandardFontDataFactory {
              _fetchData(url) {
                return fetchData(url);
              }
            };
            __name(_NodeStandardFontDataFactory, "NodeStandardFontDataFactory");
            let NodeStandardFontDataFactory = _NodeStandardFontDataFactory;
            exports2.NodeStandardFontDataFactory = NodeStandardFontDataFactory;
          },
          /* 11 */
          /***/
          (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
            var _restoreInitialState, restoreInitialState_fn, _drawFilter, drawFilter_fn;
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            exports2.CanvasGraphics = void 0;
            var _util2 = __w_pdfjs_require__2(1);
            var _display_utils2 = __w_pdfjs_require__2(6);
            var _pattern_helper = __w_pdfjs_require__2(12);
            var _image_utils = __w_pdfjs_require__2(13);
            const MIN_FONT_SIZE = 16;
            const MAX_FONT_SIZE = 100;
            const MAX_GROUP_SIZE = 4096;
            const EXECUTION_TIME = 15;
            const EXECUTION_STEPS = 10;
            const MAX_SIZE_TO_COMPILE = 1e3;
            const FULL_CHUNK_HEIGHT = 16;
            function mirrorContextOperations(ctx, destCtx) {
              if (ctx._removeMirroring) {
                throw new Error("Context is already forwarding operations.");
              }
              ctx.__originalSave = ctx.save;
              ctx.__originalRestore = ctx.restore;
              ctx.__originalRotate = ctx.rotate;
              ctx.__originalScale = ctx.scale;
              ctx.__originalTranslate = ctx.translate;
              ctx.__originalTransform = ctx.transform;
              ctx.__originalSetTransform = ctx.setTransform;
              ctx.__originalResetTransform = ctx.resetTransform;
              ctx.__originalClip = ctx.clip;
              ctx.__originalMoveTo = ctx.moveTo;
              ctx.__originalLineTo = ctx.lineTo;
              ctx.__originalBezierCurveTo = ctx.bezierCurveTo;
              ctx.__originalRect = ctx.rect;
              ctx.__originalClosePath = ctx.closePath;
              ctx.__originalBeginPath = ctx.beginPath;
              ctx._removeMirroring = () => {
                ctx.save = ctx.__originalSave;
                ctx.restore = ctx.__originalRestore;
                ctx.rotate = ctx.__originalRotate;
                ctx.scale = ctx.__originalScale;
                ctx.translate = ctx.__originalTranslate;
                ctx.transform = ctx.__originalTransform;
                ctx.setTransform = ctx.__originalSetTransform;
                ctx.resetTransform = ctx.__originalResetTransform;
                ctx.clip = ctx.__originalClip;
                ctx.moveTo = ctx.__originalMoveTo;
                ctx.lineTo = ctx.__originalLineTo;
                ctx.bezierCurveTo = ctx.__originalBezierCurveTo;
                ctx.rect = ctx.__originalRect;
                ctx.closePath = ctx.__originalClosePath;
                ctx.beginPath = ctx.__originalBeginPath;
                delete ctx._removeMirroring;
              };
              ctx.save = /* @__PURE__ */ __name(function ctxSave() {
                destCtx.save();
                this.__originalSave();
              }, "ctxSave");
              ctx.restore = /* @__PURE__ */ __name(function ctxRestore() {
                destCtx.restore();
                this.__originalRestore();
              }, "ctxRestore");
              ctx.translate = /* @__PURE__ */ __name(function ctxTranslate(x2, y2) {
                destCtx.translate(x2, y2);
                this.__originalTranslate(x2, y2);
              }, "ctxTranslate");
              ctx.scale = /* @__PURE__ */ __name(function ctxScale(x2, y2) {
                destCtx.scale(x2, y2);
                this.__originalScale(x2, y2);
              }, "ctxScale");
              ctx.transform = /* @__PURE__ */ __name(function ctxTransform(a2, b2, c2, d2, e, f2) {
                destCtx.transform(a2, b2, c2, d2, e, f2);
                this.__originalTransform(a2, b2, c2, d2, e, f2);
              }, "ctxTransform");
              ctx.setTransform = /* @__PURE__ */ __name(function ctxSetTransform(a2, b2, c2, d2, e, f2) {
                destCtx.setTransform(a2, b2, c2, d2, e, f2);
                this.__originalSetTransform(a2, b2, c2, d2, e, f2);
              }, "ctxSetTransform");
              ctx.resetTransform = /* @__PURE__ */ __name(function ctxResetTransform() {
                destCtx.resetTransform();
                this.__originalResetTransform();
              }, "ctxResetTransform");
              ctx.rotate = /* @__PURE__ */ __name(function ctxRotate(angle) {
                destCtx.rotate(angle);
                this.__originalRotate(angle);
              }, "ctxRotate");
              ctx.clip = /* @__PURE__ */ __name(function ctxRotate(rule) {
                destCtx.clip(rule);
                this.__originalClip(rule);
              }, "ctxRotate");
              ctx.moveTo = function(x2, y2) {
                destCtx.moveTo(x2, y2);
                this.__originalMoveTo(x2, y2);
              };
              ctx.lineTo = function(x2, y2) {
                destCtx.lineTo(x2, y2);
                this.__originalLineTo(x2, y2);
              };
              ctx.bezierCurveTo = function(cp1x, cp1y, cp2x, cp2y, x2, y2) {
                destCtx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x2, y2);
                this.__originalBezierCurveTo(cp1x, cp1y, cp2x, cp2y, x2, y2);
              };
              ctx.rect = function(x2, y2, width, height) {
                destCtx.rect(x2, y2, width, height);
                this.__originalRect(x2, y2, width, height);
              };
              ctx.closePath = function() {
                destCtx.closePath();
                this.__originalClosePath();
              };
              ctx.beginPath = function() {
                destCtx.beginPath();
                this.__originalBeginPath();
              };
            }
            __name(mirrorContextOperations, "mirrorContextOperations");
            const _CachedCanvases = class _CachedCanvases {
              constructor(canvasFactory) {
                this.canvasFactory = canvasFactory;
                this.cache = /* @__PURE__ */ Object.create(null);
              }
              getCanvas(id, width, height) {
                let canvasEntry;
                if (this.cache[id] !== void 0) {
                  canvasEntry = this.cache[id];
                  this.canvasFactory.reset(canvasEntry, width, height);
                } else {
                  canvasEntry = this.canvasFactory.create(width, height);
                  this.cache[id] = canvasEntry;
                }
                return canvasEntry;
              }
              delete(id) {
                delete this.cache[id];
              }
              clear() {
                for (const id in this.cache) {
                  const canvasEntry = this.cache[id];
                  this.canvasFactory.destroy(canvasEntry);
                  delete this.cache[id];
                }
              }
            };
            __name(_CachedCanvases, "CachedCanvases");
            let CachedCanvases = _CachedCanvases;
            function drawImageAtIntegerCoords(ctx, srcImg, srcX, srcY, srcW, srcH, destX, destY, destW, destH) {
              const [a2, b2, c2, d2, tx, ty] = (0, _display_utils2.getCurrentTransform)(ctx);
              if (b2 === 0 && c2 === 0) {
                const tlX = destX * a2 + tx;
                const rTlX = Math.round(tlX);
                const tlY = destY * d2 + ty;
                const rTlY = Math.round(tlY);
                const brX = (destX + destW) * a2 + tx;
                const rWidth = Math.abs(Math.round(brX) - rTlX) || 1;
                const brY = (destY + destH) * d2 + ty;
                const rHeight = Math.abs(Math.round(brY) - rTlY) || 1;
                ctx.setTransform(Math.sign(a2), 0, 0, Math.sign(d2), rTlX, rTlY);
                ctx.drawImage(srcImg, srcX, srcY, srcW, srcH, 0, 0, rWidth, rHeight);
                ctx.setTransform(a2, b2, c2, d2, tx, ty);
                return [rWidth, rHeight];
              }
              if (a2 === 0 && d2 === 0) {
                const tlX = destY * c2 + tx;
                const rTlX = Math.round(tlX);
                const tlY = destX * b2 + ty;
                const rTlY = Math.round(tlY);
                const brX = (destY + destH) * c2 + tx;
                const rWidth = Math.abs(Math.round(brX) - rTlX) || 1;
                const brY = (destX + destW) * b2 + ty;
                const rHeight = Math.abs(Math.round(brY) - rTlY) || 1;
                ctx.setTransform(0, Math.sign(b2), Math.sign(c2), 0, rTlX, rTlY);
                ctx.drawImage(srcImg, srcX, srcY, srcW, srcH, 0, 0, rHeight, rWidth);
                ctx.setTransform(a2, b2, c2, d2, tx, ty);
                return [rHeight, rWidth];
              }
              ctx.drawImage(srcImg, srcX, srcY, srcW, srcH, destX, destY, destW, destH);
              const scaleX = Math.hypot(a2, b2);
              const scaleY = Math.hypot(c2, d2);
              return [scaleX * destW, scaleY * destH];
            }
            __name(drawImageAtIntegerCoords, "drawImageAtIntegerCoords");
            function compileType3Glyph(imgData) {
              const {
                width,
                height
              } = imgData;
              if (width > MAX_SIZE_TO_COMPILE || height > MAX_SIZE_TO_COMPILE) {
                return null;
              }
              const POINT_TO_PROCESS_LIMIT = 1e3;
              const POINT_TYPES = new Uint8Array([0, 2, 4, 0, 1, 0, 5, 4, 8, 10, 0, 8, 0, 2, 1, 0]);
              const width1 = width + 1;
              let points = new Uint8Array(width1 * (height + 1));
              let i2, j2, j0;
              const lineSize = width + 7 & ~7;
              let data = new Uint8Array(lineSize * height), pos = 0;
              for (const elem of imgData.data) {
                let mask = 128;
                while (mask > 0) {
                  data[pos++] = elem & mask ? 0 : 255;
                  mask >>= 1;
                }
              }
              let count = 0;
              pos = 0;
              if (data[pos] !== 0) {
                points[0] = 1;
                ++count;
              }
              for (j2 = 1; j2 < width; j2++) {
                if (data[pos] !== data[pos + 1]) {
                  points[j2] = data[pos] ? 2 : 1;
                  ++count;
                }
                pos++;
              }
              if (data[pos] !== 0) {
                points[j2] = 2;
                ++count;
              }
              for (i2 = 1; i2 < height; i2++) {
                pos = i2 * lineSize;
                j0 = i2 * width1;
                if (data[pos - lineSize] !== data[pos]) {
                  points[j0] = data[pos] ? 1 : 8;
                  ++count;
                }
                let sum = (data[pos] ? 4 : 0) + (data[pos - lineSize] ? 8 : 0);
                for (j2 = 1; j2 < width; j2++) {
                  sum = (sum >> 2) + (data[pos + 1] ? 4 : 0) + (data[pos - lineSize + 1] ? 8 : 0);
                  if (POINT_TYPES[sum]) {
                    points[j0 + j2] = POINT_TYPES[sum];
                    ++count;
                  }
                  pos++;
                }
                if (data[pos - lineSize] !== data[pos]) {
                  points[j0 + j2] = data[pos] ? 2 : 4;
                  ++count;
                }
                if (count > POINT_TO_PROCESS_LIMIT) {
                  return null;
                }
              }
              pos = lineSize * (height - 1);
              j0 = i2 * width1;
              if (data[pos] !== 0) {
                points[j0] = 8;
                ++count;
              }
              for (j2 = 1; j2 < width; j2++) {
                if (data[pos] !== data[pos + 1]) {
                  points[j0 + j2] = data[pos] ? 4 : 8;
                  ++count;
                }
                pos++;
              }
              if (data[pos] !== 0) {
                points[j0 + j2] = 4;
                ++count;
              }
              if (count > POINT_TO_PROCESS_LIMIT) {
                return null;
              }
              const steps2 = new Int32Array([0, width1, -1, 0, -width1, 0, 0, 0, 1]);
              const path = new Path2D();
              for (i2 = 0; count && i2 <= height; i2++) {
                let p2 = i2 * width1;
                const end = p2 + width;
                while (p2 < end && !points[p2]) {
                  p2++;
                }
                if (p2 === end) {
                  continue;
                }
                path.moveTo(p2 % width1, i2);
                const p0 = p2;
                let type = points[p2];
                do {
                  const step = steps2[type];
                  do {
                    p2 += step;
                  } while (!points[p2]);
                  const pp = points[p2];
                  if (pp !== 5 && pp !== 10) {
                    type = pp;
                    points[p2] = 0;
                  } else {
                    type = pp & 51 * type >> 4;
                    points[p2] &= type >> 2 | type << 2;
                  }
                  path.lineTo(p2 % width1, p2 / width1 | 0);
                  if (!points[p2]) {
                    --count;
                  }
                } while (p0 !== p2);
                --i2;
              }
              data = null;
              points = null;
              const drawOutline = /* @__PURE__ */ __name(function(c2) {
                c2.save();
                c2.scale(1 / width, -1 / height);
                c2.translate(0, -height);
                c2.fill(path);
                c2.beginPath();
                c2.restore();
              }, "drawOutline");
              return drawOutline;
            }
            __name(compileType3Glyph, "compileType3Glyph");
            const _CanvasExtraState = class _CanvasExtraState {
              constructor(width, height) {
                this.alphaIsShape = false;
                this.fontSize = 0;
                this.fontSizeScale = 1;
                this.textMatrix = _util2.IDENTITY_MATRIX;
                this.textMatrixScale = 1;
                this.fontMatrix = _util2.FONT_IDENTITY_MATRIX;
                this.leading = 0;
                this.x = 0;
                this.y = 0;
                this.lineX = 0;
                this.lineY = 0;
                this.charSpacing = 0;
                this.wordSpacing = 0;
                this.textHScale = 1;
                this.textRenderingMode = _util2.TextRenderingMode.FILL;
                this.textRise = 0;
                this.fillColor = "#000000";
                this.strokeColor = "#000000";
                this.patternFill = false;
                this.fillAlpha = 1;
                this.strokeAlpha = 1;
                this.lineWidth = 1;
                this.activeSMask = null;
                this.transferMaps = "none";
                this.startNewPathAndClipBox([0, 0, width, height]);
              }
              clone() {
                const clone2 = Object.create(this);
                clone2.clipBox = this.clipBox.slice();
                return clone2;
              }
              setCurrentPoint(x2, y2) {
                this.x = x2;
                this.y = y2;
              }
              updatePathMinMax(transform, x2, y2) {
                [x2, y2] = _util2.Util.applyTransform([x2, y2], transform);
                this.minX = Math.min(this.minX, x2);
                this.minY = Math.min(this.minY, y2);
                this.maxX = Math.max(this.maxX, x2);
                this.maxY = Math.max(this.maxY, y2);
              }
              updateRectMinMax(transform, rect) {
                const p1 = _util2.Util.applyTransform(rect, transform);
                const p2 = _util2.Util.applyTransform(rect.slice(2), transform);
                this.minX = Math.min(this.minX, p1[0], p2[0]);
                this.minY = Math.min(this.minY, p1[1], p2[1]);
                this.maxX = Math.max(this.maxX, p1[0], p2[0]);
                this.maxY = Math.max(this.maxY, p1[1], p2[1]);
              }
              updateScalingPathMinMax(transform, minMax) {
                _util2.Util.scaleMinMax(transform, minMax);
                this.minX = Math.min(this.minX, minMax[0]);
                this.maxX = Math.max(this.maxX, minMax[1]);
                this.minY = Math.min(this.minY, minMax[2]);
                this.maxY = Math.max(this.maxY, minMax[3]);
              }
              updateCurvePathMinMax(transform, x0, y0, x1, y1, x2, y2, x3, y3, minMax) {
                const box = _util2.Util.bezierBoundingBox(x0, y0, x1, y1, x2, y2, x3, y3);
                if (minMax) {
                  minMax[0] = Math.min(minMax[0], box[0], box[2]);
                  minMax[1] = Math.max(minMax[1], box[0], box[2]);
                  minMax[2] = Math.min(minMax[2], box[1], box[3]);
                  minMax[3] = Math.max(minMax[3], box[1], box[3]);
                  return;
                }
                this.updateRectMinMax(transform, box);
              }
              getPathBoundingBox(pathType = _pattern_helper.PathType.FILL, transform = null) {
                const box = [this.minX, this.minY, this.maxX, this.maxY];
                if (pathType === _pattern_helper.PathType.STROKE) {
                  if (!transform) {
                    (0, _util2.unreachable)("Stroke bounding box must include transform.");
                  }
                  const scale = _util2.Util.singularValueDecompose2dScale(transform);
                  const xStrokePad = scale[0] * this.lineWidth / 2;
                  const yStrokePad = scale[1] * this.lineWidth / 2;
                  box[0] -= xStrokePad;
                  box[1] -= yStrokePad;
                  box[2] += xStrokePad;
                  box[3] += yStrokePad;
                }
                return box;
              }
              updateClipFromPath() {
                const intersect = _util2.Util.intersect(this.clipBox, this.getPathBoundingBox());
                this.startNewPathAndClipBox(intersect || [0, 0, 0, 0]);
              }
              isEmptyClip() {
                return this.minX === Infinity;
              }
              startNewPathAndClipBox(box) {
                this.clipBox = box;
                this.minX = Infinity;
                this.minY = Infinity;
                this.maxX = 0;
                this.maxY = 0;
              }
              getClippedPathBoundingBox(pathType = _pattern_helper.PathType.FILL, transform = null) {
                return _util2.Util.intersect(this.clipBox, this.getPathBoundingBox(pathType, transform));
              }
            };
            __name(_CanvasExtraState, "CanvasExtraState");
            let CanvasExtraState = _CanvasExtraState;
            function putBinaryImageData(ctx, imgData) {
              if (typeof ImageData !== "undefined" && imgData instanceof ImageData) {
                ctx.putImageData(imgData, 0, 0);
                return;
              }
              const height = imgData.height, width = imgData.width;
              const partialChunkHeight = height % FULL_CHUNK_HEIGHT;
              const fullChunks = (height - partialChunkHeight) / FULL_CHUNK_HEIGHT;
              const totalChunks = partialChunkHeight === 0 ? fullChunks : fullChunks + 1;
              const chunkImgData = ctx.createImageData(width, FULL_CHUNK_HEIGHT);
              let srcPos = 0, destPos;
              const src = imgData.data;
              const dest = chunkImgData.data;
              let i2, j2, thisChunkHeight, elemsInThisChunk;
              if (imgData.kind === _util2.ImageKind.GRAYSCALE_1BPP) {
                const srcLength = src.byteLength;
                const dest32 = new Uint32Array(dest.buffer, 0, dest.byteLength >> 2);
                const dest32DataLength = dest32.length;
                const fullSrcDiff = width + 7 >> 3;
                const white = 4294967295;
                const black = _util2.FeatureTest.isLittleEndian ? 4278190080 : 255;
                for (i2 = 0; i2 < totalChunks; i2++) {
                  thisChunkHeight = i2 < fullChunks ? FULL_CHUNK_HEIGHT : partialChunkHeight;
                  destPos = 0;
                  for (j2 = 0; j2 < thisChunkHeight; j2++) {
                    const srcDiff = srcLength - srcPos;
                    let k2 = 0;
                    const kEnd = srcDiff > fullSrcDiff ? width : srcDiff * 8 - 7;
                    const kEndUnrolled = kEnd & ~7;
                    let mask = 0;
                    let srcByte = 0;
                    for (; k2 < kEndUnrolled; k2 += 8) {
                      srcByte = src[srcPos++];
                      dest32[destPos++] = srcByte & 128 ? white : black;
                      dest32[destPos++] = srcByte & 64 ? white : black;
                      dest32[destPos++] = srcByte & 32 ? white : black;
                      dest32[destPos++] = srcByte & 16 ? white : black;
                      dest32[destPos++] = srcByte & 8 ? white : black;
                      dest32[destPos++] = srcByte & 4 ? white : black;
                      dest32[destPos++] = srcByte & 2 ? white : black;
                      dest32[destPos++] = srcByte & 1 ? white : black;
                    }
                    for (; k2 < kEnd; k2++) {
                      if (mask === 0) {
                        srcByte = src[srcPos++];
                        mask = 128;
                      }
                      dest32[destPos++] = srcByte & mask ? white : black;
                      mask >>= 1;
                    }
                  }
                  while (destPos < dest32DataLength) {
                    dest32[destPos++] = 0;
                  }
                  ctx.putImageData(chunkImgData, 0, i2 * FULL_CHUNK_HEIGHT);
                }
              } else if (imgData.kind === _util2.ImageKind.RGBA_32BPP) {
                j2 = 0;
                elemsInThisChunk = width * FULL_CHUNK_HEIGHT * 4;
                for (i2 = 0; i2 < fullChunks; i2++) {
                  dest.set(src.subarray(srcPos, srcPos + elemsInThisChunk));
                  srcPos += elemsInThisChunk;
                  ctx.putImageData(chunkImgData, 0, j2);
                  j2 += FULL_CHUNK_HEIGHT;
                }
                if (i2 < totalChunks) {
                  elemsInThisChunk = width * partialChunkHeight * 4;
                  dest.set(src.subarray(srcPos, srcPos + elemsInThisChunk));
                  ctx.putImageData(chunkImgData, 0, j2);
                }
              } else if (imgData.kind === _util2.ImageKind.RGB_24BPP) {
                thisChunkHeight = FULL_CHUNK_HEIGHT;
                elemsInThisChunk = width * thisChunkHeight;
                for (i2 = 0; i2 < totalChunks; i2++) {
                  if (i2 >= fullChunks) {
                    thisChunkHeight = partialChunkHeight;
                    elemsInThisChunk = width * thisChunkHeight;
                  }
                  destPos = 0;
                  for (j2 = elemsInThisChunk; j2--; ) {
                    dest[destPos++] = src[srcPos++];
                    dest[destPos++] = src[srcPos++];
                    dest[destPos++] = src[srcPos++];
                    dest[destPos++] = 255;
                  }
                  ctx.putImageData(chunkImgData, 0, i2 * FULL_CHUNK_HEIGHT);
                }
              } else {
                throw new Error(`bad image kind: ${imgData.kind}`);
              }
            }
            __name(putBinaryImageData, "putBinaryImageData");
            function putBinaryImageMask(ctx, imgData) {
              if (imgData.bitmap) {
                ctx.drawImage(imgData.bitmap, 0, 0);
                return;
              }
              const height = imgData.height, width = imgData.width;
              const partialChunkHeight = height % FULL_CHUNK_HEIGHT;
              const fullChunks = (height - partialChunkHeight) / FULL_CHUNK_HEIGHT;
              const totalChunks = partialChunkHeight === 0 ? fullChunks : fullChunks + 1;
              const chunkImgData = ctx.createImageData(width, FULL_CHUNK_HEIGHT);
              let srcPos = 0;
              const src = imgData.data;
              const dest = chunkImgData.data;
              for (let i2 = 0; i2 < totalChunks; i2++) {
                const thisChunkHeight = i2 < fullChunks ? FULL_CHUNK_HEIGHT : partialChunkHeight;
                ({
                  srcPos
                } = (0, _image_utils.convertBlackAndWhiteToRGBA)({
                  src,
                  srcPos,
                  dest,
                  width,
                  height: thisChunkHeight,
                  nonBlackColor: 0
                }));
                ctx.putImageData(chunkImgData, 0, i2 * FULL_CHUNK_HEIGHT);
              }
            }
            __name(putBinaryImageMask, "putBinaryImageMask");
            function copyCtxState(sourceCtx, destCtx) {
              const properties = ["strokeStyle", "fillStyle", "fillRule", "globalAlpha", "lineWidth", "lineCap", "lineJoin", "miterLimit", "globalCompositeOperation", "font", "filter"];
              for (const property of properties) {
                if (sourceCtx[property] !== void 0) {
                  destCtx[property] = sourceCtx[property];
                }
              }
              if (sourceCtx.setLineDash !== void 0) {
                destCtx.setLineDash(sourceCtx.getLineDash());
                destCtx.lineDashOffset = sourceCtx.lineDashOffset;
              }
            }
            __name(copyCtxState, "copyCtxState");
            function resetCtxToDefault(ctx) {
              ctx.strokeStyle = ctx.fillStyle = "#000000";
              ctx.fillRule = "nonzero";
              ctx.globalAlpha = 1;
              ctx.lineWidth = 1;
              ctx.lineCap = "butt";
              ctx.lineJoin = "miter";
              ctx.miterLimit = 10;
              ctx.globalCompositeOperation = "source-over";
              ctx.font = "10px sans-serif";
              if (ctx.setLineDash !== void 0) {
                ctx.setLineDash([]);
                ctx.lineDashOffset = 0;
              }
              if (!_util2.isNodeJS) {
                const {
                  filter
                } = ctx;
                if (filter !== "none" && filter !== "") {
                  ctx.filter = "none";
                }
              }
            }
            __name(resetCtxToDefault, "resetCtxToDefault");
            function composeSMaskBackdrop(bytes, r0, g0, b0) {
              const length = bytes.length;
              for (let i2 = 3; i2 < length; i2 += 4) {
                const alpha2 = bytes[i2];
                if (alpha2 === 0) {
                  bytes[i2 - 3] = r0;
                  bytes[i2 - 2] = g0;
                  bytes[i2 - 1] = b0;
                } else if (alpha2 < 255) {
                  const alpha_ = 255 - alpha2;
                  bytes[i2 - 3] = bytes[i2 - 3] * alpha2 + r0 * alpha_ >> 8;
                  bytes[i2 - 2] = bytes[i2 - 2] * alpha2 + g0 * alpha_ >> 8;
                  bytes[i2 - 1] = bytes[i2 - 1] * alpha2 + b0 * alpha_ >> 8;
                }
              }
            }
            __name(composeSMaskBackdrop, "composeSMaskBackdrop");
            function composeSMaskAlpha(maskData, layerData, transferMap) {
              const length = maskData.length;
              const scale = 1 / 255;
              for (let i2 = 3; i2 < length; i2 += 4) {
                const alpha2 = transferMap ? transferMap[maskData[i2]] : maskData[i2];
                layerData[i2] = layerData[i2] * alpha2 * scale | 0;
              }
            }
            __name(composeSMaskAlpha, "composeSMaskAlpha");
            function composeSMaskLuminosity(maskData, layerData, transferMap) {
              const length = maskData.length;
              for (let i2 = 3; i2 < length; i2 += 4) {
                const y2 = maskData[i2 - 3] * 77 + maskData[i2 - 2] * 152 + maskData[i2 - 1] * 28;
                layerData[i2] = transferMap ? layerData[i2] * transferMap[y2 >> 8] >> 8 : layerData[i2] * y2 >> 16;
              }
            }
            __name(composeSMaskLuminosity, "composeSMaskLuminosity");
            function genericComposeSMask(maskCtx, layerCtx, width, height, subtype, backdrop, transferMap, layerOffsetX, layerOffsetY, maskOffsetX, maskOffsetY) {
              const hasBackdrop = !!backdrop;
              const r0 = hasBackdrop ? backdrop[0] : 0;
              const g0 = hasBackdrop ? backdrop[1] : 0;
              const b0 = hasBackdrop ? backdrop[2] : 0;
              const composeFn = subtype === "Luminosity" ? composeSMaskLuminosity : composeSMaskAlpha;
              const PIXELS_TO_PROCESS = 1048576;
              const chunkSize = Math.min(height, Math.ceil(PIXELS_TO_PROCESS / width));
              for (let row = 0; row < height; row += chunkSize) {
                const chunkHeight = Math.min(chunkSize, height - row);
                const maskData = maskCtx.getImageData(layerOffsetX - maskOffsetX, row + (layerOffsetY - maskOffsetY), width, chunkHeight);
                const layerData = layerCtx.getImageData(layerOffsetX, row + layerOffsetY, width, chunkHeight);
                if (hasBackdrop) {
                  composeSMaskBackdrop(maskData.data, r0, g0, b0);
                }
                composeFn(maskData.data, layerData.data, transferMap);
                layerCtx.putImageData(layerData, layerOffsetX, row + layerOffsetY);
              }
            }
            __name(genericComposeSMask, "genericComposeSMask");
            function composeSMask(ctx, smask, layerCtx, layerBox) {
              const layerOffsetX = layerBox[0];
              const layerOffsetY = layerBox[1];
              const layerWidth = layerBox[2] - layerOffsetX;
              const layerHeight = layerBox[3] - layerOffsetY;
              if (layerWidth === 0 || layerHeight === 0) {
                return;
              }
              genericComposeSMask(smask.context, layerCtx, layerWidth, layerHeight, smask.subtype, smask.backdrop, smask.transferMap, layerOffsetX, layerOffsetY, smask.offsetX, smask.offsetY);
              ctx.save();
              ctx.globalAlpha = 1;
              ctx.globalCompositeOperation = "source-over";
              ctx.setTransform(1, 0, 0, 1, 0, 0);
              ctx.drawImage(layerCtx.canvas, 0, 0);
              ctx.restore();
            }
            __name(composeSMask, "composeSMask");
            function getImageSmoothingEnabled(transform, interpolate2) {
              const scale = _util2.Util.singularValueDecompose2dScale(transform);
              scale[0] = Math.fround(scale[0]);
              scale[1] = Math.fround(scale[1]);
              const actualScale = Math.fround((globalThis.devicePixelRatio || 1) * _display_utils2.PixelsPerInch.PDF_TO_CSS_UNITS);
              if (interpolate2 !== void 0) {
                return interpolate2;
              } else if (scale[0] <= actualScale || scale[1] <= actualScale) {
                return true;
              }
              return false;
            }
            __name(getImageSmoothingEnabled, "getImageSmoothingEnabled");
            const LINE_CAP_STYLES = ["butt", "round", "square"];
            const LINE_JOIN_STYLES = ["miter", "round", "bevel"];
            const NORMAL_CLIP = {};
            const EO_CLIP = {};
            const _CanvasGraphics = class _CanvasGraphics {
              constructor(canvasCtx, commonObjs, objs, canvasFactory, filterFactory, {
                optionalContentConfig,
                markedContentStack = null
              }, annotationCanvasMap, pageColors) {
                __privateAdd(this, _restoreInitialState);
                __privateAdd(this, _drawFilter);
                this.ctx = canvasCtx;
                this.current = new CanvasExtraState(this.ctx.canvas.width, this.ctx.canvas.height);
                this.stateStack = [];
                this.pendingClip = null;
                this.pendingEOFill = false;
                this.res = null;
                this.xobjs = null;
                this.commonObjs = commonObjs;
                this.objs = objs;
                this.canvasFactory = canvasFactory;
                this.filterFactory = filterFactory;
                this.groupStack = [];
                this.processingType3 = null;
                this.baseTransform = null;
                this.baseTransformStack = [];
                this.groupLevel = 0;
                this.smaskStack = [];
                this.smaskCounter = 0;
                this.tempSMask = null;
                this.suspendedCtx = null;
                this.contentVisible = true;
                this.markedContentStack = markedContentStack || [];
                this.optionalContentConfig = optionalContentConfig;
                this.cachedCanvases = new CachedCanvases(this.canvasFactory);
                this.cachedPatterns = /* @__PURE__ */ new Map();
                this.annotationCanvasMap = annotationCanvasMap;
                this.viewportScale = 1;
                this.outputScaleX = 1;
                this.outputScaleY = 1;
                this.pageColors = pageColors;
                this._cachedScaleForStroking = [-1, 0];
                this._cachedGetSinglePixelWidth = null;
                this._cachedBitmapsMap = /* @__PURE__ */ new Map();
              }
              getObject(data, fallback = null) {
                if (typeof data === "string") {
                  return data.startsWith("g_") ? this.commonObjs.get(data) : this.objs.get(data);
                }
                return fallback;
              }
              beginDrawing({
                transform,
                viewport,
                transparency = false,
                background = null
              }) {
                const width = this.ctx.canvas.width;
                const height = this.ctx.canvas.height;
                const savedFillStyle = this.ctx.fillStyle;
                this.ctx.fillStyle = background || "#ffffff";
                this.ctx.fillRect(0, 0, width, height);
                this.ctx.fillStyle = savedFillStyle;
                if (transparency) {
                  const transparentCanvas = this.cachedCanvases.getCanvas("transparent", width, height);
                  this.compositeCtx = this.ctx;
                  this.transparentCanvas = transparentCanvas.canvas;
                  this.ctx = transparentCanvas.context;
                  this.ctx.save();
                  this.ctx.transform(...(0, _display_utils2.getCurrentTransform)(this.compositeCtx));
                }
                this.ctx.save();
                resetCtxToDefault(this.ctx);
                if (transform) {
                  this.ctx.transform(...transform);
                  this.outputScaleX = transform[0];
                  this.outputScaleY = transform[0];
                }
                this.ctx.transform(...viewport.transform);
                this.viewportScale = viewport.scale;
                this.baseTransform = (0, _display_utils2.getCurrentTransform)(this.ctx);
              }
              executeOperatorList(operatorList, executionStartIdx, continueCallback, stepper) {
                const argsArray = operatorList.argsArray;
                const fnArray = operatorList.fnArray;
                let i2 = executionStartIdx || 0;
                const argsArrayLen = argsArray.length;
                if (argsArrayLen === i2) {
                  return i2;
                }
                const chunkOperations = argsArrayLen - i2 > EXECUTION_STEPS && typeof continueCallback === "function";
                const endTime = chunkOperations ? Date.now() + EXECUTION_TIME : 0;
                let steps2 = 0;
                const commonObjs = this.commonObjs;
                const objs = this.objs;
                let fnId;
                while (true) {
                  if (stepper !== void 0 && i2 === stepper.nextBreakPoint) {
                    stepper.breakIt(i2, continueCallback);
                    return i2;
                  }
                  fnId = fnArray[i2];
                  if (fnId !== _util2.OPS.dependency) {
                    this[fnId].apply(this, argsArray[i2]);
                  } else {
                    for (const depObjId of argsArray[i2]) {
                      const objsPool = depObjId.startsWith("g_") ? commonObjs : objs;
                      if (!objsPool.has(depObjId)) {
                        objsPool.get(depObjId, continueCallback);
                        return i2;
                      }
                    }
                  }
                  i2++;
                  if (i2 === argsArrayLen) {
                    return i2;
                  }
                  if (chunkOperations && ++steps2 > EXECUTION_STEPS) {
                    if (Date.now() > endTime) {
                      continueCallback();
                      return i2;
                    }
                    steps2 = 0;
                  }
                }
              }
              endDrawing() {
                __privateMethod(this, _restoreInitialState, restoreInitialState_fn).call(this);
                this.cachedCanvases.clear();
                this.cachedPatterns.clear();
                for (const cache of this._cachedBitmapsMap.values()) {
                  for (const canvas of cache.values()) {
                    if (typeof HTMLCanvasElement !== "undefined" && canvas instanceof HTMLCanvasElement) {
                      canvas.width = canvas.height = 0;
                    }
                  }
                  cache.clear();
                }
                this._cachedBitmapsMap.clear();
                __privateMethod(this, _drawFilter, drawFilter_fn).call(this);
              }
              _scaleImage(img, inverseTransform) {
                const width = img.width;
                const height = img.height;
                let widthScale = Math.max(Math.hypot(inverseTransform[0], inverseTransform[1]), 1);
                let heightScale = Math.max(Math.hypot(inverseTransform[2], inverseTransform[3]), 1);
                let paintWidth = width, paintHeight = height;
                let tmpCanvasId = "prescale1";
                let tmpCanvas, tmpCtx;
                while (widthScale > 2 && paintWidth > 1 || heightScale > 2 && paintHeight > 1) {
                  let newWidth = paintWidth, newHeight = paintHeight;
                  if (widthScale > 2 && paintWidth > 1) {
                    newWidth = paintWidth >= 16384 ? Math.floor(paintWidth / 2) - 1 || 1 : Math.ceil(paintWidth / 2);
                    widthScale /= paintWidth / newWidth;
                  }
                  if (heightScale > 2 && paintHeight > 1) {
                    newHeight = paintHeight >= 16384 ? Math.floor(paintHeight / 2) - 1 || 1 : Math.ceil(paintHeight) / 2;
                    heightScale /= paintHeight / newHeight;
                  }
                  tmpCanvas = this.cachedCanvases.getCanvas(tmpCanvasId, newWidth, newHeight);
                  tmpCtx = tmpCanvas.context;
                  tmpCtx.clearRect(0, 0, newWidth, newHeight);
                  tmpCtx.drawImage(img, 0, 0, paintWidth, paintHeight, 0, 0, newWidth, newHeight);
                  img = tmpCanvas.canvas;
                  paintWidth = newWidth;
                  paintHeight = newHeight;
                  tmpCanvasId = tmpCanvasId === "prescale1" ? "prescale2" : "prescale1";
                }
                return {
                  img,
                  paintWidth,
                  paintHeight
                };
              }
              _createMaskCanvas(img) {
                const ctx = this.ctx;
                const {
                  width,
                  height
                } = img;
                const fillColor = this.current.fillColor;
                const isPatternFill = this.current.patternFill;
                const currentTransform = (0, _display_utils2.getCurrentTransform)(ctx);
                let cache, cacheKey, scaled, maskCanvas;
                if ((img.bitmap || img.data) && img.count > 1) {
                  const mainKey = img.bitmap || img.data.buffer;
                  cacheKey = JSON.stringify(isPatternFill ? currentTransform : [currentTransform.slice(0, 4), fillColor]);
                  cache = this._cachedBitmapsMap.get(mainKey);
                  if (!cache) {
                    cache = /* @__PURE__ */ new Map();
                    this._cachedBitmapsMap.set(mainKey, cache);
                  }
                  const cachedImage = cache.get(cacheKey);
                  if (cachedImage && !isPatternFill) {
                    const offsetX2 = Math.round(Math.min(currentTransform[0], currentTransform[2]) + currentTransform[4]);
                    const offsetY2 = Math.round(Math.min(currentTransform[1], currentTransform[3]) + currentTransform[5]);
                    return {
                      canvas: cachedImage,
                      offsetX: offsetX2,
                      offsetY: offsetY2
                    };
                  }
                  scaled = cachedImage;
                }
                if (!scaled) {
                  maskCanvas = this.cachedCanvases.getCanvas("maskCanvas", width, height);
                  putBinaryImageMask(maskCanvas.context, img);
                }
                let maskToCanvas = _util2.Util.transform(currentTransform, [1 / width, 0, 0, -1 / height, 0, 0]);
                maskToCanvas = _util2.Util.transform(maskToCanvas, [1, 0, 0, 1, 0, -height]);
                const cord1 = _util2.Util.applyTransform([0, 0], maskToCanvas);
                const cord2 = _util2.Util.applyTransform([width, height], maskToCanvas);
                const rect = _util2.Util.normalizeRect([cord1[0], cord1[1], cord2[0], cord2[1]]);
                const drawnWidth = Math.round(rect[2] - rect[0]) || 1;
                const drawnHeight = Math.round(rect[3] - rect[1]) || 1;
                const fillCanvas = this.cachedCanvases.getCanvas("fillCanvas", drawnWidth, drawnHeight);
                const fillCtx = fillCanvas.context;
                const offsetX = Math.min(cord1[0], cord2[0]);
                const offsetY = Math.min(cord1[1], cord2[1]);
                fillCtx.translate(-offsetX, -offsetY);
                fillCtx.transform(...maskToCanvas);
                if (!scaled) {
                  scaled = this._scaleImage(maskCanvas.canvas, (0, _display_utils2.getCurrentTransformInverse)(fillCtx));
                  scaled = scaled.img;
                  if (cache && isPatternFill) {
                    cache.set(cacheKey, scaled);
                  }
                }
                fillCtx.imageSmoothingEnabled = getImageSmoothingEnabled((0, _display_utils2.getCurrentTransform)(fillCtx), img.interpolate);
                drawImageAtIntegerCoords(fillCtx, scaled, 0, 0, scaled.width, scaled.height, 0, 0, width, height);
                fillCtx.globalCompositeOperation = "source-in";
                const inverse = _util2.Util.transform((0, _display_utils2.getCurrentTransformInverse)(fillCtx), [1, 0, 0, 1, -offsetX, -offsetY]);
                fillCtx.fillStyle = isPatternFill ? fillColor.getPattern(ctx, this, inverse, _pattern_helper.PathType.FILL) : fillColor;
                fillCtx.fillRect(0, 0, width, height);
                if (cache && !isPatternFill) {
                  this.cachedCanvases.delete("fillCanvas");
                  cache.set(cacheKey, fillCanvas.canvas);
                }
                return {
                  canvas: fillCanvas.canvas,
                  offsetX: Math.round(offsetX),
                  offsetY: Math.round(offsetY)
                };
              }
              setLineWidth(width) {
                if (width !== this.current.lineWidth) {
                  this._cachedScaleForStroking[0] = -1;
                }
                this.current.lineWidth = width;
                this.ctx.lineWidth = width;
              }
              setLineCap(style) {
                this.ctx.lineCap = LINE_CAP_STYLES[style];
              }
              setLineJoin(style) {
                this.ctx.lineJoin = LINE_JOIN_STYLES[style];
              }
              setMiterLimit(limit) {
                this.ctx.miterLimit = limit;
              }
              setDash(dashArray, dashPhase) {
                const ctx = this.ctx;
                if (ctx.setLineDash !== void 0) {
                  ctx.setLineDash(dashArray);
                  ctx.lineDashOffset = dashPhase;
                }
              }
              setRenderingIntent(intent) {
              }
              setFlatness(flatness) {
              }
              setGState(states) {
                for (const [key, value] of states) {
                  switch (key) {
                    case "LW":
                      this.setLineWidth(value);
                      break;
                    case "LC":
                      this.setLineCap(value);
                      break;
                    case "LJ":
                      this.setLineJoin(value);
                      break;
                    case "ML":
                      this.setMiterLimit(value);
                      break;
                    case "D":
                      this.setDash(value[0], value[1]);
                      break;
                    case "RI":
                      this.setRenderingIntent(value);
                      break;
                    case "FL":
                      this.setFlatness(value);
                      break;
                    case "Font":
                      this.setFont(value[0], value[1]);
                      break;
                    case "CA":
                      this.current.strokeAlpha = value;
                      break;
                    case "ca":
                      this.current.fillAlpha = value;
                      this.ctx.globalAlpha = value;
                      break;
                    case "BM":
                      this.ctx.globalCompositeOperation = value;
                      break;
                    case "SMask":
                      this.current.activeSMask = value ? this.tempSMask : null;
                      this.tempSMask = null;
                      this.checkSMaskState();
                      break;
                    case "TR":
                      this.ctx.filter = this.current.transferMaps = this.filterFactory.addFilter(value);
                      break;
                  }
                }
              }
              get inSMaskMode() {
                return !!this.suspendedCtx;
              }
              checkSMaskState() {
                const inSMaskMode = this.inSMaskMode;
                if (this.current.activeSMask && !inSMaskMode) {
                  this.beginSMaskMode();
                } else if (!this.current.activeSMask && inSMaskMode) {
                  this.endSMaskMode();
                }
              }
              beginSMaskMode() {
                if (this.inSMaskMode) {
                  throw new Error("beginSMaskMode called while already in smask mode");
                }
                const drawnWidth = this.ctx.canvas.width;
                const drawnHeight = this.ctx.canvas.height;
                const cacheId = "smaskGroupAt" + this.groupLevel;
                const scratchCanvas = this.cachedCanvases.getCanvas(cacheId, drawnWidth, drawnHeight);
                this.suspendedCtx = this.ctx;
                this.ctx = scratchCanvas.context;
                const ctx = this.ctx;
                ctx.setTransform(...(0, _display_utils2.getCurrentTransform)(this.suspendedCtx));
                copyCtxState(this.suspendedCtx, ctx);
                mirrorContextOperations(ctx, this.suspendedCtx);
                this.setGState([["BM", "source-over"], ["ca", 1], ["CA", 1]]);
              }
              endSMaskMode() {
                if (!this.inSMaskMode) {
                  throw new Error("endSMaskMode called while not in smask mode");
                }
                this.ctx._removeMirroring();
                copyCtxState(this.ctx, this.suspendedCtx);
                this.ctx = this.suspendedCtx;
                this.suspendedCtx = null;
              }
              compose(dirtyBox) {
                if (!this.current.activeSMask) {
                  return;
                }
                if (!dirtyBox) {
                  dirtyBox = [0, 0, this.ctx.canvas.width, this.ctx.canvas.height];
                } else {
                  dirtyBox[0] = Math.floor(dirtyBox[0]);
                  dirtyBox[1] = Math.floor(dirtyBox[1]);
                  dirtyBox[2] = Math.ceil(dirtyBox[2]);
                  dirtyBox[3] = Math.ceil(dirtyBox[3]);
                }
                const smask = this.current.activeSMask;
                const suspendedCtx = this.suspendedCtx;
                composeSMask(suspendedCtx, smask, this.ctx, dirtyBox);
                this.ctx.save();
                this.ctx.setTransform(1, 0, 0, 1, 0, 0);
                this.ctx.clearRect(0, 0, this.ctx.canvas.width, this.ctx.canvas.height);
                this.ctx.restore();
              }
              save() {
                if (this.inSMaskMode) {
                  copyCtxState(this.ctx, this.suspendedCtx);
                  this.suspendedCtx.save();
                } else {
                  this.ctx.save();
                }
                const old = this.current;
                this.stateStack.push(old);
                this.current = old.clone();
              }
              restore() {
                if (this.stateStack.length === 0 && this.inSMaskMode) {
                  this.endSMaskMode();
                }
                if (this.stateStack.length !== 0) {
                  this.current = this.stateStack.pop();
                  if (this.inSMaskMode) {
                    this.suspendedCtx.restore();
                    copyCtxState(this.suspendedCtx, this.ctx);
                  } else {
                    this.ctx.restore();
                  }
                  this.checkSMaskState();
                  this.pendingClip = null;
                  this._cachedScaleForStroking[0] = -1;
                  this._cachedGetSinglePixelWidth = null;
                }
              }
              transform(a2, b2, c2, d2, e, f2) {
                this.ctx.transform(a2, b2, c2, d2, e, f2);
                this._cachedScaleForStroking[0] = -1;
                this._cachedGetSinglePixelWidth = null;
              }
              constructPath(ops, args, minMax) {
                const ctx = this.ctx;
                const current = this.current;
                let x2 = current.x, y2 = current.y;
                let startX, startY;
                const currentTransform = (0, _display_utils2.getCurrentTransform)(ctx);
                const isScalingMatrix = currentTransform[0] === 0 && currentTransform[3] === 0 || currentTransform[1] === 0 && currentTransform[2] === 0;
                const minMaxForBezier = isScalingMatrix ? minMax.slice(0) : null;
                for (let i2 = 0, j2 = 0, ii = ops.length; i2 < ii; i2++) {
                  switch (ops[i2] | 0) {
                    case _util2.OPS.rectangle:
                      x2 = args[j2++];
                      y2 = args[j2++];
                      const width = args[j2++];
                      const height = args[j2++];
                      const xw = x2 + width;
                      const yh = y2 + height;
                      ctx.moveTo(x2, y2);
                      if (width === 0 || height === 0) {
                        ctx.lineTo(xw, yh);
                      } else {
                        ctx.lineTo(xw, y2);
                        ctx.lineTo(xw, yh);
                        ctx.lineTo(x2, yh);
                      }
                      if (!isScalingMatrix) {
                        current.updateRectMinMax(currentTransform, [x2, y2, xw, yh]);
                      }
                      ctx.closePath();
                      break;
                    case _util2.OPS.moveTo:
                      x2 = args[j2++];
                      y2 = args[j2++];
                      ctx.moveTo(x2, y2);
                      if (!isScalingMatrix) {
                        current.updatePathMinMax(currentTransform, x2, y2);
                      }
                      break;
                    case _util2.OPS.lineTo:
                      x2 = args[j2++];
                      y2 = args[j2++];
                      ctx.lineTo(x2, y2);
                      if (!isScalingMatrix) {
                        current.updatePathMinMax(currentTransform, x2, y2);
                      }
                      break;
                    case _util2.OPS.curveTo:
                      startX = x2;
                      startY = y2;
                      x2 = args[j2 + 4];
                      y2 = args[j2 + 5];
                      ctx.bezierCurveTo(args[j2], args[j2 + 1], args[j2 + 2], args[j2 + 3], x2, y2);
                      current.updateCurvePathMinMax(currentTransform, startX, startY, args[j2], args[j2 + 1], args[j2 + 2], args[j2 + 3], x2, y2, minMaxForBezier);
                      j2 += 6;
                      break;
                    case _util2.OPS.curveTo2:
                      startX = x2;
                      startY = y2;
                      ctx.bezierCurveTo(x2, y2, args[j2], args[j2 + 1], args[j2 + 2], args[j2 + 3]);
                      current.updateCurvePathMinMax(currentTransform, startX, startY, x2, y2, args[j2], args[j2 + 1], args[j2 + 2], args[j2 + 3], minMaxForBezier);
                      x2 = args[j2 + 2];
                      y2 = args[j2 + 3];
                      j2 += 4;
                      break;
                    case _util2.OPS.curveTo3:
                      startX = x2;
                      startY = y2;
                      x2 = args[j2 + 2];
                      y2 = args[j2 + 3];
                      ctx.bezierCurveTo(args[j2], args[j2 + 1], x2, y2, x2, y2);
                      current.updateCurvePathMinMax(currentTransform, startX, startY, args[j2], args[j2 + 1], x2, y2, x2, y2, minMaxForBezier);
                      j2 += 4;
                      break;
                    case _util2.OPS.closePath:
                      ctx.closePath();
                      break;
                  }
                }
                if (isScalingMatrix) {
                  current.updateScalingPathMinMax(currentTransform, minMaxForBezier);
                }
                current.setCurrentPoint(x2, y2);
              }
              closePath() {
                this.ctx.closePath();
              }
              stroke(consumePath = true) {
                const ctx = this.ctx;
                const strokeColor = this.current.strokeColor;
                ctx.globalAlpha = this.current.strokeAlpha;
                if (this.contentVisible) {
                  if (typeof strokeColor === "object" && (strokeColor == null ? void 0 : strokeColor.getPattern)) {
                    ctx.save();
                    ctx.strokeStyle = strokeColor.getPattern(ctx, this, (0, _display_utils2.getCurrentTransformInverse)(ctx), _pattern_helper.PathType.STROKE);
                    this.rescaleAndStroke(false);
                    ctx.restore();
                  } else {
                    this.rescaleAndStroke(true);
                  }
                }
                if (consumePath) {
                  this.consumePath(this.current.getClippedPathBoundingBox());
                }
                ctx.globalAlpha = this.current.fillAlpha;
              }
              closeStroke() {
                this.closePath();
                this.stroke();
              }
              fill(consumePath = true) {
                const ctx = this.ctx;
                const fillColor = this.current.fillColor;
                const isPatternFill = this.current.patternFill;
                let needRestore = false;
                if (isPatternFill) {
                  ctx.save();
                  ctx.fillStyle = fillColor.getPattern(ctx, this, (0, _display_utils2.getCurrentTransformInverse)(ctx), _pattern_helper.PathType.FILL);
                  needRestore = true;
                }
                const intersect = this.current.getClippedPathBoundingBox();
                if (this.contentVisible && intersect !== null) {
                  if (this.pendingEOFill) {
                    ctx.fill("evenodd");
                    this.pendingEOFill = false;
                  } else {
                    ctx.fill();
                  }
                }
                if (needRestore) {
                  ctx.restore();
                }
                if (consumePath) {
                  this.consumePath(intersect);
                }
              }
              eoFill() {
                this.pendingEOFill = true;
                this.fill();
              }
              fillStroke() {
                this.fill(false);
                this.stroke(false);
                this.consumePath();
              }
              eoFillStroke() {
                this.pendingEOFill = true;
                this.fillStroke();
              }
              closeFillStroke() {
                this.closePath();
                this.fillStroke();
              }
              closeEOFillStroke() {
                this.pendingEOFill = true;
                this.closePath();
                this.fillStroke();
              }
              endPath() {
                this.consumePath();
              }
              clip() {
                this.pendingClip = NORMAL_CLIP;
              }
              eoClip() {
                this.pendingClip = EO_CLIP;
              }
              beginText() {
                this.current.textMatrix = _util2.IDENTITY_MATRIX;
                this.current.textMatrixScale = 1;
                this.current.x = this.current.lineX = 0;
                this.current.y = this.current.lineY = 0;
              }
              endText() {
                const paths = this.pendingTextPaths;
                const ctx = this.ctx;
                if (paths === void 0) {
                  ctx.beginPath();
                  return;
                }
                ctx.save();
                ctx.beginPath();
                for (const path of paths) {
                  ctx.setTransform(...path.transform);
                  ctx.translate(path.x, path.y);
                  path.addToPath(ctx, path.fontSize);
                }
                ctx.restore();
                ctx.clip();
                ctx.beginPath();
                delete this.pendingTextPaths;
              }
              setCharSpacing(spacing) {
                this.current.charSpacing = spacing;
              }
              setWordSpacing(spacing) {
                this.current.wordSpacing = spacing;
              }
              setHScale(scale) {
                this.current.textHScale = scale / 100;
              }
              setLeading(leading) {
                this.current.leading = -leading;
              }
              setFont(fontRefName, size) {
                var _a3;
                const fontObj = this.commonObjs.get(fontRefName);
                const current = this.current;
                if (!fontObj) {
                  throw new Error(`Can't find font for ${fontRefName}`);
                }
                current.fontMatrix = fontObj.fontMatrix || _util2.FONT_IDENTITY_MATRIX;
                if (current.fontMatrix[0] === 0 || current.fontMatrix[3] === 0) {
                  (0, _util2.warn)("Invalid font matrix for font " + fontRefName);
                }
                if (size < 0) {
                  size = -size;
                  current.fontDirection = -1;
                } else {
                  current.fontDirection = 1;
                }
                this.current.font = fontObj;
                this.current.fontSize = size;
                if (fontObj.isType3Font) {
                  return;
                }
                const name = fontObj.loadedName || "sans-serif";
                const typeface = ((_a3 = fontObj.systemFontInfo) == null ? void 0 : _a3.css) || `"${name}", ${fontObj.fallbackName}`;
                let bold = "normal";
                if (fontObj.black) {
                  bold = "900";
                } else if (fontObj.bold) {
                  bold = "bold";
                }
                const italic = fontObj.italic ? "italic" : "normal";
                let browserFontSize = size;
                if (size < MIN_FONT_SIZE) {
                  browserFontSize = MIN_FONT_SIZE;
                } else if (size > MAX_FONT_SIZE) {
                  browserFontSize = MAX_FONT_SIZE;
                }
                this.current.fontSizeScale = size / browserFontSize;
                this.ctx.font = `${italic} ${bold} ${browserFontSize}px ${typeface}`;
              }
              setTextRenderingMode(mode) {
                this.current.textRenderingMode = mode;
              }
              setTextRise(rise) {
                this.current.textRise = rise;
              }
              moveText(x2, y2) {
                this.current.x = this.current.lineX += x2;
                this.current.y = this.current.lineY += y2;
              }
              setLeadingMoveText(x2, y2) {
                this.setLeading(-y2);
                this.moveText(x2, y2);
              }
              setTextMatrix(a2, b2, c2, d2, e, f2) {
                this.current.textMatrix = [a2, b2, c2, d2, e, f2];
                this.current.textMatrixScale = Math.hypot(a2, b2);
                this.current.x = this.current.lineX = 0;
                this.current.y = this.current.lineY = 0;
              }
              nextLine() {
                this.moveText(0, this.current.leading);
              }
              paintChar(character, x2, y2, patternTransform) {
                const ctx = this.ctx;
                const current = this.current;
                const font = current.font;
                const textRenderingMode = current.textRenderingMode;
                const fontSize = current.fontSize / current.fontSizeScale;
                const fillStrokeMode = textRenderingMode & _util2.TextRenderingMode.FILL_STROKE_MASK;
                const isAddToPathSet = !!(textRenderingMode & _util2.TextRenderingMode.ADD_TO_PATH_FLAG);
                const patternFill = current.patternFill && !font.missingFile;
                let addToPath;
                if (font.disableFontFace || isAddToPathSet || patternFill) {
                  addToPath = font.getPathGenerator(this.commonObjs, character);
                }
                if (font.disableFontFace || patternFill) {
                  ctx.save();
                  ctx.translate(x2, y2);
                  ctx.beginPath();
                  addToPath(ctx, fontSize);
                  if (patternTransform) {
                    ctx.setTransform(...patternTransform);
                  }
                  if (fillStrokeMode === _util2.TextRenderingMode.FILL || fillStrokeMode === _util2.TextRenderingMode.FILL_STROKE) {
                    ctx.fill();
                  }
                  if (fillStrokeMode === _util2.TextRenderingMode.STROKE || fillStrokeMode === _util2.TextRenderingMode.FILL_STROKE) {
                    ctx.stroke();
                  }
                  ctx.restore();
                } else {
                  if (fillStrokeMode === _util2.TextRenderingMode.FILL || fillStrokeMode === _util2.TextRenderingMode.FILL_STROKE) {
                    ctx.fillText(character, x2, y2);
                  }
                  if (fillStrokeMode === _util2.TextRenderingMode.STROKE || fillStrokeMode === _util2.TextRenderingMode.FILL_STROKE) {
                    ctx.strokeText(character, x2, y2);
                  }
                }
                if (isAddToPathSet) {
                  const paths = this.pendingTextPaths || (this.pendingTextPaths = []);
                  paths.push({
                    transform: (0, _display_utils2.getCurrentTransform)(ctx),
                    x: x2,
                    y: y2,
                    fontSize,
                    addToPath
                  });
                }
              }
              get isFontSubpixelAAEnabled() {
                const {
                  context: ctx
                } = this.cachedCanvases.getCanvas("isFontSubpixelAAEnabled", 10, 10);
                ctx.scale(1.5, 1);
                ctx.fillText("I", 0, 10);
                const data = ctx.getImageData(0, 0, 10, 10).data;
                let enabled = false;
                for (let i2 = 3; i2 < data.length; i2 += 4) {
                  if (data[i2] > 0 && data[i2] < 255) {
                    enabled = true;
                    break;
                  }
                }
                return (0, _util2.shadow)(this, "isFontSubpixelAAEnabled", enabled);
              }
              showText(glyphs) {
                const current = this.current;
                const font = current.font;
                if (font.isType3Font) {
                  return this.showType3Text(glyphs);
                }
                const fontSize = current.fontSize;
                if (fontSize === 0) {
                  return void 0;
                }
                const ctx = this.ctx;
                const fontSizeScale = current.fontSizeScale;
                const charSpacing = current.charSpacing;
                const wordSpacing = current.wordSpacing;
                const fontDirection = current.fontDirection;
                const textHScale = current.textHScale * fontDirection;
                const glyphsLength = glyphs.length;
                const vertical = font.vertical;
                const spacingDir = vertical ? 1 : -1;
                const defaultVMetrics = font.defaultVMetrics;
                const widthAdvanceScale = fontSize * current.fontMatrix[0];
                const simpleFillText = current.textRenderingMode === _util2.TextRenderingMode.FILL && !font.disableFontFace && !current.patternFill;
                ctx.save();
                ctx.transform(...current.textMatrix);
                ctx.translate(current.x, current.y + current.textRise);
                if (fontDirection > 0) {
                  ctx.scale(textHScale, -1);
                } else {
                  ctx.scale(textHScale, 1);
                }
                let patternTransform;
                if (current.patternFill) {
                  ctx.save();
                  const pattern = current.fillColor.getPattern(ctx, this, (0, _display_utils2.getCurrentTransformInverse)(ctx), _pattern_helper.PathType.FILL);
                  patternTransform = (0, _display_utils2.getCurrentTransform)(ctx);
                  ctx.restore();
                  ctx.fillStyle = pattern;
                }
                let lineWidth = current.lineWidth;
                const scale = current.textMatrixScale;
                if (scale === 0 || lineWidth === 0) {
                  const fillStrokeMode = current.textRenderingMode & _util2.TextRenderingMode.FILL_STROKE_MASK;
                  if (fillStrokeMode === _util2.TextRenderingMode.STROKE || fillStrokeMode === _util2.TextRenderingMode.FILL_STROKE) {
                    lineWidth = this.getSinglePixelWidth();
                  }
                } else {
                  lineWidth /= scale;
                }
                if (fontSizeScale !== 1) {
                  ctx.scale(fontSizeScale, fontSizeScale);
                  lineWidth /= fontSizeScale;
                }
                ctx.lineWidth = lineWidth;
                if (font.isInvalidPDFjsFont) {
                  const chars = [];
                  let width = 0;
                  for (const glyph of glyphs) {
                    chars.push(glyph.unicode);
                    width += glyph.width;
                  }
                  ctx.fillText(chars.join(""), 0, 0);
                  current.x += width * widthAdvanceScale * textHScale;
                  ctx.restore();
                  this.compose();
                  return void 0;
                }
                let x2 = 0, i2;
                for (i2 = 0; i2 < glyphsLength; ++i2) {
                  const glyph = glyphs[i2];
                  if (typeof glyph === "number") {
                    x2 += spacingDir * glyph * fontSize / 1e3;
                    continue;
                  }
                  let restoreNeeded = false;
                  const spacing = (glyph.isSpace ? wordSpacing : 0) + charSpacing;
                  const character = glyph.fontChar;
                  const accent = glyph.accent;
                  let scaledX, scaledY;
                  let width = glyph.width;
                  if (vertical) {
                    const vmetric = glyph.vmetric || defaultVMetrics;
                    const vx = -(glyph.vmetric ? vmetric[1] : width * 0.5) * widthAdvanceScale;
                    const vy = vmetric[2] * widthAdvanceScale;
                    width = vmetric ? -vmetric[0] : width;
                    scaledX = vx / fontSizeScale;
                    scaledY = (x2 + vy) / fontSizeScale;
                  } else {
                    scaledX = x2 / fontSizeScale;
                    scaledY = 0;
                  }
                  if (font.remeasure && width > 0) {
                    const measuredWidth = ctx.measureText(character).width * 1e3 / fontSize * fontSizeScale;
                    if (width < measuredWidth && this.isFontSubpixelAAEnabled) {
                      const characterScaleX = width / measuredWidth;
                      restoreNeeded = true;
                      ctx.save();
                      ctx.scale(characterScaleX, 1);
                      scaledX /= characterScaleX;
                    } else if (width !== measuredWidth) {
                      scaledX += (width - measuredWidth) / 2e3 * fontSize / fontSizeScale;
                    }
                  }
                  if (this.contentVisible && (glyph.isInFont || font.missingFile)) {
                    if (simpleFillText && !accent) {
                      ctx.fillText(character, scaledX, scaledY);
                    } else {
                      this.paintChar(character, scaledX, scaledY, patternTransform);
                      if (accent) {
                        const scaledAccentX = scaledX + fontSize * accent.offset.x / fontSizeScale;
                        const scaledAccentY = scaledY - fontSize * accent.offset.y / fontSizeScale;
                        this.paintChar(accent.fontChar, scaledAccentX, scaledAccentY, patternTransform);
                      }
                    }
                  }
                  const charWidth = vertical ? width * widthAdvanceScale - spacing * fontDirection : width * widthAdvanceScale + spacing * fontDirection;
                  x2 += charWidth;
                  if (restoreNeeded) {
                    ctx.restore();
                  }
                }
                if (vertical) {
                  current.y -= x2;
                } else {
                  current.x += x2 * textHScale;
                }
                ctx.restore();
                this.compose();
                return void 0;
              }
              showType3Text(glyphs) {
                const ctx = this.ctx;
                const current = this.current;
                const font = current.font;
                const fontSize = current.fontSize;
                const fontDirection = current.fontDirection;
                const spacingDir = font.vertical ? 1 : -1;
                const charSpacing = current.charSpacing;
                const wordSpacing = current.wordSpacing;
                const textHScale = current.textHScale * fontDirection;
                const fontMatrix = current.fontMatrix || _util2.FONT_IDENTITY_MATRIX;
                const glyphsLength = glyphs.length;
                const isTextInvisible = current.textRenderingMode === _util2.TextRenderingMode.INVISIBLE;
                let i2, glyph, width, spacingLength;
                if (isTextInvisible || fontSize === 0) {
                  return;
                }
                this._cachedScaleForStroking[0] = -1;
                this._cachedGetSinglePixelWidth = null;
                ctx.save();
                ctx.transform(...current.textMatrix);
                ctx.translate(current.x, current.y);
                ctx.scale(textHScale, fontDirection);
                for (i2 = 0; i2 < glyphsLength; ++i2) {
                  glyph = glyphs[i2];
                  if (typeof glyph === "number") {
                    spacingLength = spacingDir * glyph * fontSize / 1e3;
                    this.ctx.translate(spacingLength, 0);
                    current.x += spacingLength * textHScale;
                    continue;
                  }
                  const spacing = (glyph.isSpace ? wordSpacing : 0) + charSpacing;
                  const operatorList = font.charProcOperatorList[glyph.operatorListId];
                  if (!operatorList) {
                    (0, _util2.warn)(`Type3 character "${glyph.operatorListId}" is not available.`);
                    continue;
                  }
                  if (this.contentVisible) {
                    this.processingType3 = glyph;
                    this.save();
                    ctx.scale(fontSize, fontSize);
                    ctx.transform(...fontMatrix);
                    this.executeOperatorList(operatorList);
                    this.restore();
                  }
                  const transformed = _util2.Util.applyTransform([glyph.width, 0], fontMatrix);
                  width = transformed[0] * fontSize + spacing;
                  ctx.translate(width, 0);
                  current.x += width * textHScale;
                }
                ctx.restore();
                this.processingType3 = null;
              }
              setCharWidth(xWidth, yWidth) {
              }
              setCharWidthAndBounds(xWidth, yWidth, llx, lly, urx, ury) {
                this.ctx.rect(llx, lly, urx - llx, ury - lly);
                this.ctx.clip();
                this.endPath();
              }
              getColorN_Pattern(IR) {
                let pattern;
                if (IR[0] === "TilingPattern") {
                  const color2 = IR[1];
                  const baseTransform = this.baseTransform || (0, _display_utils2.getCurrentTransform)(this.ctx);
                  const canvasGraphicsFactory = {
                    createCanvasGraphics: (ctx) => {
                      return new _CanvasGraphics(ctx, this.commonObjs, this.objs, this.canvasFactory, this.filterFactory, {
                        optionalContentConfig: this.optionalContentConfig,
                        markedContentStack: this.markedContentStack
                      });
                    }
                  };
                  pattern = new _pattern_helper.TilingPattern(IR, color2, this.ctx, canvasGraphicsFactory, baseTransform);
                } else {
                  pattern = this._getPattern(IR[1], IR[2]);
                }
                return pattern;
              }
              setStrokeColorN() {
                this.current.strokeColor = this.getColorN_Pattern(arguments);
              }
              setFillColorN() {
                this.current.fillColor = this.getColorN_Pattern(arguments);
                this.current.patternFill = true;
              }
              setStrokeRGBColor(r, g2, b2) {
                const color2 = _util2.Util.makeHexColor(r, g2, b2);
                this.ctx.strokeStyle = color2;
                this.current.strokeColor = color2;
              }
              setFillRGBColor(r, g2, b2) {
                const color2 = _util2.Util.makeHexColor(r, g2, b2);
                this.ctx.fillStyle = color2;
                this.current.fillColor = color2;
                this.current.patternFill = false;
              }
              _getPattern(objId, matrix = null) {
                let pattern;
                if (this.cachedPatterns.has(objId)) {
                  pattern = this.cachedPatterns.get(objId);
                } else {
                  pattern = (0, _pattern_helper.getShadingPattern)(this.getObject(objId));
                  this.cachedPatterns.set(objId, pattern);
                }
                if (matrix) {
                  pattern.matrix = matrix;
                }
                return pattern;
              }
              shadingFill(objId) {
                if (!this.contentVisible) {
                  return;
                }
                const ctx = this.ctx;
                this.save();
                const pattern = this._getPattern(objId);
                ctx.fillStyle = pattern.getPattern(ctx, this, (0, _display_utils2.getCurrentTransformInverse)(ctx), _pattern_helper.PathType.SHADING);
                const inv = (0, _display_utils2.getCurrentTransformInverse)(ctx);
                if (inv) {
                  const {
                    width,
                    height
                  } = ctx.canvas;
                  const [x0, y0, x1, y1] = _util2.Util.getAxialAlignedBoundingBox([0, 0, width, height], inv);
                  this.ctx.fillRect(x0, y0, x1 - x0, y1 - y0);
                } else {
                  this.ctx.fillRect(-1e10, -1e10, 2e10, 2e10);
                }
                this.compose(this.current.getClippedPathBoundingBox());
                this.restore();
              }
              beginInlineImage() {
                (0, _util2.unreachable)("Should not call beginInlineImage");
              }
              beginImageData() {
                (0, _util2.unreachable)("Should not call beginImageData");
              }
              paintFormXObjectBegin(matrix, bbox) {
                if (!this.contentVisible) {
                  return;
                }
                this.save();
                this.baseTransformStack.push(this.baseTransform);
                if (Array.isArray(matrix) && matrix.length === 6) {
                  this.transform(...matrix);
                }
                this.baseTransform = (0, _display_utils2.getCurrentTransform)(this.ctx);
                if (bbox) {
                  const width = bbox[2] - bbox[0];
                  const height = bbox[3] - bbox[1];
                  this.ctx.rect(bbox[0], bbox[1], width, height);
                  this.current.updateRectMinMax((0, _display_utils2.getCurrentTransform)(this.ctx), bbox);
                  this.clip();
                  this.endPath();
                }
              }
              paintFormXObjectEnd() {
                if (!this.contentVisible) {
                  return;
                }
                this.restore();
                this.baseTransform = this.baseTransformStack.pop();
              }
              beginGroup(group) {
                if (!this.contentVisible) {
                  return;
                }
                this.save();
                if (this.inSMaskMode) {
                  this.endSMaskMode();
                  this.current.activeSMask = null;
                }
                const currentCtx = this.ctx;
                if (!group.isolated) {
                  (0, _util2.info)("TODO: Support non-isolated groups.");
                }
                if (group.knockout) {
                  (0, _util2.warn)("Knockout groups not supported.");
                }
                const currentTransform = (0, _display_utils2.getCurrentTransform)(currentCtx);
                if (group.matrix) {
                  currentCtx.transform(...group.matrix);
                }
                if (!group.bbox) {
                  throw new Error("Bounding box is required.");
                }
                let bounds = _util2.Util.getAxialAlignedBoundingBox(group.bbox, (0, _display_utils2.getCurrentTransform)(currentCtx));
                const canvasBounds = [0, 0, currentCtx.canvas.width, currentCtx.canvas.height];
                bounds = _util2.Util.intersect(bounds, canvasBounds) || [0, 0, 0, 0];
                const offsetX = Math.floor(bounds[0]);
                const offsetY = Math.floor(bounds[1]);
                let drawnWidth = Math.max(Math.ceil(bounds[2]) - offsetX, 1);
                let drawnHeight = Math.max(Math.ceil(bounds[3]) - offsetY, 1);
                let scaleX = 1, scaleY = 1;
                if (drawnWidth > MAX_GROUP_SIZE) {
                  scaleX = drawnWidth / MAX_GROUP_SIZE;
                  drawnWidth = MAX_GROUP_SIZE;
                }
                if (drawnHeight > MAX_GROUP_SIZE) {
                  scaleY = drawnHeight / MAX_GROUP_SIZE;
                  drawnHeight = MAX_GROUP_SIZE;
                }
                this.current.startNewPathAndClipBox([0, 0, drawnWidth, drawnHeight]);
                let cacheId = "groupAt" + this.groupLevel;
                if (group.smask) {
                  cacheId += "_smask_" + this.smaskCounter++ % 2;
                }
                const scratchCanvas = this.cachedCanvases.getCanvas(cacheId, drawnWidth, drawnHeight);
                const groupCtx = scratchCanvas.context;
                groupCtx.scale(1 / scaleX, 1 / scaleY);
                groupCtx.translate(-offsetX, -offsetY);
                groupCtx.transform(...currentTransform);
                if (group.smask) {
                  this.smaskStack.push({
                    canvas: scratchCanvas.canvas,
                    context: groupCtx,
                    offsetX,
                    offsetY,
                    scaleX,
                    scaleY,
                    subtype: group.smask.subtype,
                    backdrop: group.smask.backdrop,
                    transferMap: group.smask.transferMap || null,
                    startTransformInverse: null
                  });
                } else {
                  currentCtx.setTransform(1, 0, 0, 1, 0, 0);
                  currentCtx.translate(offsetX, offsetY);
                  currentCtx.scale(scaleX, scaleY);
                  currentCtx.save();
                }
                copyCtxState(currentCtx, groupCtx);
                this.ctx = groupCtx;
                this.setGState([["BM", "source-over"], ["ca", 1], ["CA", 1]]);
                this.groupStack.push(currentCtx);
                this.groupLevel++;
              }
              endGroup(group) {
                if (!this.contentVisible) {
                  return;
                }
                this.groupLevel--;
                const groupCtx = this.ctx;
                const ctx = this.groupStack.pop();
                this.ctx = ctx;
                this.ctx.imageSmoothingEnabled = false;
                if (group.smask) {
                  this.tempSMask = this.smaskStack.pop();
                  this.restore();
                } else {
                  this.ctx.restore();
                  const currentMtx = (0, _display_utils2.getCurrentTransform)(this.ctx);
                  this.restore();
                  this.ctx.save();
                  this.ctx.setTransform(...currentMtx);
                  const dirtyBox = _util2.Util.getAxialAlignedBoundingBox([0, 0, groupCtx.canvas.width, groupCtx.canvas.height], currentMtx);
                  this.ctx.drawImage(groupCtx.canvas, 0, 0);
                  this.ctx.restore();
                  this.compose(dirtyBox);
                }
              }
              beginAnnotation(id, rect, transform, matrix, hasOwnCanvas) {
                __privateMethod(this, _restoreInitialState, restoreInitialState_fn).call(this);
                resetCtxToDefault(this.ctx);
                this.ctx.save();
                this.save();
                if (this.baseTransform) {
                  this.ctx.setTransform(...this.baseTransform);
                }
                if (Array.isArray(rect) && rect.length === 4) {
                  const width = rect[2] - rect[0];
                  const height = rect[3] - rect[1];
                  if (hasOwnCanvas && this.annotationCanvasMap) {
                    transform = transform.slice();
                    transform[4] -= rect[0];
                    transform[5] -= rect[1];
                    rect = rect.slice();
                    rect[0] = rect[1] = 0;
                    rect[2] = width;
                    rect[3] = height;
                    const [scaleX, scaleY] = _util2.Util.singularValueDecompose2dScale((0, _display_utils2.getCurrentTransform)(this.ctx));
                    const {
                      viewportScale
                    } = this;
                    const canvasWidth = Math.ceil(width * this.outputScaleX * viewportScale);
                    const canvasHeight = Math.ceil(height * this.outputScaleY * viewportScale);
                    this.annotationCanvas = this.canvasFactory.create(canvasWidth, canvasHeight);
                    const {
                      canvas,
                      context
                    } = this.annotationCanvas;
                    this.annotationCanvasMap.set(id, canvas);
                    this.annotationCanvas.savedCtx = this.ctx;
                    this.ctx = context;
                    this.ctx.save();
                    this.ctx.setTransform(scaleX, 0, 0, -scaleY, 0, height * scaleY);
                    resetCtxToDefault(this.ctx);
                  } else {
                    resetCtxToDefault(this.ctx);
                    this.ctx.rect(rect[0], rect[1], width, height);
                    this.ctx.clip();
                    this.endPath();
                  }
                }
                this.current = new CanvasExtraState(this.ctx.canvas.width, this.ctx.canvas.height);
                this.transform(...transform);
                this.transform(...matrix);
              }
              endAnnotation() {
                if (this.annotationCanvas) {
                  this.ctx.restore();
                  __privateMethod(this, _drawFilter, drawFilter_fn).call(this);
                  this.ctx = this.annotationCanvas.savedCtx;
                  delete this.annotationCanvas.savedCtx;
                  delete this.annotationCanvas;
                }
              }
              paintImageMaskXObject(img) {
                if (!this.contentVisible) {
                  return;
                }
                const count = img.count;
                img = this.getObject(img.data, img);
                img.count = count;
                const ctx = this.ctx;
                const glyph = this.processingType3;
                if (glyph) {
                  if (glyph.compiled === void 0) {
                    glyph.compiled = compileType3Glyph(img);
                  }
                  if (glyph.compiled) {
                    glyph.compiled(ctx);
                    return;
                  }
                }
                const mask = this._createMaskCanvas(img);
                const maskCanvas = mask.canvas;
                ctx.save();
                ctx.setTransform(1, 0, 0, 1, 0, 0);
                ctx.drawImage(maskCanvas, mask.offsetX, mask.offsetY);
                ctx.restore();
                this.compose();
              }
              paintImageMaskXObjectRepeat(img, scaleX, skewX = 0, skewY = 0, scaleY, positions2) {
                if (!this.contentVisible) {
                  return;
                }
                img = this.getObject(img.data, img);
                const ctx = this.ctx;
                ctx.save();
                const currentTransform = (0, _display_utils2.getCurrentTransform)(ctx);
                ctx.transform(scaleX, skewX, skewY, scaleY, 0, 0);
                const mask = this._createMaskCanvas(img);
                ctx.setTransform(1, 0, 0, 1, mask.offsetX - currentTransform[4], mask.offsetY - currentTransform[5]);
                for (let i2 = 0, ii = positions2.length; i2 < ii; i2 += 2) {
                  const trans = _util2.Util.transform(currentTransform, [scaleX, skewX, skewY, scaleY, positions2[i2], positions2[i2 + 1]]);
                  const [x2, y2] = _util2.Util.applyTransform([0, 0], trans);
                  ctx.drawImage(mask.canvas, x2, y2);
                }
                ctx.restore();
                this.compose();
              }
              paintImageMaskXObjectGroup(images) {
                if (!this.contentVisible) {
                  return;
                }
                const ctx = this.ctx;
                const fillColor = this.current.fillColor;
                const isPatternFill = this.current.patternFill;
                for (const image of images) {
                  const {
                    data,
                    width,
                    height,
                    transform
                  } = image;
                  const maskCanvas = this.cachedCanvases.getCanvas("maskCanvas", width, height);
                  const maskCtx = maskCanvas.context;
                  maskCtx.save();
                  const img = this.getObject(data, image);
                  putBinaryImageMask(maskCtx, img);
                  maskCtx.globalCompositeOperation = "source-in";
                  maskCtx.fillStyle = isPatternFill ? fillColor.getPattern(maskCtx, this, (0, _display_utils2.getCurrentTransformInverse)(ctx), _pattern_helper.PathType.FILL) : fillColor;
                  maskCtx.fillRect(0, 0, width, height);
                  maskCtx.restore();
                  ctx.save();
                  ctx.transform(...transform);
                  ctx.scale(1, -1);
                  drawImageAtIntegerCoords(ctx, maskCanvas.canvas, 0, 0, width, height, 0, -1, 1, 1);
                  ctx.restore();
                }
                this.compose();
              }
              paintImageXObject(objId) {
                if (!this.contentVisible) {
                  return;
                }
                const imgData = this.getObject(objId);
                if (!imgData) {
                  (0, _util2.warn)("Dependent image isn't ready yet");
                  return;
                }
                this.paintInlineImageXObject(imgData);
              }
              paintImageXObjectRepeat(objId, scaleX, scaleY, positions2) {
                if (!this.contentVisible) {
                  return;
                }
                const imgData = this.getObject(objId);
                if (!imgData) {
                  (0, _util2.warn)("Dependent image isn't ready yet");
                  return;
                }
                const width = imgData.width;
                const height = imgData.height;
                const map2 = [];
                for (let i2 = 0, ii = positions2.length; i2 < ii; i2 += 2) {
                  map2.push({
                    transform: [scaleX, 0, 0, scaleY, positions2[i2], positions2[i2 + 1]],
                    x: 0,
                    y: 0,
                    w: width,
                    h: height
                  });
                }
                this.paintInlineImageXObjectGroup(imgData, map2);
              }
              applyTransferMapsToCanvas(ctx) {
                if (this.current.transferMaps !== "none") {
                  ctx.filter = this.current.transferMaps;
                  ctx.drawImage(ctx.canvas, 0, 0);
                  ctx.filter = "none";
                }
                return ctx.canvas;
              }
              applyTransferMapsToBitmap(imgData) {
                if (this.current.transferMaps === "none") {
                  return imgData.bitmap;
                }
                const {
                  bitmap,
                  width,
                  height
                } = imgData;
                const tmpCanvas = this.cachedCanvases.getCanvas("inlineImage", width, height);
                const tmpCtx = tmpCanvas.context;
                tmpCtx.filter = this.current.transferMaps;
                tmpCtx.drawImage(bitmap, 0, 0);
                tmpCtx.filter = "none";
                return tmpCanvas.canvas;
              }
              paintInlineImageXObject(imgData) {
                if (!this.contentVisible) {
                  return;
                }
                const width = imgData.width;
                const height = imgData.height;
                const ctx = this.ctx;
                this.save();
                if (!_util2.isNodeJS) {
                  const {
                    filter
                  } = ctx;
                  if (filter !== "none" && filter !== "") {
                    ctx.filter = "none";
                  }
                }
                ctx.scale(1 / width, -1 / height);
                let imgToPaint;
                if (imgData.bitmap) {
                  imgToPaint = this.applyTransferMapsToBitmap(imgData);
                } else if (typeof HTMLElement === "function" && imgData instanceof HTMLElement || !imgData.data) {
                  imgToPaint = imgData;
                } else {
                  const tmpCanvas = this.cachedCanvases.getCanvas("inlineImage", width, height);
                  const tmpCtx = tmpCanvas.context;
                  putBinaryImageData(tmpCtx, imgData);
                  imgToPaint = this.applyTransferMapsToCanvas(tmpCtx);
                }
                const scaled = this._scaleImage(imgToPaint, (0, _display_utils2.getCurrentTransformInverse)(ctx));
                ctx.imageSmoothingEnabled = getImageSmoothingEnabled((0, _display_utils2.getCurrentTransform)(ctx), imgData.interpolate);
                drawImageAtIntegerCoords(ctx, scaled.img, 0, 0, scaled.paintWidth, scaled.paintHeight, 0, -height, width, height);
                this.compose();
                this.restore();
              }
              paintInlineImageXObjectGroup(imgData, map2) {
                if (!this.contentVisible) {
                  return;
                }
                const ctx = this.ctx;
                let imgToPaint;
                if (imgData.bitmap) {
                  imgToPaint = imgData.bitmap;
                } else {
                  const w2 = imgData.width;
                  const h3 = imgData.height;
                  const tmpCanvas = this.cachedCanvases.getCanvas("inlineImage", w2, h3);
                  const tmpCtx = tmpCanvas.context;
                  putBinaryImageData(tmpCtx, imgData);
                  imgToPaint = this.applyTransferMapsToCanvas(tmpCtx);
                }
                for (const entry of map2) {
                  ctx.save();
                  ctx.transform(...entry.transform);
                  ctx.scale(1, -1);
                  drawImageAtIntegerCoords(ctx, imgToPaint, entry.x, entry.y, entry.w, entry.h, 0, -1, 1, 1);
                  ctx.restore();
                }
                this.compose();
              }
              paintSolidColorImageMask() {
                if (!this.contentVisible) {
                  return;
                }
                this.ctx.fillRect(0, 0, 1, 1);
                this.compose();
              }
              markPoint(tag) {
              }
              markPointProps(tag, properties) {
              }
              beginMarkedContent(tag) {
                this.markedContentStack.push({
                  visible: true
                });
              }
              beginMarkedContentProps(tag, properties) {
                if (tag === "OC") {
                  this.markedContentStack.push({
                    visible: this.optionalContentConfig.isVisible(properties)
                  });
                } else {
                  this.markedContentStack.push({
                    visible: true
                  });
                }
                this.contentVisible = this.isContentVisible();
              }
              endMarkedContent() {
                this.markedContentStack.pop();
                this.contentVisible = this.isContentVisible();
              }
              beginCompat() {
              }
              endCompat() {
              }
              consumePath(clipBox) {
                const isEmpty = this.current.isEmptyClip();
                if (this.pendingClip) {
                  this.current.updateClipFromPath();
                }
                if (!this.pendingClip) {
                  this.compose(clipBox);
                }
                const ctx = this.ctx;
                if (this.pendingClip) {
                  if (!isEmpty) {
                    if (this.pendingClip === EO_CLIP) {
                      ctx.clip("evenodd");
                    } else {
                      ctx.clip();
                    }
                  }
                  this.pendingClip = null;
                }
                this.current.startNewPathAndClipBox(this.current.clipBox);
                ctx.beginPath();
              }
              getSinglePixelWidth() {
                if (!this._cachedGetSinglePixelWidth) {
                  const m2 = (0, _display_utils2.getCurrentTransform)(this.ctx);
                  if (m2[1] === 0 && m2[2] === 0) {
                    this._cachedGetSinglePixelWidth = 1 / Math.min(Math.abs(m2[0]), Math.abs(m2[3]));
                  } else {
                    const absDet = Math.abs(m2[0] * m2[3] - m2[2] * m2[1]);
                    const normX = Math.hypot(m2[0], m2[2]);
                    const normY = Math.hypot(m2[1], m2[3]);
                    this._cachedGetSinglePixelWidth = Math.max(normX, normY) / absDet;
                  }
                }
                return this._cachedGetSinglePixelWidth;
              }
              getScaleForStroking() {
                if (this._cachedScaleForStroking[0] === -1) {
                  const {
                    lineWidth
                  } = this.current;
                  const {
                    a: a2,
                    b: b2,
                    c: c2,
                    d: d2
                  } = this.ctx.getTransform();
                  let scaleX, scaleY;
                  if (b2 === 0 && c2 === 0) {
                    const normX = Math.abs(a2);
                    const normY = Math.abs(d2);
                    if (normX === normY) {
                      if (lineWidth === 0) {
                        scaleX = scaleY = 1 / normX;
                      } else {
                        const scaledLineWidth = normX * lineWidth;
                        scaleX = scaleY = scaledLineWidth < 1 ? 1 / scaledLineWidth : 1;
                      }
                    } else if (lineWidth === 0) {
                      scaleX = 1 / normX;
                      scaleY = 1 / normY;
                    } else {
                      const scaledXLineWidth = normX * lineWidth;
                      const scaledYLineWidth = normY * lineWidth;
                      scaleX = scaledXLineWidth < 1 ? 1 / scaledXLineWidth : 1;
                      scaleY = scaledYLineWidth < 1 ? 1 / scaledYLineWidth : 1;
                    }
                  } else {
                    const absDet = Math.abs(a2 * d2 - b2 * c2);
                    const normX = Math.hypot(a2, b2);
                    const normY = Math.hypot(c2, d2);
                    if (lineWidth === 0) {
                      scaleX = normY / absDet;
                      scaleY = normX / absDet;
                    } else {
                      const baseArea = lineWidth * absDet;
                      scaleX = normY > baseArea ? normY / baseArea : 1;
                      scaleY = normX > baseArea ? normX / baseArea : 1;
                    }
                  }
                  this._cachedScaleForStroking[0] = scaleX;
                  this._cachedScaleForStroking[1] = scaleY;
                }
                return this._cachedScaleForStroking;
              }
              rescaleAndStroke(saveRestore) {
                const {
                  ctx
                } = this;
                const {
                  lineWidth
                } = this.current;
                const [scaleX, scaleY] = this.getScaleForStroking();
                ctx.lineWidth = lineWidth || 1;
                if (scaleX === 1 && scaleY === 1) {
                  ctx.stroke();
                  return;
                }
                const dashes = ctx.getLineDash();
                if (saveRestore) {
                  ctx.save();
                }
                ctx.scale(scaleX, scaleY);
                if (dashes.length > 0) {
                  const scale = Math.max(scaleX, scaleY);
                  ctx.setLineDash(dashes.map((x2) => x2 / scale));
                  ctx.lineDashOffset /= scale;
                }
                ctx.stroke();
                if (saveRestore) {
                  ctx.restore();
                }
              }
              isContentVisible() {
                for (let i2 = this.markedContentStack.length - 1; i2 >= 0; i2--) {
                  if (!this.markedContentStack[i2].visible) {
                    return false;
                  }
                }
                return true;
              }
            };
            _restoreInitialState = new WeakSet();
            restoreInitialState_fn = /* @__PURE__ */ __name(function() {
              while (this.stateStack.length || this.inSMaskMode) {
                this.restore();
              }
              this.ctx.restore();
              if (this.transparentCanvas) {
                this.ctx = this.compositeCtx;
                this.ctx.save();
                this.ctx.setTransform(1, 0, 0, 1, 0, 0);
                this.ctx.drawImage(this.transparentCanvas, 0, 0);
                this.ctx.restore();
                this.transparentCanvas = null;
              }
            }, "#restoreInitialState");
            _drawFilter = new WeakSet();
            drawFilter_fn = /* @__PURE__ */ __name(function() {
              if (this.pageColors) {
                const hcmFilterId = this.filterFactory.addHCMFilter(this.pageColors.foreground, this.pageColors.background);
                if (hcmFilterId !== "none") {
                  const savedFilter = this.ctx.filter;
                  this.ctx.filter = hcmFilterId;
                  this.ctx.drawImage(this.ctx.canvas, 0, 0);
                  this.ctx.filter = savedFilter;
                }
              }
            }, "#drawFilter");
            __name(_CanvasGraphics, "CanvasGraphics");
            let CanvasGraphics = _CanvasGraphics;
            exports2.CanvasGraphics = CanvasGraphics;
            for (const op in _util2.OPS) {
              if (CanvasGraphics.prototype[op] !== void 0) {
                CanvasGraphics.prototype[_util2.OPS[op]] = CanvasGraphics.prototype[op];
              }
            }
          },
          /* 12 */
          /***/
          (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            exports2.TilingPattern = exports2.PathType = void 0;
            exports2.getShadingPattern = getShadingPattern;
            var _util2 = __w_pdfjs_require__2(1);
            var _display_utils2 = __w_pdfjs_require__2(6);
            const PathType = {
              FILL: "Fill",
              STROKE: "Stroke",
              SHADING: "Shading"
            };
            exports2.PathType = PathType;
            function applyBoundingBox(ctx, bbox) {
              if (!bbox) {
                return;
              }
              const width = bbox[2] - bbox[0];
              const height = bbox[3] - bbox[1];
              const region = new Path2D();
              region.rect(bbox[0], bbox[1], width, height);
              ctx.clip(region);
            }
            __name(applyBoundingBox, "applyBoundingBox");
            const _BaseShadingPattern = class _BaseShadingPattern {
              constructor() {
                if (this.constructor === _BaseShadingPattern) {
                  (0, _util2.unreachable)("Cannot initialize BaseShadingPattern.");
                }
              }
              getPattern() {
                (0, _util2.unreachable)("Abstract method `getPattern` called.");
              }
            };
            __name(_BaseShadingPattern, "BaseShadingPattern");
            let BaseShadingPattern = _BaseShadingPattern;
            const _RadialAxialShadingPattern = class _RadialAxialShadingPattern extends BaseShadingPattern {
              constructor(IR) {
                super();
                this._type = IR[1];
                this._bbox = IR[2];
                this._colorStops = IR[3];
                this._p0 = IR[4];
                this._p1 = IR[5];
                this._r0 = IR[6];
                this._r1 = IR[7];
                this.matrix = null;
              }
              _createGradient(ctx) {
                let grad;
                if (this._type === "axial") {
                  grad = ctx.createLinearGradient(this._p0[0], this._p0[1], this._p1[0], this._p1[1]);
                } else if (this._type === "radial") {
                  grad = ctx.createRadialGradient(this._p0[0], this._p0[1], this._r0, this._p1[0], this._p1[1], this._r1);
                }
                for (const colorStop of this._colorStops) {
                  grad.addColorStop(colorStop[0], colorStop[1]);
                }
                return grad;
              }
              getPattern(ctx, owner, inverse, pathType) {
                let pattern;
                if (pathType === PathType.STROKE || pathType === PathType.FILL) {
                  const ownerBBox = owner.current.getClippedPathBoundingBox(pathType, (0, _display_utils2.getCurrentTransform)(ctx)) || [0, 0, 0, 0];
                  const width = Math.ceil(ownerBBox[2] - ownerBBox[0]) || 1;
                  const height = Math.ceil(ownerBBox[3] - ownerBBox[1]) || 1;
                  const tmpCanvas = owner.cachedCanvases.getCanvas("pattern", width, height, true);
                  const tmpCtx = tmpCanvas.context;
                  tmpCtx.clearRect(0, 0, tmpCtx.canvas.width, tmpCtx.canvas.height);
                  tmpCtx.beginPath();
                  tmpCtx.rect(0, 0, tmpCtx.canvas.width, tmpCtx.canvas.height);
                  tmpCtx.translate(-ownerBBox[0], -ownerBBox[1]);
                  inverse = _util2.Util.transform(inverse, [1, 0, 0, 1, ownerBBox[0], ownerBBox[1]]);
                  tmpCtx.transform(...owner.baseTransform);
                  if (this.matrix) {
                    tmpCtx.transform(...this.matrix);
                  }
                  applyBoundingBox(tmpCtx, this._bbox);
                  tmpCtx.fillStyle = this._createGradient(tmpCtx);
                  tmpCtx.fill();
                  pattern = ctx.createPattern(tmpCanvas.canvas, "no-repeat");
                  const domMatrix = new DOMMatrix(inverse);
                  pattern.setTransform(domMatrix);
                } else {
                  applyBoundingBox(ctx, this._bbox);
                  pattern = this._createGradient(ctx);
                }
                return pattern;
              }
            };
            __name(_RadialAxialShadingPattern, "RadialAxialShadingPattern");
            let RadialAxialShadingPattern = _RadialAxialShadingPattern;
            function drawTriangle(data, context, p1, p2, p3, c1, c2, c3) {
              const coords = context.coords, colors2 = context.colors;
              const bytes = data.data, rowSize = data.width * 4;
              let tmp;
              if (coords[p1 + 1] > coords[p2 + 1]) {
                tmp = p1;
                p1 = p2;
                p2 = tmp;
                tmp = c1;
                c1 = c2;
                c2 = tmp;
              }
              if (coords[p2 + 1] > coords[p3 + 1]) {
                tmp = p2;
                p2 = p3;
                p3 = tmp;
                tmp = c2;
                c2 = c3;
                c3 = tmp;
              }
              if (coords[p1 + 1] > coords[p2 + 1]) {
                tmp = p1;
                p1 = p2;
                p2 = tmp;
                tmp = c1;
                c1 = c2;
                c2 = tmp;
              }
              const x1 = (coords[p1] + context.offsetX) * context.scaleX;
              const y1 = (coords[p1 + 1] + context.offsetY) * context.scaleY;
              const x2 = (coords[p2] + context.offsetX) * context.scaleX;
              const y2 = (coords[p2 + 1] + context.offsetY) * context.scaleY;
              const x3 = (coords[p3] + context.offsetX) * context.scaleX;
              const y3 = (coords[p3 + 1] + context.offsetY) * context.scaleY;
              if (y1 >= y3) {
                return;
              }
              const c1r = colors2[c1], c1g = colors2[c1 + 1], c1b = colors2[c1 + 2];
              const c2r = colors2[c2], c2g = colors2[c2 + 1], c2b = colors2[c2 + 2];
              const c3r = colors2[c3], c3g = colors2[c3 + 1], c3b = colors2[c3 + 2];
              const minY = Math.round(y1), maxY = Math.round(y3);
              let xa, car, cag, cab;
              let xb, cbr, cbg, cbb;
              for (let y4 = minY; y4 <= maxY; y4++) {
                if (y4 < y2) {
                  const k3 = y4 < y1 ? 0 : (y1 - y4) / (y1 - y2);
                  xa = x1 - (x1 - x2) * k3;
                  car = c1r - (c1r - c2r) * k3;
                  cag = c1g - (c1g - c2g) * k3;
                  cab = c1b - (c1b - c2b) * k3;
                } else {
                  let k3;
                  if (y4 > y3) {
                    k3 = 1;
                  } else if (y2 === y3) {
                    k3 = 0;
                  } else {
                    k3 = (y2 - y4) / (y2 - y3);
                  }
                  xa = x2 - (x2 - x3) * k3;
                  car = c2r - (c2r - c3r) * k3;
                  cag = c2g - (c2g - c3g) * k3;
                  cab = c2b - (c2b - c3b) * k3;
                }
                let k2;
                if (y4 < y1) {
                  k2 = 0;
                } else if (y4 > y3) {
                  k2 = 1;
                } else {
                  k2 = (y1 - y4) / (y1 - y3);
                }
                xb = x1 - (x1 - x3) * k2;
                cbr = c1r - (c1r - c3r) * k2;
                cbg = c1g - (c1g - c3g) * k2;
                cbb = c1b - (c1b - c3b) * k2;
                const x1_ = Math.round(Math.min(xa, xb));
                const x2_ = Math.round(Math.max(xa, xb));
                let j2 = rowSize * y4 + x1_ * 4;
                for (let x4 = x1_; x4 <= x2_; x4++) {
                  k2 = (xa - x4) / (xa - xb);
                  if (k2 < 0) {
                    k2 = 0;
                  } else if (k2 > 1) {
                    k2 = 1;
                  }
                  bytes[j2++] = car - (car - cbr) * k2 | 0;
                  bytes[j2++] = cag - (cag - cbg) * k2 | 0;
                  bytes[j2++] = cab - (cab - cbb) * k2 | 0;
                  bytes[j2++] = 255;
                }
              }
            }
            __name(drawTriangle, "drawTriangle");
            function drawFigure(data, figure, context) {
              const ps = figure.coords;
              const cs = figure.colors;
              let i2, ii;
              switch (figure.type) {
                case "lattice":
                  const verticesPerRow = figure.verticesPerRow;
                  const rows = Math.floor(ps.length / verticesPerRow) - 1;
                  const cols = verticesPerRow - 1;
                  for (i2 = 0; i2 < rows; i2++) {
                    let q2 = i2 * verticesPerRow;
                    for (let j2 = 0; j2 < cols; j2++, q2++) {
                      drawTriangle(data, context, ps[q2], ps[q2 + 1], ps[q2 + verticesPerRow], cs[q2], cs[q2 + 1], cs[q2 + verticesPerRow]);
                      drawTriangle(data, context, ps[q2 + verticesPerRow + 1], ps[q2 + 1], ps[q2 + verticesPerRow], cs[q2 + verticesPerRow + 1], cs[q2 + 1], cs[q2 + verticesPerRow]);
                    }
                  }
                  break;
                case "triangles":
                  for (i2 = 0, ii = ps.length; i2 < ii; i2 += 3) {
                    drawTriangle(data, context, ps[i2], ps[i2 + 1], ps[i2 + 2], cs[i2], cs[i2 + 1], cs[i2 + 2]);
                  }
                  break;
                default:
                  throw new Error("illegal figure");
              }
            }
            __name(drawFigure, "drawFigure");
            const _MeshShadingPattern = class _MeshShadingPattern extends BaseShadingPattern {
              constructor(IR) {
                super();
                this._coords = IR[2];
                this._colors = IR[3];
                this._figures = IR[4];
                this._bounds = IR[5];
                this._bbox = IR[7];
                this._background = IR[8];
                this.matrix = null;
              }
              _createMeshCanvas(combinedScale, backgroundColor, cachedCanvases) {
                const EXPECTED_SCALE = 1.1;
                const MAX_PATTERN_SIZE = 3e3;
                const BORDER_SIZE = 2;
                const offsetX = Math.floor(this._bounds[0]);
                const offsetY = Math.floor(this._bounds[1]);
                const boundsWidth = Math.ceil(this._bounds[2]) - offsetX;
                const boundsHeight = Math.ceil(this._bounds[3]) - offsetY;
                const width = Math.min(Math.ceil(Math.abs(boundsWidth * combinedScale[0] * EXPECTED_SCALE)), MAX_PATTERN_SIZE);
                const height = Math.min(Math.ceil(Math.abs(boundsHeight * combinedScale[1] * EXPECTED_SCALE)), MAX_PATTERN_SIZE);
                const scaleX = boundsWidth / width;
                const scaleY = boundsHeight / height;
                const context = {
                  coords: this._coords,
                  colors: this._colors,
                  offsetX: -offsetX,
                  offsetY: -offsetY,
                  scaleX: 1 / scaleX,
                  scaleY: 1 / scaleY
                };
                const paddedWidth = width + BORDER_SIZE * 2;
                const paddedHeight = height + BORDER_SIZE * 2;
                const tmpCanvas = cachedCanvases.getCanvas("mesh", paddedWidth, paddedHeight, false);
                const tmpCtx = tmpCanvas.context;
                const data = tmpCtx.createImageData(width, height);
                if (backgroundColor) {
                  const bytes = data.data;
                  for (let i2 = 0, ii = bytes.length; i2 < ii; i2 += 4) {
                    bytes[i2] = backgroundColor[0];
                    bytes[i2 + 1] = backgroundColor[1];
                    bytes[i2 + 2] = backgroundColor[2];
                    bytes[i2 + 3] = 255;
                  }
                }
                for (const figure of this._figures) {
                  drawFigure(data, figure, context);
                }
                tmpCtx.putImageData(data, BORDER_SIZE, BORDER_SIZE);
                const canvas = tmpCanvas.canvas;
                return {
                  canvas,
                  offsetX: offsetX - BORDER_SIZE * scaleX,
                  offsetY: offsetY - BORDER_SIZE * scaleY,
                  scaleX,
                  scaleY
                };
              }
              getPattern(ctx, owner, inverse, pathType) {
                applyBoundingBox(ctx, this._bbox);
                let scale;
                if (pathType === PathType.SHADING) {
                  scale = _util2.Util.singularValueDecompose2dScale((0, _display_utils2.getCurrentTransform)(ctx));
                } else {
                  scale = _util2.Util.singularValueDecompose2dScale(owner.baseTransform);
                  if (this.matrix) {
                    const matrixScale = _util2.Util.singularValueDecompose2dScale(this.matrix);
                    scale = [scale[0] * matrixScale[0], scale[1] * matrixScale[1]];
                  }
                }
                const temporaryPatternCanvas = this._createMeshCanvas(scale, pathType === PathType.SHADING ? null : this._background, owner.cachedCanvases);
                if (pathType !== PathType.SHADING) {
                  ctx.setTransform(...owner.baseTransform);
                  if (this.matrix) {
                    ctx.transform(...this.matrix);
                  }
                }
                ctx.translate(temporaryPatternCanvas.offsetX, temporaryPatternCanvas.offsetY);
                ctx.scale(temporaryPatternCanvas.scaleX, temporaryPatternCanvas.scaleY);
                return ctx.createPattern(temporaryPatternCanvas.canvas, "no-repeat");
              }
            };
            __name(_MeshShadingPattern, "MeshShadingPattern");
            let MeshShadingPattern = _MeshShadingPattern;
            const _DummyShadingPattern = class _DummyShadingPattern extends BaseShadingPattern {
              getPattern() {
                return "hotpink";
              }
            };
            __name(_DummyShadingPattern, "DummyShadingPattern");
            let DummyShadingPattern = _DummyShadingPattern;
            function getShadingPattern(IR) {
              switch (IR[0]) {
                case "RadialAxial":
                  return new RadialAxialShadingPattern(IR);
                case "Mesh":
                  return new MeshShadingPattern(IR);
                case "Dummy":
                  return new DummyShadingPattern();
              }
              throw new Error(`Unknown IR type: ${IR[0]}`);
            }
            __name(getShadingPattern, "getShadingPattern");
            const PaintType = {
              COLORED: 1,
              UNCOLORED: 2
            };
            const _TilingPattern = class _TilingPattern {
              constructor(IR, color2, ctx, canvasGraphicsFactory, baseTransform) {
                this.operatorList = IR[2];
                this.matrix = IR[3] || [1, 0, 0, 1, 0, 0];
                this.bbox = IR[4];
                this.xstep = IR[5];
                this.ystep = IR[6];
                this.paintType = IR[7];
                this.tilingType = IR[8];
                this.color = color2;
                this.ctx = ctx;
                this.canvasGraphicsFactory = canvasGraphicsFactory;
                this.baseTransform = baseTransform;
              }
              createPatternCanvas(owner) {
                const operatorList = this.operatorList;
                const bbox = this.bbox;
                const xstep = this.xstep;
                const ystep = this.ystep;
                const paintType = this.paintType;
                const tilingType = this.tilingType;
                const color2 = this.color;
                const canvasGraphicsFactory = this.canvasGraphicsFactory;
                (0, _util2.info)("TilingType: " + tilingType);
                const x0 = bbox[0], y0 = bbox[1], x1 = bbox[2], y1 = bbox[3];
                const matrixScale = _util2.Util.singularValueDecompose2dScale(this.matrix);
                const curMatrixScale = _util2.Util.singularValueDecompose2dScale(this.baseTransform);
                const combinedScale = [matrixScale[0] * curMatrixScale[0], matrixScale[1] * curMatrixScale[1]];
                const dimx = this.getSizeAndScale(xstep, this.ctx.canvas.width, combinedScale[0]);
                const dimy = this.getSizeAndScale(ystep, this.ctx.canvas.height, combinedScale[1]);
                const tmpCanvas = owner.cachedCanvases.getCanvas("pattern", dimx.size, dimy.size, true);
                const tmpCtx = tmpCanvas.context;
                const graphics = canvasGraphicsFactory.createCanvasGraphics(tmpCtx);
                graphics.groupLevel = owner.groupLevel;
                this.setFillAndStrokeStyleToContext(graphics, paintType, color2);
                let adjustedX0 = x0;
                let adjustedY0 = y0;
                let adjustedX1 = x1;
                let adjustedY1 = y1;
                if (x0 < 0) {
                  adjustedX0 = 0;
                  adjustedX1 += Math.abs(x0);
                }
                if (y0 < 0) {
                  adjustedY0 = 0;
                  adjustedY1 += Math.abs(y0);
                }
                tmpCtx.translate(-(dimx.scale * adjustedX0), -(dimy.scale * adjustedY0));
                graphics.transform(dimx.scale, 0, 0, dimy.scale, 0, 0);
                tmpCtx.save();
                this.clipBbox(graphics, adjustedX0, adjustedY0, adjustedX1, adjustedY1);
                graphics.baseTransform = (0, _display_utils2.getCurrentTransform)(graphics.ctx);
                graphics.executeOperatorList(operatorList);
                graphics.endDrawing();
                return {
                  canvas: tmpCanvas.canvas,
                  scaleX: dimx.scale,
                  scaleY: dimy.scale,
                  offsetX: adjustedX0,
                  offsetY: adjustedY0
                };
              }
              getSizeAndScale(step, realOutputSize, scale) {
                step = Math.abs(step);
                const maxSize = Math.max(_TilingPattern.MAX_PATTERN_SIZE, realOutputSize);
                let size = Math.ceil(step * scale);
                if (size >= maxSize) {
                  size = maxSize;
                } else {
                  scale = size / step;
                }
                return {
                  scale,
                  size
                };
              }
              clipBbox(graphics, x0, y0, x1, y1) {
                const bboxWidth = x1 - x0;
                const bboxHeight = y1 - y0;
                graphics.ctx.rect(x0, y0, bboxWidth, bboxHeight);
                graphics.current.updateRectMinMax((0, _display_utils2.getCurrentTransform)(graphics.ctx), [x0, y0, x1, y1]);
                graphics.clip();
                graphics.endPath();
              }
              setFillAndStrokeStyleToContext(graphics, paintType, color2) {
                const context = graphics.ctx, current = graphics.current;
                switch (paintType) {
                  case PaintType.COLORED:
                    const ctx = this.ctx;
                    context.fillStyle = ctx.fillStyle;
                    context.strokeStyle = ctx.strokeStyle;
                    current.fillColor = ctx.fillStyle;
                    current.strokeColor = ctx.strokeStyle;
                    break;
                  case PaintType.UNCOLORED:
                    const cssColor = _util2.Util.makeHexColor(color2[0], color2[1], color2[2]);
                    context.fillStyle = cssColor;
                    context.strokeStyle = cssColor;
                    current.fillColor = cssColor;
                    current.strokeColor = cssColor;
                    break;
                  default:
                    throw new _util2.FormatError(`Unsupported paint type: ${paintType}`);
                }
              }
              getPattern(ctx, owner, inverse, pathType) {
                let matrix = inverse;
                if (pathType !== PathType.SHADING) {
                  matrix = _util2.Util.transform(matrix, owner.baseTransform);
                  if (this.matrix) {
                    matrix = _util2.Util.transform(matrix, this.matrix);
                  }
                }
                const temporaryPatternCanvas = this.createPatternCanvas(owner);
                let domMatrix = new DOMMatrix(matrix);
                domMatrix = domMatrix.translate(temporaryPatternCanvas.offsetX, temporaryPatternCanvas.offsetY);
                domMatrix = domMatrix.scale(1 / temporaryPatternCanvas.scaleX, 1 / temporaryPatternCanvas.scaleY);
                const pattern = ctx.createPattern(temporaryPatternCanvas.canvas, "repeat");
                pattern.setTransform(domMatrix);
                return pattern;
              }
            };
            __name(_TilingPattern, "TilingPattern");
            __publicField(_TilingPattern, "MAX_PATTERN_SIZE", 3e3);
            let TilingPattern = _TilingPattern;
            exports2.TilingPattern = TilingPattern;
          },
          /* 13 */
          /***/
          (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            exports2.convertBlackAndWhiteToRGBA = convertBlackAndWhiteToRGBA;
            exports2.convertToRGBA = convertToRGBA;
            exports2.grayToRGBA = grayToRGBA;
            var _util2 = __w_pdfjs_require__2(1);
            function convertToRGBA(params) {
              switch (params.kind) {
                case _util2.ImageKind.GRAYSCALE_1BPP:
                  return convertBlackAndWhiteToRGBA(params);
                case _util2.ImageKind.RGB_24BPP:
                  return convertRGBToRGBA(params);
              }
              return null;
            }
            __name(convertToRGBA, "convertToRGBA");
            function convertBlackAndWhiteToRGBA({
              src,
              srcPos = 0,
              dest,
              width,
              height,
              nonBlackColor = 4294967295,
              inverseDecode = false
            }) {
              const black = _util2.FeatureTest.isLittleEndian ? 4278190080 : 255;
              const [zeroMapping, oneMapping] = inverseDecode ? [nonBlackColor, black] : [black, nonBlackColor];
              const widthInSource = width >> 3;
              const widthRemainder = width & 7;
              const srcLength = src.length;
              dest = new Uint32Array(dest.buffer);
              let destPos = 0;
              for (let i2 = 0; i2 < height; i2++) {
                for (const max2 = srcPos + widthInSource; srcPos < max2; srcPos++) {
                  const elem2 = srcPos < srcLength ? src[srcPos] : 255;
                  dest[destPos++] = elem2 & 128 ? oneMapping : zeroMapping;
                  dest[destPos++] = elem2 & 64 ? oneMapping : zeroMapping;
                  dest[destPos++] = elem2 & 32 ? oneMapping : zeroMapping;
                  dest[destPos++] = elem2 & 16 ? oneMapping : zeroMapping;
                  dest[destPos++] = elem2 & 8 ? oneMapping : zeroMapping;
                  dest[destPos++] = elem2 & 4 ? oneMapping : zeroMapping;
                  dest[destPos++] = elem2 & 2 ? oneMapping : zeroMapping;
                  dest[destPos++] = elem2 & 1 ? oneMapping : zeroMapping;
                }
                if (widthRemainder === 0) {
                  continue;
                }
                const elem = srcPos < srcLength ? src[srcPos++] : 255;
                for (let j2 = 0; j2 < widthRemainder; j2++) {
                  dest[destPos++] = elem & 1 << 7 - j2 ? oneMapping : zeroMapping;
                }
              }
              return {
                srcPos,
                destPos
              };
            }
            __name(convertBlackAndWhiteToRGBA, "convertBlackAndWhiteToRGBA");
            function convertRGBToRGBA({
              src,
              srcPos = 0,
              dest,
              destPos = 0,
              width,
              height
            }) {
              let i2 = 0;
              const len32 = src.length >> 2;
              const src32 = new Uint32Array(src.buffer, srcPos, len32);
              if (_util2.FeatureTest.isLittleEndian) {
                for (; i2 < len32 - 2; i2 += 3, destPos += 4) {
                  const s1 = src32[i2];
                  const s2 = src32[i2 + 1];
                  const s3 = src32[i2 + 2];
                  dest[destPos] = s1 | 4278190080;
                  dest[destPos + 1] = s1 >>> 24 | s2 << 8 | 4278190080;
                  dest[destPos + 2] = s2 >>> 16 | s3 << 16 | 4278190080;
                  dest[destPos + 3] = s3 >>> 8 | 4278190080;
                }
                for (let j2 = i2 * 4, jj = src.length; j2 < jj; j2 += 3) {
                  dest[destPos++] = src[j2] | src[j2 + 1] << 8 | src[j2 + 2] << 16 | 4278190080;
                }
              } else {
                for (; i2 < len32 - 2; i2 += 3, destPos += 4) {
                  const s1 = src32[i2];
                  const s2 = src32[i2 + 1];
                  const s3 = src32[i2 + 2];
                  dest[destPos] = s1 | 255;
                  dest[destPos + 1] = s1 << 24 | s2 >>> 8 | 255;
                  dest[destPos + 2] = s2 << 16 | s3 >>> 16 | 255;
                  dest[destPos + 3] = s3 << 8 | 255;
                }
                for (let j2 = i2 * 4, jj = src.length; j2 < jj; j2 += 3) {
                  dest[destPos++] = src[j2] << 24 | src[j2 + 1] << 16 | src[j2 + 2] << 8 | 255;
                }
              }
              return {
                srcPos,
                destPos
              };
            }
            __name(convertRGBToRGBA, "convertRGBToRGBA");
            function grayToRGBA(src, dest) {
              if (_util2.FeatureTest.isLittleEndian) {
                for (let i2 = 0, ii = src.length; i2 < ii; i2++) {
                  dest[i2] = src[i2] * 65793 | 4278190080;
                }
              } else {
                for (let i2 = 0, ii = src.length; i2 < ii; i2++) {
                  dest[i2] = src[i2] * 16843008 | 255;
                }
              }
            }
            __name(grayToRGBA, "grayToRGBA");
          },
          /* 14 */
          /***/
          (__unused_webpack_module2, exports2) => {
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            exports2.GlobalWorkerOptions = void 0;
            const GlobalWorkerOptions = /* @__PURE__ */ Object.create(null);
            exports2.GlobalWorkerOptions = GlobalWorkerOptions;
            GlobalWorkerOptions.workerPort = null;
            GlobalWorkerOptions.workerSrc = "";
          },
          /* 15 */
          /***/
          (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
            var _createStreamSink, createStreamSink_fn, _processStreamMessage, processStreamMessage_fn, _deleteStreamController, deleteStreamController_fn;
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            exports2.MessageHandler = void 0;
            var _util2 = __w_pdfjs_require__2(1);
            const CallbackKind = {
              UNKNOWN: 0,
              DATA: 1,
              ERROR: 2
            };
            const StreamKind = {
              UNKNOWN: 0,
              CANCEL: 1,
              CANCEL_COMPLETE: 2,
              CLOSE: 3,
              ENQUEUE: 4,
              ERROR: 5,
              PULL: 6,
              PULL_COMPLETE: 7,
              START_COMPLETE: 8
            };
            function wrapReason(reason) {
              if (!(reason instanceof Error || typeof reason === "object" && reason !== null)) {
                (0, _util2.unreachable)('wrapReason: Expected "reason" to be a (possibly cloned) Error.');
              }
              switch (reason.name) {
                case "AbortException":
                  return new _util2.AbortException(reason.message);
                case "MissingPDFException":
                  return new _util2.MissingPDFException(reason.message);
                case "PasswordException":
                  return new _util2.PasswordException(reason.message, reason.code);
                case "UnexpectedResponseException":
                  return new _util2.UnexpectedResponseException(reason.message, reason.status);
                case "UnknownErrorException":
                  return new _util2.UnknownErrorException(reason.message, reason.details);
                default:
                  return new _util2.UnknownErrorException(reason.message, reason.toString());
              }
            }
            __name(wrapReason, "wrapReason");
            const _MessageHandler = class _MessageHandler {
              constructor(sourceName, targetName, comObj) {
                __privateAdd(this, _createStreamSink);
                __privateAdd(this, _processStreamMessage);
                __privateAdd(this, _deleteStreamController);
                this.sourceName = sourceName;
                this.targetName = targetName;
                this.comObj = comObj;
                this.callbackId = 1;
                this.streamId = 1;
                this.streamSinks = /* @__PURE__ */ Object.create(null);
                this.streamControllers = /* @__PURE__ */ Object.create(null);
                this.callbackCapabilities = /* @__PURE__ */ Object.create(null);
                this.actionHandler = /* @__PURE__ */ Object.create(null);
                this._onComObjOnMessage = (event) => {
                  const data = event.data;
                  if (data.targetName !== this.sourceName) {
                    return;
                  }
                  if (data.stream) {
                    __privateMethod(this, _processStreamMessage, processStreamMessage_fn).call(this, data);
                    return;
                  }
                  if (data.callback) {
                    const callbackId = data.callbackId;
                    const capability = this.callbackCapabilities[callbackId];
                    if (!capability) {
                      throw new Error(`Cannot resolve callback ${callbackId}`);
                    }
                    delete this.callbackCapabilities[callbackId];
                    if (data.callback === CallbackKind.DATA) {
                      capability.resolve(data.data);
                    } else if (data.callback === CallbackKind.ERROR) {
                      capability.reject(wrapReason(data.reason));
                    } else {
                      throw new Error("Unexpected callback case");
                    }
                    return;
                  }
                  const action = this.actionHandler[data.action];
                  if (!action) {
                    throw new Error(`Unknown action from worker: ${data.action}`);
                  }
                  if (data.callbackId) {
                    const cbSourceName = this.sourceName;
                    const cbTargetName = data.sourceName;
                    new Promise(function(resolve2) {
                      resolve2(action(data.data));
                    }).then(function(result) {
                      comObj.postMessage({
                        sourceName: cbSourceName,
                        targetName: cbTargetName,
                        callback: CallbackKind.DATA,
                        callbackId: data.callbackId,
                        data: result
                      });
                    }, function(reason) {
                      comObj.postMessage({
                        sourceName: cbSourceName,
                        targetName: cbTargetName,
                        callback: CallbackKind.ERROR,
                        callbackId: data.callbackId,
                        reason: wrapReason(reason)
                      });
                    });
                    return;
                  }
                  if (data.streamId) {
                    __privateMethod(this, _createStreamSink, createStreamSink_fn).call(this, data);
                    return;
                  }
                  action(data.data);
                };
                comObj.addEventListener("message", this._onComObjOnMessage);
              }
              on(actionName, handler) {
                const ah = this.actionHandler;
                if (ah[actionName]) {
                  throw new Error(`There is already an actionName called "${actionName}"`);
                }
                ah[actionName] = handler;
              }
              send(actionName, data, transfers) {
                this.comObj.postMessage({
                  sourceName: this.sourceName,
                  targetName: this.targetName,
                  action: actionName,
                  data
                }, transfers);
              }
              sendWithPromise(actionName, data, transfers) {
                const callbackId = this.callbackId++;
                const capability = new _util2.PromiseCapability();
                this.callbackCapabilities[callbackId] = capability;
                try {
                  this.comObj.postMessage({
                    sourceName: this.sourceName,
                    targetName: this.targetName,
                    action: actionName,
                    callbackId,
                    data
                  }, transfers);
                } catch (ex) {
                  capability.reject(ex);
                }
                return capability.promise;
              }
              sendWithStream(actionName, data, queueingStrategy, transfers) {
                const streamId = this.streamId++, sourceName = this.sourceName, targetName = this.targetName, comObj = this.comObj;
                return new ReadableStream({
                  start: (controller) => {
                    const startCapability = new _util2.PromiseCapability();
                    this.streamControllers[streamId] = {
                      controller,
                      startCall: startCapability,
                      pullCall: null,
                      cancelCall: null,
                      isClosed: false
                    };
                    comObj.postMessage({
                      sourceName,
                      targetName,
                      action: actionName,
                      streamId,
                      data,
                      desiredSize: controller.desiredSize
                    }, transfers);
                    return startCapability.promise;
                  },
                  pull: (controller) => {
                    const pullCapability = new _util2.PromiseCapability();
                    this.streamControllers[streamId].pullCall = pullCapability;
                    comObj.postMessage({
                      sourceName,
                      targetName,
                      stream: StreamKind.PULL,
                      streamId,
                      desiredSize: controller.desiredSize
                    });
                    return pullCapability.promise;
                  },
                  cancel: (reason) => {
                    (0, _util2.assert)(reason instanceof Error, "cancel must have a valid reason");
                    const cancelCapability = new _util2.PromiseCapability();
                    this.streamControllers[streamId].cancelCall = cancelCapability;
                    this.streamControllers[streamId].isClosed = true;
                    comObj.postMessage({
                      sourceName,
                      targetName,
                      stream: StreamKind.CANCEL,
                      streamId,
                      reason: wrapReason(reason)
                    });
                    return cancelCapability.promise;
                  }
                }, queueingStrategy);
              }
              destroy() {
                this.comObj.removeEventListener("message", this._onComObjOnMessage);
              }
            };
            _createStreamSink = new WeakSet();
            createStreamSink_fn = /* @__PURE__ */ __name(function(data) {
              const streamId = data.streamId, sourceName = this.sourceName, targetName = data.sourceName, comObj = this.comObj;
              const self2 = this, action = this.actionHandler[data.action];
              const streamSink = {
                enqueue(chunk, size = 1, transfers) {
                  if (this.isCancelled) {
                    return;
                  }
                  const lastDesiredSize = this.desiredSize;
                  this.desiredSize -= size;
                  if (lastDesiredSize > 0 && this.desiredSize <= 0) {
                    this.sinkCapability = new _util2.PromiseCapability();
                    this.ready = this.sinkCapability.promise;
                  }
                  comObj.postMessage({
                    sourceName,
                    targetName,
                    stream: StreamKind.ENQUEUE,
                    streamId,
                    chunk
                  }, transfers);
                },
                close() {
                  if (this.isCancelled) {
                    return;
                  }
                  this.isCancelled = true;
                  comObj.postMessage({
                    sourceName,
                    targetName,
                    stream: StreamKind.CLOSE,
                    streamId
                  });
                  delete self2.streamSinks[streamId];
                },
                error(reason) {
                  (0, _util2.assert)(reason instanceof Error, "error must have a valid reason");
                  if (this.isCancelled) {
                    return;
                  }
                  this.isCancelled = true;
                  comObj.postMessage({
                    sourceName,
                    targetName,
                    stream: StreamKind.ERROR,
                    streamId,
                    reason: wrapReason(reason)
                  });
                },
                sinkCapability: new _util2.PromiseCapability(),
                onPull: null,
                onCancel: null,
                isCancelled: false,
                desiredSize: data.desiredSize,
                ready: null
              };
              streamSink.sinkCapability.resolve();
              streamSink.ready = streamSink.sinkCapability.promise;
              this.streamSinks[streamId] = streamSink;
              new Promise(function(resolve2) {
                resolve2(action(data.data, streamSink));
              }).then(function() {
                comObj.postMessage({
                  sourceName,
                  targetName,
                  stream: StreamKind.START_COMPLETE,
                  streamId,
                  success: true
                });
              }, function(reason) {
                comObj.postMessage({
                  sourceName,
                  targetName,
                  stream: StreamKind.START_COMPLETE,
                  streamId,
                  reason: wrapReason(reason)
                });
              });
            }, "#createStreamSink");
            _processStreamMessage = new WeakSet();
            processStreamMessage_fn = /* @__PURE__ */ __name(function(data) {
              const streamId = data.streamId, sourceName = this.sourceName, targetName = data.sourceName, comObj = this.comObj;
              const streamController = this.streamControllers[streamId], streamSink = this.streamSinks[streamId];
              switch (data.stream) {
                case StreamKind.START_COMPLETE:
                  if (data.success) {
                    streamController.startCall.resolve();
                  } else {
                    streamController.startCall.reject(wrapReason(data.reason));
                  }
                  break;
                case StreamKind.PULL_COMPLETE:
                  if (data.success) {
                    streamController.pullCall.resolve();
                  } else {
                    streamController.pullCall.reject(wrapReason(data.reason));
                  }
                  break;
                case StreamKind.PULL:
                  if (!streamSink) {
                    comObj.postMessage({
                      sourceName,
                      targetName,
                      stream: StreamKind.PULL_COMPLETE,
                      streamId,
                      success: true
                    });
                    break;
                  }
                  if (streamSink.desiredSize <= 0 && data.desiredSize > 0) {
                    streamSink.sinkCapability.resolve();
                  }
                  streamSink.desiredSize = data.desiredSize;
                  new Promise(function(resolve2) {
                    var _a3;
                    resolve2((_a3 = streamSink.onPull) == null ? void 0 : _a3.call(streamSink));
                  }).then(function() {
                    comObj.postMessage({
                      sourceName,
                      targetName,
                      stream: StreamKind.PULL_COMPLETE,
                      streamId,
                      success: true
                    });
                  }, function(reason) {
                    comObj.postMessage({
                      sourceName,
                      targetName,
                      stream: StreamKind.PULL_COMPLETE,
                      streamId,
                      reason: wrapReason(reason)
                    });
                  });
                  break;
                case StreamKind.ENQUEUE:
                  (0, _util2.assert)(streamController, "enqueue should have stream controller");
                  if (streamController.isClosed) {
                    break;
                  }
                  streamController.controller.enqueue(data.chunk);
                  break;
                case StreamKind.CLOSE:
                  (0, _util2.assert)(streamController, "close should have stream controller");
                  if (streamController.isClosed) {
                    break;
                  }
                  streamController.isClosed = true;
                  streamController.controller.close();
                  __privateMethod(this, _deleteStreamController, deleteStreamController_fn).call(this, streamController, streamId);
                  break;
                case StreamKind.ERROR:
                  (0, _util2.assert)(streamController, "error should have stream controller");
                  streamController.controller.error(wrapReason(data.reason));
                  __privateMethod(this, _deleteStreamController, deleteStreamController_fn).call(this, streamController, streamId);
                  break;
                case StreamKind.CANCEL_COMPLETE:
                  if (data.success) {
                    streamController.cancelCall.resolve();
                  } else {
                    streamController.cancelCall.reject(wrapReason(data.reason));
                  }
                  __privateMethod(this, _deleteStreamController, deleteStreamController_fn).call(this, streamController, streamId);
                  break;
                case StreamKind.CANCEL:
                  if (!streamSink) {
                    break;
                  }
                  new Promise(function(resolve2) {
                    var _a3;
                    resolve2((_a3 = streamSink.onCancel) == null ? void 0 : _a3.call(streamSink, wrapReason(data.reason)));
                  }).then(function() {
                    comObj.postMessage({
                      sourceName,
                      targetName,
                      stream: StreamKind.CANCEL_COMPLETE,
                      streamId,
                      success: true
                    });
                  }, function(reason) {
                    comObj.postMessage({
                      sourceName,
                      targetName,
                      stream: StreamKind.CANCEL_COMPLETE,
                      streamId,
                      reason: wrapReason(reason)
                    });
                  });
                  streamSink.sinkCapability.reject(wrapReason(data.reason));
                  streamSink.isCancelled = true;
                  delete this.streamSinks[streamId];
                  break;
                default:
                  throw new Error("Unexpected stream case");
              }
            }, "#processStreamMessage");
            _deleteStreamController = new WeakSet();
            deleteStreamController_fn = /* @__PURE__ */ __name(async function(streamController, streamId) {
              var _a3, _b2, _c;
              await Promise.allSettled([(_a3 = streamController.startCall) == null ? void 0 : _a3.promise, (_b2 = streamController.pullCall) == null ? void 0 : _b2.promise, (_c = streamController.cancelCall) == null ? void 0 : _c.promise]);
              delete this.streamControllers[streamId];
            }, "#deleteStreamController");
            __name(_MessageHandler, "MessageHandler");
            let MessageHandler = _MessageHandler;
            exports2.MessageHandler = MessageHandler;
          },
          /* 16 */
          /***/
          (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
            var _metadataMap, _data;
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            exports2.Metadata = void 0;
            var _util2 = __w_pdfjs_require__2(1);
            const _Metadata = class _Metadata {
              constructor({
                parsedData,
                rawData
              }) {
                __privateAdd(this, _metadataMap, void 0);
                __privateAdd(this, _data, void 0);
                __privateSet(this, _metadataMap, parsedData);
                __privateSet(this, _data, rawData);
              }
              getRaw() {
                return __privateGet(this, _data);
              }
              get(name) {
                return __privateGet(this, _metadataMap).get(name) ?? null;
              }
              getAll() {
                return (0, _util2.objectFromMap)(__privateGet(this, _metadataMap));
              }
              has(name) {
                return __privateGet(this, _metadataMap).has(name);
              }
            };
            _metadataMap = new WeakMap();
            _data = new WeakMap();
            __name(_Metadata, "Metadata");
            let Metadata = _Metadata;
            exports2.Metadata = Metadata;
          },
          /* 17 */
          /***/
          (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
            var _visible, _cachedGetHash, _groups, _initialHash, _order, _evaluateVisibilityExpression, evaluateVisibilityExpression_fn;
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            exports2.OptionalContentConfig = void 0;
            var _util2 = __w_pdfjs_require__2(1);
            var _murmurhash = __w_pdfjs_require__2(8);
            const INTERNAL = Symbol("INTERNAL");
            const _OptionalContentGroup = class _OptionalContentGroup {
              constructor(name, intent) {
                __privateAdd(this, _visible, true);
                this.name = name;
                this.intent = intent;
              }
              get visible() {
                return __privateGet(this, _visible);
              }
              _setVisible(internal, visible) {
                if (internal !== INTERNAL) {
                  (0, _util2.unreachable)("Internal method `_setVisible` called.");
                }
                __privateSet(this, _visible, visible);
              }
            };
            _visible = new WeakMap();
            __name(_OptionalContentGroup, "OptionalContentGroup");
            let OptionalContentGroup = _OptionalContentGroup;
            const _OptionalContentConfig = class _OptionalContentConfig {
              constructor(data) {
                __privateAdd(this, _evaluateVisibilityExpression);
                __privateAdd(this, _cachedGetHash, null);
                __privateAdd(this, _groups, /* @__PURE__ */ new Map());
                __privateAdd(this, _initialHash, null);
                __privateAdd(this, _order, null);
                this.name = null;
                this.creator = null;
                if (data === null) {
                  return;
                }
                this.name = data.name;
                this.creator = data.creator;
                __privateSet(this, _order, data.order);
                for (const group of data.groups) {
                  __privateGet(this, _groups).set(group.id, new OptionalContentGroup(group.name, group.intent));
                }
                if (data.baseState === "OFF") {
                  for (const group of __privateGet(this, _groups).values()) {
                    group._setVisible(INTERNAL, false);
                  }
                }
                for (const on of data.on) {
                  __privateGet(this, _groups).get(on)._setVisible(INTERNAL, true);
                }
                for (const off of data.off) {
                  __privateGet(this, _groups).get(off)._setVisible(INTERNAL, false);
                }
                __privateSet(this, _initialHash, this.getHash());
              }
              isVisible(group) {
                if (__privateGet(this, _groups).size === 0) {
                  return true;
                }
                if (!group) {
                  (0, _util2.warn)("Optional content group not defined.");
                  return true;
                }
                if (group.type === "OCG") {
                  if (!__privateGet(this, _groups).has(group.id)) {
                    (0, _util2.warn)(`Optional content group not found: ${group.id}`);
                    return true;
                  }
                  return __privateGet(this, _groups).get(group.id).visible;
                } else if (group.type === "OCMD") {
                  if (group.expression) {
                    return __privateMethod(this, _evaluateVisibilityExpression, evaluateVisibilityExpression_fn).call(this, group.expression);
                  }
                  if (!group.policy || group.policy === "AnyOn") {
                    for (const id of group.ids) {
                      if (!__privateGet(this, _groups).has(id)) {
                        (0, _util2.warn)(`Optional content group not found: ${id}`);
                        return true;
                      }
                      if (__privateGet(this, _groups).get(id).visible) {
                        return true;
                      }
                    }
                    return false;
                  } else if (group.policy === "AllOn") {
                    for (const id of group.ids) {
                      if (!__privateGet(this, _groups).has(id)) {
                        (0, _util2.warn)(`Optional content group not found: ${id}`);
                        return true;
                      }
                      if (!__privateGet(this, _groups).get(id).visible) {
                        return false;
                      }
                    }
                    return true;
                  } else if (group.policy === "AnyOff") {
                    for (const id of group.ids) {
                      if (!__privateGet(this, _groups).has(id)) {
                        (0, _util2.warn)(`Optional content group not found: ${id}`);
                        return true;
                      }
                      if (!__privateGet(this, _groups).get(id).visible) {
                        return true;
                      }
                    }
                    return false;
                  } else if (group.policy === "AllOff") {
                    for (const id of group.ids) {
                      if (!__privateGet(this, _groups).has(id)) {
                        (0, _util2.warn)(`Optional content group not found: ${id}`);
                        return true;
                      }
                      if (__privateGet(this, _groups).get(id).visible) {
                        return false;
                      }
                    }
                    return true;
                  }
                  (0, _util2.warn)(`Unknown optional content policy ${group.policy}.`);
                  return true;
                }
                (0, _util2.warn)(`Unknown group type ${group.type}.`);
                return true;
              }
              setVisibility(id, visible = true) {
                if (!__privateGet(this, _groups).has(id)) {
                  (0, _util2.warn)(`Optional content group not found: ${id}`);
                  return;
                }
                __privateGet(this, _groups).get(id)._setVisible(INTERNAL, !!visible);
                __privateSet(this, _cachedGetHash, null);
              }
              get hasInitialVisibility() {
                return __privateGet(this, _initialHash) === null || this.getHash() === __privateGet(this, _initialHash);
              }
              getOrder() {
                if (!__privateGet(this, _groups).size) {
                  return null;
                }
                if (__privateGet(this, _order)) {
                  return __privateGet(this, _order).slice();
                }
                return [...__privateGet(this, _groups).keys()];
              }
              getGroups() {
                return __privateGet(this, _groups).size > 0 ? (0, _util2.objectFromMap)(__privateGet(this, _groups)) : null;
              }
              getGroup(id) {
                return __privateGet(this, _groups).get(id) || null;
              }
              getHash() {
                if (__privateGet(this, _cachedGetHash) !== null) {
                  return __privateGet(this, _cachedGetHash);
                }
                const hash = new _murmurhash.MurmurHash3_64();
                for (const [id, group] of __privateGet(this, _groups)) {
                  hash.update(`${id}:${group.visible}`);
                }
                return __privateSet(this, _cachedGetHash, hash.hexdigest());
              }
            };
            _cachedGetHash = new WeakMap();
            _groups = new WeakMap();
            _initialHash = new WeakMap();
            _order = new WeakMap();
            _evaluateVisibilityExpression = new WeakSet();
            evaluateVisibilityExpression_fn = /* @__PURE__ */ __name(function(array) {
              const length = array.length;
              if (length < 2) {
                return true;
              }
              const operator = array[0];
              for (let i2 = 1; i2 < length; i2++) {
                const element = array[i2];
                let state;
                if (Array.isArray(element)) {
                  state = __privateMethod(this, _evaluateVisibilityExpression, evaluateVisibilityExpression_fn).call(this, element);
                } else if (__privateGet(this, _groups).has(element)) {
                  state = __privateGet(this, _groups).get(element).visible;
                } else {
                  (0, _util2.warn)(`Optional content group not found: ${element}`);
                  return true;
                }
                switch (operator) {
                  case "And":
                    if (!state) {
                      return false;
                    }
                    break;
                  case "Or":
                    if (state) {
                      return true;
                    }
                    break;
                  case "Not":
                    return !state;
                  default:
                    return true;
                }
              }
              return operator === "And";
            }, "#evaluateVisibilityExpression");
            __name(_OptionalContentConfig, "OptionalContentConfig");
            let OptionalContentConfig = _OptionalContentConfig;
            exports2.OptionalContentConfig = OptionalContentConfig;
          },
          /* 18 */
          /***/
          (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            exports2.PDFDataTransportStream = void 0;
            var _util2 = __w_pdfjs_require__2(1);
            var _display_utils2 = __w_pdfjs_require__2(6);
            const _PDFDataTransportStream = class _PDFDataTransportStream {
              constructor({
                length,
                initialData,
                progressiveDone = false,
                contentDispositionFilename = null,
                disableRange = false,
                disableStream = false
              }, pdfDataRangeTransport) {
                (0, _util2.assert)(pdfDataRangeTransport, 'PDFDataTransportStream - missing required "pdfDataRangeTransport" argument.');
                this._queuedChunks = [];
                this._progressiveDone = progressiveDone;
                this._contentDispositionFilename = contentDispositionFilename;
                if ((initialData == null ? void 0 : initialData.length) > 0) {
                  const buffer = initialData instanceof Uint8Array && initialData.byteLength === initialData.buffer.byteLength ? initialData.buffer : new Uint8Array(initialData).buffer;
                  this._queuedChunks.push(buffer);
                }
                this._pdfDataRangeTransport = pdfDataRangeTransport;
                this._isStreamingSupported = !disableStream;
                this._isRangeSupported = !disableRange;
                this._contentLength = length;
                this._fullRequestReader = null;
                this._rangeReaders = [];
                this._pdfDataRangeTransport.addRangeListener((begin, chunk) => {
                  this._onReceiveData({
                    begin,
                    chunk
                  });
                });
                this._pdfDataRangeTransport.addProgressListener((loaded, total) => {
                  this._onProgress({
                    loaded,
                    total
                  });
                });
                this._pdfDataRangeTransport.addProgressiveReadListener((chunk) => {
                  this._onReceiveData({
                    chunk
                  });
                });
                this._pdfDataRangeTransport.addProgressiveDoneListener(() => {
                  this._onProgressiveDone();
                });
                this._pdfDataRangeTransport.transportReady();
              }
              _onReceiveData({
                begin,
                chunk
              }) {
                const buffer = chunk instanceof Uint8Array && chunk.byteLength === chunk.buffer.byteLength ? chunk.buffer : new Uint8Array(chunk).buffer;
                if (begin === void 0) {
                  if (this._fullRequestReader) {
                    this._fullRequestReader._enqueue(buffer);
                  } else {
                    this._queuedChunks.push(buffer);
                  }
                } else {
                  const found = this._rangeReaders.some(function(rangeReader) {
                    if (rangeReader._begin !== begin) {
                      return false;
                    }
                    rangeReader._enqueue(buffer);
                    return true;
                  });
                  (0, _util2.assert)(found, "_onReceiveData - no `PDFDataTransportStreamRangeReader` instance found.");
                }
              }
              get _progressiveDataLength() {
                var _a3;
                return ((_a3 = this._fullRequestReader) == null ? void 0 : _a3._loaded) ?? 0;
              }
              _onProgress(evt) {
                var _a3, _b2, _c, _d;
                if (evt.total === void 0) {
                  (_b2 = (_a3 = this._rangeReaders[0]) == null ? void 0 : _a3.onProgress) == null ? void 0 : _b2.call(_a3, {
                    loaded: evt.loaded
                  });
                } else {
                  (_d = (_c = this._fullRequestReader) == null ? void 0 : _c.onProgress) == null ? void 0 : _d.call(_c, {
                    loaded: evt.loaded,
                    total: evt.total
                  });
                }
              }
              _onProgressiveDone() {
                var _a3;
                (_a3 = this._fullRequestReader) == null ? void 0 : _a3.progressiveDone();
                this._progressiveDone = true;
              }
              _removeRangeReader(reader) {
                const i2 = this._rangeReaders.indexOf(reader);
                if (i2 >= 0) {
                  this._rangeReaders.splice(i2, 1);
                }
              }
              getFullReader() {
                (0, _util2.assert)(!this._fullRequestReader, "PDFDataTransportStream.getFullReader can only be called once.");
                const queuedChunks = this._queuedChunks;
                this._queuedChunks = null;
                return new PDFDataTransportStreamReader(this, queuedChunks, this._progressiveDone, this._contentDispositionFilename);
              }
              getRangeReader(begin, end) {
                if (end <= this._progressiveDataLength) {
                  return null;
                }
                const reader = new PDFDataTransportStreamRangeReader(this, begin, end);
                this._pdfDataRangeTransport.requestDataRange(begin, end);
                this._rangeReaders.push(reader);
                return reader;
              }
              cancelAllRequests(reason) {
                var _a3;
                (_a3 = this._fullRequestReader) == null ? void 0 : _a3.cancel(reason);
                for (const reader of this._rangeReaders.slice(0)) {
                  reader.cancel(reason);
                }
                this._pdfDataRangeTransport.abort();
              }
            };
            __name(_PDFDataTransportStream, "PDFDataTransportStream");
            let PDFDataTransportStream = _PDFDataTransportStream;
            exports2.PDFDataTransportStream = PDFDataTransportStream;
            const _PDFDataTransportStreamReader = class _PDFDataTransportStreamReader {
              constructor(stream, queuedChunks, progressiveDone = false, contentDispositionFilename = null) {
                this._stream = stream;
                this._done = progressiveDone || false;
                this._filename = (0, _display_utils2.isPdfFile)(contentDispositionFilename) ? contentDispositionFilename : null;
                this._queuedChunks = queuedChunks || [];
                this._loaded = 0;
                for (const chunk of this._queuedChunks) {
                  this._loaded += chunk.byteLength;
                }
                this._requests = [];
                this._headersReady = Promise.resolve();
                stream._fullRequestReader = this;
                this.onProgress = null;
              }
              _enqueue(chunk) {
                if (this._done) {
                  return;
                }
                if (this._requests.length > 0) {
                  const requestCapability = this._requests.shift();
                  requestCapability.resolve({
                    value: chunk,
                    done: false
                  });
                } else {
                  this._queuedChunks.push(chunk);
                }
                this._loaded += chunk.byteLength;
              }
              get headersReady() {
                return this._headersReady;
              }
              get filename() {
                return this._filename;
              }
              get isRangeSupported() {
                return this._stream._isRangeSupported;
              }
              get isStreamingSupported() {
                return this._stream._isStreamingSupported;
              }
              get contentLength() {
                return this._stream._contentLength;
              }
              async read() {
                if (this._queuedChunks.length > 0) {
                  const chunk = this._queuedChunks.shift();
                  return {
                    value: chunk,
                    done: false
                  };
                }
                if (this._done) {
                  return {
                    value: void 0,
                    done: true
                  };
                }
                const requestCapability = new _util2.PromiseCapability();
                this._requests.push(requestCapability);
                return requestCapability.promise;
              }
              cancel(reason) {
                this._done = true;
                for (const requestCapability of this._requests) {
                  requestCapability.resolve({
                    value: void 0,
                    done: true
                  });
                }
                this._requests.length = 0;
              }
              progressiveDone() {
                if (this._done) {
                  return;
                }
                this._done = true;
              }
            };
            __name(_PDFDataTransportStreamReader, "PDFDataTransportStreamReader");
            let PDFDataTransportStreamReader = _PDFDataTransportStreamReader;
            const _PDFDataTransportStreamRangeReader = class _PDFDataTransportStreamRangeReader {
              constructor(stream, begin, end) {
                this._stream = stream;
                this._begin = begin;
                this._end = end;
                this._queuedChunk = null;
                this._requests = [];
                this._done = false;
                this.onProgress = null;
              }
              _enqueue(chunk) {
                if (this._done) {
                  return;
                }
                if (this._requests.length === 0) {
                  this._queuedChunk = chunk;
                } else {
                  const requestsCapability = this._requests.shift();
                  requestsCapability.resolve({
                    value: chunk,
                    done: false
                  });
                  for (const requestCapability of this._requests) {
                    requestCapability.resolve({
                      value: void 0,
                      done: true
                    });
                  }
                  this._requests.length = 0;
                }
                this._done = true;
                this._stream._removeRangeReader(this);
              }
              get isStreamingSupported() {
                return false;
              }
              async read() {
                if (this._queuedChunk) {
                  const chunk = this._queuedChunk;
                  this._queuedChunk = null;
                  return {
                    value: chunk,
                    done: false
                  };
                }
                if (this._done) {
                  return {
                    value: void 0,
                    done: true
                  };
                }
                const requestCapability = new _util2.PromiseCapability();
                this._requests.push(requestCapability);
                return requestCapability.promise;
              }
              cancel(reason) {
                this._done = true;
                for (const requestCapability of this._requests) {
                  requestCapability.resolve({
                    value: void 0,
                    done: true
                  });
                }
                this._requests.length = 0;
                this._stream._removeRangeReader(this);
              }
            };
            __name(_PDFDataTransportStreamRangeReader, "PDFDataTransportStreamRangeReader");
            let PDFDataTransportStreamRangeReader = _PDFDataTransportStreamRangeReader;
          },
          /* 19 */
          /***/
          (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            exports2.PDFFetchStream = void 0;
            var _util2 = __w_pdfjs_require__2(1);
            var _network_utils = __w_pdfjs_require__2(20);
            function createFetchOptions(headers, withCredentials, abortController) {
              return {
                method: "GET",
                headers,
                signal: abortController.signal,
                mode: "cors",
                credentials: withCredentials ? "include" : "same-origin",
                redirect: "follow"
              };
            }
            __name(createFetchOptions, "createFetchOptions");
            function createHeaders(httpHeaders) {
              const headers = new Headers();
              for (const property in httpHeaders) {
                const value = httpHeaders[property];
                if (value === void 0) {
                  continue;
                }
                headers.append(property, value);
              }
              return headers;
            }
            __name(createHeaders, "createHeaders");
            function getArrayBuffer(val) {
              if (val instanceof Uint8Array) {
                return val.buffer;
              }
              if (val instanceof ArrayBuffer) {
                return val;
              }
              (0, _util2.warn)(`getArrayBuffer - unexpected data format: ${val}`);
              return new Uint8Array(val).buffer;
            }
            __name(getArrayBuffer, "getArrayBuffer");
            const _PDFFetchStream = class _PDFFetchStream {
              constructor(source) {
                this.source = source;
                this.isHttp = /^https?:/i.test(source.url);
                this.httpHeaders = this.isHttp && source.httpHeaders || {};
                this._fullRequestReader = null;
                this._rangeRequestReaders = [];
              }
              get _progressiveDataLength() {
                var _a3;
                return ((_a3 = this._fullRequestReader) == null ? void 0 : _a3._loaded) ?? 0;
              }
              getFullReader() {
                (0, _util2.assert)(!this._fullRequestReader, "PDFFetchStream.getFullReader can only be called once.");
                this._fullRequestReader = new PDFFetchStreamReader(this);
                return this._fullRequestReader;
              }
              getRangeReader(begin, end) {
                if (end <= this._progressiveDataLength) {
                  return null;
                }
                const reader = new PDFFetchStreamRangeReader(this, begin, end);
                this._rangeRequestReaders.push(reader);
                return reader;
              }
              cancelAllRequests(reason) {
                var _a3;
                (_a3 = this._fullRequestReader) == null ? void 0 : _a3.cancel(reason);
                for (const reader of this._rangeRequestReaders.slice(0)) {
                  reader.cancel(reason);
                }
              }
            };
            __name(_PDFFetchStream, "PDFFetchStream");
            let PDFFetchStream = _PDFFetchStream;
            exports2.PDFFetchStream = PDFFetchStream;
            const _PDFFetchStreamReader = class _PDFFetchStreamReader {
              constructor(stream) {
                this._stream = stream;
                this._reader = null;
                this._loaded = 0;
                this._filename = null;
                const source = stream.source;
                this._withCredentials = source.withCredentials || false;
                this._contentLength = source.length;
                this._headersCapability = new _util2.PromiseCapability();
                this._disableRange = source.disableRange || false;
                this._rangeChunkSize = source.rangeChunkSize;
                if (!this._rangeChunkSize && !this._disableRange) {
                  this._disableRange = true;
                }
                this._abortController = new AbortController();
                this._isStreamingSupported = !source.disableStream;
                this._isRangeSupported = !source.disableRange;
                this._headers = createHeaders(this._stream.httpHeaders);
                const url = source.url;
                fetch(url, createFetchOptions(this._headers, this._withCredentials, this._abortController)).then((response) => {
                  if (!(0, _network_utils.validateResponseStatus)(response.status)) {
                    throw (0, _network_utils.createResponseStatusError)(response.status, url);
                  }
                  this._reader = response.body.getReader();
                  this._headersCapability.resolve();
                  const getResponseHeader = /* @__PURE__ */ __name((name) => {
                    return response.headers.get(name);
                  }, "getResponseHeader");
                  const {
                    allowRangeRequests,
                    suggestedLength
                  } = (0, _network_utils.validateRangeRequestCapabilities)({
                    getResponseHeader,
                    isHttp: this._stream.isHttp,
                    rangeChunkSize: this._rangeChunkSize,
                    disableRange: this._disableRange
                  });
                  this._isRangeSupported = allowRangeRequests;
                  this._contentLength = suggestedLength || this._contentLength;
                  this._filename = (0, _network_utils.extractFilenameFromHeader)(getResponseHeader);
                  if (!this._isStreamingSupported && this._isRangeSupported) {
                    this.cancel(new _util2.AbortException("Streaming is disabled."));
                  }
                }).catch(this._headersCapability.reject);
                this.onProgress = null;
              }
              get headersReady() {
                return this._headersCapability.promise;
              }
              get filename() {
                return this._filename;
              }
              get contentLength() {
                return this._contentLength;
              }
              get isRangeSupported() {
                return this._isRangeSupported;
              }
              get isStreamingSupported() {
                return this._isStreamingSupported;
              }
              async read() {
                var _a3;
                await this._headersCapability.promise;
                const {
                  value,
                  done
                } = await this._reader.read();
                if (done) {
                  return {
                    value,
                    done
                  };
                }
                this._loaded += value.byteLength;
                (_a3 = this.onProgress) == null ? void 0 : _a3.call(this, {
                  loaded: this._loaded,
                  total: this._contentLength
                });
                return {
                  value: getArrayBuffer(value),
                  done: false
                };
              }
              cancel(reason) {
                var _a3;
                (_a3 = this._reader) == null ? void 0 : _a3.cancel(reason);
                this._abortController.abort();
              }
            };
            __name(_PDFFetchStreamReader, "PDFFetchStreamReader");
            let PDFFetchStreamReader = _PDFFetchStreamReader;
            const _PDFFetchStreamRangeReader = class _PDFFetchStreamRangeReader {
              constructor(stream, begin, end) {
                this._stream = stream;
                this._reader = null;
                this._loaded = 0;
                const source = stream.source;
                this._withCredentials = source.withCredentials || false;
                this._readCapability = new _util2.PromiseCapability();
                this._isStreamingSupported = !source.disableStream;
                this._abortController = new AbortController();
                this._headers = createHeaders(this._stream.httpHeaders);
                this._headers.append("Range", `bytes=${begin}-${end - 1}`);
                const url = source.url;
                fetch(url, createFetchOptions(this._headers, this._withCredentials, this._abortController)).then((response) => {
                  if (!(0, _network_utils.validateResponseStatus)(response.status)) {
                    throw (0, _network_utils.createResponseStatusError)(response.status, url);
                  }
                  this._readCapability.resolve();
                  this._reader = response.body.getReader();
                }).catch(this._readCapability.reject);
                this.onProgress = null;
              }
              get isStreamingSupported() {
                return this._isStreamingSupported;
              }
              async read() {
                var _a3;
                await this._readCapability.promise;
                const {
                  value,
                  done
                } = await this._reader.read();
                if (done) {
                  return {
                    value,
                    done
                  };
                }
                this._loaded += value.byteLength;
                (_a3 = this.onProgress) == null ? void 0 : _a3.call(this, {
                  loaded: this._loaded
                });
                return {
                  value: getArrayBuffer(value),
                  done: false
                };
              }
              cancel(reason) {
                var _a3;
                (_a3 = this._reader) == null ? void 0 : _a3.cancel(reason);
                this._abortController.abort();
              }
            };
            __name(_PDFFetchStreamRangeReader, "PDFFetchStreamRangeReader");
            let PDFFetchStreamRangeReader = _PDFFetchStreamRangeReader;
          },
          /* 20 */
          /***/
          (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            exports2.createResponseStatusError = createResponseStatusError;
            exports2.extractFilenameFromHeader = extractFilenameFromHeader;
            exports2.validateRangeRequestCapabilities = validateRangeRequestCapabilities;
            exports2.validateResponseStatus = validateResponseStatus;
            var _util2 = __w_pdfjs_require__2(1);
            var _content_disposition = __w_pdfjs_require__2(21);
            var _display_utils2 = __w_pdfjs_require__2(6);
            function validateRangeRequestCapabilities({
              getResponseHeader,
              isHttp,
              rangeChunkSize,
              disableRange
            }) {
              const returnValues = {
                allowRangeRequests: false,
                suggestedLength: void 0
              };
              const length = parseInt(getResponseHeader("Content-Length"), 10);
              if (!Number.isInteger(length)) {
                return returnValues;
              }
              returnValues.suggestedLength = length;
              if (length <= 2 * rangeChunkSize) {
                return returnValues;
              }
              if (disableRange || !isHttp) {
                return returnValues;
              }
              if (getResponseHeader("Accept-Ranges") !== "bytes") {
                return returnValues;
              }
              const contentEncoding = getResponseHeader("Content-Encoding") || "identity";
              if (contentEncoding !== "identity") {
                return returnValues;
              }
              returnValues.allowRangeRequests = true;
              return returnValues;
            }
            __name(validateRangeRequestCapabilities, "validateRangeRequestCapabilities");
            function extractFilenameFromHeader(getResponseHeader) {
              const contentDisposition = getResponseHeader("Content-Disposition");
              if (contentDisposition) {
                let filename = (0, _content_disposition.getFilenameFromContentDispositionHeader)(contentDisposition);
                if (filename.includes("%")) {
                  try {
                    filename = decodeURIComponent(filename);
                  } catch {
                  }
                }
                if ((0, _display_utils2.isPdfFile)(filename)) {
                  return filename;
                }
              }
              return null;
            }
            __name(extractFilenameFromHeader, "extractFilenameFromHeader");
            function createResponseStatusError(status, url) {
              if (status === 404 || status === 0 && url.startsWith("file:")) {
                return new _util2.MissingPDFException('Missing PDF "' + url + '".');
              }
              return new _util2.UnexpectedResponseException(`Unexpected server response (${status}) while retrieving PDF "${url}".`, status);
            }
            __name(createResponseStatusError, "createResponseStatusError");
            function validateResponseStatus(status) {
              return status === 200 || status === 206;
            }
            __name(validateResponseStatus, "validateResponseStatus");
          },
          /* 21 */
          /***/
          (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            exports2.getFilenameFromContentDispositionHeader = getFilenameFromContentDispositionHeader;
            var _util2 = __w_pdfjs_require__2(1);
            function getFilenameFromContentDispositionHeader(contentDisposition) {
              let needsEncodingFixup = true;
              let tmp = toParamRegExp("filename\\*", "i").exec(contentDisposition);
              if (tmp) {
                tmp = tmp[1];
                let filename = rfc2616unquote(tmp);
                filename = unescape(filename);
                filename = rfc5987decode(filename);
                filename = rfc2047decode(filename);
                return fixupEncoding(filename);
              }
              tmp = rfc2231getparam(contentDisposition);
              if (tmp) {
                const filename = rfc2047decode(tmp);
                return fixupEncoding(filename);
              }
              tmp = toParamRegExp("filename", "i").exec(contentDisposition);
              if (tmp) {
                tmp = tmp[1];
                let filename = rfc2616unquote(tmp);
                filename = rfc2047decode(filename);
                return fixupEncoding(filename);
              }
              function toParamRegExp(attributePattern, flags) {
                return new RegExp("(?:^|;)\\s*" + attributePattern + '\\s*=\\s*([^";\\s][^;\\s]*|"(?:[^"\\\\]|\\\\"?)+"?)', flags);
              }
              __name(toParamRegExp, "toParamRegExp");
              function textdecode(encoding, value) {
                if (encoding) {
                  if (!/^[\x00-\xFF]+$/.test(value)) {
                    return value;
                  }
                  try {
                    const decoder = new TextDecoder(encoding, {
                      fatal: true
                    });
                    const buffer = (0, _util2.stringToBytes)(value);
                    value = decoder.decode(buffer);
                    needsEncodingFixup = false;
                  } catch {
                  }
                }
                return value;
              }
              __name(textdecode, "textdecode");
              function fixupEncoding(value) {
                if (needsEncodingFixup && /[\x80-\xff]/.test(value)) {
                  value = textdecode("utf-8", value);
                  if (needsEncodingFixup) {
                    value = textdecode("iso-8859-1", value);
                  }
                }
                return value;
              }
              __name(fixupEncoding, "fixupEncoding");
              function rfc2231getparam(contentDispositionStr) {
                const matches = [];
                let match;
                const iter = toParamRegExp("filename\\*((?!0\\d)\\d+)(\\*?)", "ig");
                while ((match = iter.exec(contentDispositionStr)) !== null) {
                  let [, n2, quot, part] = match;
                  n2 = parseInt(n2, 10);
                  if (n2 in matches) {
                    if (n2 === 0) {
                      break;
                    }
                    continue;
                  }
                  matches[n2] = [quot, part];
                }
                const parts = [];
                for (let n2 = 0; n2 < matches.length; ++n2) {
                  if (!(n2 in matches)) {
                    break;
                  }
                  let [quot, part] = matches[n2];
                  part = rfc2616unquote(part);
                  if (quot) {
                    part = unescape(part);
                    if (n2 === 0) {
                      part = rfc5987decode(part);
                    }
                  }
                  parts.push(part);
                }
                return parts.join("");
              }
              __name(rfc2231getparam, "rfc2231getparam");
              function rfc2616unquote(value) {
                if (value.startsWith('"')) {
                  const parts = value.slice(1).split('\\"');
                  for (let i2 = 0; i2 < parts.length; ++i2) {
                    const quotindex = parts[i2].indexOf('"');
                    if (quotindex !== -1) {
                      parts[i2] = parts[i2].slice(0, quotindex);
                      parts.length = i2 + 1;
                    }
                    parts[i2] = parts[i2].replaceAll(/\\(.)/g, "$1");
                  }
                  value = parts.join('"');
                }
                return value;
              }
              __name(rfc2616unquote, "rfc2616unquote");
              function rfc5987decode(extvalue) {
                const encodingend = extvalue.indexOf("'");
                if (encodingend === -1) {
                  return extvalue;
                }
                const encoding = extvalue.slice(0, encodingend);
                const langvalue = extvalue.slice(encodingend + 1);
                const value = langvalue.replace(/^[^']*'/, "");
                return textdecode(encoding, value);
              }
              __name(rfc5987decode, "rfc5987decode");
              function rfc2047decode(value) {
                if (!value.startsWith("=?") || /[\x00-\x19\x80-\xff]/.test(value)) {
                  return value;
                }
                return value.replaceAll(/=\?([\w-]*)\?([QqBb])\?((?:[^?]|\?(?!=))*)\?=/g, function(matches, charset, encoding, text) {
                  if (encoding === "q" || encoding === "Q") {
                    text = text.replaceAll("_", " ");
                    text = text.replaceAll(/=([0-9a-fA-F]{2})/g, function(match, hex2) {
                      return String.fromCharCode(parseInt(hex2, 16));
                    });
                    return textdecode(charset, text);
                  }
                  try {
                    text = atob(text);
                  } catch {
                  }
                  return textdecode(charset, text);
                });
              }
              __name(rfc2047decode, "rfc2047decode");
              return "";
            }
            __name(getFilenameFromContentDispositionHeader, "getFilenameFromContentDispositionHeader");
          },
          /* 22 */
          /***/
          (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            exports2.PDFNetworkStream = void 0;
            var _util2 = __w_pdfjs_require__2(1);
            var _network_utils = __w_pdfjs_require__2(20);
            const OK_RESPONSE = 200;
            const PARTIAL_CONTENT_RESPONSE = 206;
            function getArrayBuffer(xhr) {
              const data = xhr.response;
              if (typeof data !== "string") {
                return data;
              }
              return (0, _util2.stringToBytes)(data).buffer;
            }
            __name(getArrayBuffer, "getArrayBuffer");
            const _NetworkManager = class _NetworkManager {
              constructor(url, args = {}) {
                this.url = url;
                this.isHttp = /^https?:/i.test(url);
                this.httpHeaders = this.isHttp && args.httpHeaders || /* @__PURE__ */ Object.create(null);
                this.withCredentials = args.withCredentials || false;
                this.currXhrId = 0;
                this.pendingRequests = /* @__PURE__ */ Object.create(null);
              }
              requestRange(begin, end, listeners) {
                const args = {
                  begin,
                  end
                };
                for (const prop in listeners) {
                  args[prop] = listeners[prop];
                }
                return this.request(args);
              }
              requestFull(listeners) {
                return this.request(listeners);
              }
              request(args) {
                const xhr = new XMLHttpRequest();
                const xhrId = this.currXhrId++;
                const pendingRequest = this.pendingRequests[xhrId] = {
                  xhr
                };
                xhr.open("GET", this.url);
                xhr.withCredentials = this.withCredentials;
                for (const property in this.httpHeaders) {
                  const value = this.httpHeaders[property];
                  if (value === void 0) {
                    continue;
                  }
                  xhr.setRequestHeader(property, value);
                }
                if (this.isHttp && "begin" in args && "end" in args) {
                  xhr.setRequestHeader("Range", `bytes=${args.begin}-${args.end - 1}`);
                  pendingRequest.expectedStatus = PARTIAL_CONTENT_RESPONSE;
                } else {
                  pendingRequest.expectedStatus = OK_RESPONSE;
                }
                xhr.responseType = "arraybuffer";
                if (args.onError) {
                  xhr.onerror = function(evt) {
                    args.onError(xhr.status);
                  };
                }
                xhr.onreadystatechange = this.onStateChange.bind(this, xhrId);
                xhr.onprogress = this.onProgress.bind(this, xhrId);
                pendingRequest.onHeadersReceived = args.onHeadersReceived;
                pendingRequest.onDone = args.onDone;
                pendingRequest.onError = args.onError;
                pendingRequest.onProgress = args.onProgress;
                xhr.send(null);
                return xhrId;
              }
              onProgress(xhrId, evt) {
                var _a3;
                const pendingRequest = this.pendingRequests[xhrId];
                if (!pendingRequest) {
                  return;
                }
                (_a3 = pendingRequest.onProgress) == null ? void 0 : _a3.call(pendingRequest, evt);
              }
              onStateChange(xhrId, evt) {
                var _a3, _b2, _c;
                const pendingRequest = this.pendingRequests[xhrId];
                if (!pendingRequest) {
                  return;
                }
                const xhr = pendingRequest.xhr;
                if (xhr.readyState >= 2 && pendingRequest.onHeadersReceived) {
                  pendingRequest.onHeadersReceived();
                  delete pendingRequest.onHeadersReceived;
                }
                if (xhr.readyState !== 4) {
                  return;
                }
                if (!(xhrId in this.pendingRequests)) {
                  return;
                }
                delete this.pendingRequests[xhrId];
                if (xhr.status === 0 && this.isHttp) {
                  (_a3 = pendingRequest.onError) == null ? void 0 : _a3.call(pendingRequest, xhr.status);
                  return;
                }
                const xhrStatus = xhr.status || OK_RESPONSE;
                const ok_response_on_range_request = xhrStatus === OK_RESPONSE && pendingRequest.expectedStatus === PARTIAL_CONTENT_RESPONSE;
                if (!ok_response_on_range_request && xhrStatus !== pendingRequest.expectedStatus) {
                  (_b2 = pendingRequest.onError) == null ? void 0 : _b2.call(pendingRequest, xhr.status);
                  return;
                }
                const chunk = getArrayBuffer(xhr);
                if (xhrStatus === PARTIAL_CONTENT_RESPONSE) {
                  const rangeHeader = xhr.getResponseHeader("Content-Range");
                  const matches = /bytes (\d+)-(\d+)\/(\d+)/.exec(rangeHeader);
                  pendingRequest.onDone({
                    begin: parseInt(matches[1], 10),
                    chunk
                  });
                } else if (chunk) {
                  pendingRequest.onDone({
                    begin: 0,
                    chunk
                  });
                } else {
                  (_c = pendingRequest.onError) == null ? void 0 : _c.call(pendingRequest, xhr.status);
                }
              }
              getRequestXhr(xhrId) {
                return this.pendingRequests[xhrId].xhr;
              }
              isPendingRequest(xhrId) {
                return xhrId in this.pendingRequests;
              }
              abortRequest(xhrId) {
                const xhr = this.pendingRequests[xhrId].xhr;
                delete this.pendingRequests[xhrId];
                xhr.abort();
              }
            };
            __name(_NetworkManager, "NetworkManager");
            let NetworkManager = _NetworkManager;
            const _PDFNetworkStream = class _PDFNetworkStream {
              constructor(source) {
                this._source = source;
                this._manager = new NetworkManager(source.url, {
                  httpHeaders: source.httpHeaders,
                  withCredentials: source.withCredentials
                });
                this._rangeChunkSize = source.rangeChunkSize;
                this._fullRequestReader = null;
                this._rangeRequestReaders = [];
              }
              _onRangeRequestReaderClosed(reader) {
                const i2 = this._rangeRequestReaders.indexOf(reader);
                if (i2 >= 0) {
                  this._rangeRequestReaders.splice(i2, 1);
                }
              }
              getFullReader() {
                (0, _util2.assert)(!this._fullRequestReader, "PDFNetworkStream.getFullReader can only be called once.");
                this._fullRequestReader = new PDFNetworkStreamFullRequestReader(this._manager, this._source);
                return this._fullRequestReader;
              }
              getRangeReader(begin, end) {
                const reader = new PDFNetworkStreamRangeRequestReader(this._manager, begin, end);
                reader.onClosed = this._onRangeRequestReaderClosed.bind(this);
                this._rangeRequestReaders.push(reader);
                return reader;
              }
              cancelAllRequests(reason) {
                var _a3;
                (_a3 = this._fullRequestReader) == null ? void 0 : _a3.cancel(reason);
                for (const reader of this._rangeRequestReaders.slice(0)) {
                  reader.cancel(reason);
                }
              }
            };
            __name(_PDFNetworkStream, "PDFNetworkStream");
            let PDFNetworkStream = _PDFNetworkStream;
            exports2.PDFNetworkStream = PDFNetworkStream;
            const _PDFNetworkStreamFullRequestReader = class _PDFNetworkStreamFullRequestReader {
              constructor(manager, source) {
                this._manager = manager;
                const args = {
                  onHeadersReceived: this._onHeadersReceived.bind(this),
                  onDone: this._onDone.bind(this),
                  onError: this._onError.bind(this),
                  onProgress: this._onProgress.bind(this)
                };
                this._url = source.url;
                this._fullRequestId = manager.requestFull(args);
                this._headersReceivedCapability = new _util2.PromiseCapability();
                this._disableRange = source.disableRange || false;
                this._contentLength = source.length;
                this._rangeChunkSize = source.rangeChunkSize;
                if (!this._rangeChunkSize && !this._disableRange) {
                  this._disableRange = true;
                }
                this._isStreamingSupported = false;
                this._isRangeSupported = false;
                this._cachedChunks = [];
                this._requests = [];
                this._done = false;
                this._storedError = void 0;
                this._filename = null;
                this.onProgress = null;
              }
              _onHeadersReceived() {
                const fullRequestXhrId = this._fullRequestId;
                const fullRequestXhr = this._manager.getRequestXhr(fullRequestXhrId);
                const getResponseHeader = /* @__PURE__ */ __name((name) => {
                  return fullRequestXhr.getResponseHeader(name);
                }, "getResponseHeader");
                const {
                  allowRangeRequests,
                  suggestedLength
                } = (0, _network_utils.validateRangeRequestCapabilities)({
                  getResponseHeader,
                  isHttp: this._manager.isHttp,
                  rangeChunkSize: this._rangeChunkSize,
                  disableRange: this._disableRange
                });
                if (allowRangeRequests) {
                  this._isRangeSupported = true;
                }
                this._contentLength = suggestedLength || this._contentLength;
                this._filename = (0, _network_utils.extractFilenameFromHeader)(getResponseHeader);
                if (this._isRangeSupported) {
                  this._manager.abortRequest(fullRequestXhrId);
                }
                this._headersReceivedCapability.resolve();
              }
              _onDone(data) {
                if (data) {
                  if (this._requests.length > 0) {
                    const requestCapability = this._requests.shift();
                    requestCapability.resolve({
                      value: data.chunk,
                      done: false
                    });
                  } else {
                    this._cachedChunks.push(data.chunk);
                  }
                }
                this._done = true;
                if (this._cachedChunks.length > 0) {
                  return;
                }
                for (const requestCapability of this._requests) {
                  requestCapability.resolve({
                    value: void 0,
                    done: true
                  });
                }
                this._requests.length = 0;
              }
              _onError(status) {
                this._storedError = (0, _network_utils.createResponseStatusError)(status, this._url);
                this._headersReceivedCapability.reject(this._storedError);
                for (const requestCapability of this._requests) {
                  requestCapability.reject(this._storedError);
                }
                this._requests.length = 0;
                this._cachedChunks.length = 0;
              }
              _onProgress(evt) {
                var _a3;
                (_a3 = this.onProgress) == null ? void 0 : _a3.call(this, {
                  loaded: evt.loaded,
                  total: evt.lengthComputable ? evt.total : this._contentLength
                });
              }
              get filename() {
                return this._filename;
              }
              get isRangeSupported() {
                return this._isRangeSupported;
              }
              get isStreamingSupported() {
                return this._isStreamingSupported;
              }
              get contentLength() {
                return this._contentLength;
              }
              get headersReady() {
                return this._headersReceivedCapability.promise;
              }
              async read() {
                if (this._storedError) {
                  throw this._storedError;
                }
                if (this._cachedChunks.length > 0) {
                  const chunk = this._cachedChunks.shift();
                  return {
                    value: chunk,
                    done: false
                  };
                }
                if (this._done) {
                  return {
                    value: void 0,
                    done: true
                  };
                }
                const requestCapability = new _util2.PromiseCapability();
                this._requests.push(requestCapability);
                return requestCapability.promise;
              }
              cancel(reason) {
                this._done = true;
                this._headersReceivedCapability.reject(reason);
                for (const requestCapability of this._requests) {
                  requestCapability.resolve({
                    value: void 0,
                    done: true
                  });
                }
                this._requests.length = 0;
                if (this._manager.isPendingRequest(this._fullRequestId)) {
                  this._manager.abortRequest(this._fullRequestId);
                }
                this._fullRequestReader = null;
              }
            };
            __name(_PDFNetworkStreamFullRequestReader, "PDFNetworkStreamFullRequestReader");
            let PDFNetworkStreamFullRequestReader = _PDFNetworkStreamFullRequestReader;
            const _PDFNetworkStreamRangeRequestReader = class _PDFNetworkStreamRangeRequestReader {
              constructor(manager, begin, end) {
                this._manager = manager;
                const args = {
                  onDone: this._onDone.bind(this),
                  onError: this._onError.bind(this),
                  onProgress: this._onProgress.bind(this)
                };
                this._url = manager.url;
                this._requestId = manager.requestRange(begin, end, args);
                this._requests = [];
                this._queuedChunk = null;
                this._done = false;
                this._storedError = void 0;
                this.onProgress = null;
                this.onClosed = null;
              }
              _close() {
                var _a3;
                (_a3 = this.onClosed) == null ? void 0 : _a3.call(this, this);
              }
              _onDone(data) {
                const chunk = data.chunk;
                if (this._requests.length > 0) {
                  const requestCapability = this._requests.shift();
                  requestCapability.resolve({
                    value: chunk,
                    done: false
                  });
                } else {
                  this._queuedChunk = chunk;
                }
                this._done = true;
                for (const requestCapability of this._requests) {
                  requestCapability.resolve({
                    value: void 0,
                    done: true
                  });
                }
                this._requests.length = 0;
                this._close();
              }
              _onError(status) {
                this._storedError = (0, _network_utils.createResponseStatusError)(status, this._url);
                for (const requestCapability of this._requests) {
                  requestCapability.reject(this._storedError);
                }
                this._requests.length = 0;
                this._queuedChunk = null;
              }
              _onProgress(evt) {
                var _a3;
                if (!this.isStreamingSupported) {
                  (_a3 = this.onProgress) == null ? void 0 : _a3.call(this, {
                    loaded: evt.loaded
                  });
                }
              }
              get isStreamingSupported() {
                return false;
              }
              async read() {
                if (this._storedError) {
                  throw this._storedError;
                }
                if (this._queuedChunk !== null) {
                  const chunk = this._queuedChunk;
                  this._queuedChunk = null;
                  return {
                    value: chunk,
                    done: false
                  };
                }
                if (this._done) {
                  return {
                    value: void 0,
                    done: true
                  };
                }
                const requestCapability = new _util2.PromiseCapability();
                this._requests.push(requestCapability);
                return requestCapability.promise;
              }
              cancel(reason) {
                this._done = true;
                for (const requestCapability of this._requests) {
                  requestCapability.resolve({
                    value: void 0,
                    done: true
                  });
                }
                this._requests.length = 0;
                if (this._manager.isPendingRequest(this._requestId)) {
                  this._manager.abortRequest(this._requestId);
                }
                this._close();
              }
            };
            __name(_PDFNetworkStreamRangeRequestReader, "PDFNetworkStreamRangeRequestReader");
            let PDFNetworkStreamRangeRequestReader = _PDFNetworkStreamRangeRequestReader;
          },
          /* 23 */
          /***/
          (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            exports2.PDFNodeStream = void 0;
            var _util2 = __w_pdfjs_require__2(1);
            var _network_utils = __w_pdfjs_require__2(20);
            const fileUriRegex = /^file:\/\/\/[a-zA-Z]:\//;
            function parseUrl(sourceUrl) {
              const url = require$$5;
              const parsedUrl = url.parse(sourceUrl);
              if (parsedUrl.protocol === "file:" || parsedUrl.host) {
                return parsedUrl;
              }
              if (/^[a-z]:[/\\]/i.test(sourceUrl)) {
                return url.parse(`file:///${sourceUrl}`);
              }
              if (!parsedUrl.host) {
                parsedUrl.protocol = "file:";
              }
              return parsedUrl;
            }
            __name(parseUrl, "parseUrl");
            const _PDFNodeStream = class _PDFNodeStream {
              constructor(source) {
                this.source = source;
                this.url = parseUrl(source.url);
                this.isHttp = this.url.protocol === "http:" || this.url.protocol === "https:";
                this.isFsUrl = this.url.protocol === "file:";
                this.httpHeaders = this.isHttp && source.httpHeaders || {};
                this._fullRequestReader = null;
                this._rangeRequestReaders = [];
              }
              get _progressiveDataLength() {
                var _a3;
                return ((_a3 = this._fullRequestReader) == null ? void 0 : _a3._loaded) ?? 0;
              }
              getFullReader() {
                (0, _util2.assert)(!this._fullRequestReader, "PDFNodeStream.getFullReader can only be called once.");
                this._fullRequestReader = this.isFsUrl ? new PDFNodeStreamFsFullReader(this) : new PDFNodeStreamFullReader(this);
                return this._fullRequestReader;
              }
              getRangeReader(start, end) {
                if (end <= this._progressiveDataLength) {
                  return null;
                }
                const rangeReader = this.isFsUrl ? new PDFNodeStreamFsRangeReader(this, start, end) : new PDFNodeStreamRangeReader(this, start, end);
                this._rangeRequestReaders.push(rangeReader);
                return rangeReader;
              }
              cancelAllRequests(reason) {
                var _a3;
                (_a3 = this._fullRequestReader) == null ? void 0 : _a3.cancel(reason);
                for (const reader of this._rangeRequestReaders.slice(0)) {
                  reader.cancel(reason);
                }
              }
            };
            __name(_PDFNodeStream, "PDFNodeStream");
            let PDFNodeStream = _PDFNodeStream;
            exports2.PDFNodeStream = PDFNodeStream;
            const _BaseFullReader = class _BaseFullReader {
              constructor(stream) {
                this._url = stream.url;
                this._done = false;
                this._storedError = null;
                this.onProgress = null;
                const source = stream.source;
                this._contentLength = source.length;
                this._loaded = 0;
                this._filename = null;
                this._disableRange = source.disableRange || false;
                this._rangeChunkSize = source.rangeChunkSize;
                if (!this._rangeChunkSize && !this._disableRange) {
                  this._disableRange = true;
                }
                this._isStreamingSupported = !source.disableStream;
                this._isRangeSupported = !source.disableRange;
                this._readableStream = null;
                this._readCapability = new _util2.PromiseCapability();
                this._headersCapability = new _util2.PromiseCapability();
              }
              get headersReady() {
                return this._headersCapability.promise;
              }
              get filename() {
                return this._filename;
              }
              get contentLength() {
                return this._contentLength;
              }
              get isRangeSupported() {
                return this._isRangeSupported;
              }
              get isStreamingSupported() {
                return this._isStreamingSupported;
              }
              async read() {
                var _a3;
                await this._readCapability.promise;
                if (this._done) {
                  return {
                    value: void 0,
                    done: true
                  };
                }
                if (this._storedError) {
                  throw this._storedError;
                }
                const chunk = this._readableStream.read();
                if (chunk === null) {
                  this._readCapability = new _util2.PromiseCapability();
                  return this.read();
                }
                this._loaded += chunk.length;
                (_a3 = this.onProgress) == null ? void 0 : _a3.call(this, {
                  loaded: this._loaded,
                  total: this._contentLength
                });
                const buffer = new Uint8Array(chunk).buffer;
                return {
                  value: buffer,
                  done: false
                };
              }
              cancel(reason) {
                if (!this._readableStream) {
                  this._error(reason);
                  return;
                }
                this._readableStream.destroy(reason);
              }
              _error(reason) {
                this._storedError = reason;
                this._readCapability.resolve();
              }
              _setReadableStream(readableStream) {
                this._readableStream = readableStream;
                readableStream.on("readable", () => {
                  this._readCapability.resolve();
                });
                readableStream.on("end", () => {
                  readableStream.destroy();
                  this._done = true;
                  this._readCapability.resolve();
                });
                readableStream.on("error", (reason) => {
                  this._error(reason);
                });
                if (!this._isStreamingSupported && this._isRangeSupported) {
                  this._error(new _util2.AbortException("streaming is disabled"));
                }
                if (this._storedError) {
                  this._readableStream.destroy(this._storedError);
                }
              }
            };
            __name(_BaseFullReader, "BaseFullReader");
            let BaseFullReader = _BaseFullReader;
            const _BaseRangeReader = class _BaseRangeReader {
              constructor(stream) {
                this._url = stream.url;
                this._done = false;
                this._storedError = null;
                this.onProgress = null;
                this._loaded = 0;
                this._readableStream = null;
                this._readCapability = new _util2.PromiseCapability();
                const source = stream.source;
                this._isStreamingSupported = !source.disableStream;
              }
              get isStreamingSupported() {
                return this._isStreamingSupported;
              }
              async read() {
                var _a3;
                await this._readCapability.promise;
                if (this._done) {
                  return {
                    value: void 0,
                    done: true
                  };
                }
                if (this._storedError) {
                  throw this._storedError;
                }
                const chunk = this._readableStream.read();
                if (chunk === null) {
                  this._readCapability = new _util2.PromiseCapability();
                  return this.read();
                }
                this._loaded += chunk.length;
                (_a3 = this.onProgress) == null ? void 0 : _a3.call(this, {
                  loaded: this._loaded
                });
                const buffer = new Uint8Array(chunk).buffer;
                return {
                  value: buffer,
                  done: false
                };
              }
              cancel(reason) {
                if (!this._readableStream) {
                  this._error(reason);
                  return;
                }
                this._readableStream.destroy(reason);
              }
              _error(reason) {
                this._storedError = reason;
                this._readCapability.resolve();
              }
              _setReadableStream(readableStream) {
                this._readableStream = readableStream;
                readableStream.on("readable", () => {
                  this._readCapability.resolve();
                });
                readableStream.on("end", () => {
                  readableStream.destroy();
                  this._done = true;
                  this._readCapability.resolve();
                });
                readableStream.on("error", (reason) => {
                  this._error(reason);
                });
                if (this._storedError) {
                  this._readableStream.destroy(this._storedError);
                }
              }
            };
            __name(_BaseRangeReader, "BaseRangeReader");
            let BaseRangeReader = _BaseRangeReader;
            function createRequestOptions(parsedUrl, headers) {
              return {
                protocol: parsedUrl.protocol,
                auth: parsedUrl.auth,
                host: parsedUrl.hostname,
                port: parsedUrl.port,
                path: parsedUrl.path,
                method: "GET",
                headers
              };
            }
            __name(createRequestOptions, "createRequestOptions");
            const _PDFNodeStreamFullReader = class _PDFNodeStreamFullReader extends BaseFullReader {
              constructor(stream) {
                super(stream);
                const handleResponse = /* @__PURE__ */ __name((response) => {
                  if (response.statusCode === 404) {
                    const error = new _util2.MissingPDFException(`Missing PDF "${this._url}".`);
                    this._storedError = error;
                    this._headersCapability.reject(error);
                    return;
                  }
                  this._headersCapability.resolve();
                  this._setReadableStream(response);
                  const getResponseHeader = /* @__PURE__ */ __name((name) => {
                    return this._readableStream.headers[name.toLowerCase()];
                  }, "getResponseHeader");
                  const {
                    allowRangeRequests,
                    suggestedLength
                  } = (0, _network_utils.validateRangeRequestCapabilities)({
                    getResponseHeader,
                    isHttp: stream.isHttp,
                    rangeChunkSize: this._rangeChunkSize,
                    disableRange: this._disableRange
                  });
                  this._isRangeSupported = allowRangeRequests;
                  this._contentLength = suggestedLength || this._contentLength;
                  this._filename = (0, _network_utils.extractFilenameFromHeader)(getResponseHeader);
                }, "handleResponse");
                this._request = null;
                if (this._url.protocol === "http:") {
                  const http = require$$5;
                  this._request = http.request(createRequestOptions(this._url, stream.httpHeaders), handleResponse);
                } else {
                  const https = require$$5;
                  this._request = https.request(createRequestOptions(this._url, stream.httpHeaders), handleResponse);
                }
                this._request.on("error", (reason) => {
                  this._storedError = reason;
                  this._headersCapability.reject(reason);
                });
                this._request.end();
              }
            };
            __name(_PDFNodeStreamFullReader, "PDFNodeStreamFullReader");
            let PDFNodeStreamFullReader = _PDFNodeStreamFullReader;
            const _PDFNodeStreamRangeReader = class _PDFNodeStreamRangeReader extends BaseRangeReader {
              constructor(stream, start, end) {
                super(stream);
                this._httpHeaders = {};
                for (const property in stream.httpHeaders) {
                  const value = stream.httpHeaders[property];
                  if (value === void 0) {
                    continue;
                  }
                  this._httpHeaders[property] = value;
                }
                this._httpHeaders.Range = `bytes=${start}-${end - 1}`;
                const handleResponse = /* @__PURE__ */ __name((response) => {
                  if (response.statusCode === 404) {
                    const error = new _util2.MissingPDFException(`Missing PDF "${this._url}".`);
                    this._storedError = error;
                    return;
                  }
                  this._setReadableStream(response);
                }, "handleResponse");
                this._request = null;
                if (this._url.protocol === "http:") {
                  const http = require$$5;
                  this._request = http.request(createRequestOptions(this._url, this._httpHeaders), handleResponse);
                } else {
                  const https = require$$5;
                  this._request = https.request(createRequestOptions(this._url, this._httpHeaders), handleResponse);
                }
                this._request.on("error", (reason) => {
                  this._storedError = reason;
                });
                this._request.end();
              }
            };
            __name(_PDFNodeStreamRangeReader, "PDFNodeStreamRangeReader");
            let PDFNodeStreamRangeReader = _PDFNodeStreamRangeReader;
            const _PDFNodeStreamFsFullReader = class _PDFNodeStreamFsFullReader extends BaseFullReader {
              constructor(stream) {
                super(stream);
                let path = decodeURIComponent(this._url.path);
                if (fileUriRegex.test(this._url.href)) {
                  path = path.replace(/^\//, "");
                }
                const fs = require$$5;
                fs.lstat(path, (error, stat) => {
                  if (error) {
                    if (error.code === "ENOENT") {
                      error = new _util2.MissingPDFException(`Missing PDF "${path}".`);
                    }
                    this._storedError = error;
                    this._headersCapability.reject(error);
                    return;
                  }
                  this._contentLength = stat.size;
                  this._setReadableStream(fs.createReadStream(path));
                  this._headersCapability.resolve();
                });
              }
            };
            __name(_PDFNodeStreamFsFullReader, "PDFNodeStreamFsFullReader");
            let PDFNodeStreamFsFullReader = _PDFNodeStreamFsFullReader;
            const _PDFNodeStreamFsRangeReader = class _PDFNodeStreamFsRangeReader extends BaseRangeReader {
              constructor(stream, start, end) {
                super(stream);
                let path = decodeURIComponent(this._url.path);
                if (fileUriRegex.test(this._url.href)) {
                  path = path.replace(/^\//, "");
                }
                const fs = require$$5;
                this._setReadableStream(fs.createReadStream(path, {
                  start,
                  end: end - 1
                }));
              }
            };
            __name(_PDFNodeStreamFsRangeReader, "PDFNodeStreamFsRangeReader");
            let PDFNodeStreamFsRangeReader = _PDFNodeStreamFsRangeReader;
          },
          /* 24 */
          /***/
          (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            exports2.SVGGraphics = void 0;
            var _display_utils2 = __w_pdfjs_require__2(6);
            var _util2 = __w_pdfjs_require__2(1);
            const SVG_DEFAULTS = {
              fontStyle: "normal",
              fontWeight: "normal",
              fillColor: "#000000"
            };
            const XML_NS = "http://www.w3.org/XML/1998/namespace";
            const XLINK_NS = "http://www.w3.org/1999/xlink";
            const LINE_CAP_STYLES = ["butt", "round", "square"];
            const LINE_JOIN_STYLES = ["miter", "round", "bevel"];
            const createObjectURL = /* @__PURE__ */ __name(function(data, contentType = "", forceDataSchema = false) {
              if (URL.createObjectURL && typeof Blob !== "undefined" && !forceDataSchema) {
                return URL.createObjectURL(new Blob([data], {
                  type: contentType
                }));
              }
              const digits = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
              let buffer = `data:${contentType};base64,`;
              for (let i2 = 0, ii = data.length; i2 < ii; i2 += 3) {
                const b1 = data[i2] & 255;
                const b2 = data[i2 + 1] & 255;
                const b3 = data[i2 + 2] & 255;
                const d1 = b1 >> 2, d2 = (b1 & 3) << 4 | b2 >> 4;
                const d3 = i2 + 1 < ii ? (b2 & 15) << 2 | b3 >> 6 : 64;
                const d4 = i2 + 2 < ii ? b3 & 63 : 64;
                buffer += digits[d1] + digits[d2] + digits[d3] + digits[d4];
              }
              return buffer;
            }, "createObjectURL");
            const convertImgDataToPng = function() {
              const PNG_HEADER = new Uint8Array([137, 80, 78, 71, 13, 10, 26, 10]);
              const CHUNK_WRAPPER_SIZE = 12;
              const crcTable = new Int32Array(256);
              for (let i2 = 0; i2 < 256; i2++) {
                let c2 = i2;
                for (let h3 = 0; h3 < 8; h3++) {
                  c2 = c2 & 1 ? 3988292384 ^ c2 >> 1 & 2147483647 : c2 >> 1 & 2147483647;
                }
                crcTable[i2] = c2;
              }
              function crc32(data, start, end) {
                let crc = -1;
                for (let i2 = start; i2 < end; i2++) {
                  const a2 = (crc ^ data[i2]) & 255;
                  const b2 = crcTable[a2];
                  crc = crc >>> 8 ^ b2;
                }
                return crc ^ -1;
              }
              __name(crc32, "crc32");
              function writePngChunk(type, body, data, offset) {
                let p2 = offset;
                const len = body.length;
                data[p2] = len >> 24 & 255;
                data[p2 + 1] = len >> 16 & 255;
                data[p2 + 2] = len >> 8 & 255;
                data[p2 + 3] = len & 255;
                p2 += 4;
                data[p2] = type.charCodeAt(0) & 255;
                data[p2 + 1] = type.charCodeAt(1) & 255;
                data[p2 + 2] = type.charCodeAt(2) & 255;
                data[p2 + 3] = type.charCodeAt(3) & 255;
                p2 += 4;
                data.set(body, p2);
                p2 += body.length;
                const crc = crc32(data, offset + 4, p2);
                data[p2] = crc >> 24 & 255;
                data[p2 + 1] = crc >> 16 & 255;
                data[p2 + 2] = crc >> 8 & 255;
                data[p2 + 3] = crc & 255;
              }
              __name(writePngChunk, "writePngChunk");
              function adler32(data, start, end) {
                let a2 = 1;
                let b2 = 0;
                for (let i2 = start; i2 < end; ++i2) {
                  a2 = (a2 + (data[i2] & 255)) % 65521;
                  b2 = (b2 + a2) % 65521;
                }
                return b2 << 16 | a2;
              }
              __name(adler32, "adler32");
              function deflateSync(literals) {
                if (!_util2.isNodeJS) {
                  return deflateSyncUncompressed(literals);
                }
                try {
                  const input = parseInt(process.versions.node) >= 8 ? literals : Buffer.from(literals);
                  const output = require$$5.deflateSync(input, {
                    level: 9
                  });
                  return output instanceof Uint8Array ? output : new Uint8Array(output);
                } catch (e) {
                  (0, _util2.warn)("Not compressing PNG because zlib.deflateSync is unavailable: " + e);
                }
                return deflateSyncUncompressed(literals);
              }
              __name(deflateSync, "deflateSync");
              function deflateSyncUncompressed(literals) {
                let len = literals.length;
                const maxBlockLength = 65535;
                const deflateBlocks = Math.ceil(len / maxBlockLength);
                const idat = new Uint8Array(2 + len + deflateBlocks * 5 + 4);
                let pi = 0;
                idat[pi++] = 120;
                idat[pi++] = 156;
                let pos = 0;
                while (len > maxBlockLength) {
                  idat[pi++] = 0;
                  idat[pi++] = 255;
                  idat[pi++] = 255;
                  idat[pi++] = 0;
                  idat[pi++] = 0;
                  idat.set(literals.subarray(pos, pos + maxBlockLength), pi);
                  pi += maxBlockLength;
                  pos += maxBlockLength;
                  len -= maxBlockLength;
                }
                idat[pi++] = 1;
                idat[pi++] = len & 255;
                idat[pi++] = len >> 8 & 255;
                idat[pi++] = ~len & 65535 & 255;
                idat[pi++] = (~len & 65535) >> 8 & 255;
                idat.set(literals.subarray(pos), pi);
                pi += literals.length - pos;
                const adler2 = adler32(literals, 0, literals.length);
                idat[pi++] = adler2 >> 24 & 255;
                idat[pi++] = adler2 >> 16 & 255;
                idat[pi++] = adler2 >> 8 & 255;
                idat[pi++] = adler2 & 255;
                return idat;
              }
              __name(deflateSyncUncompressed, "deflateSyncUncompressed");
              function encode(imgData, kind, forceDataSchema, isMask) {
                const width = imgData.width;
                const height = imgData.height;
                let bitDepth, colorType, lineSize;
                const bytes = imgData.data;
                switch (kind) {
                  case _util2.ImageKind.GRAYSCALE_1BPP:
                    colorType = 0;
                    bitDepth = 1;
                    lineSize = width + 7 >> 3;
                    break;
                  case _util2.ImageKind.RGB_24BPP:
                    colorType = 2;
                    bitDepth = 8;
                    lineSize = width * 3;
                    break;
                  case _util2.ImageKind.RGBA_32BPP:
                    colorType = 6;
                    bitDepth = 8;
                    lineSize = width * 4;
                    break;
                  default:
                    throw new Error("invalid format");
                }
                const literals = new Uint8Array((1 + lineSize) * height);
                let offsetLiterals = 0, offsetBytes = 0;
                for (let y2 = 0; y2 < height; ++y2) {
                  literals[offsetLiterals++] = 0;
                  literals.set(bytes.subarray(offsetBytes, offsetBytes + lineSize), offsetLiterals);
                  offsetBytes += lineSize;
                  offsetLiterals += lineSize;
                }
                if (kind === _util2.ImageKind.GRAYSCALE_1BPP && isMask) {
                  offsetLiterals = 0;
                  for (let y2 = 0; y2 < height; y2++) {
                    offsetLiterals++;
                    for (let i2 = 0; i2 < lineSize; i2++) {
                      literals[offsetLiterals++] ^= 255;
                    }
                  }
                }
                const ihdr = new Uint8Array([width >> 24 & 255, width >> 16 & 255, width >> 8 & 255, width & 255, height >> 24 & 255, height >> 16 & 255, height >> 8 & 255, height & 255, bitDepth, colorType, 0, 0, 0]);
                const idat = deflateSync(literals);
                const pngLength = PNG_HEADER.length + CHUNK_WRAPPER_SIZE * 3 + ihdr.length + idat.length;
                const data = new Uint8Array(pngLength);
                let offset = 0;
                data.set(PNG_HEADER, offset);
                offset += PNG_HEADER.length;
                writePngChunk("IHDR", ihdr, data, offset);
                offset += CHUNK_WRAPPER_SIZE + ihdr.length;
                writePngChunk("IDATA", idat, data, offset);
                offset += CHUNK_WRAPPER_SIZE + idat.length;
                writePngChunk("IEND", new Uint8Array(0), data, offset);
                return createObjectURL(data, "image/png", forceDataSchema);
              }
              __name(encode, "encode");
              return /* @__PURE__ */ __name(function convertImgDataToPng2(imgData, forceDataSchema, isMask) {
                const kind = imgData.kind === void 0 ? _util2.ImageKind.GRAYSCALE_1BPP : imgData.kind;
                return encode(imgData, kind, forceDataSchema, isMask);
              }, "convertImgDataToPng");
            }();
            const _SVGExtraState = class _SVGExtraState {
              constructor() {
                this.fontSizeScale = 1;
                this.fontWeight = SVG_DEFAULTS.fontWeight;
                this.fontSize = 0;
                this.textMatrix = _util2.IDENTITY_MATRIX;
                this.fontMatrix = _util2.FONT_IDENTITY_MATRIX;
                this.leading = 0;
                this.textRenderingMode = _util2.TextRenderingMode.FILL;
                this.textMatrixScale = 1;
                this.x = 0;
                this.y = 0;
                this.lineX = 0;
                this.lineY = 0;
                this.charSpacing = 0;
                this.wordSpacing = 0;
                this.textHScale = 1;
                this.textRise = 0;
                this.fillColor = SVG_DEFAULTS.fillColor;
                this.strokeColor = "#000000";
                this.fillAlpha = 1;
                this.strokeAlpha = 1;
                this.lineWidth = 1;
                this.lineJoin = "";
                this.lineCap = "";
                this.miterLimit = 0;
                this.dashArray = [];
                this.dashPhase = 0;
                this.dependencies = [];
                this.activeClipUrl = null;
                this.clipGroup = null;
                this.maskId = "";
              }
              clone() {
                return Object.create(this);
              }
              setCurrentPoint(x2, y2) {
                this.x = x2;
                this.y = y2;
              }
            };
            __name(_SVGExtraState, "SVGExtraState");
            let SVGExtraState = _SVGExtraState;
            function opListToTree(opList) {
              let opTree = [];
              const tmp = [];
              for (const opListElement of opList) {
                if (opListElement.fn === "save") {
                  opTree.push({
                    fnId: 92,
                    fn: "group",
                    items: []
                  });
                  tmp.push(opTree);
                  opTree = opTree.at(-1).items;
                  continue;
                }
                if (opListElement.fn === "restore") {
                  opTree = tmp.pop();
                } else {
                  opTree.push(opListElement);
                }
              }
              return opTree;
            }
            __name(opListToTree, "opListToTree");
            function pf(value) {
              if (Number.isInteger(value)) {
                return value.toString();
              }
              const s2 = value.toFixed(10);
              let i2 = s2.length - 1;
              if (s2[i2] !== "0") {
                return s2;
              }
              do {
                i2--;
              } while (s2[i2] === "0");
              return s2.substring(0, s2[i2] === "." ? i2 : i2 + 1);
            }
            __name(pf, "pf");
            function pm(m2) {
              if (m2[4] === 0 && m2[5] === 0) {
                if (m2[1] === 0 && m2[2] === 0) {
                  if (m2[0] === 1 && m2[3] === 1) {
                    return "";
                  }
                  return `scale(${pf(m2[0])} ${pf(m2[3])})`;
                }
                if (m2[0] === m2[3] && m2[1] === -m2[2]) {
                  const a2 = Math.acos(m2[0]) * 180 / Math.PI;
                  return `rotate(${pf(a2)})`;
                }
              } else if (m2[0] === 1 && m2[1] === 0 && m2[2] === 0 && m2[3] === 1) {
                return `translate(${pf(m2[4])} ${pf(m2[5])})`;
              }
              return `matrix(${pf(m2[0])} ${pf(m2[1])} ${pf(m2[2])} ${pf(m2[3])} ${pf(m2[4])} ${pf(m2[5])})`;
            }
            __name(pm, "pm");
            let clipCount = 0;
            let maskCount = 0;
            let shadingCount = 0;
            const _SVGGraphics = class _SVGGraphics {
              constructor(commonObjs, objs, forceDataSchema = false) {
                (0, _display_utils2.deprecated)("The SVG back-end is no longer maintained and *may* be removed in the future.");
                this.svgFactory = new _display_utils2.DOMSVGFactory();
                this.current = new SVGExtraState();
                this.transformMatrix = _util2.IDENTITY_MATRIX;
                this.transformStack = [];
                this.extraStack = [];
                this.commonObjs = commonObjs;
                this.objs = objs;
                this.pendingClip = null;
                this.pendingEOFill = false;
                this.embedFonts = false;
                this.embeddedFonts = /* @__PURE__ */ Object.create(null);
                this.cssStyle = null;
                this.forceDataSchema = !!forceDataSchema;
                this._operatorIdMapping = [];
                for (const op in _util2.OPS) {
                  this._operatorIdMapping[_util2.OPS[op]] = op;
                }
              }
              getObject(data, fallback = null) {
                if (typeof data === "string") {
                  return data.startsWith("g_") ? this.commonObjs.get(data) : this.objs.get(data);
                }
                return fallback;
              }
              save() {
                this.transformStack.push(this.transformMatrix);
                const old = this.current;
                this.extraStack.push(old);
                this.current = old.clone();
              }
              restore() {
                this.transformMatrix = this.transformStack.pop();
                this.current = this.extraStack.pop();
                this.pendingClip = null;
                this.tgrp = null;
              }
              group(items) {
                this.save();
                this.executeOpTree(items);
                this.restore();
              }
              loadDependencies(operatorList) {
                const fnArray = operatorList.fnArray;
                const argsArray = operatorList.argsArray;
                for (let i2 = 0, ii = fnArray.length; i2 < ii; i2++) {
                  if (fnArray[i2] !== _util2.OPS.dependency) {
                    continue;
                  }
                  for (const obj of argsArray[i2]) {
                    const objsPool = obj.startsWith("g_") ? this.commonObjs : this.objs;
                    const promise = new Promise((resolve2) => {
                      objsPool.get(obj, resolve2);
                    });
                    this.current.dependencies.push(promise);
                  }
                }
                return Promise.all(this.current.dependencies);
              }
              transform(a2, b2, c2, d2, e, f2) {
                const transformMatrix = [a2, b2, c2, d2, e, f2];
                this.transformMatrix = _util2.Util.transform(this.transformMatrix, transformMatrix);
                this.tgrp = null;
              }
              getSVG(operatorList, viewport) {
                this.viewport = viewport;
                const svgElement = this._initialize(viewport);
                return this.loadDependencies(operatorList).then(() => {
                  this.transformMatrix = _util2.IDENTITY_MATRIX;
                  this.executeOpTree(this.convertOpList(operatorList));
                  return svgElement;
                });
              }
              convertOpList(operatorList) {
                const operatorIdMapping = this._operatorIdMapping;
                const argsArray = operatorList.argsArray;
                const fnArray = operatorList.fnArray;
                const opList = [];
                for (let i2 = 0, ii = fnArray.length; i2 < ii; i2++) {
                  const fnId = fnArray[i2];
                  opList.push({
                    fnId,
                    fn: operatorIdMapping[fnId],
                    args: argsArray[i2]
                  });
                }
                return opListToTree(opList);
              }
              executeOpTree(opTree) {
                for (const opTreeElement of opTree) {
                  const fn = opTreeElement.fn;
                  const fnId = opTreeElement.fnId;
                  const args = opTreeElement.args;
                  switch (fnId | 0) {
                    case _util2.OPS.beginText:
                      this.beginText();
                      break;
                    case _util2.OPS.dependency:
                      break;
                    case _util2.OPS.setLeading:
                      this.setLeading(args);
                      break;
                    case _util2.OPS.setLeadingMoveText:
                      this.setLeadingMoveText(args[0], args[1]);
                      break;
                    case _util2.OPS.setFont:
                      this.setFont(args);
                      break;
                    case _util2.OPS.showText:
                      this.showText(args[0]);
                      break;
                    case _util2.OPS.showSpacedText:
                      this.showText(args[0]);
                      break;
                    case _util2.OPS.endText:
                      this.endText();
                      break;
                    case _util2.OPS.moveText:
                      this.moveText(args[0], args[1]);
                      break;
                    case _util2.OPS.setCharSpacing:
                      this.setCharSpacing(args[0]);
                      break;
                    case _util2.OPS.setWordSpacing:
                      this.setWordSpacing(args[0]);
                      break;
                    case _util2.OPS.setHScale:
                      this.setHScale(args[0]);
                      break;
                    case _util2.OPS.setTextMatrix:
                      this.setTextMatrix(args[0], args[1], args[2], args[3], args[4], args[5]);
                      break;
                    case _util2.OPS.setTextRise:
                      this.setTextRise(args[0]);
                      break;
                    case _util2.OPS.setTextRenderingMode:
                      this.setTextRenderingMode(args[0]);
                      break;
                    case _util2.OPS.setLineWidth:
                      this.setLineWidth(args[0]);
                      break;
                    case _util2.OPS.setLineJoin:
                      this.setLineJoin(args[0]);
                      break;
                    case _util2.OPS.setLineCap:
                      this.setLineCap(args[0]);
                      break;
                    case _util2.OPS.setMiterLimit:
                      this.setMiterLimit(args[0]);
                      break;
                    case _util2.OPS.setFillRGBColor:
                      this.setFillRGBColor(args[0], args[1], args[2]);
                      break;
                    case _util2.OPS.setStrokeRGBColor:
                      this.setStrokeRGBColor(args[0], args[1], args[2]);
                      break;
                    case _util2.OPS.setStrokeColorN:
                      this.setStrokeColorN(args);
                      break;
                    case _util2.OPS.setFillColorN:
                      this.setFillColorN(args);
                      break;
                    case _util2.OPS.shadingFill:
                      this.shadingFill(args[0]);
                      break;
                    case _util2.OPS.setDash:
                      this.setDash(args[0], args[1]);
                      break;
                    case _util2.OPS.setRenderingIntent:
                      this.setRenderingIntent(args[0]);
                      break;
                    case _util2.OPS.setFlatness:
                      this.setFlatness(args[0]);
                      break;
                    case _util2.OPS.setGState:
                      this.setGState(args[0]);
                      break;
                    case _util2.OPS.fill:
                      this.fill();
                      break;
                    case _util2.OPS.eoFill:
                      this.eoFill();
                      break;
                    case _util2.OPS.stroke:
                      this.stroke();
                      break;
                    case _util2.OPS.fillStroke:
                      this.fillStroke();
                      break;
                    case _util2.OPS.eoFillStroke:
                      this.eoFillStroke();
                      break;
                    case _util2.OPS.clip:
                      this.clip("nonzero");
                      break;
                    case _util2.OPS.eoClip:
                      this.clip("evenodd");
                      break;
                    case _util2.OPS.paintSolidColorImageMask:
                      this.paintSolidColorImageMask();
                      break;
                    case _util2.OPS.paintImageXObject:
                      this.paintImageXObject(args[0]);
                      break;
                    case _util2.OPS.paintInlineImageXObject:
                      this.paintInlineImageXObject(args[0]);
                      break;
                    case _util2.OPS.paintImageMaskXObject:
                      this.paintImageMaskXObject(args[0]);
                      break;
                    case _util2.OPS.paintFormXObjectBegin:
                      this.paintFormXObjectBegin(args[0], args[1]);
                      break;
                    case _util2.OPS.paintFormXObjectEnd:
                      this.paintFormXObjectEnd();
                      break;
                    case _util2.OPS.closePath:
                      this.closePath();
                      break;
                    case _util2.OPS.closeStroke:
                      this.closeStroke();
                      break;
                    case _util2.OPS.closeFillStroke:
                      this.closeFillStroke();
                      break;
                    case _util2.OPS.closeEOFillStroke:
                      this.closeEOFillStroke();
                      break;
                    case _util2.OPS.nextLine:
                      this.nextLine();
                      break;
                    case _util2.OPS.transform:
                      this.transform(args[0], args[1], args[2], args[3], args[4], args[5]);
                      break;
                    case _util2.OPS.constructPath:
                      this.constructPath(args[0], args[1]);
                      break;
                    case _util2.OPS.endPath:
                      this.endPath();
                      break;
                    case 92:
                      this.group(opTreeElement.items);
                      break;
                    default:
                      (0, _util2.warn)(`Unimplemented operator ${fn}`);
                      break;
                  }
                }
              }
              setWordSpacing(wordSpacing) {
                this.current.wordSpacing = wordSpacing;
              }
              setCharSpacing(charSpacing) {
                this.current.charSpacing = charSpacing;
              }
              nextLine() {
                this.moveText(0, this.current.leading);
              }
              setTextMatrix(a2, b2, c2, d2, e, f2) {
                const current = this.current;
                current.textMatrix = current.lineMatrix = [a2, b2, c2, d2, e, f2];
                current.textMatrixScale = Math.hypot(a2, b2);
                current.x = current.lineX = 0;
                current.y = current.lineY = 0;
                current.xcoords = [];
                current.ycoords = [];
                current.tspan = this.svgFactory.createElement("svg:tspan");
                current.tspan.setAttributeNS(null, "font-family", current.fontFamily);
                current.tspan.setAttributeNS(null, "font-size", `${pf(current.fontSize)}px`);
                current.tspan.setAttributeNS(null, "y", pf(-current.y));
                current.txtElement = this.svgFactory.createElement("svg:text");
                current.txtElement.append(current.tspan);
              }
              beginText() {
                const current = this.current;
                current.x = current.lineX = 0;
                current.y = current.lineY = 0;
                current.textMatrix = _util2.IDENTITY_MATRIX;
                current.lineMatrix = _util2.IDENTITY_MATRIX;
                current.textMatrixScale = 1;
                current.tspan = this.svgFactory.createElement("svg:tspan");
                current.txtElement = this.svgFactory.createElement("svg:text");
                current.txtgrp = this.svgFactory.createElement("svg:g");
                current.xcoords = [];
                current.ycoords = [];
              }
              moveText(x2, y2) {
                const current = this.current;
                current.x = current.lineX += x2;
                current.y = current.lineY += y2;
                current.xcoords = [];
                current.ycoords = [];
                current.tspan = this.svgFactory.createElement("svg:tspan");
                current.tspan.setAttributeNS(null, "font-family", current.fontFamily);
                current.tspan.setAttributeNS(null, "font-size", `${pf(current.fontSize)}px`);
                current.tspan.setAttributeNS(null, "y", pf(-current.y));
              }
              showText(glyphs) {
                const current = this.current;
                const font = current.font;
                const fontSize = current.fontSize;
                if (fontSize === 0) {
                  return;
                }
                const fontSizeScale = current.fontSizeScale;
                const charSpacing = current.charSpacing;
                const wordSpacing = current.wordSpacing;
                const fontDirection = current.fontDirection;
                const textHScale = current.textHScale * fontDirection;
                const vertical = font.vertical;
                const spacingDir = vertical ? 1 : -1;
                const defaultVMetrics = font.defaultVMetrics;
                const widthAdvanceScale = fontSize * current.fontMatrix[0];
                let x2 = 0;
                for (const glyph of glyphs) {
                  if (glyph === null) {
                    x2 += fontDirection * wordSpacing;
                    continue;
                  } else if (typeof glyph === "number") {
                    x2 += spacingDir * glyph * fontSize / 1e3;
                    continue;
                  }
                  const spacing = (glyph.isSpace ? wordSpacing : 0) + charSpacing;
                  const character = glyph.fontChar;
                  let scaledX, scaledY;
                  let width = glyph.width;
                  if (vertical) {
                    let vx;
                    const vmetric = glyph.vmetric || defaultVMetrics;
                    vx = glyph.vmetric ? vmetric[1] : width * 0.5;
                    vx = -vx * widthAdvanceScale;
                    const vy = vmetric[2] * widthAdvanceScale;
                    width = vmetric ? -vmetric[0] : width;
                    scaledX = vx / fontSizeScale;
                    scaledY = (x2 + vy) / fontSizeScale;
                  } else {
                    scaledX = x2 / fontSizeScale;
                    scaledY = 0;
                  }
                  if (glyph.isInFont || font.missingFile) {
                    current.xcoords.push(current.x + scaledX);
                    if (vertical) {
                      current.ycoords.push(-current.y + scaledY);
                    }
                    current.tspan.textContent += character;
                  }
                  const charWidth = vertical ? width * widthAdvanceScale - spacing * fontDirection : width * widthAdvanceScale + spacing * fontDirection;
                  x2 += charWidth;
                }
                current.tspan.setAttributeNS(null, "x", current.xcoords.map(pf).join(" "));
                if (vertical) {
                  current.tspan.setAttributeNS(null, "y", current.ycoords.map(pf).join(" "));
                } else {
                  current.tspan.setAttributeNS(null, "y", pf(-current.y));
                }
                if (vertical) {
                  current.y -= x2;
                } else {
                  current.x += x2 * textHScale;
                }
                current.tspan.setAttributeNS(null, "font-family", current.fontFamily);
                current.tspan.setAttributeNS(null, "font-size", `${pf(current.fontSize)}px`);
                if (current.fontStyle !== SVG_DEFAULTS.fontStyle) {
                  current.tspan.setAttributeNS(null, "font-style", current.fontStyle);
                }
                if (current.fontWeight !== SVG_DEFAULTS.fontWeight) {
                  current.tspan.setAttributeNS(null, "font-weight", current.fontWeight);
                }
                const fillStrokeMode = current.textRenderingMode & _util2.TextRenderingMode.FILL_STROKE_MASK;
                if (fillStrokeMode === _util2.TextRenderingMode.FILL || fillStrokeMode === _util2.TextRenderingMode.FILL_STROKE) {
                  if (current.fillColor !== SVG_DEFAULTS.fillColor) {
                    current.tspan.setAttributeNS(null, "fill", current.fillColor);
                  }
                  if (current.fillAlpha < 1) {
                    current.tspan.setAttributeNS(null, "fill-opacity", current.fillAlpha);
                  }
                } else if (current.textRenderingMode === _util2.TextRenderingMode.ADD_TO_PATH) {
                  current.tspan.setAttributeNS(null, "fill", "transparent");
                } else {
                  current.tspan.setAttributeNS(null, "fill", "none");
                }
                if (fillStrokeMode === _util2.TextRenderingMode.STROKE || fillStrokeMode === _util2.TextRenderingMode.FILL_STROKE) {
                  const lineWidthScale = 1 / (current.textMatrixScale || 1);
                  this._setStrokeAttributes(current.tspan, lineWidthScale);
                }
                let textMatrix = current.textMatrix;
                if (current.textRise !== 0) {
                  textMatrix = textMatrix.slice();
                  textMatrix[5] += current.textRise;
                }
                current.txtElement.setAttributeNS(null, "transform", `${pm(textMatrix)} scale(${pf(textHScale)}, -1)`);
                current.txtElement.setAttributeNS(XML_NS, "xml:space", "preserve");
                current.txtElement.append(current.tspan);
                current.txtgrp.append(current.txtElement);
                this._ensureTransformGroup().append(current.txtElement);
              }
              setLeadingMoveText(x2, y2) {
                this.setLeading(-y2);
                this.moveText(x2, y2);
              }
              addFontStyle(fontObj) {
                if (!fontObj.data) {
                  throw new Error('addFontStyle: No font data available, ensure that the "fontExtraProperties" API parameter is set.');
                }
                if (!this.cssStyle) {
                  this.cssStyle = this.svgFactory.createElement("svg:style");
                  this.cssStyle.setAttributeNS(null, "type", "text/css");
                  this.defs.append(this.cssStyle);
                }
                const url = createObjectURL(fontObj.data, fontObj.mimetype, this.forceDataSchema);
                this.cssStyle.textContent += `@font-face { font-family: "${fontObj.loadedName}"; src: url(${url}); }
`;
              }
              setFont(details) {
                const current = this.current;
                const fontObj = this.commonObjs.get(details[0]);
                let size = details[1];
                current.font = fontObj;
                if (this.embedFonts && !fontObj.missingFile && !this.embeddedFonts[fontObj.loadedName]) {
                  this.addFontStyle(fontObj);
                  this.embeddedFonts[fontObj.loadedName] = fontObj;
                }
                current.fontMatrix = fontObj.fontMatrix || _util2.FONT_IDENTITY_MATRIX;
                let bold = "normal";
                if (fontObj.black) {
                  bold = "900";
                } else if (fontObj.bold) {
                  bold = "bold";
                }
                const italic = fontObj.italic ? "italic" : "normal";
                if (size < 0) {
                  size = -size;
                  current.fontDirection = -1;
                } else {
                  current.fontDirection = 1;
                }
                current.fontSize = size;
                current.fontFamily = fontObj.loadedName;
                current.fontWeight = bold;
                current.fontStyle = italic;
                current.tspan = this.svgFactory.createElement("svg:tspan");
                current.tspan.setAttributeNS(null, "y", pf(-current.y));
                current.xcoords = [];
                current.ycoords = [];
              }
              endText() {
                var _a3;
                const current = this.current;
                if (current.textRenderingMode & _util2.TextRenderingMode.ADD_TO_PATH_FLAG && ((_a3 = current.txtElement) == null ? void 0 : _a3.hasChildNodes())) {
                  current.element = current.txtElement;
                  this.clip("nonzero");
                  this.endPath();
                }
              }
              setLineWidth(width) {
                if (width > 0) {
                  this.current.lineWidth = width;
                }
              }
              setLineCap(style) {
                this.current.lineCap = LINE_CAP_STYLES[style];
              }
              setLineJoin(style) {
                this.current.lineJoin = LINE_JOIN_STYLES[style];
              }
              setMiterLimit(limit) {
                this.current.miterLimit = limit;
              }
              setStrokeAlpha(strokeAlpha) {
                this.current.strokeAlpha = strokeAlpha;
              }
              setStrokeRGBColor(r, g2, b2) {
                this.current.strokeColor = _util2.Util.makeHexColor(r, g2, b2);
              }
              setFillAlpha(fillAlpha) {
                this.current.fillAlpha = fillAlpha;
              }
              setFillRGBColor(r, g2, b2) {
                this.current.fillColor = _util2.Util.makeHexColor(r, g2, b2);
                this.current.tspan = this.svgFactory.createElement("svg:tspan");
                this.current.xcoords = [];
                this.current.ycoords = [];
              }
              setStrokeColorN(args) {
                this.current.strokeColor = this._makeColorN_Pattern(args);
              }
              setFillColorN(args) {
                this.current.fillColor = this._makeColorN_Pattern(args);
              }
              shadingFill(args) {
                const {
                  width,
                  height
                } = this.viewport;
                const inv = _util2.Util.inverseTransform(this.transformMatrix);
                const [x0, y0, x1, y1] = _util2.Util.getAxialAlignedBoundingBox([0, 0, width, height], inv);
                const rect = this.svgFactory.createElement("svg:rect");
                rect.setAttributeNS(null, "x", x0);
                rect.setAttributeNS(null, "y", y0);
                rect.setAttributeNS(null, "width", x1 - x0);
                rect.setAttributeNS(null, "height", y1 - y0);
                rect.setAttributeNS(null, "fill", this._makeShadingPattern(args));
                if (this.current.fillAlpha < 1) {
                  rect.setAttributeNS(null, "fill-opacity", this.current.fillAlpha);
                }
                this._ensureTransformGroup().append(rect);
              }
              _makeColorN_Pattern(args) {
                if (args[0] === "TilingPattern") {
                  return this._makeTilingPattern(args);
                }
                return this._makeShadingPattern(args);
              }
              _makeTilingPattern(args) {
                const color2 = args[1];
                const operatorList = args[2];
                const matrix = args[3] || _util2.IDENTITY_MATRIX;
                const [x0, y0, x1, y1] = args[4];
                const xstep = args[5];
                const ystep = args[6];
                const paintType = args[7];
                const tilingId = `shading${shadingCount++}`;
                const [tx0, ty0, tx1, ty1] = _util2.Util.normalizeRect([..._util2.Util.applyTransform([x0, y0], matrix), ..._util2.Util.applyTransform([x1, y1], matrix)]);
                const [xscale, yscale] = _util2.Util.singularValueDecompose2dScale(matrix);
                const txstep = xstep * xscale;
                const tystep = ystep * yscale;
                const tiling = this.svgFactory.createElement("svg:pattern");
                tiling.setAttributeNS(null, "id", tilingId);
                tiling.setAttributeNS(null, "patternUnits", "userSpaceOnUse");
                tiling.setAttributeNS(null, "width", txstep);
                tiling.setAttributeNS(null, "height", tystep);
                tiling.setAttributeNS(null, "x", `${tx0}`);
                tiling.setAttributeNS(null, "y", `${ty0}`);
                const svg = this.svg;
                const transformMatrix = this.transformMatrix;
                const fillColor = this.current.fillColor;
                const strokeColor = this.current.strokeColor;
                const bbox = this.svgFactory.create(tx1 - tx0, ty1 - ty0);
                this.svg = bbox;
                this.transformMatrix = matrix;
                if (paintType === 2) {
                  const cssColor = _util2.Util.makeHexColor(...color2);
                  this.current.fillColor = cssColor;
                  this.current.strokeColor = cssColor;
                }
                this.executeOpTree(this.convertOpList(operatorList));
                this.svg = svg;
                this.transformMatrix = transformMatrix;
                this.current.fillColor = fillColor;
                this.current.strokeColor = strokeColor;
                tiling.append(bbox.childNodes[0]);
                this.defs.append(tiling);
                return `url(#${tilingId})`;
              }
              _makeShadingPattern(args) {
                if (typeof args === "string") {
                  args = this.objs.get(args);
                }
                switch (args[0]) {
                  case "RadialAxial":
                    const shadingId = `shading${shadingCount++}`;
                    const colorStops = args[3];
                    let gradient;
                    switch (args[1]) {
                      case "axial":
                        const point0 = args[4];
                        const point1 = args[5];
                        gradient = this.svgFactory.createElement("svg:linearGradient");
                        gradient.setAttributeNS(null, "id", shadingId);
                        gradient.setAttributeNS(null, "gradientUnits", "userSpaceOnUse");
                        gradient.setAttributeNS(null, "x1", point0[0]);
                        gradient.setAttributeNS(null, "y1", point0[1]);
                        gradient.setAttributeNS(null, "x2", point1[0]);
                        gradient.setAttributeNS(null, "y2", point1[1]);
                        break;
                      case "radial":
                        const focalPoint = args[4];
                        const circlePoint = args[5];
                        const focalRadius = args[6];
                        const circleRadius = args[7];
                        gradient = this.svgFactory.createElement("svg:radialGradient");
                        gradient.setAttributeNS(null, "id", shadingId);
                        gradient.setAttributeNS(null, "gradientUnits", "userSpaceOnUse");
                        gradient.setAttributeNS(null, "cx", circlePoint[0]);
                        gradient.setAttributeNS(null, "cy", circlePoint[1]);
                        gradient.setAttributeNS(null, "r", circleRadius);
                        gradient.setAttributeNS(null, "fx", focalPoint[0]);
                        gradient.setAttributeNS(null, "fy", focalPoint[1]);
                        gradient.setAttributeNS(null, "fr", focalRadius);
                        break;
                      default:
                        throw new Error(`Unknown RadialAxial type: ${args[1]}`);
                    }
                    for (const colorStop of colorStops) {
                      const stop = this.svgFactory.createElement("svg:stop");
                      stop.setAttributeNS(null, "offset", colorStop[0]);
                      stop.setAttributeNS(null, "stop-color", colorStop[1]);
                      gradient.append(stop);
                    }
                    this.defs.append(gradient);
                    return `url(#${shadingId})`;
                  case "Mesh":
                    (0, _util2.warn)("Unimplemented pattern Mesh");
                    return null;
                  case "Dummy":
                    return "hotpink";
                  default:
                    throw new Error(`Unknown IR type: ${args[0]}`);
                }
              }
              setDash(dashArray, dashPhase) {
                this.current.dashArray = dashArray;
                this.current.dashPhase = dashPhase;
              }
              constructPath(ops, args) {
                const current = this.current;
                let x2 = current.x, y2 = current.y;
                let d2 = [];
                let j2 = 0;
                for (const op of ops) {
                  switch (op | 0) {
                    case _util2.OPS.rectangle:
                      x2 = args[j2++];
                      y2 = args[j2++];
                      const width = args[j2++];
                      const height = args[j2++];
                      const xw = x2 + width;
                      const yh = y2 + height;
                      d2.push("M", pf(x2), pf(y2), "L", pf(xw), pf(y2), "L", pf(xw), pf(yh), "L", pf(x2), pf(yh), "Z");
                      break;
                    case _util2.OPS.moveTo:
                      x2 = args[j2++];
                      y2 = args[j2++];
                      d2.push("M", pf(x2), pf(y2));
                      break;
                    case _util2.OPS.lineTo:
                      x2 = args[j2++];
                      y2 = args[j2++];
                      d2.push("L", pf(x2), pf(y2));
                      break;
                    case _util2.OPS.curveTo:
                      x2 = args[j2 + 4];
                      y2 = args[j2 + 5];
                      d2.push("C", pf(args[j2]), pf(args[j2 + 1]), pf(args[j2 + 2]), pf(args[j2 + 3]), pf(x2), pf(y2));
                      j2 += 6;
                      break;
                    case _util2.OPS.curveTo2:
                      d2.push("C", pf(x2), pf(y2), pf(args[j2]), pf(args[j2 + 1]), pf(args[j2 + 2]), pf(args[j2 + 3]));
                      x2 = args[j2 + 2];
                      y2 = args[j2 + 3];
                      j2 += 4;
                      break;
                    case _util2.OPS.curveTo3:
                      x2 = args[j2 + 2];
                      y2 = args[j2 + 3];
                      d2.push("C", pf(args[j2]), pf(args[j2 + 1]), pf(x2), pf(y2), pf(x2), pf(y2));
                      j2 += 4;
                      break;
                    case _util2.OPS.closePath:
                      d2.push("Z");
                      break;
                  }
                }
                d2 = d2.join(" ");
                if (current.path && ops.length > 0 && ops[0] !== _util2.OPS.rectangle && ops[0] !== _util2.OPS.moveTo) {
                  d2 = current.path.getAttributeNS(null, "d") + d2;
                } else {
                  current.path = this.svgFactory.createElement("svg:path");
                  this._ensureTransformGroup().append(current.path);
                }
                current.path.setAttributeNS(null, "d", d2);
                current.path.setAttributeNS(null, "fill", "none");
                current.element = current.path;
                current.setCurrentPoint(x2, y2);
              }
              endPath() {
                const current = this.current;
                current.path = null;
                if (!this.pendingClip) {
                  return;
                }
                if (!current.element) {
                  this.pendingClip = null;
                  return;
                }
                const clipId = `clippath${clipCount++}`;
                const clipPath = this.svgFactory.createElement("svg:clipPath");
                clipPath.setAttributeNS(null, "id", clipId);
                clipPath.setAttributeNS(null, "transform", pm(this.transformMatrix));
                const clipElement = current.element.cloneNode(true);
                if (this.pendingClip === "evenodd") {
                  clipElement.setAttributeNS(null, "clip-rule", "evenodd");
                } else {
                  clipElement.setAttributeNS(null, "clip-rule", "nonzero");
                }
                this.pendingClip = null;
                clipPath.append(clipElement);
                this.defs.append(clipPath);
                if (current.activeClipUrl) {
                  current.clipGroup = null;
                  for (const prev of this.extraStack) {
                    prev.clipGroup = null;
                  }
                  clipPath.setAttributeNS(null, "clip-path", current.activeClipUrl);
                }
                current.activeClipUrl = `url(#${clipId})`;
                this.tgrp = null;
              }
              clip(type) {
                this.pendingClip = type;
              }
              closePath() {
                const current = this.current;
                if (current.path) {
                  const d2 = `${current.path.getAttributeNS(null, "d")}Z`;
                  current.path.setAttributeNS(null, "d", d2);
                }
              }
              setLeading(leading) {
                this.current.leading = -leading;
              }
              setTextRise(textRise) {
                this.current.textRise = textRise;
              }
              setTextRenderingMode(textRenderingMode) {
                this.current.textRenderingMode = textRenderingMode;
              }
              setHScale(scale) {
                this.current.textHScale = scale / 100;
              }
              setRenderingIntent(intent) {
              }
              setFlatness(flatness) {
              }
              setGState(states) {
                for (const [key, value] of states) {
                  switch (key) {
                    case "LW":
                      this.setLineWidth(value);
                      break;
                    case "LC":
                      this.setLineCap(value);
                      break;
                    case "LJ":
                      this.setLineJoin(value);
                      break;
                    case "ML":
                      this.setMiterLimit(value);
                      break;
                    case "D":
                      this.setDash(value[0], value[1]);
                      break;
                    case "RI":
                      this.setRenderingIntent(value);
                      break;
                    case "FL":
                      this.setFlatness(value);
                      break;
                    case "Font":
                      this.setFont(value);
                      break;
                    case "CA":
                      this.setStrokeAlpha(value);
                      break;
                    case "ca":
                      this.setFillAlpha(value);
                      break;
                    default:
                      (0, _util2.warn)(`Unimplemented graphic state operator ${key}`);
                      break;
                  }
                }
              }
              fill() {
                const current = this.current;
                if (current.element) {
                  current.element.setAttributeNS(null, "fill", current.fillColor);
                  current.element.setAttributeNS(null, "fill-opacity", current.fillAlpha);
                  this.endPath();
                }
              }
              stroke() {
                const current = this.current;
                if (current.element) {
                  this._setStrokeAttributes(current.element);
                  current.element.setAttributeNS(null, "fill", "none");
                  this.endPath();
                }
              }
              _setStrokeAttributes(element, lineWidthScale = 1) {
                const current = this.current;
                let dashArray = current.dashArray;
                if (lineWidthScale !== 1 && dashArray.length > 0) {
                  dashArray = dashArray.map(function(value) {
                    return lineWidthScale * value;
                  });
                }
                element.setAttributeNS(null, "stroke", current.strokeColor);
                element.setAttributeNS(null, "stroke-opacity", current.strokeAlpha);
                element.setAttributeNS(null, "stroke-miterlimit", pf(current.miterLimit));
                element.setAttributeNS(null, "stroke-linecap", current.lineCap);
                element.setAttributeNS(null, "stroke-linejoin", current.lineJoin);
                element.setAttributeNS(null, "stroke-width", pf(lineWidthScale * current.lineWidth) + "px");
                element.setAttributeNS(null, "stroke-dasharray", dashArray.map(pf).join(" "));
                element.setAttributeNS(null, "stroke-dashoffset", pf(lineWidthScale * current.dashPhase) + "px");
              }
              eoFill() {
                var _a3;
                (_a3 = this.current.element) == null ? void 0 : _a3.setAttributeNS(null, "fill-rule", "evenodd");
                this.fill();
              }
              fillStroke() {
                this.stroke();
                this.fill();
              }
              eoFillStroke() {
                var _a3;
                (_a3 = this.current.element) == null ? void 0 : _a3.setAttributeNS(null, "fill-rule", "evenodd");
                this.fillStroke();
              }
              closeStroke() {
                this.closePath();
                this.stroke();
              }
              closeFillStroke() {
                this.closePath();
                this.fillStroke();
              }
              closeEOFillStroke() {
                this.closePath();
                this.eoFillStroke();
              }
              paintSolidColorImageMask() {
                const rect = this.svgFactory.createElement("svg:rect");
                rect.setAttributeNS(null, "x", "0");
                rect.setAttributeNS(null, "y", "0");
                rect.setAttributeNS(null, "width", "1px");
                rect.setAttributeNS(null, "height", "1px");
                rect.setAttributeNS(null, "fill", this.current.fillColor);
                this._ensureTransformGroup().append(rect);
              }
              paintImageXObject(objId) {
                const imgData = this.getObject(objId);
                if (!imgData) {
                  (0, _util2.warn)(`Dependent image with object ID ${objId} is not ready yet`);
                  return;
                }
                this.paintInlineImageXObject(imgData);
              }
              paintInlineImageXObject(imgData, mask) {
                const width = imgData.width;
                const height = imgData.height;
                const imgSrc = convertImgDataToPng(imgData, this.forceDataSchema, !!mask);
                const cliprect = this.svgFactory.createElement("svg:rect");
                cliprect.setAttributeNS(null, "x", "0");
                cliprect.setAttributeNS(null, "y", "0");
                cliprect.setAttributeNS(null, "width", pf(width));
                cliprect.setAttributeNS(null, "height", pf(height));
                this.current.element = cliprect;
                this.clip("nonzero");
                const imgEl = this.svgFactory.createElement("svg:image");
                imgEl.setAttributeNS(XLINK_NS, "xlink:href", imgSrc);
                imgEl.setAttributeNS(null, "x", "0");
                imgEl.setAttributeNS(null, "y", pf(-height));
                imgEl.setAttributeNS(null, "width", pf(width) + "px");
                imgEl.setAttributeNS(null, "height", pf(height) + "px");
                imgEl.setAttributeNS(null, "transform", `scale(${pf(1 / width)} ${pf(-1 / height)})`);
                if (mask) {
                  mask.append(imgEl);
                } else {
                  this._ensureTransformGroup().append(imgEl);
                }
              }
              paintImageMaskXObject(img) {
                const imgData = this.getObject(img.data, img);
                if (imgData.bitmap) {
                  (0, _util2.warn)("paintImageMaskXObject: ImageBitmap support is not implemented, ensure that the `isOffscreenCanvasSupported` API parameter is disabled.");
                  return;
                }
                const current = this.current;
                const width = imgData.width;
                const height = imgData.height;
                const fillColor = current.fillColor;
                current.maskId = `mask${maskCount++}`;
                const mask = this.svgFactory.createElement("svg:mask");
                mask.setAttributeNS(null, "id", current.maskId);
                const rect = this.svgFactory.createElement("svg:rect");
                rect.setAttributeNS(null, "x", "0");
                rect.setAttributeNS(null, "y", "0");
                rect.setAttributeNS(null, "width", pf(width));
                rect.setAttributeNS(null, "height", pf(height));
                rect.setAttributeNS(null, "fill", fillColor);
                rect.setAttributeNS(null, "mask", `url(#${current.maskId})`);
                this.defs.append(mask);
                this._ensureTransformGroup().append(rect);
                this.paintInlineImageXObject(imgData, mask);
              }
              paintFormXObjectBegin(matrix, bbox) {
                if (Array.isArray(matrix) && matrix.length === 6) {
                  this.transform(matrix[0], matrix[1], matrix[2], matrix[3], matrix[4], matrix[5]);
                }
                if (bbox) {
                  const width = bbox[2] - bbox[0];
                  const height = bbox[3] - bbox[1];
                  const cliprect = this.svgFactory.createElement("svg:rect");
                  cliprect.setAttributeNS(null, "x", bbox[0]);
                  cliprect.setAttributeNS(null, "y", bbox[1]);
                  cliprect.setAttributeNS(null, "width", pf(width));
                  cliprect.setAttributeNS(null, "height", pf(height));
                  this.current.element = cliprect;
                  this.clip("nonzero");
                  this.endPath();
                }
              }
              paintFormXObjectEnd() {
              }
              _initialize(viewport) {
                const svg = this.svgFactory.create(viewport.width, viewport.height);
                const definitions = this.svgFactory.createElement("svg:defs");
                svg.append(definitions);
                this.defs = definitions;
                const rootGroup = this.svgFactory.createElement("svg:g");
                rootGroup.setAttributeNS(null, "transform", pm(viewport.transform));
                svg.append(rootGroup);
                this.svg = rootGroup;
                return svg;
              }
              _ensureClipGroup() {
                if (!this.current.clipGroup) {
                  const clipGroup = this.svgFactory.createElement("svg:g");
                  clipGroup.setAttributeNS(null, "clip-path", this.current.activeClipUrl);
                  this.svg.append(clipGroup);
                  this.current.clipGroup = clipGroup;
                }
                return this.current.clipGroup;
              }
              _ensureTransformGroup() {
                if (!this.tgrp) {
                  this.tgrp = this.svgFactory.createElement("svg:g");
                  this.tgrp.setAttributeNS(null, "transform", pm(this.transformMatrix));
                  if (this.current.activeClipUrl) {
                    this._ensureClipGroup().append(this.tgrp);
                  } else {
                    this.svg.append(this.tgrp);
                  }
                }
                return this.tgrp;
              }
            };
            __name(_SVGGraphics, "SVGGraphics");
            let SVGGraphics = _SVGGraphics;
            exports2.SVGGraphics = SVGGraphics;
          },
          /* 25 */
          /***/
          (__unused_webpack_module2, exports2) => {
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            exports2.XfaText = void 0;
            const _XfaText = class _XfaText {
              static textContent(xfa) {
                const items = [];
                const output = {
                  items,
                  styles: /* @__PURE__ */ Object.create(null)
                };
                function walk(node) {
                  var _a3;
                  if (!node) {
                    return;
                  }
                  let str = null;
                  const name = node.name;
                  if (name === "#text") {
                    str = node.value;
                  } else if (!_XfaText.shouldBuildText(name)) {
                    return;
                  } else if ((_a3 = node == null ? void 0 : node.attributes) == null ? void 0 : _a3.textContent) {
                    str = node.attributes.textContent;
                  } else if (node.value) {
                    str = node.value;
                  }
                  if (str !== null) {
                    items.push({
                      str
                    });
                  }
                  if (!node.children) {
                    return;
                  }
                  for (const child of node.children) {
                    walk(child);
                  }
                }
                __name(walk, "walk");
                walk(xfa);
                return output;
              }
              static shouldBuildText(name) {
                return !(name === "textarea" || name === "input" || name === "option" || name === "select");
              }
            };
            __name(_XfaText, "XfaText");
            let XfaText = _XfaText;
            exports2.XfaText = XfaText;
          },
          /* 26 */
          /***/
          (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            exports2.TextLayerRenderTask = void 0;
            exports2.renderTextLayer = renderTextLayer;
            exports2.updateTextLayer = updateTextLayer;
            var _util2 = __w_pdfjs_require__2(1);
            var _display_utils2 = __w_pdfjs_require__2(6);
            const MAX_TEXT_DIVS_TO_RENDER = 1e5;
            const DEFAULT_FONT_SIZE = 30;
            const DEFAULT_FONT_ASCENT = 0.8;
            const ascentCache = /* @__PURE__ */ new Map();
            function getCtx(size, isOffscreenCanvasSupported) {
              let ctx;
              if (isOffscreenCanvasSupported && _util2.FeatureTest.isOffscreenCanvasSupported) {
                ctx = new OffscreenCanvas(size, size).getContext("2d", {
                  alpha: false
                });
              } else {
                const canvas = document.createElement("canvas");
                canvas.width = canvas.height = size;
                ctx = canvas.getContext("2d", {
                  alpha: false
                });
              }
              return ctx;
            }
            __name(getCtx, "getCtx");
            function getAscent(fontFamily, isOffscreenCanvasSupported) {
              const cachedAscent = ascentCache.get(fontFamily);
              if (cachedAscent) {
                return cachedAscent;
              }
              const ctx = getCtx(DEFAULT_FONT_SIZE, isOffscreenCanvasSupported);
              ctx.font = `${DEFAULT_FONT_SIZE}px ${fontFamily}`;
              const metrics = ctx.measureText("");
              let ascent = metrics.fontBoundingBoxAscent;
              let descent = Math.abs(metrics.fontBoundingBoxDescent);
              if (ascent) {
                const ratio = ascent / (ascent + descent);
                ascentCache.set(fontFamily, ratio);
                ctx.canvas.width = ctx.canvas.height = 0;
                return ratio;
              }
              ctx.strokeStyle = "red";
              ctx.clearRect(0, 0, DEFAULT_FONT_SIZE, DEFAULT_FONT_SIZE);
              ctx.strokeText("g", 0, 0);
              let pixels = ctx.getImageData(0, 0, DEFAULT_FONT_SIZE, DEFAULT_FONT_SIZE).data;
              descent = 0;
              for (let i2 = pixels.length - 1 - 3; i2 >= 0; i2 -= 4) {
                if (pixels[i2] > 0) {
                  descent = Math.ceil(i2 / 4 / DEFAULT_FONT_SIZE);
                  break;
                }
              }
              ctx.clearRect(0, 0, DEFAULT_FONT_SIZE, DEFAULT_FONT_SIZE);
              ctx.strokeText("A", 0, DEFAULT_FONT_SIZE);
              pixels = ctx.getImageData(0, 0, DEFAULT_FONT_SIZE, DEFAULT_FONT_SIZE).data;
              ascent = 0;
              for (let i2 = 0, ii = pixels.length; i2 < ii; i2 += 4) {
                if (pixels[i2] > 0) {
                  ascent = DEFAULT_FONT_SIZE - Math.floor(i2 / 4 / DEFAULT_FONT_SIZE);
                  break;
                }
              }
              ctx.canvas.width = ctx.canvas.height = 0;
              if (ascent) {
                const ratio = ascent / (ascent + descent);
                ascentCache.set(fontFamily, ratio);
                return ratio;
              }
              ascentCache.set(fontFamily, DEFAULT_FONT_ASCENT);
              return DEFAULT_FONT_ASCENT;
            }
            __name(getAscent, "getAscent");
            function appendText(task, geom, styles) {
              const textDiv = document.createElement("span");
              const textDivProperties = {
                angle: 0,
                canvasWidth: 0,
                hasText: geom.str !== "",
                hasEOL: geom.hasEOL,
                fontSize: 0
              };
              task._textDivs.push(textDiv);
              const tx = _util2.Util.transform(task._transform, geom.transform);
              let angle = Math.atan2(tx[1], tx[0]);
              const style = styles[geom.fontName];
              if (style.vertical) {
                angle += Math.PI / 2;
              }
              const fontHeight = Math.hypot(tx[2], tx[3]);
              const fontAscent = fontHeight * getAscent(style.fontFamily, task._isOffscreenCanvasSupported);
              let left, top;
              if (angle === 0) {
                left = tx[4];
                top = tx[5] - fontAscent;
              } else {
                left = tx[4] + fontAscent * Math.sin(angle);
                top = tx[5] - fontAscent * Math.cos(angle);
              }
              const scaleFactorStr = "calc(var(--scale-factor)*";
              const divStyle = textDiv.style;
              if (task._container === task._rootContainer) {
                divStyle.left = `${(100 * left / task._pageWidth).toFixed(2)}%`;
                divStyle.top = `${(100 * top / task._pageHeight).toFixed(2)}%`;
              } else {
                divStyle.left = `${scaleFactorStr}${left.toFixed(2)}px)`;
                divStyle.top = `${scaleFactorStr}${top.toFixed(2)}px)`;
              }
              divStyle.fontSize = `${scaleFactorStr}${fontHeight.toFixed(2)}px)`;
              divStyle.fontFamily = style.fontFamily;
              textDivProperties.fontSize = fontHeight;
              textDiv.setAttribute("role", "presentation");
              textDiv.textContent = geom.str;
              textDiv.dir = geom.dir;
              if (task._fontInspectorEnabled) {
                textDiv.dataset.fontName = geom.fontName;
              }
              if (angle !== 0) {
                textDivProperties.angle = angle * (180 / Math.PI);
              }
              let shouldScaleText = false;
              if (geom.str.length > 1) {
                shouldScaleText = true;
              } else if (geom.str !== " " && geom.transform[0] !== geom.transform[3]) {
                const absScaleX = Math.abs(geom.transform[0]), absScaleY = Math.abs(geom.transform[3]);
                if (absScaleX !== absScaleY && Math.max(absScaleX, absScaleY) / Math.min(absScaleX, absScaleY) > 1.5) {
                  shouldScaleText = true;
                }
              }
              if (shouldScaleText) {
                textDivProperties.canvasWidth = style.vertical ? geom.height : geom.width;
              }
              task._textDivProperties.set(textDiv, textDivProperties);
              if (task._isReadableStream) {
                task._layoutText(textDiv);
              }
            }
            __name(appendText, "appendText");
            function layout(params) {
              const {
                div,
                scale,
                properties,
                ctx,
                prevFontSize,
                prevFontFamily
              } = params;
              const {
                style
              } = div;
              let transform = "";
              if (properties.canvasWidth !== 0 && properties.hasText) {
                const {
                  fontFamily
                } = style;
                const {
                  canvasWidth,
                  fontSize
                } = properties;
                if (prevFontSize !== fontSize || prevFontFamily !== fontFamily) {
                  ctx.font = `${fontSize * scale}px ${fontFamily}`;
                  params.prevFontSize = fontSize;
                  params.prevFontFamily = fontFamily;
                }
                const {
                  width
                } = ctx.measureText(div.textContent);
                if (width > 0) {
                  transform = `scaleX(${canvasWidth * scale / width})`;
                }
              }
              if (properties.angle !== 0) {
                transform = `rotate(${properties.angle}deg) ${transform}`;
              }
              if (transform.length > 0) {
                style.transform = transform;
              }
            }
            __name(layout, "layout");
            function render(task) {
              if (task._canceled) {
                return;
              }
              const textDivs = task._textDivs;
              const capability = task._capability;
              const textDivsLength = textDivs.length;
              if (textDivsLength > MAX_TEXT_DIVS_TO_RENDER) {
                capability.resolve();
                return;
              }
              if (!task._isReadableStream) {
                for (const textDiv of textDivs) {
                  task._layoutText(textDiv);
                }
              }
              capability.resolve();
            }
            __name(render, "render");
            const _TextLayerRenderTask = class _TextLayerRenderTask {
              constructor({
                textContentSource,
                container,
                viewport,
                textDivs,
                textDivProperties,
                textContentItemsStr,
                isOffscreenCanvasSupported
              }) {
                var _a3;
                this._textContentSource = textContentSource;
                this._isReadableStream = textContentSource instanceof ReadableStream;
                this._container = this._rootContainer = container;
                this._textDivs = textDivs || [];
                this._textContentItemsStr = textContentItemsStr || [];
                this._isOffscreenCanvasSupported = isOffscreenCanvasSupported;
                this._fontInspectorEnabled = !!((_a3 = globalThis.FontInspector) == null ? void 0 : _a3.enabled);
                this._reader = null;
                this._textDivProperties = textDivProperties || /* @__PURE__ */ new WeakMap();
                this._canceled = false;
                this._capability = new _util2.PromiseCapability();
                this._layoutTextParams = {
                  prevFontSize: null,
                  prevFontFamily: null,
                  div: null,
                  scale: viewport.scale * (globalThis.devicePixelRatio || 1),
                  properties: null,
                  ctx: getCtx(0, isOffscreenCanvasSupported)
                };
                const {
                  pageWidth,
                  pageHeight,
                  pageX,
                  pageY
                } = viewport.rawDims;
                this._transform = [1, 0, 0, -1, -pageX, pageY + pageHeight];
                this._pageWidth = pageWidth;
                this._pageHeight = pageHeight;
                (0, _display_utils2.setLayerDimensions)(container, viewport);
                this._capability.promise.finally(() => {
                  this._layoutTextParams = null;
                }).catch(() => {
                });
              }
              get promise() {
                return this._capability.promise;
              }
              cancel() {
                this._canceled = true;
                if (this._reader) {
                  this._reader.cancel(new _util2.AbortException("TextLayer task cancelled.")).catch(() => {
                  });
                  this._reader = null;
                }
                this._capability.reject(new _util2.AbortException("TextLayer task cancelled."));
              }
              _processItems(items, styleCache) {
                for (const item of items) {
                  if (item.str === void 0) {
                    if (item.type === "beginMarkedContentProps" || item.type === "beginMarkedContent") {
                      const parent = this._container;
                      this._container = document.createElement("span");
                      this._container.classList.add("markedContent");
                      if (item.id !== null) {
                        this._container.setAttribute("id", `${item.id}`);
                      }
                      parent.append(this._container);
                    } else if (item.type === "endMarkedContent") {
                      this._container = this._container.parentNode;
                    }
                    continue;
                  }
                  this._textContentItemsStr.push(item.str);
                  appendText(this, item, styleCache);
                }
              }
              _layoutText(textDiv) {
                const textDivProperties = this._layoutTextParams.properties = this._textDivProperties.get(textDiv);
                this._layoutTextParams.div = textDiv;
                layout(this._layoutTextParams);
                if (textDivProperties.hasText) {
                  this._container.append(textDiv);
                }
                if (textDivProperties.hasEOL) {
                  const br = document.createElement("br");
                  br.setAttribute("role", "presentation");
                  this._container.append(br);
                }
              }
              _render() {
                const capability = new _util2.PromiseCapability();
                let styleCache = /* @__PURE__ */ Object.create(null);
                if (this._isReadableStream) {
                  const pump = /* @__PURE__ */ __name(() => {
                    this._reader.read().then(({
                      value,
                      done
                    }) => {
                      if (done) {
                        capability.resolve();
                        return;
                      }
                      Object.assign(styleCache, value.styles);
                      this._processItems(value.items, styleCache);
                      pump();
                    }, capability.reject);
                  }, "pump");
                  this._reader = this._textContentSource.getReader();
                  pump();
                } else if (this._textContentSource) {
                  const {
                    items,
                    styles
                  } = this._textContentSource;
                  this._processItems(items, styles);
                  capability.resolve();
                } else {
                  throw new Error('No "textContentSource" parameter specified.');
                }
                capability.promise.then(() => {
                  styleCache = null;
                  render(this);
                }, this._capability.reject);
              }
            };
            __name(_TextLayerRenderTask, "TextLayerRenderTask");
            let TextLayerRenderTask = _TextLayerRenderTask;
            exports2.TextLayerRenderTask = TextLayerRenderTask;
            function renderTextLayer(params) {
              if (!params.textContentSource && (params.textContent || params.textContentStream)) {
                (0, _display_utils2.deprecated)("The TextLayerRender `textContent`/`textContentStream` parameters will be removed in the future, please use `textContentSource` instead.");
                params.textContentSource = params.textContent || params.textContentStream;
              }
              const {
                container,
                viewport
              } = params;
              const style = getComputedStyle(container);
              const visibility = style.getPropertyValue("visibility");
              const scaleFactor = parseFloat(style.getPropertyValue("--scale-factor"));
              if (visibility === "visible" && (!scaleFactor || Math.abs(scaleFactor - viewport.scale) > 1e-5)) {
                console.error("The `--scale-factor` CSS-variable must be set, to the same value as `viewport.scale`, either on the `container`-element itself or higher up in the DOM.");
              }
              const task = new TextLayerRenderTask(params);
              task._render();
              return task;
            }
            __name(renderTextLayer, "renderTextLayer");
            function updateTextLayer({
              container,
              viewport,
              textDivs,
              textDivProperties,
              isOffscreenCanvasSupported,
              mustRotate = true,
              mustRescale = true
            }) {
              if (mustRotate) {
                (0, _display_utils2.setLayerDimensions)(container, {
                  rotation: viewport.rotation
                });
              }
              if (mustRescale) {
                const ctx = getCtx(0, isOffscreenCanvasSupported);
                const scale = viewport.scale * (globalThis.devicePixelRatio || 1);
                const params = {
                  prevFontSize: null,
                  prevFontFamily: null,
                  div: null,
                  scale,
                  properties: null,
                  ctx
                };
                for (const div of textDivs) {
                  params.properties = textDivProperties.get(div);
                  params.div = div;
                  layout(params);
                }
              }
            }
            __name(updateTextLayer, "updateTextLayer");
          },
          /* 27 */
          /***/
          (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
            var _accessibilityManager, _allowClick, _annotationLayer, _boundPointerup, _boundPointerdown, _editors, _hadPointerDown, _isCleaningUp, _isDisabling, _uiManager, _createNewEditor, createNewEditor_fn, _createAndAddNewEditor, createAndAddNewEditor_fn, _getCenterPoint, getCenterPoint_fn, _cleanup, cleanup_fn;
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            exports2.AnnotationEditorLayer = void 0;
            var _util2 = __w_pdfjs_require__2(1);
            var _editor = __w_pdfjs_require__2(4);
            var _freetext = __w_pdfjs_require__2(28);
            var _ink = __w_pdfjs_require__2(33);
            var _display_utils2 = __w_pdfjs_require__2(6);
            var _stamp = __w_pdfjs_require__2(34);
            const _AnnotationEditorLayer = class _AnnotationEditorLayer {
              constructor({
                uiManager,
                pageIndex,
                div,
                accessibilityManager,
                annotationLayer,
                viewport,
                l10n
              }) {
                __privateAdd(this, _createNewEditor);
                __privateAdd(this, _createAndAddNewEditor);
                __privateAdd(this, _getCenterPoint);
                __privateAdd(this, _cleanup);
                __privateAdd(this, _accessibilityManager, void 0);
                __privateAdd(this, _allowClick, false);
                __privateAdd(this, _annotationLayer, null);
                __privateAdd(this, _boundPointerup, this.pointerup.bind(this));
                __privateAdd(this, _boundPointerdown, this.pointerdown.bind(this));
                __privateAdd(this, _editors, /* @__PURE__ */ new Map());
                __privateAdd(this, _hadPointerDown, false);
                __privateAdd(this, _isCleaningUp, false);
                __privateAdd(this, _isDisabling, false);
                __privateAdd(this, _uiManager, void 0);
                const editorTypes = [_freetext.FreeTextEditor, _ink.InkEditor, _stamp.StampEditor];
                if (!_AnnotationEditorLayer._initialized) {
                  _AnnotationEditorLayer._initialized = true;
                  for (const editorType of editorTypes) {
                    editorType.initialize(l10n);
                  }
                }
                uiManager.registerEditorTypes(editorTypes);
                __privateSet(this, _uiManager, uiManager);
                this.pageIndex = pageIndex;
                this.div = div;
                __privateSet(this, _accessibilityManager, accessibilityManager);
                __privateSet(this, _annotationLayer, annotationLayer);
                this.viewport = viewport;
                __privateGet(this, _uiManager).addLayer(this);
              }
              get isEmpty() {
                return __privateGet(this, _editors).size === 0;
              }
              updateToolbar(mode) {
                __privateGet(this, _uiManager).updateToolbar(mode);
              }
              updateMode(mode = __privateGet(this, _uiManager).getMode()) {
                __privateMethod(this, _cleanup, cleanup_fn).call(this);
                if (mode === _util2.AnnotationEditorType.INK) {
                  this.addInkEditorIfNeeded(false);
                  this.disableClick();
                } else {
                  this.enableClick();
                }
                if (mode !== _util2.AnnotationEditorType.NONE) {
                  this.div.classList.toggle("freeTextEditing", mode === _util2.AnnotationEditorType.FREETEXT);
                  this.div.classList.toggle("inkEditing", mode === _util2.AnnotationEditorType.INK);
                  this.div.classList.toggle("stampEditing", mode === _util2.AnnotationEditorType.STAMP);
                  this.div.hidden = false;
                }
              }
              addInkEditorIfNeeded(isCommitting) {
                if (!isCommitting && __privateGet(this, _uiManager).getMode() !== _util2.AnnotationEditorType.INK) {
                  return;
                }
                if (!isCommitting) {
                  for (const editor2 of __privateGet(this, _editors).values()) {
                    if (editor2.isEmpty()) {
                      editor2.setInBackground();
                      return;
                    }
                  }
                }
                const editor = __privateMethod(this, _createAndAddNewEditor, createAndAddNewEditor_fn).call(this, {
                  offsetX: 0,
                  offsetY: 0
                }, false);
                editor.setInBackground();
              }
              setEditingState(isEditing) {
                __privateGet(this, _uiManager).setEditingState(isEditing);
              }
              addCommands(params) {
                __privateGet(this, _uiManager).addCommands(params);
              }
              enable() {
                this.div.style.pointerEvents = "auto";
                const annotationElementIds = /* @__PURE__ */ new Set();
                for (const editor of __privateGet(this, _editors).values()) {
                  editor.enableEditing();
                  if (editor.annotationElementId) {
                    annotationElementIds.add(editor.annotationElementId);
                  }
                }
                if (!__privateGet(this, _annotationLayer)) {
                  return;
                }
                const editables = __privateGet(this, _annotationLayer).getEditableAnnotations();
                for (const editable of editables) {
                  editable.hide();
                  if (__privateGet(this, _uiManager).isDeletedAnnotationElement(editable.data.id)) {
                    continue;
                  }
                  if (annotationElementIds.has(editable.data.id)) {
                    continue;
                  }
                  const editor = this.deserialize(editable);
                  if (!editor) {
                    continue;
                  }
                  this.addOrRebuild(editor);
                  editor.enableEditing();
                }
              }
              disable() {
                var _a3;
                __privateSet(this, _isDisabling, true);
                this.div.style.pointerEvents = "none";
                const hiddenAnnotationIds = /* @__PURE__ */ new Set();
                for (const editor of __privateGet(this, _editors).values()) {
                  editor.disableEditing();
                  if (!editor.annotationElementId || editor.serialize() !== null) {
                    hiddenAnnotationIds.add(editor.annotationElementId);
                    continue;
                  }
                  (_a3 = this.getEditableAnnotation(editor.annotationElementId)) == null ? void 0 : _a3.show();
                  editor.remove();
                }
                if (__privateGet(this, _annotationLayer)) {
                  const editables = __privateGet(this, _annotationLayer).getEditableAnnotations();
                  for (const editable of editables) {
                    const {
                      id
                    } = editable.data;
                    if (hiddenAnnotationIds.has(id) || __privateGet(this, _uiManager).isDeletedAnnotationElement(id)) {
                      continue;
                    }
                    editable.show();
                  }
                }
                __privateMethod(this, _cleanup, cleanup_fn).call(this);
                if (this.isEmpty) {
                  this.div.hidden = true;
                }
                __privateSet(this, _isDisabling, false);
              }
              getEditableAnnotation(id) {
                var _a3;
                return ((_a3 = __privateGet(this, _annotationLayer)) == null ? void 0 : _a3.getEditableAnnotation(id)) || null;
              }
              setActiveEditor(editor) {
                const currentActive = __privateGet(this, _uiManager).getActive();
                if (currentActive === editor) {
                  return;
                }
                __privateGet(this, _uiManager).setActiveEditor(editor);
              }
              enableClick() {
                this.div.addEventListener("pointerdown", __privateGet(this, _boundPointerdown));
                this.div.addEventListener("pointerup", __privateGet(this, _boundPointerup));
              }
              disableClick() {
                this.div.removeEventListener("pointerdown", __privateGet(this, _boundPointerdown));
                this.div.removeEventListener("pointerup", __privateGet(this, _boundPointerup));
              }
              attach(editor) {
                __privateGet(this, _editors).set(editor.id, editor);
                const {
                  annotationElementId
                } = editor;
                if (annotationElementId && __privateGet(this, _uiManager).isDeletedAnnotationElement(annotationElementId)) {
                  __privateGet(this, _uiManager).removeDeletedAnnotationElement(editor);
                }
              }
              detach(editor) {
                var _a3;
                __privateGet(this, _editors).delete(editor.id);
                (_a3 = __privateGet(this, _accessibilityManager)) == null ? void 0 : _a3.removePointerInTextLayer(editor.contentDiv);
                if (!__privateGet(this, _isDisabling) && editor.annotationElementId) {
                  __privateGet(this, _uiManager).addDeletedAnnotationElement(editor);
                }
              }
              remove(editor) {
                this.detach(editor);
                __privateGet(this, _uiManager).removeEditor(editor);
                if (editor.div.contains(document.activeElement)) {
                  setTimeout(() => {
                    __privateGet(this, _uiManager).focusMainContainer();
                  }, 0);
                }
                editor.div.remove();
                editor.isAttachedToDOM = false;
                if (!__privateGet(this, _isCleaningUp)) {
                  this.addInkEditorIfNeeded(false);
                }
              }
              changeParent(editor) {
                var _a3;
                if (editor.parent === this) {
                  return;
                }
                if (editor.annotationElementId) {
                  __privateGet(this, _uiManager).addDeletedAnnotationElement(editor.annotationElementId);
                  _editor.AnnotationEditor.deleteAnnotationElement(editor);
                  editor.annotationElementId = null;
                }
                this.attach(editor);
                (_a3 = editor.parent) == null ? void 0 : _a3.detach(editor);
                editor.setParent(this);
                if (editor.div && editor.isAttachedToDOM) {
                  editor.div.remove();
                  this.div.append(editor.div);
                }
              }
              add(editor) {
                this.changeParent(editor);
                __privateGet(this, _uiManager).addEditor(editor);
                this.attach(editor);
                if (!editor.isAttachedToDOM) {
                  const div = editor.render();
                  this.div.append(div);
                  editor.isAttachedToDOM = true;
                }
                editor.fixAndSetPosition();
                editor.onceAdded();
                __privateGet(this, _uiManager).addToAnnotationStorage(editor);
              }
              moveEditorInDOM(editor) {
                var _a3;
                if (!editor.isAttachedToDOM) {
                  return;
                }
                const {
                  activeElement
                } = document;
                if (editor.div.contains(activeElement)) {
                  editor._focusEventsAllowed = false;
                  setTimeout(() => {
                    if (!editor.div.contains(document.activeElement)) {
                      editor.div.addEventListener("focusin", () => {
                        editor._focusEventsAllowed = true;
                      }, {
                        once: true
                      });
                      activeElement.focus();
                    } else {
                      editor._focusEventsAllowed = true;
                    }
                  }, 0);
                }
                editor._structTreeParentId = (_a3 = __privateGet(this, _accessibilityManager)) == null ? void 0 : _a3.moveElementInDOM(this.div, editor.div, editor.contentDiv, true);
              }
              addOrRebuild(editor) {
                if (editor.needsToBeRebuilt()) {
                  editor.rebuild();
                } else {
                  this.add(editor);
                }
              }
              addUndoableEditor(editor) {
                const cmd = /* @__PURE__ */ __name(() => editor._uiManager.rebuild(editor), "cmd");
                const undo = /* @__PURE__ */ __name(() => {
                  editor.remove();
                }, "undo");
                this.addCommands({
                  cmd,
                  undo,
                  mustExec: false
                });
              }
              getNextId() {
                return __privateGet(this, _uiManager).getId();
              }
              pasteEditor(mode, params) {
                __privateGet(this, _uiManager).updateToolbar(mode);
                __privateGet(this, _uiManager).updateMode(mode);
                const {
                  offsetX,
                  offsetY
                } = __privateMethod(this, _getCenterPoint, getCenterPoint_fn).call(this);
                const id = this.getNextId();
                const editor = __privateMethod(this, _createNewEditor, createNewEditor_fn).call(this, {
                  parent: this,
                  id,
                  x: offsetX,
                  y: offsetY,
                  uiManager: __privateGet(this, _uiManager),
                  isCentered: true,
                  ...params
                });
                if (editor) {
                  this.add(editor);
                }
              }
              deserialize(data) {
                switch (data.annotationType ?? data.annotationEditorType) {
                  case _util2.AnnotationEditorType.FREETEXT:
                    return _freetext.FreeTextEditor.deserialize(data, this, __privateGet(this, _uiManager));
                  case _util2.AnnotationEditorType.INK:
                    return _ink.InkEditor.deserialize(data, this, __privateGet(this, _uiManager));
                  case _util2.AnnotationEditorType.STAMP:
                    return _stamp.StampEditor.deserialize(data, this, __privateGet(this, _uiManager));
                }
                return null;
              }
              addNewEditor() {
                __privateMethod(this, _createAndAddNewEditor, createAndAddNewEditor_fn).call(this, __privateMethod(this, _getCenterPoint, getCenterPoint_fn).call(this), true);
              }
              setSelected(editor) {
                __privateGet(this, _uiManager).setSelected(editor);
              }
              toggleSelected(editor) {
                __privateGet(this, _uiManager).toggleSelected(editor);
              }
              isSelected(editor) {
                return __privateGet(this, _uiManager).isSelected(editor);
              }
              unselect(editor) {
                __privateGet(this, _uiManager).unselect(editor);
              }
              pointerup(event) {
                const {
                  isMac
                } = _util2.FeatureTest.platform;
                if (event.button !== 0 || event.ctrlKey && isMac) {
                  return;
                }
                if (event.target !== this.div) {
                  return;
                }
                if (!__privateGet(this, _hadPointerDown)) {
                  return;
                }
                __privateSet(this, _hadPointerDown, false);
                if (!__privateGet(this, _allowClick)) {
                  __privateSet(this, _allowClick, true);
                  return;
                }
                if (__privateGet(this, _uiManager).getMode() === _util2.AnnotationEditorType.STAMP) {
                  __privateGet(this, _uiManager).unselectAll();
                  return;
                }
                __privateMethod(this, _createAndAddNewEditor, createAndAddNewEditor_fn).call(this, event, false);
              }
              pointerdown(event) {
                if (__privateGet(this, _hadPointerDown)) {
                  __privateSet(this, _hadPointerDown, false);
                  return;
                }
                const {
                  isMac
                } = _util2.FeatureTest.platform;
                if (event.button !== 0 || event.ctrlKey && isMac) {
                  return;
                }
                if (event.target !== this.div) {
                  return;
                }
                __privateSet(this, _hadPointerDown, true);
                const editor = __privateGet(this, _uiManager).getActive();
                __privateSet(this, _allowClick, !editor || editor.isEmpty());
              }
              findNewParent(editor, x2, y2) {
                const layer = __privateGet(this, _uiManager).findParent(x2, y2);
                if (layer === null || layer === this) {
                  return false;
                }
                layer.changeParent(editor);
                return true;
              }
              destroy() {
                var _a3, _b2;
                if (((_a3 = __privateGet(this, _uiManager).getActive()) == null ? void 0 : _a3.parent) === this) {
                  __privateGet(this, _uiManager).commitOrRemove();
                  __privateGet(this, _uiManager).setActiveEditor(null);
                }
                for (const editor of __privateGet(this, _editors).values()) {
                  (_b2 = __privateGet(this, _accessibilityManager)) == null ? void 0 : _b2.removePointerInTextLayer(editor.contentDiv);
                  editor.setParent(null);
                  editor.isAttachedToDOM = false;
                  editor.div.remove();
                }
                this.div = null;
                __privateGet(this, _editors).clear();
                __privateGet(this, _uiManager).removeLayer(this);
              }
              render({
                viewport
              }) {
                this.viewport = viewport;
                (0, _display_utils2.setLayerDimensions)(this.div, viewport);
                for (const editor of __privateGet(this, _uiManager).getEditors(this.pageIndex)) {
                  this.add(editor);
                }
                this.updateMode();
              }
              update({
                viewport
              }) {
                __privateGet(this, _uiManager).commitOrRemove();
                this.viewport = viewport;
                (0, _display_utils2.setLayerDimensions)(this.div, {
                  rotation: viewport.rotation
                });
                this.updateMode();
              }
              get pageDimensions() {
                const {
                  pageWidth,
                  pageHeight
                } = this.viewport.rawDims;
                return [pageWidth, pageHeight];
              }
            };
            _accessibilityManager = new WeakMap();
            _allowClick = new WeakMap();
            _annotationLayer = new WeakMap();
            _boundPointerup = new WeakMap();
            _boundPointerdown = new WeakMap();
            _editors = new WeakMap();
            _hadPointerDown = new WeakMap();
            _isCleaningUp = new WeakMap();
            _isDisabling = new WeakMap();
            _uiManager = new WeakMap();
            _createNewEditor = new WeakSet();
            createNewEditor_fn = /* @__PURE__ */ __name(function(params) {
              switch (__privateGet(this, _uiManager).getMode()) {
                case _util2.AnnotationEditorType.FREETEXT:
                  return new _freetext.FreeTextEditor(params);
                case _util2.AnnotationEditorType.INK:
                  return new _ink.InkEditor(params);
                case _util2.AnnotationEditorType.STAMP:
                  return new _stamp.StampEditor(params);
              }
              return null;
            }, "#createNewEditor");
            _createAndAddNewEditor = new WeakSet();
            createAndAddNewEditor_fn = /* @__PURE__ */ __name(function(event, isCentered) {
              const id = this.getNextId();
              const editor = __privateMethod(this, _createNewEditor, createNewEditor_fn).call(this, {
                parent: this,
                id,
                x: event.offsetX,
                y: event.offsetY,
                uiManager: __privateGet(this, _uiManager),
                isCentered
              });
              if (editor) {
                this.add(editor);
              }
              return editor;
            }, "#createAndAddNewEditor");
            _getCenterPoint = new WeakSet();
            getCenterPoint_fn = /* @__PURE__ */ __name(function() {
              const {
                x: x2,
                y: y2,
                width,
                height
              } = this.div.getBoundingClientRect();
              const tlX = Math.max(0, x2);
              const tlY = Math.max(0, y2);
              const brX = Math.min(window.innerWidth, x2 + width);
              const brY = Math.min(window.innerHeight, y2 + height);
              const centerX = (tlX + brX) / 2 - x2;
              const centerY = (tlY + brY) / 2 - y2;
              const [offsetX, offsetY] = this.viewport.rotation % 180 === 0 ? [centerX, centerY] : [centerY, centerX];
              return {
                offsetX,
                offsetY
              };
            }, "#getCenterPoint");
            _cleanup = new WeakSet();
            cleanup_fn = /* @__PURE__ */ __name(function() {
              __privateSet(this, _isCleaningUp, true);
              for (const editor of __privateGet(this, _editors).values()) {
                if (editor.isEmpty()) {
                  editor.remove();
                }
              }
              __privateSet(this, _isCleaningUp, false);
            }, "#cleanup");
            __name(_AnnotationEditorLayer, "AnnotationEditorLayer");
            __publicField(_AnnotationEditorLayer, "_initialized", false);
            let AnnotationEditorLayer = _AnnotationEditorLayer;
            exports2.AnnotationEditorLayer = AnnotationEditorLayer;
          },
          /* 28 */
          /***/
          (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
            var _boundEditorDivBlur, _boundEditorDivFocus, _boundEditorDivInput, _boundEditorDivKeydown, _color, _content, _editorDivId, _fontSize, _initialData, _updateFontSize, updateFontSize_fn, _updateColor, updateColor_fn, _extractText, extractText_fn, _setEditorDimensions, setEditorDimensions_fn, _setContent, setContent_fn, _hasElementChanged, hasElementChanged_fn, _cheatInitialRect, cheatInitialRect_fn;
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            exports2.FreeTextEditor = void 0;
            var _util2 = __w_pdfjs_require__2(1);
            var _tools = __w_pdfjs_require__2(5);
            var _editor = __w_pdfjs_require__2(4);
            var _annotation_layer = __w_pdfjs_require__2(29);
            const _FreeTextEditor = class _FreeTextEditor extends _editor.AnnotationEditor {
              constructor(params) {
                super({
                  ...params,
                  name: "freeTextEditor"
                });
                __privateAdd(this, _updateFontSize);
                __privateAdd(this, _updateColor);
                __privateAdd(this, _extractText);
                __privateAdd(this, _setEditorDimensions);
                __privateAdd(this, _setContent);
                __privateAdd(this, _hasElementChanged);
                __privateAdd(this, _cheatInitialRect);
                __privateAdd(this, _boundEditorDivBlur, this.editorDivBlur.bind(this));
                __privateAdd(this, _boundEditorDivFocus, this.editorDivFocus.bind(this));
                __privateAdd(this, _boundEditorDivInput, this.editorDivInput.bind(this));
                __privateAdd(this, _boundEditorDivKeydown, this.editorDivKeydown.bind(this));
                __privateAdd(this, _color, void 0);
                __privateAdd(this, _content, "");
                __privateAdd(this, _editorDivId, `${this.id}-editor`);
                __privateAdd(this, _fontSize, void 0);
                __privateAdd(this, _initialData, null);
                __privateSet(this, _color, params.color || _FreeTextEditor._defaultColor || _editor.AnnotationEditor._defaultLineColor);
                __privateSet(this, _fontSize, params.fontSize || _FreeTextEditor._defaultFontSize);
              }
              static get _keyboardManager() {
                const proto = _FreeTextEditor.prototype;
                const arrowChecker = /* @__PURE__ */ __name((self2) => self2.isEmpty(), "arrowChecker");
                const small = _tools.AnnotationEditorUIManager.TRANSLATE_SMALL;
                const big = _tools.AnnotationEditorUIManager.TRANSLATE_BIG;
                return (0, _util2.shadow)(this, "_keyboardManager", new _tools.KeyboardManager([[["ctrl+s", "mac+meta+s", "ctrl+p", "mac+meta+p"], proto.commitOrRemove, {
                  bubbles: true
                }], [["ctrl+Enter", "mac+meta+Enter", "Escape", "mac+Escape"], proto.commitOrRemove], [["ArrowLeft", "mac+ArrowLeft"], proto._translateEmpty, {
                  args: [-small, 0],
                  checker: arrowChecker
                }], [["ctrl+ArrowLeft", "mac+shift+ArrowLeft"], proto._translateEmpty, {
                  args: [-big, 0],
                  checker: arrowChecker
                }], [["ArrowRight", "mac+ArrowRight"], proto._translateEmpty, {
                  args: [small, 0],
                  checker: arrowChecker
                }], [["ctrl+ArrowRight", "mac+shift+ArrowRight"], proto._translateEmpty, {
                  args: [big, 0],
                  checker: arrowChecker
                }], [["ArrowUp", "mac+ArrowUp"], proto._translateEmpty, {
                  args: [0, -small],
                  checker: arrowChecker
                }], [["ctrl+ArrowUp", "mac+shift+ArrowUp"], proto._translateEmpty, {
                  args: [0, -big],
                  checker: arrowChecker
                }], [["ArrowDown", "mac+ArrowDown"], proto._translateEmpty, {
                  args: [0, small],
                  checker: arrowChecker
                }], [["ctrl+ArrowDown", "mac+shift+ArrowDown"], proto._translateEmpty, {
                  args: [0, big],
                  checker: arrowChecker
                }]]));
              }
              static initialize(l10n) {
                _editor.AnnotationEditor.initialize(l10n, {
                  strings: ["free_text2_default_content", "editor_free_text2_aria_label"]
                });
                const style = getComputedStyle(document.documentElement);
                this._internalPadding = parseFloat(style.getPropertyValue("--freetext-padding"));
              }
              static updateDefaultParams(type, value) {
                switch (type) {
                  case _util2.AnnotationEditorParamsType.FREETEXT_SIZE:
                    _FreeTextEditor._defaultFontSize = value;
                    break;
                  case _util2.AnnotationEditorParamsType.FREETEXT_COLOR:
                    _FreeTextEditor._defaultColor = value;
                    break;
                }
              }
              updateParams(type, value) {
                switch (type) {
                  case _util2.AnnotationEditorParamsType.FREETEXT_SIZE:
                    __privateMethod(this, _updateFontSize, updateFontSize_fn).call(this, value);
                    break;
                  case _util2.AnnotationEditorParamsType.FREETEXT_COLOR:
                    __privateMethod(this, _updateColor, updateColor_fn).call(this, value);
                    break;
                }
              }
              static get defaultPropertiesToUpdate() {
                return [[_util2.AnnotationEditorParamsType.FREETEXT_SIZE, _FreeTextEditor._defaultFontSize], [_util2.AnnotationEditorParamsType.FREETEXT_COLOR, _FreeTextEditor._defaultColor || _editor.AnnotationEditor._defaultLineColor]];
              }
              get propertiesToUpdate() {
                return [[_util2.AnnotationEditorParamsType.FREETEXT_SIZE, __privateGet(this, _fontSize)], [_util2.AnnotationEditorParamsType.FREETEXT_COLOR, __privateGet(this, _color)]];
              }
              _translateEmpty(x2, y2) {
                this._uiManager.translateSelectedEditors(x2, y2, true);
              }
              getInitialTranslation() {
                const scale = this.parentScale;
                return [-_FreeTextEditor._internalPadding * scale, -(_FreeTextEditor._internalPadding + __privateGet(this, _fontSize)) * scale];
              }
              rebuild() {
                if (!this.parent) {
                  return;
                }
                super.rebuild();
                if (this.div === null) {
                  return;
                }
                if (!this.isAttachedToDOM) {
                  this.parent.add(this);
                }
              }
              enableEditMode() {
                if (this.isInEditMode()) {
                  return;
                }
                this.parent.setEditingState(false);
                this.parent.updateToolbar(_util2.AnnotationEditorType.FREETEXT);
                super.enableEditMode();
                this.overlayDiv.classList.remove("enabled");
                this.editorDiv.contentEditable = true;
                this._isDraggable = false;
                this.div.removeAttribute("aria-activedescendant");
                this.editorDiv.addEventListener("keydown", __privateGet(this, _boundEditorDivKeydown));
                this.editorDiv.addEventListener("focus", __privateGet(this, _boundEditorDivFocus));
                this.editorDiv.addEventListener("blur", __privateGet(this, _boundEditorDivBlur));
                this.editorDiv.addEventListener("input", __privateGet(this, _boundEditorDivInput));
              }
              disableEditMode() {
                if (!this.isInEditMode()) {
                  return;
                }
                this.parent.setEditingState(true);
                super.disableEditMode();
                this.overlayDiv.classList.add("enabled");
                this.editorDiv.contentEditable = false;
                this.div.setAttribute("aria-activedescendant", __privateGet(this, _editorDivId));
                this._isDraggable = true;
                this.editorDiv.removeEventListener("keydown", __privateGet(this, _boundEditorDivKeydown));
                this.editorDiv.removeEventListener("focus", __privateGet(this, _boundEditorDivFocus));
                this.editorDiv.removeEventListener("blur", __privateGet(this, _boundEditorDivBlur));
                this.editorDiv.removeEventListener("input", __privateGet(this, _boundEditorDivInput));
                this.div.focus({
                  preventScroll: true
                });
                this.isEditing = false;
                this.parent.div.classList.add("freeTextEditing");
              }
              focusin(event) {
                if (!this._focusEventsAllowed) {
                  return;
                }
                super.focusin(event);
                if (event.target !== this.editorDiv) {
                  this.editorDiv.focus();
                }
              }
              onceAdded() {
                var _a3;
                if (this.width) {
                  __privateMethod(this, _cheatInitialRect, cheatInitialRect_fn).call(this);
                  return;
                }
                this.enableEditMode();
                this.editorDiv.focus();
                if ((_a3 = this._initialOptions) == null ? void 0 : _a3.isCentered) {
                  this.center();
                }
                this._initialOptions = null;
              }
              isEmpty() {
                return !this.editorDiv || this.editorDiv.innerText.trim() === "";
              }
              remove() {
                this.isEditing = false;
                if (this.parent) {
                  this.parent.setEditingState(true);
                  this.parent.div.classList.add("freeTextEditing");
                }
                super.remove();
              }
              commit() {
                if (!this.isInEditMode()) {
                  return;
                }
                super.commit();
                this.disableEditMode();
                const savedText = __privateGet(this, _content);
                const newText = __privateSet(this, _content, __privateMethod(this, _extractText, extractText_fn).call(this).trimEnd());
                if (savedText === newText) {
                  return;
                }
                const setText = /* @__PURE__ */ __name((text) => {
                  __privateSet(this, _content, text);
                  if (!text) {
                    this.remove();
                    return;
                  }
                  __privateMethod(this, _setContent, setContent_fn).call(this);
                  this._uiManager.rebuild(this);
                  __privateMethod(this, _setEditorDimensions, setEditorDimensions_fn).call(this);
                }, "setText");
                this.addCommands({
                  cmd: () => {
                    setText(newText);
                  },
                  undo: () => {
                    setText(savedText);
                  },
                  mustExec: false
                });
                __privateMethod(this, _setEditorDimensions, setEditorDimensions_fn).call(this);
              }
              shouldGetKeyboardEvents() {
                return this.isInEditMode();
              }
              enterInEditMode() {
                this.enableEditMode();
                this.editorDiv.focus();
              }
              dblclick(event) {
                this.enterInEditMode();
              }
              keydown(event) {
                if (event.target === this.div && event.key === "Enter") {
                  this.enterInEditMode();
                  event.preventDefault();
                }
              }
              editorDivKeydown(event) {
                _FreeTextEditor._keyboardManager.exec(this, event);
              }
              editorDivFocus(event) {
                this.isEditing = true;
              }
              editorDivBlur(event) {
                this.isEditing = false;
              }
              editorDivInput(event) {
                this.parent.div.classList.toggle("freeTextEditing", this.isEmpty());
              }
              disableEditing() {
                this.editorDiv.setAttribute("role", "comment");
                this.editorDiv.removeAttribute("aria-multiline");
              }
              enableEditing() {
                this.editorDiv.setAttribute("role", "textbox");
                this.editorDiv.setAttribute("aria-multiline", true);
              }
              render() {
                if (this.div) {
                  return this.div;
                }
                let baseX, baseY;
                if (this.width) {
                  baseX = this.x;
                  baseY = this.y;
                }
                super.render();
                this.editorDiv = document.createElement("div");
                this.editorDiv.className = "internal";
                this.editorDiv.setAttribute("id", __privateGet(this, _editorDivId));
                this.enableEditing();
                _editor.AnnotationEditor._l10nPromise.get("editor_free_text2_aria_label").then((msg) => {
                  var _a3;
                  return (_a3 = this.editorDiv) == null ? void 0 : _a3.setAttribute("aria-label", msg);
                });
                _editor.AnnotationEditor._l10nPromise.get("free_text2_default_content").then((msg) => {
                  var _a3;
                  return (_a3 = this.editorDiv) == null ? void 0 : _a3.setAttribute("default-content", msg);
                });
                this.editorDiv.contentEditable = true;
                const {
                  style
                } = this.editorDiv;
                style.fontSize = `calc(${__privateGet(this, _fontSize)}px * var(--scale-factor))`;
                style.color = __privateGet(this, _color);
                this.div.append(this.editorDiv);
                this.overlayDiv = document.createElement("div");
                this.overlayDiv.classList.add("overlay", "enabled");
                this.div.append(this.overlayDiv);
                (0, _tools.bindEvents)(this, this.div, ["dblclick", "keydown"]);
                if (this.width) {
                  const [parentWidth, parentHeight] = this.parentDimensions;
                  if (this.annotationElementId) {
                    const {
                      position
                    } = __privateGet(this, _initialData);
                    let [tx, ty] = this.getInitialTranslation();
                    [tx, ty] = this.pageTranslationToScreen(tx, ty);
                    const [pageWidth, pageHeight] = this.pageDimensions;
                    const [pageX, pageY] = this.pageTranslation;
                    let posX, posY;
                    switch (this.rotation) {
                      case 0:
                        posX = baseX + (position[0] - pageX) / pageWidth;
                        posY = baseY + this.height - (position[1] - pageY) / pageHeight;
                        break;
                      case 90:
                        posX = baseX + (position[0] - pageX) / pageWidth;
                        posY = baseY - (position[1] - pageY) / pageHeight;
                        [tx, ty] = [ty, -tx];
                        break;
                      case 180:
                        posX = baseX - this.width + (position[0] - pageX) / pageWidth;
                        posY = baseY - (position[1] - pageY) / pageHeight;
                        [tx, ty] = [-tx, -ty];
                        break;
                      case 270:
                        posX = baseX + (position[0] - pageX - this.height * pageHeight) / pageWidth;
                        posY = baseY + (position[1] - pageY - this.width * pageWidth) / pageHeight;
                        [tx, ty] = [-ty, tx];
                        break;
                    }
                    this.setAt(posX * parentWidth, posY * parentHeight, tx, ty);
                  } else {
                    this.setAt(baseX * parentWidth, baseY * parentHeight, this.width * parentWidth, this.height * parentHeight);
                  }
                  __privateMethod(this, _setContent, setContent_fn).call(this);
                  this._isDraggable = true;
                  this.editorDiv.contentEditable = false;
                } else {
                  this._isDraggable = false;
                  this.editorDiv.contentEditable = true;
                }
                return this.div;
              }
              get contentDiv() {
                return this.editorDiv;
              }
              static deserialize(data, parent, uiManager) {
                let initialData = null;
                if (data instanceof _annotation_layer.FreeTextAnnotationElement) {
                  const {
                    data: {
                      defaultAppearanceData: {
                        fontSize,
                        fontColor
                      },
                      rect,
                      rotation,
                      id
                    },
                    textContent,
                    textPosition,
                    parent: {
                      page: {
                        pageNumber
                      }
                    }
                  } = data;
                  if (!textContent || textContent.length === 0) {
                    return null;
                  }
                  initialData = data = {
                    annotationType: _util2.AnnotationEditorType.FREETEXT,
                    color: Array.from(fontColor),
                    fontSize,
                    value: textContent.join("\n"),
                    position: textPosition,
                    pageIndex: pageNumber - 1,
                    rect,
                    rotation,
                    id,
                    deleted: false
                  };
                }
                const editor = super.deserialize(data, parent, uiManager);
                __privateSet(editor, _fontSize, data.fontSize);
                __privateSet(editor, _color, _util2.Util.makeHexColor(...data.color));
                __privateSet(editor, _content, data.value);
                editor.annotationElementId = data.id || null;
                __privateSet(editor, _initialData, initialData);
                return editor;
              }
              serialize(isForCopying = false) {
                if (this.isEmpty()) {
                  return null;
                }
                if (this.deleted) {
                  return {
                    pageIndex: this.pageIndex,
                    id: this.annotationElementId,
                    deleted: true
                  };
                }
                const padding = _FreeTextEditor._internalPadding * this.parentScale;
                const rect = this.getRect(padding, padding);
                const color2 = _editor.AnnotationEditor._colorManager.convert(this.isAttachedToDOM ? getComputedStyle(this.editorDiv).color : __privateGet(this, _color));
                const serialized = {
                  annotationType: _util2.AnnotationEditorType.FREETEXT,
                  color: color2,
                  fontSize: __privateGet(this, _fontSize),
                  value: __privateGet(this, _content),
                  pageIndex: this.pageIndex,
                  rect,
                  rotation: this.rotation,
                  structTreeParentId: this._structTreeParentId
                };
                if (isForCopying) {
                  return serialized;
                }
                if (this.annotationElementId && !__privateMethod(this, _hasElementChanged, hasElementChanged_fn).call(this, serialized)) {
                  return null;
                }
                serialized.id = this.annotationElementId;
                return serialized;
              }
            };
            _boundEditorDivBlur = new WeakMap();
            _boundEditorDivFocus = new WeakMap();
            _boundEditorDivInput = new WeakMap();
            _boundEditorDivKeydown = new WeakMap();
            _color = new WeakMap();
            _content = new WeakMap();
            _editorDivId = new WeakMap();
            _fontSize = new WeakMap();
            _initialData = new WeakMap();
            _updateFontSize = new WeakSet();
            updateFontSize_fn = /* @__PURE__ */ __name(function(fontSize) {
              const setFontsize = /* @__PURE__ */ __name((size) => {
                this.editorDiv.style.fontSize = `calc(${size}px * var(--scale-factor))`;
                this.translate(0, -(size - __privateGet(this, _fontSize)) * this.parentScale);
                __privateSet(this, _fontSize, size);
                __privateMethod(this, _setEditorDimensions, setEditorDimensions_fn).call(this);
              }, "setFontsize");
              const savedFontsize = __privateGet(this, _fontSize);
              this.addCommands({
                cmd: () => {
                  setFontsize(fontSize);
                },
                undo: () => {
                  setFontsize(savedFontsize);
                },
                mustExec: true,
                type: _util2.AnnotationEditorParamsType.FREETEXT_SIZE,
                overwriteIfSameType: true,
                keepUndo: true
              });
            }, "#updateFontSize");
            _updateColor = new WeakSet();
            updateColor_fn = /* @__PURE__ */ __name(function(color2) {
              const savedColor = __privateGet(this, _color);
              this.addCommands({
                cmd: () => {
                  __privateSet(this, _color, this.editorDiv.style.color = color2);
                },
                undo: () => {
                  __privateSet(this, _color, this.editorDiv.style.color = savedColor);
                },
                mustExec: true,
                type: _util2.AnnotationEditorParamsType.FREETEXT_COLOR,
                overwriteIfSameType: true,
                keepUndo: true
              });
            }, "#updateColor");
            _extractText = new WeakSet();
            extractText_fn = /* @__PURE__ */ __name(function() {
              const divs = this.editorDiv.getElementsByTagName("div");
              if (divs.length === 0) {
                return this.editorDiv.innerText;
              }
              const buffer = [];
              for (const div of divs) {
                buffer.push(div.innerText.replace(/\r\n?|\n/, ""));
              }
              return buffer.join("\n");
            }, "#extractText");
            _setEditorDimensions = new WeakSet();
            setEditorDimensions_fn = /* @__PURE__ */ __name(function() {
              const [parentWidth, parentHeight] = this.parentDimensions;
              let rect;
              if (this.isAttachedToDOM) {
                rect = this.div.getBoundingClientRect();
              } else {
                const {
                  currentLayer,
                  div
                } = this;
                const savedDisplay = div.style.display;
                div.style.display = "hidden";
                currentLayer.div.append(this.div);
                rect = div.getBoundingClientRect();
                div.remove();
                div.style.display = savedDisplay;
              }
              if (this.rotation % 180 === this.parentRotation % 180) {
                this.width = rect.width / parentWidth;
                this.height = rect.height / parentHeight;
              } else {
                this.width = rect.height / parentWidth;
                this.height = rect.width / parentHeight;
              }
              this.fixAndSetPosition();
            }, "#setEditorDimensions");
            _setContent = new WeakSet();
            setContent_fn = /* @__PURE__ */ __name(function() {
              this.editorDiv.replaceChildren();
              if (!__privateGet(this, _content)) {
                return;
              }
              for (const line of __privateGet(this, _content).split("\n")) {
                const div = document.createElement("div");
                div.append(line ? document.createTextNode(line) : document.createElement("br"));
                this.editorDiv.append(div);
              }
            }, "#setContent");
            _hasElementChanged = new WeakSet();
            hasElementChanged_fn = /* @__PURE__ */ __name(function(serialized) {
              const {
                value,
                fontSize,
                color: color2,
                rect,
                pageIndex
              } = __privateGet(this, _initialData);
              return serialized.value !== value || serialized.fontSize !== fontSize || serialized.rect.some((x2, i2) => Math.abs(x2 - rect[i2]) >= 1) || serialized.color.some((c2, i2) => c2 !== color2[i2]) || serialized.pageIndex !== pageIndex;
            }, "#hasElementChanged");
            _cheatInitialRect = new WeakSet();
            cheatInitialRect_fn = /* @__PURE__ */ __name(function(delayed = false) {
              if (!this.annotationElementId) {
                return;
              }
              __privateMethod(this, _setEditorDimensions, setEditorDimensions_fn).call(this);
              if (!delayed && (this.width === 0 || this.height === 0)) {
                setTimeout(() => __privateMethod(this, _cheatInitialRect, cheatInitialRect_fn).call(this, true), 0);
                return;
              }
              const padding = _FreeTextEditor._internalPadding * this.parentScale;
              __privateGet(this, _initialData).rect = this.getRect(padding, padding);
            }, "#cheatInitialRect");
            __name(_FreeTextEditor, "FreeTextEditor");
            __publicField(_FreeTextEditor, "_freeTextDefaultContent", "");
            __publicField(_FreeTextEditor, "_internalPadding", 0);
            __publicField(_FreeTextEditor, "_defaultColor", null);
            __publicField(_FreeTextEditor, "_defaultFontSize", 10);
            __publicField(_FreeTextEditor, "_type", "freetext");
            let FreeTextEditor = _FreeTextEditor;
            exports2.FreeTextEditor = FreeTextEditor;
          },
          /* 29 */
          /***/
          (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
            var _hasBorder, _setInternalLink, setInternalLink_fn, _bindSetOCGState, bindSetOCGState_fn, _dateTimePromise, _boundKeyDown, _boundHide, _boundShow, _boundToggle, _color, _container, _contentsObj, _elements, _parent, _parentRect, _pinned, _popup, _rect, _richText, _titleObj, _wasVisible, _keyDown, keyDown_fn, _toggle, toggle_fn, _show, show_fn, _hide, hide_fn, _line, _square, _circle, _polyline, _polylines, _trigger, _download, download_fn, _accessibilityManager, _annotationCanvasMap, _editableAnnotations, _appendElement, appendElement_fn, _setAnnotationCanvasMap, setAnnotationCanvasMap_fn;
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            exports2.StampAnnotationElement = exports2.InkAnnotationElement = exports2.FreeTextAnnotationElement = exports2.AnnotationLayer = void 0;
            var _util2 = __w_pdfjs_require__2(1);
            var _display_utils2 = __w_pdfjs_require__2(6);
            var _annotation_storage2 = __w_pdfjs_require__2(3);
            var _scripting_utils = __w_pdfjs_require__2(30);
            var _displayL10n_utils = __w_pdfjs_require__2(31);
            var _xfa_layer = __w_pdfjs_require__2(32);
            const DEFAULT_TAB_INDEX = 1e3;
            const DEFAULT_FONT_SIZE = 9;
            const GetElementsByNameSet = /* @__PURE__ */ new WeakSet();
            function getRectDims(rect) {
              return {
                width: rect[2] - rect[0],
                height: rect[3] - rect[1]
              };
            }
            __name(getRectDims, "getRectDims");
            const _AnnotationElementFactory = class _AnnotationElementFactory {
              static create(parameters) {
                const subtype = parameters.data.annotationType;
                switch (subtype) {
                  case _util2.AnnotationType.LINK:
                    return new LinkAnnotationElement(parameters);
                  case _util2.AnnotationType.TEXT:
                    return new TextAnnotationElement(parameters);
                  case _util2.AnnotationType.WIDGET:
                    const fieldType = parameters.data.fieldType;
                    switch (fieldType) {
                      case "Tx":
                        return new TextWidgetAnnotationElement(parameters);
                      case "Btn":
                        if (parameters.data.radioButton) {
                          return new RadioButtonWidgetAnnotationElement(parameters);
                        } else if (parameters.data.checkBox) {
                          return new CheckboxWidgetAnnotationElement(parameters);
                        }
                        return new PushButtonWidgetAnnotationElement(parameters);
                      case "Ch":
                        return new ChoiceWidgetAnnotationElement(parameters);
                      case "Sig":
                        return new SignatureWidgetAnnotationElement(parameters);
                    }
                    return new WidgetAnnotationElement(parameters);
                  case _util2.AnnotationType.POPUP:
                    return new PopupAnnotationElement(parameters);
                  case _util2.AnnotationType.FREETEXT:
                    return new FreeTextAnnotationElement(parameters);
                  case _util2.AnnotationType.LINE:
                    return new LineAnnotationElement(parameters);
                  case _util2.AnnotationType.SQUARE:
                    return new SquareAnnotationElement(parameters);
                  case _util2.AnnotationType.CIRCLE:
                    return new CircleAnnotationElement(parameters);
                  case _util2.AnnotationType.POLYLINE:
                    return new PolylineAnnotationElement(parameters);
                  case _util2.AnnotationType.CARET:
                    return new CaretAnnotationElement(parameters);
                  case _util2.AnnotationType.INK:
                    return new InkAnnotationElement(parameters);
                  case _util2.AnnotationType.POLYGON:
                    return new PolygonAnnotationElement(parameters);
                  case _util2.AnnotationType.HIGHLIGHT:
                    return new HighlightAnnotationElement(parameters);
                  case _util2.AnnotationType.UNDERLINE:
                    return new UnderlineAnnotationElement(parameters);
                  case _util2.AnnotationType.SQUIGGLY:
                    return new SquigglyAnnotationElement(parameters);
                  case _util2.AnnotationType.STRIKEOUT:
                    return new StrikeOutAnnotationElement(parameters);
                  case _util2.AnnotationType.STAMP:
                    return new StampAnnotationElement(parameters);
                  case _util2.AnnotationType.FILEATTACHMENT:
                    return new FileAttachmentAnnotationElement(parameters);
                  default:
                    return new AnnotationElement(parameters);
                }
              }
            };
            __name(_AnnotationElementFactory, "AnnotationElementFactory");
            let AnnotationElementFactory = _AnnotationElementFactory;
            const _AnnotationElement = class _AnnotationElement {
              constructor(parameters, {
                isRenderable = false,
                ignoreBorder = false,
                createQuadrilaterals = false
              } = {}) {
                __privateAdd(this, _hasBorder, false);
                this.isRenderable = isRenderable;
                this.data = parameters.data;
                this.layer = parameters.layer;
                this.linkService = parameters.linkService;
                this.downloadManager = parameters.downloadManager;
                this.imageResourcesPath = parameters.imageResourcesPath;
                this.renderForms = parameters.renderForms;
                this.svgFactory = parameters.svgFactory;
                this.annotationStorage = parameters.annotationStorage;
                this.enableScripting = parameters.enableScripting;
                this.hasJSActions = parameters.hasJSActions;
                this._fieldObjects = parameters.fieldObjects;
                this.parent = parameters.parent;
                if (isRenderable) {
                  this.container = this._createContainer(ignoreBorder);
                }
                if (createQuadrilaterals) {
                  this._createQuadrilaterals();
                }
              }
              static _hasPopupData({
                titleObj,
                contentsObj,
                richText
              }) {
                return !!((titleObj == null ? void 0 : titleObj.str) || (contentsObj == null ? void 0 : contentsObj.str) || (richText == null ? void 0 : richText.str));
              }
              get hasPopupData() {
                return _AnnotationElement._hasPopupData(this.data);
              }
              _createContainer(ignoreBorder) {
                const {
                  data,
                  parent: {
                    page,
                    viewport
                  }
                } = this;
                const container = document.createElement("section");
                container.setAttribute("data-annotation-id", data.id);
                if (!(this instanceof WidgetAnnotationElement)) {
                  container.tabIndex = DEFAULT_TAB_INDEX;
                }
                container.style.zIndex = this.parent.zIndex++;
                if (this.data.popupRef) {
                  container.setAttribute("aria-haspopup", "dialog");
                }
                if (data.noRotate) {
                  container.classList.add("norotate");
                }
                const {
                  pageWidth,
                  pageHeight,
                  pageX,
                  pageY
                } = viewport.rawDims;
                if (!data.rect || this instanceof PopupAnnotationElement) {
                  const {
                    rotation: rotation2
                  } = data;
                  if (!data.hasOwnCanvas && rotation2 !== 0) {
                    this.setRotation(rotation2, container);
                  }
                  return container;
                }
                const {
                  width,
                  height
                } = getRectDims(data.rect);
                const rect = _util2.Util.normalizeRect([data.rect[0], page.view[3] - data.rect[1] + page.view[1], data.rect[2], page.view[3] - data.rect[3] + page.view[1]]);
                if (!ignoreBorder && data.borderStyle.width > 0) {
                  container.style.borderWidth = `${data.borderStyle.width}px`;
                  const horizontalRadius = data.borderStyle.horizontalCornerRadius;
                  const verticalRadius = data.borderStyle.verticalCornerRadius;
                  if (horizontalRadius > 0 || verticalRadius > 0) {
                    const radius = `calc(${horizontalRadius}px * var(--scale-factor)) / calc(${verticalRadius}px * var(--scale-factor))`;
                    container.style.borderRadius = radius;
                  } else if (this instanceof RadioButtonWidgetAnnotationElement) {
                    const radius = `calc(${width}px * var(--scale-factor)) / calc(${height}px * var(--scale-factor))`;
                    container.style.borderRadius = radius;
                  }
                  switch (data.borderStyle.style) {
                    case _util2.AnnotationBorderStyleType.SOLID:
                      container.style.borderStyle = "solid";
                      break;
                    case _util2.AnnotationBorderStyleType.DASHED:
                      container.style.borderStyle = "dashed";
                      break;
                    case _util2.AnnotationBorderStyleType.BEVELED:
                      (0, _util2.warn)("Unimplemented border style: beveled");
                      break;
                    case _util2.AnnotationBorderStyleType.INSET:
                      (0, _util2.warn)("Unimplemented border style: inset");
                      break;
                    case _util2.AnnotationBorderStyleType.UNDERLINE:
                      container.style.borderBottomStyle = "solid";
                      break;
                  }
                  const borderColor = data.borderColor || null;
                  if (borderColor) {
                    __privateSet(this, _hasBorder, true);
                    container.style.borderColor = _util2.Util.makeHexColor(borderColor[0] | 0, borderColor[1] | 0, borderColor[2] | 0);
                  } else {
                    container.style.borderWidth = 0;
                  }
                }
                container.style.left = `${100 * (rect[0] - pageX) / pageWidth}%`;
                container.style.top = `${100 * (rect[1] - pageY) / pageHeight}%`;
                const {
                  rotation
                } = data;
                if (data.hasOwnCanvas || rotation === 0) {
                  container.style.width = `${100 * width / pageWidth}%`;
                  container.style.height = `${100 * height / pageHeight}%`;
                } else {
                  this.setRotation(rotation, container);
                }
                return container;
              }
              setRotation(angle, container = this.container) {
                if (!this.data.rect) {
                  return;
                }
                const {
                  pageWidth,
                  pageHeight
                } = this.parent.viewport.rawDims;
                const {
                  width,
                  height
                } = getRectDims(this.data.rect);
                let elementWidth, elementHeight;
                if (angle % 180 === 0) {
                  elementWidth = 100 * width / pageWidth;
                  elementHeight = 100 * height / pageHeight;
                } else {
                  elementWidth = 100 * height / pageWidth;
                  elementHeight = 100 * width / pageHeight;
                }
                container.style.width = `${elementWidth}%`;
                container.style.height = `${elementHeight}%`;
                container.setAttribute("data-main-rotation", (360 - angle) % 360);
              }
              get _commonActions() {
                const setColor = /* @__PURE__ */ __name((jsName, styleName, event) => {
                  const color2 = event.detail[jsName];
                  const colorType = color2[0];
                  const colorArray = color2.slice(1);
                  event.target.style[styleName] = _scripting_utils.ColorConverters[`${colorType}_HTML`](colorArray);
                  this.annotationStorage.setValue(this.data.id, {
                    [styleName]: _scripting_utils.ColorConverters[`${colorType}_rgb`](colorArray)
                  });
                }, "setColor");
                return (0, _util2.shadow)(this, "_commonActions", {
                  display: (event) => {
                    const {
                      display
                    } = event.detail;
                    const hidden = display % 2 === 1;
                    this.container.style.visibility = hidden ? "hidden" : "visible";
                    this.annotationStorage.setValue(this.data.id, {
                      noView: hidden,
                      noPrint: display === 1 || display === 2
                    });
                  },
                  print: (event) => {
                    this.annotationStorage.setValue(this.data.id, {
                      noPrint: !event.detail.print
                    });
                  },
                  hidden: (event) => {
                    const {
                      hidden
                    } = event.detail;
                    this.container.style.visibility = hidden ? "hidden" : "visible";
                    this.annotationStorage.setValue(this.data.id, {
                      noPrint: hidden,
                      noView: hidden
                    });
                  },
                  focus: (event) => {
                    setTimeout(() => event.target.focus({
                      preventScroll: false
                    }), 0);
                  },
                  userName: (event) => {
                    event.target.title = event.detail.userName;
                  },
                  readonly: (event) => {
                    event.target.disabled = event.detail.readonly;
                  },
                  required: (event) => {
                    this._setRequired(event.target, event.detail.required);
                  },
                  bgColor: (event) => {
                    setColor("bgColor", "backgroundColor", event);
                  },
                  fillColor: (event) => {
                    setColor("fillColor", "backgroundColor", event);
                  },
                  fgColor: (event) => {
                    setColor("fgColor", "color", event);
                  },
                  textColor: (event) => {
                    setColor("textColor", "color", event);
                  },
                  borderColor: (event) => {
                    setColor("borderColor", "borderColor", event);
                  },
                  strokeColor: (event) => {
                    setColor("strokeColor", "borderColor", event);
                  },
                  rotation: (event) => {
                    const angle = event.detail.rotation;
                    this.setRotation(angle);
                    this.annotationStorage.setValue(this.data.id, {
                      rotation: angle
                    });
                  }
                });
              }
              _dispatchEventFromSandbox(actions, jsEvent) {
                const commonActions = this._commonActions;
                for (const name of Object.keys(jsEvent.detail)) {
                  const action = actions[name] || commonActions[name];
                  action == null ? void 0 : action(jsEvent);
                }
              }
              _setDefaultPropertiesFromJS(element) {
                if (!this.enableScripting) {
                  return;
                }
                const storedData = this.annotationStorage.getRawValue(this.data.id);
                if (!storedData) {
                  return;
                }
                const commonActions = this._commonActions;
                for (const [actionName, detail] of Object.entries(storedData)) {
                  const action = commonActions[actionName];
                  if (action) {
                    const eventProxy = {
                      detail: {
                        [actionName]: detail
                      },
                      target: element
                    };
                    action(eventProxy);
                    delete storedData[actionName];
                  }
                }
              }
              _createQuadrilaterals() {
                if (!this.container) {
                  return;
                }
                const {
                  quadPoints
                } = this.data;
                if (!quadPoints) {
                  return;
                }
                const [rectBlX, rectBlY, rectTrX, rectTrY] = this.data.rect;
                if (quadPoints.length === 1) {
                  const [, {
                    x: trX,
                    y: trY
                  }, {
                    x: blX,
                    y: blY
                  }] = quadPoints[0];
                  if (rectTrX === trX && rectTrY === trY && rectBlX === blX && rectBlY === blY) {
                    return;
                  }
                }
                const {
                  style
                } = this.container;
                let svgBuffer;
                if (__privateGet(this, _hasBorder)) {
                  const {
                    borderColor,
                    borderWidth
                  } = style;
                  style.borderWidth = 0;
                  svgBuffer = ["url('data:image/svg+xml;utf8,", `<svg xmlns="http://www.w3.org/2000/svg"`, ` preserveAspectRatio="none" viewBox="0 0 1 1">`, `<g fill="transparent" stroke="${borderColor}" stroke-width="${borderWidth}">`];
                  this.container.classList.add("hasBorder");
                }
                const width = rectTrX - rectBlX;
                const height = rectTrY - rectBlY;
                const {
                  svgFactory
                } = this;
                const svg = svgFactory.createElement("svg");
                svg.classList.add("quadrilateralsContainer");
                svg.setAttribute("width", 0);
                svg.setAttribute("height", 0);
                const defs = svgFactory.createElement("defs");
                svg.append(defs);
                const clipPath = svgFactory.createElement("clipPath");
                const id = `clippath_${this.data.id}`;
                clipPath.setAttribute("id", id);
                clipPath.setAttribute("clipPathUnits", "objectBoundingBox");
                defs.append(clipPath);
                for (const [, {
                  x: trX,
                  y: trY
                }, {
                  x: blX,
                  y: blY
                }] of quadPoints) {
                  const rect = svgFactory.createElement("rect");
                  const x2 = (blX - rectBlX) / width;
                  const y2 = (rectTrY - trY) / height;
                  const rectWidth = (trX - blX) / width;
                  const rectHeight = (trY - blY) / height;
                  rect.setAttribute("x", x2);
                  rect.setAttribute("y", y2);
                  rect.setAttribute("width", rectWidth);
                  rect.setAttribute("height", rectHeight);
                  clipPath.append(rect);
                  svgBuffer == null ? void 0 : svgBuffer.push(`<rect vector-effect="non-scaling-stroke" x="${x2}" y="${y2}" width="${rectWidth}" height="${rectHeight}"/>`);
                }
                if (__privateGet(this, _hasBorder)) {
                  svgBuffer.push(`</g></svg>')`);
                  style.backgroundImage = svgBuffer.join("");
                }
                this.container.append(svg);
                this.container.style.clipPath = `url(#${id})`;
              }
              _createPopup() {
                const {
                  container,
                  data
                } = this;
                container.setAttribute("aria-haspopup", "dialog");
                const popup = new PopupAnnotationElement({
                  data: {
                    color: data.color,
                    titleObj: data.titleObj,
                    modificationDate: data.modificationDate,
                    contentsObj: data.contentsObj,
                    richText: data.richText,
                    parentRect: data.rect,
                    borderStyle: 0,
                    id: `popup_${data.id}`,
                    rotation: data.rotation
                  },
                  parent: this.parent,
                  elements: [this]
                });
                this.parent.div.append(popup.render());
              }
              render() {
                (0, _util2.unreachable)("Abstract method `AnnotationElement.render` called");
              }
              _getElementsByName(name, skipId = null) {
                const fields = [];
                if (this._fieldObjects) {
                  const fieldObj = this._fieldObjects[name];
                  if (fieldObj) {
                    for (const {
                      page,
                      id,
                      exportValues
                    } of fieldObj) {
                      if (page === -1) {
                        continue;
                      }
                      if (id === skipId) {
                        continue;
                      }
                      const exportValue = typeof exportValues === "string" ? exportValues : null;
                      const domElement = document.querySelector(`[data-element-id="${id}"]`);
                      if (domElement && !GetElementsByNameSet.has(domElement)) {
                        (0, _util2.warn)(`_getElementsByName - element not allowed: ${id}`);
                        continue;
                      }
                      fields.push({
                        id,
                        exportValue,
                        domElement
                      });
                    }
                  }
                  return fields;
                }
                for (const domElement of document.getElementsByName(name)) {
                  const {
                    exportValue
                  } = domElement;
                  const id = domElement.getAttribute("data-element-id");
                  if (id === skipId) {
                    continue;
                  }
                  if (!GetElementsByNameSet.has(domElement)) {
                    continue;
                  }
                  fields.push({
                    id,
                    exportValue,
                    domElement
                  });
                }
                return fields;
              }
              show() {
                var _a3;
                if (this.container) {
                  this.container.hidden = false;
                }
                (_a3 = this.popup) == null ? void 0 : _a3.maybeShow();
              }
              hide() {
                var _a3;
                if (this.container) {
                  this.container.hidden = true;
                }
                (_a3 = this.popup) == null ? void 0 : _a3.forceHide();
              }
              getElementsToTriggerPopup() {
                return this.container;
              }
              addHighlightArea() {
                const triggers = this.getElementsToTriggerPopup();
                if (Array.isArray(triggers)) {
                  for (const element of triggers) {
                    element.classList.add("highlightArea");
                  }
                } else {
                  triggers.classList.add("highlightArea");
                }
              }
              _editOnDoubleClick() {
                const {
                  annotationEditorType: mode,
                  data: {
                    id: editId
                  }
                } = this;
                this.container.addEventListener("dblclick", () => {
                  var _a3;
                  (_a3 = this.linkService.eventBus) == null ? void 0 : _a3.dispatch("switchannotationeditormode", {
                    source: this,
                    mode,
                    editId
                  });
                });
              }
            };
            _hasBorder = new WeakMap();
            __name(_AnnotationElement, "AnnotationElement");
            let AnnotationElement = _AnnotationElement;
            const _LinkAnnotationElement = class _LinkAnnotationElement extends AnnotationElement {
              constructor(parameters, options = null) {
                super(parameters, {
                  isRenderable: true,
                  ignoreBorder: !!(options == null ? void 0 : options.ignoreBorder),
                  createQuadrilaterals: true
                });
                __privateAdd(this, _setInternalLink);
                __privateAdd(this, _bindSetOCGState);
                this.isTooltipOnly = parameters.data.isTooltipOnly;
              }
              render() {
                const {
                  data,
                  linkService
                } = this;
                const link = document.createElement("a");
                link.setAttribute("data-element-id", data.id);
                let isBound = false;
                if (data.url) {
                  linkService.addLinkAttributes(link, data.url, data.newWindow);
                  isBound = true;
                } else if (data.action) {
                  this._bindNamedAction(link, data.action);
                  isBound = true;
                } else if (data.attachment) {
                  this._bindAttachment(link, data.attachment);
                  isBound = true;
                } else if (data.setOCGState) {
                  __privateMethod(this, _bindSetOCGState, bindSetOCGState_fn).call(this, link, data.setOCGState);
                  isBound = true;
                } else if (data.dest) {
                  this._bindLink(link, data.dest);
                  isBound = true;
                } else {
                  if (data.actions && (data.actions.Action || data.actions["Mouse Up"] || data.actions["Mouse Down"]) && this.enableScripting && this.hasJSActions) {
                    this._bindJSAction(link, data);
                    isBound = true;
                  }
                  if (data.resetForm) {
                    this._bindResetFormAction(link, data.resetForm);
                    isBound = true;
                  } else if (this.isTooltipOnly && !isBound) {
                    this._bindLink(link, "");
                    isBound = true;
                  }
                }
                this.container.classList.add("linkAnnotation");
                if (isBound) {
                  this.container.append(link);
                }
                return this.container;
              }
              _bindLink(link, destination) {
                link.href = this.linkService.getDestinationHash(destination);
                link.onclick = () => {
                  if (destination) {
                    this.linkService.goToDestination(destination);
                  }
                  return false;
                };
                if (destination || destination === "") {
                  __privateMethod(this, _setInternalLink, setInternalLink_fn).call(this);
                }
              }
              _bindNamedAction(link, action) {
                link.href = this.linkService.getAnchorUrl("");
                link.onclick = () => {
                  this.linkService.executeNamedAction(action);
                  return false;
                };
                __privateMethod(this, _setInternalLink, setInternalLink_fn).call(this);
              }
              _bindAttachment(link, attachment) {
                link.href = this.linkService.getAnchorUrl("");
                link.onclick = () => {
                  var _a3;
                  (_a3 = this.downloadManager) == null ? void 0 : _a3.openOrDownloadData(this.container, attachment.content, attachment.filename);
                  return false;
                };
                __privateMethod(this, _setInternalLink, setInternalLink_fn).call(this);
              }
              _bindJSAction(link, data) {
                link.href = this.linkService.getAnchorUrl("");
                const map2 = /* @__PURE__ */ new Map([["Action", "onclick"], ["Mouse Up", "onmouseup"], ["Mouse Down", "onmousedown"]]);
                for (const name of Object.keys(data.actions)) {
                  const jsName = map2.get(name);
                  if (!jsName) {
                    continue;
                  }
                  link[jsName] = () => {
                    var _a3;
                    (_a3 = this.linkService.eventBus) == null ? void 0 : _a3.dispatch("dispatcheventinsandbox", {
                      source: this,
                      detail: {
                        id: data.id,
                        name
                      }
                    });
                    return false;
                  };
                }
                if (!link.onclick) {
                  link.onclick = () => false;
                }
                __privateMethod(this, _setInternalLink, setInternalLink_fn).call(this);
              }
              _bindResetFormAction(link, resetForm) {
                const otherClickAction = link.onclick;
                if (!otherClickAction) {
                  link.href = this.linkService.getAnchorUrl("");
                }
                __privateMethod(this, _setInternalLink, setInternalLink_fn).call(this);
                if (!this._fieldObjects) {
                  (0, _util2.warn)(`_bindResetFormAction - "resetForm" action not supported, ensure that the \`fieldObjects\` parameter is provided.`);
                  if (!otherClickAction) {
                    link.onclick = () => false;
                  }
                  return;
                }
                link.onclick = () => {
                  var _a3;
                  otherClickAction == null ? void 0 : otherClickAction();
                  const {
                    fields: resetFormFields,
                    refs: resetFormRefs,
                    include
                  } = resetForm;
                  const allFields = [];
                  if (resetFormFields.length !== 0 || resetFormRefs.length !== 0) {
                    const fieldIds = new Set(resetFormRefs);
                    for (const fieldName of resetFormFields) {
                      const fields = this._fieldObjects[fieldName] || [];
                      for (const {
                        id
                      } of fields) {
                        fieldIds.add(id);
                      }
                    }
                    for (const fields of Object.values(this._fieldObjects)) {
                      for (const field of fields) {
                        if (fieldIds.has(field.id) === include) {
                          allFields.push(field);
                        }
                      }
                    }
                  } else {
                    for (const fields of Object.values(this._fieldObjects)) {
                      allFields.push(...fields);
                    }
                  }
                  const storage = this.annotationStorage;
                  const allIds = [];
                  for (const field of allFields) {
                    const {
                      id
                    } = field;
                    allIds.push(id);
                    switch (field.type) {
                      case "text": {
                        const value = field.defaultValue || "";
                        storage.setValue(id, {
                          value
                        });
                        break;
                      }
                      case "checkbox":
                      case "radiobutton": {
                        const value = field.defaultValue === field.exportValues;
                        storage.setValue(id, {
                          value
                        });
                        break;
                      }
                      case "combobox":
                      case "listbox": {
                        const value = field.defaultValue || "";
                        storage.setValue(id, {
                          value
                        });
                        break;
                      }
                      default:
                        continue;
                    }
                    const domElement = document.querySelector(`[data-element-id="${id}"]`);
                    if (!domElement) {
                      continue;
                    } else if (!GetElementsByNameSet.has(domElement)) {
                      (0, _util2.warn)(`_bindResetFormAction - element not allowed: ${id}`);
                      continue;
                    }
                    domElement.dispatchEvent(new Event("resetform"));
                  }
                  if (this.enableScripting) {
                    (_a3 = this.linkService.eventBus) == null ? void 0 : _a3.dispatch("dispatcheventinsandbox", {
                      source: this,
                      detail: {
                        id: "app",
                        ids: allIds,
                        name: "ResetForm"
                      }
                    });
                  }
                  return false;
                };
              }
            };
            _setInternalLink = new WeakSet();
            setInternalLink_fn = /* @__PURE__ */ __name(function() {
              this.container.setAttribute("data-internal-link", "");
            }, "#setInternalLink");
            _bindSetOCGState = new WeakSet();
            bindSetOCGState_fn = /* @__PURE__ */ __name(function(link, action) {
              link.href = this.linkService.getAnchorUrl("");
              link.onclick = () => {
                this.linkService.executeSetOCGState(action);
                return false;
              };
              __privateMethod(this, _setInternalLink, setInternalLink_fn).call(this);
            }, "#bindSetOCGState");
            __name(_LinkAnnotationElement, "LinkAnnotationElement");
            let LinkAnnotationElement = _LinkAnnotationElement;
            const _TextAnnotationElement = class _TextAnnotationElement extends AnnotationElement {
              constructor(parameters) {
                super(parameters, {
                  isRenderable: true
                });
              }
              render() {
                this.container.classList.add("textAnnotation");
                const image = document.createElement("img");
                image.src = this.imageResourcesPath + "annotation-" + this.data.name.toLowerCase() + ".svg";
                image.alt = "[{{type}} Annotation]";
                image.dataset.l10nId = "text_annotation_type";
                image.dataset.l10nArgs = JSON.stringify({
                  type: this.data.name
                });
                if (!this.data.popupRef && this.hasPopupData) {
                  this._createPopup();
                }
                this.container.append(image);
                return this.container;
              }
            };
            __name(_TextAnnotationElement, "TextAnnotationElement");
            let TextAnnotationElement = _TextAnnotationElement;
            const _WidgetAnnotationElement = class _WidgetAnnotationElement extends AnnotationElement {
              render() {
                if (this.data.alternativeText) {
                  this.container.title = this.data.alternativeText;
                }
                return this.container;
              }
              showElementAndHideCanvas(element) {
                var _a3;
                if (this.data.hasOwnCanvas) {
                  if (((_a3 = element.previousSibling) == null ? void 0 : _a3.nodeName) === "CANVAS") {
                    element.previousSibling.hidden = true;
                  }
                  element.hidden = false;
                }
              }
              _getKeyModifier(event) {
                const {
                  isWin,
                  isMac
                } = _util2.FeatureTest.platform;
                return isWin && event.ctrlKey || isMac && event.metaKey;
              }
              _setEventListener(element, elementData, baseName, eventName, valueGetter) {
                if (baseName.includes("mouse")) {
                  element.addEventListener(baseName, (event) => {
                    var _a3;
                    (_a3 = this.linkService.eventBus) == null ? void 0 : _a3.dispatch("dispatcheventinsandbox", {
                      source: this,
                      detail: {
                        id: this.data.id,
                        name: eventName,
                        value: valueGetter(event),
                        shift: event.shiftKey,
                        modifier: this._getKeyModifier(event)
                      }
                    });
                  });
                } else {
                  element.addEventListener(baseName, (event) => {
                    var _a3;
                    if (baseName === "blur") {
                      if (!elementData.focused || !event.relatedTarget) {
                        return;
                      }
                      elementData.focused = false;
                    } else if (baseName === "focus") {
                      if (elementData.focused) {
                        return;
                      }
                      elementData.focused = true;
                    }
                    if (!valueGetter) {
                      return;
                    }
                    (_a3 = this.linkService.eventBus) == null ? void 0 : _a3.dispatch("dispatcheventinsandbox", {
                      source: this,
                      detail: {
                        id: this.data.id,
                        name: eventName,
                        value: valueGetter(event)
                      }
                    });
                  });
                }
              }
              _setEventListeners(element, elementData, names2, getter) {
                var _a3, _b2, _c;
                for (const [baseName, eventName] of names2) {
                  if (eventName === "Action" || ((_a3 = this.data.actions) == null ? void 0 : _a3[eventName])) {
                    if (eventName === "Focus" || eventName === "Blur") {
                      elementData || (elementData = {
                        focused: false
                      });
                    }
                    this._setEventListener(element, elementData, baseName, eventName, getter);
                    if (eventName === "Focus" && !((_b2 = this.data.actions) == null ? void 0 : _b2.Blur)) {
                      this._setEventListener(element, elementData, "blur", "Blur", null);
                    } else if (eventName === "Blur" && !((_c = this.data.actions) == null ? void 0 : _c.Focus)) {
                      this._setEventListener(element, elementData, "focus", "Focus", null);
                    }
                  }
                }
              }
              _setBackgroundColor(element) {
                const color2 = this.data.backgroundColor || null;
                element.style.backgroundColor = color2 === null ? "transparent" : _util2.Util.makeHexColor(color2[0], color2[1], color2[2]);
              }
              _setTextStyle(element) {
                const TEXT_ALIGNMENT = ["left", "center", "right"];
                const {
                  fontColor
                } = this.data.defaultAppearanceData;
                const fontSize = this.data.defaultAppearanceData.fontSize || DEFAULT_FONT_SIZE;
                const style = element.style;
                let computedFontSize;
                const BORDER_SIZE = 2;
                const roundToOneDecimal = /* @__PURE__ */ __name((x2) => Math.round(10 * x2) / 10, "roundToOneDecimal");
                if (this.data.multiLine) {
                  const height = Math.abs(this.data.rect[3] - this.data.rect[1] - BORDER_SIZE);
                  const numberOfLines = Math.round(height / (_util2.LINE_FACTOR * fontSize)) || 1;
                  const lineHeight = height / numberOfLines;
                  computedFontSize = Math.min(fontSize, roundToOneDecimal(lineHeight / _util2.LINE_FACTOR));
                } else {
                  const height = Math.abs(this.data.rect[3] - this.data.rect[1] - BORDER_SIZE);
                  computedFontSize = Math.min(fontSize, roundToOneDecimal(height / _util2.LINE_FACTOR));
                }
                style.fontSize = `calc(${computedFontSize}px * var(--scale-factor))`;
                style.color = _util2.Util.makeHexColor(fontColor[0], fontColor[1], fontColor[2]);
                if (this.data.textAlignment !== null) {
                  style.textAlign = TEXT_ALIGNMENT[this.data.textAlignment];
                }
              }
              _setRequired(element, isRequired) {
                if (isRequired) {
                  element.setAttribute("required", true);
                } else {
                  element.removeAttribute("required");
                }
                element.setAttribute("aria-required", isRequired);
              }
            };
            __name(_WidgetAnnotationElement, "WidgetAnnotationElement");
            let WidgetAnnotationElement = _WidgetAnnotationElement;
            const _TextWidgetAnnotationElement = class _TextWidgetAnnotationElement extends WidgetAnnotationElement {
              constructor(parameters) {
                const isRenderable = parameters.renderForms || !parameters.data.hasAppearance && !!parameters.data.fieldValue;
                super(parameters, {
                  isRenderable
                });
              }
              setPropertyOnSiblings(base, key, value, keyInStorage) {
                const storage = this.annotationStorage;
                for (const element of this._getElementsByName(base.name, base.id)) {
                  if (element.domElement) {
                    element.domElement[key] = value;
                  }
                  storage.setValue(element.id, {
                    [keyInStorage]: value
                  });
                }
              }
              render() {
                var _a3, _b2;
                const storage = this.annotationStorage;
                const id = this.data.id;
                this.container.classList.add("textWidgetAnnotation");
                let element = null;
                if (this.renderForms) {
                  const storedData = storage.getValue(id, {
                    value: this.data.fieldValue
                  });
                  let textContent = storedData.value || "";
                  const maxLen = storage.getValue(id, {
                    charLimit: this.data.maxLen
                  }).charLimit;
                  if (maxLen && textContent.length > maxLen) {
                    textContent = textContent.slice(0, maxLen);
                  }
                  let fieldFormattedValues = storedData.formattedValue || ((_a3 = this.data.textContent) == null ? void 0 : _a3.join("\n")) || null;
                  if (fieldFormattedValues && this.data.comb) {
                    fieldFormattedValues = fieldFormattedValues.replaceAll(/\s+/g, "");
                  }
                  const elementData = {
                    userValue: textContent,
                    formattedValue: fieldFormattedValues,
                    lastCommittedValue: null,
                    commitKey: 1,
                    focused: false
                  };
                  if (this.data.multiLine) {
                    element = document.createElement("textarea");
                    element.textContent = fieldFormattedValues ?? textContent;
                    if (this.data.doNotScroll) {
                      element.style.overflowY = "hidden";
                    }
                  } else {
                    element = document.createElement("input");
                    element.type = "text";
                    element.setAttribute("value", fieldFormattedValues ?? textContent);
                    if (this.data.doNotScroll) {
                      element.style.overflowX = "hidden";
                    }
                  }
                  if (this.data.hasOwnCanvas) {
                    element.hidden = true;
                  }
                  GetElementsByNameSet.add(element);
                  element.setAttribute("data-element-id", id);
                  element.disabled = this.data.readOnly;
                  element.name = this.data.fieldName;
                  element.tabIndex = DEFAULT_TAB_INDEX;
                  this._setRequired(element, this.data.required);
                  if (maxLen) {
                    element.maxLength = maxLen;
                  }
                  element.addEventListener("input", (event) => {
                    storage.setValue(id, {
                      value: event.target.value
                    });
                    this.setPropertyOnSiblings(element, "value", event.target.value, "value");
                    elementData.formattedValue = null;
                  });
                  element.addEventListener("resetform", (event) => {
                    const defaultValue = this.data.defaultFieldValue ?? "";
                    element.value = elementData.userValue = defaultValue;
                    elementData.formattedValue = null;
                  });
                  let blurListener = /* @__PURE__ */ __name((event) => {
                    const {
                      formattedValue
                    } = elementData;
                    if (formattedValue !== null && formattedValue !== void 0) {
                      event.target.value = formattedValue;
                    }
                    event.target.scrollLeft = 0;
                  }, "blurListener");
                  if (this.enableScripting && this.hasJSActions) {
                    element.addEventListener("focus", (event) => {
                      if (elementData.focused) {
                        return;
                      }
                      const {
                        target
                      } = event;
                      if (elementData.userValue) {
                        target.value = elementData.userValue;
                      }
                      elementData.lastCommittedValue = target.value;
                      elementData.commitKey = 1;
                      elementData.focused = true;
                    });
                    element.addEventListener("updatefromsandbox", (jsEvent) => {
                      this.showElementAndHideCanvas(jsEvent.target);
                      const actions = {
                        value(event) {
                          elementData.userValue = event.detail.value ?? "";
                          storage.setValue(id, {
                            value: elementData.userValue.toString()
                          });
                          event.target.value = elementData.userValue;
                        },
                        formattedValue(event) {
                          const {
                            formattedValue
                          } = event.detail;
                          elementData.formattedValue = formattedValue;
                          if (formattedValue !== null && formattedValue !== void 0 && event.target !== document.activeElement) {
                            event.target.value = formattedValue;
                          }
                          storage.setValue(id, {
                            formattedValue
                          });
                        },
                        selRange(event) {
                          event.target.setSelectionRange(...event.detail.selRange);
                        },
                        charLimit: (event) => {
                          var _a4;
                          const {
                            charLimit
                          } = event.detail;
                          const {
                            target
                          } = event;
                          if (charLimit === 0) {
                            target.removeAttribute("maxLength");
                            return;
                          }
                          target.setAttribute("maxLength", charLimit);
                          let value = elementData.userValue;
                          if (!value || value.length <= charLimit) {
                            return;
                          }
                          value = value.slice(0, charLimit);
                          target.value = elementData.userValue = value;
                          storage.setValue(id, {
                            value
                          });
                          (_a4 = this.linkService.eventBus) == null ? void 0 : _a4.dispatch("dispatcheventinsandbox", {
                            source: this,
                            detail: {
                              id,
                              name: "Keystroke",
                              value,
                              willCommit: true,
                              commitKey: 1,
                              selStart: target.selectionStart,
                              selEnd: target.selectionEnd
                            }
                          });
                        }
                      };
                      this._dispatchEventFromSandbox(actions, jsEvent);
                    });
                    element.addEventListener("keydown", (event) => {
                      var _a4;
                      elementData.commitKey = 1;
                      let commitKey = -1;
                      if (event.key === "Escape") {
                        commitKey = 0;
                      } else if (event.key === "Enter" && !this.data.multiLine) {
                        commitKey = 2;
                      } else if (event.key === "Tab") {
                        elementData.commitKey = 3;
                      }
                      if (commitKey === -1) {
                        return;
                      }
                      const {
                        value
                      } = event.target;
                      if (elementData.lastCommittedValue === value) {
                        return;
                      }
                      elementData.lastCommittedValue = value;
                      elementData.userValue = value;
                      (_a4 = this.linkService.eventBus) == null ? void 0 : _a4.dispatch("dispatcheventinsandbox", {
                        source: this,
                        detail: {
                          id,
                          name: "Keystroke",
                          value,
                          willCommit: true,
                          commitKey,
                          selStart: event.target.selectionStart,
                          selEnd: event.target.selectionEnd
                        }
                      });
                    });
                    const _blurListener = blurListener;
                    blurListener = null;
                    element.addEventListener("blur", (event) => {
                      var _a4;
                      if (!elementData.focused || !event.relatedTarget) {
                        return;
                      }
                      elementData.focused = false;
                      const {
                        value
                      } = event.target;
                      elementData.userValue = value;
                      if (elementData.lastCommittedValue !== value) {
                        (_a4 = this.linkService.eventBus) == null ? void 0 : _a4.dispatch("dispatcheventinsandbox", {
                          source: this,
                          detail: {
                            id,
                            name: "Keystroke",
                            value,
                            willCommit: true,
                            commitKey: elementData.commitKey,
                            selStart: event.target.selectionStart,
                            selEnd: event.target.selectionEnd
                          }
                        });
                      }
                      _blurListener(event);
                    });
                    if ((_b2 = this.data.actions) == null ? void 0 : _b2.Keystroke) {
                      element.addEventListener("beforeinput", (event) => {
                        var _a4;
                        elementData.lastCommittedValue = null;
                        const {
                          data,
                          target
                        } = event;
                        const {
                          value,
                          selectionStart,
                          selectionEnd
                        } = target;
                        let selStart = selectionStart, selEnd = selectionEnd;
                        switch (event.inputType) {
                          case "deleteWordBackward": {
                            const match = value.substring(0, selectionStart).match(/\w*[^\w]*$/);
                            if (match) {
                              selStart -= match[0].length;
                            }
                            break;
                          }
                          case "deleteWordForward": {
                            const match = value.substring(selectionStart).match(/^[^\w]*\w*/);
                            if (match) {
                              selEnd += match[0].length;
                            }
                            break;
                          }
                          case "deleteContentBackward":
                            if (selectionStart === selectionEnd) {
                              selStart -= 1;
                            }
                            break;
                          case "deleteContentForward":
                            if (selectionStart === selectionEnd) {
                              selEnd += 1;
                            }
                            break;
                        }
                        event.preventDefault();
                        (_a4 = this.linkService.eventBus) == null ? void 0 : _a4.dispatch("dispatcheventinsandbox", {
                          source: this,
                          detail: {
                            id,
                            name: "Keystroke",
                            value,
                            change: data || "",
                            willCommit: false,
                            selStart,
                            selEnd
                          }
                        });
                      });
                    }
                    this._setEventListeners(element, elementData, [["focus", "Focus"], ["blur", "Blur"], ["mousedown", "Mouse Down"], ["mouseenter", "Mouse Enter"], ["mouseleave", "Mouse Exit"], ["mouseup", "Mouse Up"]], (event) => event.target.value);
                  }
                  if (blurListener) {
                    element.addEventListener("blur", blurListener);
                  }
                  if (this.data.comb) {
                    const fieldWidth = this.data.rect[2] - this.data.rect[0];
                    const combWidth = fieldWidth / maxLen;
                    element.classList.add("comb");
                    element.style.letterSpacing = `calc(${combWidth}px * var(--scale-factor) - 1ch)`;
                  }
                } else {
                  element = document.createElement("div");
                  element.textContent = this.data.fieldValue;
                  element.style.verticalAlign = "middle";
                  element.style.display = "table-cell";
                }
                this._setTextStyle(element);
                this._setBackgroundColor(element);
                this._setDefaultPropertiesFromJS(element);
                this.container.append(element);
                return this.container;
              }
            };
            __name(_TextWidgetAnnotationElement, "TextWidgetAnnotationElement");
            let TextWidgetAnnotationElement = _TextWidgetAnnotationElement;
            const _SignatureWidgetAnnotationElement = class _SignatureWidgetAnnotationElement extends WidgetAnnotationElement {
              constructor(parameters) {
                super(parameters, {
                  isRenderable: !!parameters.data.hasOwnCanvas
                });
              }
            };
            __name(_SignatureWidgetAnnotationElement, "SignatureWidgetAnnotationElement");
            let SignatureWidgetAnnotationElement = _SignatureWidgetAnnotationElement;
            const _CheckboxWidgetAnnotationElement = class _CheckboxWidgetAnnotationElement extends WidgetAnnotationElement {
              constructor(parameters) {
                super(parameters, {
                  isRenderable: parameters.renderForms
                });
              }
              render() {
                const storage = this.annotationStorage;
                const data = this.data;
                const id = data.id;
                let value = storage.getValue(id, {
                  value: data.exportValue === data.fieldValue
                }).value;
                if (typeof value === "string") {
                  value = value !== "Off";
                  storage.setValue(id, {
                    value
                  });
                }
                this.container.classList.add("buttonWidgetAnnotation", "checkBox");
                const element = document.createElement("input");
                GetElementsByNameSet.add(element);
                element.setAttribute("data-element-id", id);
                element.disabled = data.readOnly;
                this._setRequired(element, this.data.required);
                element.type = "checkbox";
                element.name = data.fieldName;
                if (value) {
                  element.setAttribute("checked", true);
                }
                element.setAttribute("exportValue", data.exportValue);
                element.tabIndex = DEFAULT_TAB_INDEX;
                element.addEventListener("change", (event) => {
                  const {
                    name,
                    checked
                  } = event.target;
                  for (const checkbox of this._getElementsByName(name, id)) {
                    const curChecked = checked && checkbox.exportValue === data.exportValue;
                    if (checkbox.domElement) {
                      checkbox.domElement.checked = curChecked;
                    }
                    storage.setValue(checkbox.id, {
                      value: curChecked
                    });
                  }
                  storage.setValue(id, {
                    value: checked
                  });
                });
                element.addEventListener("resetform", (event) => {
                  const defaultValue = data.defaultFieldValue || "Off";
                  event.target.checked = defaultValue === data.exportValue;
                });
                if (this.enableScripting && this.hasJSActions) {
                  element.addEventListener("updatefromsandbox", (jsEvent) => {
                    const actions = {
                      value(event) {
                        event.target.checked = event.detail.value !== "Off";
                        storage.setValue(id, {
                          value: event.target.checked
                        });
                      }
                    };
                    this._dispatchEventFromSandbox(actions, jsEvent);
                  });
                  this._setEventListeners(element, null, [["change", "Validate"], ["change", "Action"], ["focus", "Focus"], ["blur", "Blur"], ["mousedown", "Mouse Down"], ["mouseenter", "Mouse Enter"], ["mouseleave", "Mouse Exit"], ["mouseup", "Mouse Up"]], (event) => event.target.checked);
                }
                this._setBackgroundColor(element);
                this._setDefaultPropertiesFromJS(element);
                this.container.append(element);
                return this.container;
              }
            };
            __name(_CheckboxWidgetAnnotationElement, "CheckboxWidgetAnnotationElement");
            let CheckboxWidgetAnnotationElement = _CheckboxWidgetAnnotationElement;
            const _RadioButtonWidgetAnnotationElement = class _RadioButtonWidgetAnnotationElement extends WidgetAnnotationElement {
              constructor(parameters) {
                super(parameters, {
                  isRenderable: parameters.renderForms
                });
              }
              render() {
                this.container.classList.add("buttonWidgetAnnotation", "radioButton");
                const storage = this.annotationStorage;
                const data = this.data;
                const id = data.id;
                let value = storage.getValue(id, {
                  value: data.fieldValue === data.buttonValue
                }).value;
                if (typeof value === "string") {
                  value = value !== data.buttonValue;
                  storage.setValue(id, {
                    value
                  });
                }
                const element = document.createElement("input");
                GetElementsByNameSet.add(element);
                element.setAttribute("data-element-id", id);
                element.disabled = data.readOnly;
                this._setRequired(element, this.data.required);
                element.type = "radio";
                element.name = data.fieldName;
                if (value) {
                  element.setAttribute("checked", true);
                }
                element.tabIndex = DEFAULT_TAB_INDEX;
                element.addEventListener("change", (event) => {
                  const {
                    name,
                    checked
                  } = event.target;
                  for (const radio of this._getElementsByName(name, id)) {
                    storage.setValue(radio.id, {
                      value: false
                    });
                  }
                  storage.setValue(id, {
                    value: checked
                  });
                });
                element.addEventListener("resetform", (event) => {
                  const defaultValue = data.defaultFieldValue;
                  event.target.checked = defaultValue !== null && defaultValue !== void 0 && defaultValue === data.buttonValue;
                });
                if (this.enableScripting && this.hasJSActions) {
                  const pdfButtonValue = data.buttonValue;
                  element.addEventListener("updatefromsandbox", (jsEvent) => {
                    const actions = {
                      value: (event) => {
                        const checked = pdfButtonValue === event.detail.value;
                        for (const radio of this._getElementsByName(event.target.name)) {
                          const curChecked = checked && radio.id === id;
                          if (radio.domElement) {
                            radio.domElement.checked = curChecked;
                          }
                          storage.setValue(radio.id, {
                            value: curChecked
                          });
                        }
                      }
                    };
                    this._dispatchEventFromSandbox(actions, jsEvent);
                  });
                  this._setEventListeners(element, null, [["change", "Validate"], ["change", "Action"], ["focus", "Focus"], ["blur", "Blur"], ["mousedown", "Mouse Down"], ["mouseenter", "Mouse Enter"], ["mouseleave", "Mouse Exit"], ["mouseup", "Mouse Up"]], (event) => event.target.checked);
                }
                this._setBackgroundColor(element);
                this._setDefaultPropertiesFromJS(element);
                this.container.append(element);
                return this.container;
              }
            };
            __name(_RadioButtonWidgetAnnotationElement, "RadioButtonWidgetAnnotationElement");
            let RadioButtonWidgetAnnotationElement = _RadioButtonWidgetAnnotationElement;
            const _PushButtonWidgetAnnotationElement = class _PushButtonWidgetAnnotationElement extends LinkAnnotationElement {
              constructor(parameters) {
                super(parameters, {
                  ignoreBorder: parameters.data.hasAppearance
                });
              }
              render() {
                const container = super.render();
                container.classList.add("buttonWidgetAnnotation", "pushButton");
                if (this.data.alternativeText) {
                  container.title = this.data.alternativeText;
                }
                const linkElement = container.lastChild;
                if (this.enableScripting && this.hasJSActions && linkElement) {
                  this._setDefaultPropertiesFromJS(linkElement);
                  linkElement.addEventListener("updatefromsandbox", (jsEvent) => {
                    this._dispatchEventFromSandbox({}, jsEvent);
                  });
                }
                return container;
              }
            };
            __name(_PushButtonWidgetAnnotationElement, "PushButtonWidgetAnnotationElement");
            let PushButtonWidgetAnnotationElement = _PushButtonWidgetAnnotationElement;
            const _ChoiceWidgetAnnotationElement = class _ChoiceWidgetAnnotationElement extends WidgetAnnotationElement {
              constructor(parameters) {
                super(parameters, {
                  isRenderable: parameters.renderForms
                });
              }
              render() {
                this.container.classList.add("choiceWidgetAnnotation");
                const storage = this.annotationStorage;
                const id = this.data.id;
                const storedData = storage.getValue(id, {
                  value: this.data.fieldValue
                });
                const selectElement = document.createElement("select");
                GetElementsByNameSet.add(selectElement);
                selectElement.setAttribute("data-element-id", id);
                selectElement.disabled = this.data.readOnly;
                this._setRequired(selectElement, this.data.required);
                selectElement.name = this.data.fieldName;
                selectElement.tabIndex = DEFAULT_TAB_INDEX;
                let addAnEmptyEntry = this.data.combo && this.data.options.length > 0;
                if (!this.data.combo) {
                  selectElement.size = this.data.options.length;
                  if (this.data.multiSelect) {
                    selectElement.multiple = true;
                  }
                }
                selectElement.addEventListener("resetform", (event) => {
                  const defaultValue = this.data.defaultFieldValue;
                  for (const option of selectElement.options) {
                    option.selected = option.value === defaultValue;
                  }
                });
                for (const option of this.data.options) {
                  const optionElement = document.createElement("option");
                  optionElement.textContent = option.displayValue;
                  optionElement.value = option.exportValue;
                  if (storedData.value.includes(option.exportValue)) {
                    optionElement.setAttribute("selected", true);
                    addAnEmptyEntry = false;
                  }
                  selectElement.append(optionElement);
                }
                let removeEmptyEntry = null;
                if (addAnEmptyEntry) {
                  const noneOptionElement = document.createElement("option");
                  noneOptionElement.value = " ";
                  noneOptionElement.setAttribute("hidden", true);
                  noneOptionElement.setAttribute("selected", true);
                  selectElement.prepend(noneOptionElement);
                  removeEmptyEntry = /* @__PURE__ */ __name(() => {
                    noneOptionElement.remove();
                    selectElement.removeEventListener("input", removeEmptyEntry);
                    removeEmptyEntry = null;
                  }, "removeEmptyEntry");
                  selectElement.addEventListener("input", removeEmptyEntry);
                }
                const getValue = /* @__PURE__ */ __name((isExport) => {
                  const name = isExport ? "value" : "textContent";
                  const {
                    options,
                    multiple
                  } = selectElement;
                  if (!multiple) {
                    return options.selectedIndex === -1 ? null : options[options.selectedIndex][name];
                  }
                  return Array.prototype.filter.call(options, (option) => option.selected).map((option) => option[name]);
                }, "getValue");
                let selectedValues = getValue(false);
                const getItems = /* @__PURE__ */ __name((event) => {
                  const options = event.target.options;
                  return Array.prototype.map.call(options, (option) => {
                    return {
                      displayValue: option.textContent,
                      exportValue: option.value
                    };
                  });
                }, "getItems");
                if (this.enableScripting && this.hasJSActions) {
                  selectElement.addEventListener("updatefromsandbox", (jsEvent) => {
                    const actions = {
                      value(event) {
                        removeEmptyEntry == null ? void 0 : removeEmptyEntry();
                        const value = event.detail.value;
                        const values = new Set(Array.isArray(value) ? value : [value]);
                        for (const option of selectElement.options) {
                          option.selected = values.has(option.value);
                        }
                        storage.setValue(id, {
                          value: getValue(true)
                        });
                        selectedValues = getValue(false);
                      },
                      multipleSelection(event) {
                        selectElement.multiple = true;
                      },
                      remove(event) {
                        const options = selectElement.options;
                        const index2 = event.detail.remove;
                        options[index2].selected = false;
                        selectElement.remove(index2);
                        if (options.length > 0) {
                          const i2 = Array.prototype.findIndex.call(options, (option) => option.selected);
                          if (i2 === -1) {
                            options[0].selected = true;
                          }
                        }
                        storage.setValue(id, {
                          value: getValue(true),
                          items: getItems(event)
                        });
                        selectedValues = getValue(false);
                      },
                      clear(event) {
                        while (selectElement.length !== 0) {
                          selectElement.remove(0);
                        }
                        storage.setValue(id, {
                          value: null,
                          items: []
                        });
                        selectedValues = getValue(false);
                      },
                      insert(event) {
                        const {
                          index: index2,
                          displayValue,
                          exportValue
                        } = event.detail.insert;
                        const selectChild = selectElement.children[index2];
                        const optionElement = document.createElement("option");
                        optionElement.textContent = displayValue;
                        optionElement.value = exportValue;
                        if (selectChild) {
                          selectChild.before(optionElement);
                        } else {
                          selectElement.append(optionElement);
                        }
                        storage.setValue(id, {
                          value: getValue(true),
                          items: getItems(event)
                        });
                        selectedValues = getValue(false);
                      },
                      items(event) {
                        const {
                          items
                        } = event.detail;
                        while (selectElement.length !== 0) {
                          selectElement.remove(0);
                        }
                        for (const item of items) {
                          const {
                            displayValue,
                            exportValue
                          } = item;
                          const optionElement = document.createElement("option");
                          optionElement.textContent = displayValue;
                          optionElement.value = exportValue;
                          selectElement.append(optionElement);
                        }
                        if (selectElement.options.length > 0) {
                          selectElement.options[0].selected = true;
                        }
                        storage.setValue(id, {
                          value: getValue(true),
                          items: getItems(event)
                        });
                        selectedValues = getValue(false);
                      },
                      indices(event) {
                        const indices = new Set(event.detail.indices);
                        for (const option of event.target.options) {
                          option.selected = indices.has(option.index);
                        }
                        storage.setValue(id, {
                          value: getValue(true)
                        });
                        selectedValues = getValue(false);
                      },
                      editable(event) {
                        event.target.disabled = !event.detail.editable;
                      }
                    };
                    this._dispatchEventFromSandbox(actions, jsEvent);
                  });
                  selectElement.addEventListener("input", (event) => {
                    var _a3;
                    const exportValue = getValue(true);
                    storage.setValue(id, {
                      value: exportValue
                    });
                    event.preventDefault();
                    (_a3 = this.linkService.eventBus) == null ? void 0 : _a3.dispatch("dispatcheventinsandbox", {
                      source: this,
                      detail: {
                        id,
                        name: "Keystroke",
                        value: selectedValues,
                        changeEx: exportValue,
                        willCommit: false,
                        commitKey: 1,
                        keyDown: false
                      }
                    });
                  });
                  this._setEventListeners(selectElement, null, [["focus", "Focus"], ["blur", "Blur"], ["mousedown", "Mouse Down"], ["mouseenter", "Mouse Enter"], ["mouseleave", "Mouse Exit"], ["mouseup", "Mouse Up"], ["input", "Action"], ["input", "Validate"]], (event) => event.target.value);
                } else {
                  selectElement.addEventListener("input", function(event) {
                    storage.setValue(id, {
                      value: getValue(true)
                    });
                  });
                }
                if (this.data.combo) {
                  this._setTextStyle(selectElement);
                }
                this._setBackgroundColor(selectElement);
                this._setDefaultPropertiesFromJS(selectElement);
                this.container.append(selectElement);
                return this.container;
              }
            };
            __name(_ChoiceWidgetAnnotationElement, "ChoiceWidgetAnnotationElement");
            let ChoiceWidgetAnnotationElement = _ChoiceWidgetAnnotationElement;
            const _PopupAnnotationElement = class _PopupAnnotationElement extends AnnotationElement {
              constructor(parameters) {
                const {
                  data,
                  elements
                } = parameters;
                super(parameters, {
                  isRenderable: AnnotationElement._hasPopupData(data)
                });
                this.elements = elements;
              }
              render() {
                this.container.classList.add("popupAnnotation");
                const popup = new PopupElement({
                  container: this.container,
                  color: this.data.color,
                  titleObj: this.data.titleObj,
                  modificationDate: this.data.modificationDate,
                  contentsObj: this.data.contentsObj,
                  richText: this.data.richText,
                  rect: this.data.rect,
                  parentRect: this.data.parentRect || null,
                  parent: this.parent,
                  elements: this.elements,
                  open: this.data.open
                });
                const elementIds = [];
                for (const element of this.elements) {
                  element.popup = popup;
                  elementIds.push(element.data.id);
                  element.addHighlightArea();
                }
                this.container.setAttribute("aria-controls", elementIds.map((id) => `${_util2.AnnotationPrefix}${id}`).join(","));
                return this.container;
              }
            };
            __name(_PopupAnnotationElement, "PopupAnnotationElement");
            let PopupAnnotationElement = _PopupAnnotationElement;
            const _PopupElement = class _PopupElement {
              constructor({
                container,
                color: color2,
                elements,
                titleObj,
                modificationDate,
                contentsObj,
                richText,
                parent,
                rect,
                parentRect,
                open: open2
              }) {
                __privateAdd(this, _keyDown);
                __privateAdd(this, _toggle);
                __privateAdd(this, _show);
                __privateAdd(this, _hide);
                __privateAdd(this, _dateTimePromise, null);
                __privateAdd(this, _boundKeyDown, __privateMethod(this, _keyDown, keyDown_fn).bind(this));
                __privateAdd(this, _boundHide, __privateMethod(this, _hide, hide_fn).bind(this));
                __privateAdd(this, _boundShow, __privateMethod(this, _show, show_fn).bind(this));
                __privateAdd(this, _boundToggle, __privateMethod(this, _toggle, toggle_fn).bind(this));
                __privateAdd(this, _color, null);
                __privateAdd(this, _container, null);
                __privateAdd(this, _contentsObj, null);
                __privateAdd(this, _elements, null);
                __privateAdd(this, _parent, null);
                __privateAdd(this, _parentRect, null);
                __privateAdd(this, _pinned, false);
                __privateAdd(this, _popup, null);
                __privateAdd(this, _rect, null);
                __privateAdd(this, _richText, null);
                __privateAdd(this, _titleObj, null);
                __privateAdd(this, _wasVisible, false);
                var _a3;
                __privateSet(this, _container, container);
                __privateSet(this, _titleObj, titleObj);
                __privateSet(this, _contentsObj, contentsObj);
                __privateSet(this, _richText, richText);
                __privateSet(this, _parent, parent);
                __privateSet(this, _color, color2);
                __privateSet(this, _rect, rect);
                __privateSet(this, _parentRect, parentRect);
                __privateSet(this, _elements, elements);
                const dateObject = _display_utils2.PDFDateString.toDateObject(modificationDate);
                if (dateObject) {
                  __privateSet(this, _dateTimePromise, parent.l10n.get("annotation_date_string", {
                    date: dateObject.toLocaleDateString(),
                    time: dateObject.toLocaleTimeString()
                  }));
                }
                this.trigger = elements.flatMap((e) => e.getElementsToTriggerPopup());
                for (const element of this.trigger) {
                  element.addEventListener("click", __privateGet(this, _boundToggle));
                  element.addEventListener("mouseenter", __privateGet(this, _boundShow));
                  element.addEventListener("mouseleave", __privateGet(this, _boundHide));
                  element.classList.add("popupTriggerArea");
                }
                for (const element of elements) {
                  (_a3 = element.container) == null ? void 0 : _a3.addEventListener("keydown", __privateGet(this, _boundKeyDown));
                }
                __privateGet(this, _container).hidden = true;
                if (open2) {
                  __privateMethod(this, _toggle, toggle_fn).call(this);
                }
              }
              render() {
                if (__privateGet(this, _popup)) {
                  return;
                }
                const {
                  page: {
                    view
                  },
                  viewport: {
                    rawDims: {
                      pageWidth,
                      pageHeight,
                      pageX,
                      pageY
                    }
                  }
                } = __privateGet(this, _parent);
                const popup = __privateSet(this, _popup, document.createElement("div"));
                popup.className = "popup";
                if (__privateGet(this, _color)) {
                  const baseColor = popup.style.outlineColor = _util2.Util.makeHexColor(...__privateGet(this, _color));
                  if (CSS.supports("background-color", "color-mix(in srgb, red 30%, white)")) {
                    popup.style.backgroundColor = `color-mix(in srgb, ${baseColor} 30%, white)`;
                  } else {
                    const BACKGROUND_ENLIGHT = 0.7;
                    popup.style.backgroundColor = _util2.Util.makeHexColor(...__privateGet(this, _color).map((c2) => Math.floor(BACKGROUND_ENLIGHT * (255 - c2) + c2)));
                  }
                }
                const header = document.createElement("span");
                header.className = "header";
                const title = document.createElement("h1");
                header.append(title);
                ({
                  dir: title.dir,
                  str: title.textContent
                } = __privateGet(this, _titleObj));
                popup.append(header);
                if (__privateGet(this, _dateTimePromise)) {
                  const modificationDate = document.createElement("span");
                  modificationDate.classList.add("popupDate");
                  __privateGet(this, _dateTimePromise).then((localized) => {
                    modificationDate.textContent = localized;
                  });
                  header.append(modificationDate);
                }
                const contentsObj = __privateGet(this, _contentsObj);
                const richText = __privateGet(this, _richText);
                if ((richText == null ? void 0 : richText.str) && (!(contentsObj == null ? void 0 : contentsObj.str) || contentsObj.str === richText.str)) {
                  _xfa_layer.XfaLayer.render({
                    xfaHtml: richText.html,
                    intent: "richText",
                    div: popup
                  });
                  popup.lastChild.classList.add("richText", "popupContent");
                } else {
                  const contents = this._formatContents(contentsObj);
                  popup.append(contents);
                }
                let useParentRect = !!__privateGet(this, _parentRect);
                let rect = useParentRect ? __privateGet(this, _parentRect) : __privateGet(this, _rect);
                for (const element of __privateGet(this, _elements)) {
                  if (!rect || _util2.Util.intersect(element.data.rect, rect) !== null) {
                    rect = element.data.rect;
                    useParentRect = true;
                    break;
                  }
                }
                const normalizedRect = _util2.Util.normalizeRect([rect[0], view[3] - rect[1] + view[1], rect[2], view[3] - rect[3] + view[1]]);
                const HORIZONTAL_SPACE_AFTER_ANNOTATION = 5;
                const parentWidth = useParentRect ? rect[2] - rect[0] + HORIZONTAL_SPACE_AFTER_ANNOTATION : 0;
                const popupLeft = normalizedRect[0] + parentWidth;
                const popupTop = normalizedRect[1];
                const {
                  style
                } = __privateGet(this, _container);
                style.left = `${100 * (popupLeft - pageX) / pageWidth}%`;
                style.top = `${100 * (popupTop - pageY) / pageHeight}%`;
                __privateGet(this, _container).append(popup);
              }
              _formatContents({
                str,
                dir
              }) {
                const p2 = document.createElement("p");
                p2.classList.add("popupContent");
                p2.dir = dir;
                const lines = str.split(/(?:\r\n?|\n)/);
                for (let i2 = 0, ii = lines.length; i2 < ii; ++i2) {
                  const line = lines[i2];
                  p2.append(document.createTextNode(line));
                  if (i2 < ii - 1) {
                    p2.append(document.createElement("br"));
                  }
                }
                return p2;
              }
              forceHide() {
                __privateSet(this, _wasVisible, this.isVisible);
                if (!__privateGet(this, _wasVisible)) {
                  return;
                }
                __privateGet(this, _container).hidden = true;
              }
              maybeShow() {
                if (!__privateGet(this, _wasVisible)) {
                  return;
                }
                __privateSet(this, _wasVisible, false);
                __privateGet(this, _container).hidden = false;
              }
              get isVisible() {
                return __privateGet(this, _container).hidden === false;
              }
            };
            _dateTimePromise = new WeakMap();
            _boundKeyDown = new WeakMap();
            _boundHide = new WeakMap();
            _boundShow = new WeakMap();
            _boundToggle = new WeakMap();
            _color = new WeakMap();
            _container = new WeakMap();
            _contentsObj = new WeakMap();
            _elements = new WeakMap();
            _parent = new WeakMap();
            _parentRect = new WeakMap();
            _pinned = new WeakMap();
            _popup = new WeakMap();
            _rect = new WeakMap();
            _richText = new WeakMap();
            _titleObj = new WeakMap();
            _wasVisible = new WeakMap();
            _keyDown = new WeakSet();
            keyDown_fn = /* @__PURE__ */ __name(function(event) {
              if (event.altKey || event.shiftKey || event.ctrlKey || event.metaKey) {
                return;
              }
              if (event.key === "Enter" || event.key === "Escape" && __privateGet(this, _pinned)) {
                __privateMethod(this, _toggle, toggle_fn).call(this);
              }
            }, "#keyDown");
            _toggle = new WeakSet();
            toggle_fn = /* @__PURE__ */ __name(function() {
              __privateSet(this, _pinned, !__privateGet(this, _pinned));
              if (__privateGet(this, _pinned)) {
                __privateMethod(this, _show, show_fn).call(this);
                __privateGet(this, _container).addEventListener("click", __privateGet(this, _boundToggle));
                __privateGet(this, _container).addEventListener("keydown", __privateGet(this, _boundKeyDown));
              } else {
                __privateMethod(this, _hide, hide_fn).call(this);
                __privateGet(this, _container).removeEventListener("click", __privateGet(this, _boundToggle));
                __privateGet(this, _container).removeEventListener("keydown", __privateGet(this, _boundKeyDown));
              }
            }, "#toggle");
            _show = new WeakSet();
            show_fn = /* @__PURE__ */ __name(function() {
              if (!__privateGet(this, _popup)) {
                this.render();
              }
              if (!this.isVisible) {
                __privateGet(this, _container).hidden = false;
                __privateGet(this, _container).style.zIndex = parseInt(__privateGet(this, _container).style.zIndex) + 1e3;
              } else if (__privateGet(this, _pinned)) {
                __privateGet(this, _container).classList.add("focused");
              }
            }, "#show");
            _hide = new WeakSet();
            hide_fn = /* @__PURE__ */ __name(function() {
              __privateGet(this, _container).classList.remove("focused");
              if (__privateGet(this, _pinned) || !this.isVisible) {
                return;
              }
              __privateGet(this, _container).hidden = true;
              __privateGet(this, _container).style.zIndex = parseInt(__privateGet(this, _container).style.zIndex) - 1e3;
            }, "#hide");
            __name(_PopupElement, "PopupElement");
            let PopupElement = _PopupElement;
            const _FreeTextAnnotationElement = class _FreeTextAnnotationElement extends AnnotationElement {
              constructor(parameters) {
                super(parameters, {
                  isRenderable: true,
                  ignoreBorder: true
                });
                this.textContent = parameters.data.textContent;
                this.textPosition = parameters.data.textPosition;
                this.annotationEditorType = _util2.AnnotationEditorType.FREETEXT;
              }
              render() {
                this.container.classList.add("freeTextAnnotation");
                if (this.textContent) {
                  const content = document.createElement("div");
                  content.classList.add("annotationTextContent");
                  content.setAttribute("role", "comment");
                  for (const line of this.textContent) {
                    const lineSpan = document.createElement("span");
                    lineSpan.textContent = line;
                    content.append(lineSpan);
                  }
                  this.container.append(content);
                }
                if (!this.data.popupRef && this.hasPopupData) {
                  this._createPopup();
                }
                this._editOnDoubleClick();
                return this.container;
              }
            };
            __name(_FreeTextAnnotationElement, "FreeTextAnnotationElement");
            let FreeTextAnnotationElement = _FreeTextAnnotationElement;
            exports2.FreeTextAnnotationElement = FreeTextAnnotationElement;
            const _LineAnnotationElement = class _LineAnnotationElement extends AnnotationElement {
              constructor(parameters) {
                super(parameters, {
                  isRenderable: true,
                  ignoreBorder: true
                });
                __privateAdd(this, _line, null);
              }
              render() {
                this.container.classList.add("lineAnnotation");
                const data = this.data;
                const {
                  width,
                  height
                } = getRectDims(data.rect);
                const svg = this.svgFactory.create(width, height, true);
                const line = __privateSet(this, _line, this.svgFactory.createElement("svg:line"));
                line.setAttribute("x1", data.rect[2] - data.lineCoordinates[0]);
                line.setAttribute("y1", data.rect[3] - data.lineCoordinates[1]);
                line.setAttribute("x2", data.rect[2] - data.lineCoordinates[2]);
                line.setAttribute("y2", data.rect[3] - data.lineCoordinates[3]);
                line.setAttribute("stroke-width", data.borderStyle.width || 1);
                line.setAttribute("stroke", "transparent");
                line.setAttribute("fill", "transparent");
                svg.append(line);
                this.container.append(svg);
                if (!data.popupRef && this.hasPopupData) {
                  this._createPopup();
                }
                return this.container;
              }
              getElementsToTriggerPopup() {
                return __privateGet(this, _line);
              }
              addHighlightArea() {
                this.container.classList.add("highlightArea");
              }
            };
            _line = new WeakMap();
            __name(_LineAnnotationElement, "LineAnnotationElement");
            let LineAnnotationElement = _LineAnnotationElement;
            const _SquareAnnotationElement = class _SquareAnnotationElement extends AnnotationElement {
              constructor(parameters) {
                super(parameters, {
                  isRenderable: true,
                  ignoreBorder: true
                });
                __privateAdd(this, _square, null);
              }
              render() {
                this.container.classList.add("squareAnnotation");
                const data = this.data;
                const {
                  width,
                  height
                } = getRectDims(data.rect);
                const svg = this.svgFactory.create(width, height, true);
                const borderWidth = data.borderStyle.width;
                const square = __privateSet(this, _square, this.svgFactory.createElement("svg:rect"));
                square.setAttribute("x", borderWidth / 2);
                square.setAttribute("y", borderWidth / 2);
                square.setAttribute("width", width - borderWidth);
                square.setAttribute("height", height - borderWidth);
                square.setAttribute("stroke-width", borderWidth || 1);
                square.setAttribute("stroke", "transparent");
                square.setAttribute("fill", "transparent");
                svg.append(square);
                this.container.append(svg);
                if (!data.popupRef && this.hasPopupData) {
                  this._createPopup();
                }
                return this.container;
              }
              getElementsToTriggerPopup() {
                return __privateGet(this, _square);
              }
              addHighlightArea() {
                this.container.classList.add("highlightArea");
              }
            };
            _square = new WeakMap();
            __name(_SquareAnnotationElement, "SquareAnnotationElement");
            let SquareAnnotationElement = _SquareAnnotationElement;
            const _CircleAnnotationElement = class _CircleAnnotationElement extends AnnotationElement {
              constructor(parameters) {
                super(parameters, {
                  isRenderable: true,
                  ignoreBorder: true
                });
                __privateAdd(this, _circle, null);
              }
              render() {
                this.container.classList.add("circleAnnotation");
                const data = this.data;
                const {
                  width,
                  height
                } = getRectDims(data.rect);
                const svg = this.svgFactory.create(width, height, true);
                const borderWidth = data.borderStyle.width;
                const circle = __privateSet(this, _circle, this.svgFactory.createElement("svg:ellipse"));
                circle.setAttribute("cx", width / 2);
                circle.setAttribute("cy", height / 2);
                circle.setAttribute("rx", width / 2 - borderWidth / 2);
                circle.setAttribute("ry", height / 2 - borderWidth / 2);
                circle.setAttribute("stroke-width", borderWidth || 1);
                circle.setAttribute("stroke", "transparent");
                circle.setAttribute("fill", "transparent");
                svg.append(circle);
                this.container.append(svg);
                if (!data.popupRef && this.hasPopupData) {
                  this._createPopup();
                }
                return this.container;
              }
              getElementsToTriggerPopup() {
                return __privateGet(this, _circle);
              }
              addHighlightArea() {
                this.container.classList.add("highlightArea");
              }
            };
            _circle = new WeakMap();
            __name(_CircleAnnotationElement, "CircleAnnotationElement");
            let CircleAnnotationElement = _CircleAnnotationElement;
            const _PolylineAnnotationElement = class _PolylineAnnotationElement extends AnnotationElement {
              constructor(parameters) {
                super(parameters, {
                  isRenderable: true,
                  ignoreBorder: true
                });
                __privateAdd(this, _polyline, null);
                this.containerClassName = "polylineAnnotation";
                this.svgElementName = "svg:polyline";
              }
              render() {
                this.container.classList.add(this.containerClassName);
                const data = this.data;
                const {
                  width,
                  height
                } = getRectDims(data.rect);
                const svg = this.svgFactory.create(width, height, true);
                let points = [];
                for (const coordinate of data.vertices) {
                  const x2 = coordinate.x - data.rect[0];
                  const y2 = data.rect[3] - coordinate.y;
                  points.push(x2 + "," + y2);
                }
                points = points.join(" ");
                const polyline = __privateSet(this, _polyline, this.svgFactory.createElement(this.svgElementName));
                polyline.setAttribute("points", points);
                polyline.setAttribute("stroke-width", data.borderStyle.width || 1);
                polyline.setAttribute("stroke", "transparent");
                polyline.setAttribute("fill", "transparent");
                svg.append(polyline);
                this.container.append(svg);
                if (!data.popupRef && this.hasPopupData) {
                  this._createPopup();
                }
                return this.container;
              }
              getElementsToTriggerPopup() {
                return __privateGet(this, _polyline);
              }
              addHighlightArea() {
                this.container.classList.add("highlightArea");
              }
            };
            _polyline = new WeakMap();
            __name(_PolylineAnnotationElement, "PolylineAnnotationElement");
            let PolylineAnnotationElement = _PolylineAnnotationElement;
            const _PolygonAnnotationElement = class _PolygonAnnotationElement extends PolylineAnnotationElement {
              constructor(parameters) {
                super(parameters);
                this.containerClassName = "polygonAnnotation";
                this.svgElementName = "svg:polygon";
              }
            };
            __name(_PolygonAnnotationElement, "PolygonAnnotationElement");
            let PolygonAnnotationElement = _PolygonAnnotationElement;
            const _CaretAnnotationElement = class _CaretAnnotationElement extends AnnotationElement {
              constructor(parameters) {
                super(parameters, {
                  isRenderable: true,
                  ignoreBorder: true
                });
              }
              render() {
                this.container.classList.add("caretAnnotation");
                if (!this.data.popupRef && this.hasPopupData) {
                  this._createPopup();
                }
                return this.container;
              }
            };
            __name(_CaretAnnotationElement, "CaretAnnotationElement");
            let CaretAnnotationElement = _CaretAnnotationElement;
            const _InkAnnotationElement = class _InkAnnotationElement extends AnnotationElement {
              constructor(parameters) {
                super(parameters, {
                  isRenderable: true,
                  ignoreBorder: true
                });
                __privateAdd(this, _polylines, []);
                this.containerClassName = "inkAnnotation";
                this.svgElementName = "svg:polyline";
                this.annotationEditorType = _util2.AnnotationEditorType.INK;
              }
              render() {
                this.container.classList.add(this.containerClassName);
                const data = this.data;
                const {
                  width,
                  height
                } = getRectDims(data.rect);
                const svg = this.svgFactory.create(width, height, true);
                for (const inkList of data.inkLists) {
                  let points = [];
                  for (const coordinate of inkList) {
                    const x2 = coordinate.x - data.rect[0];
                    const y2 = data.rect[3] - coordinate.y;
                    points.push(`${x2},${y2}`);
                  }
                  points = points.join(" ");
                  const polyline = this.svgFactory.createElement(this.svgElementName);
                  __privateGet(this, _polylines).push(polyline);
                  polyline.setAttribute("points", points);
                  polyline.setAttribute("stroke-width", data.borderStyle.width || 1);
                  polyline.setAttribute("stroke", "transparent");
                  polyline.setAttribute("fill", "transparent");
                  if (!data.popupRef && this.hasPopupData) {
                    this._createPopup();
                  }
                  svg.append(polyline);
                }
                this.container.append(svg);
                return this.container;
              }
              getElementsToTriggerPopup() {
                return __privateGet(this, _polylines);
              }
              addHighlightArea() {
                this.container.classList.add("highlightArea");
              }
            };
            _polylines = new WeakMap();
            __name(_InkAnnotationElement, "InkAnnotationElement");
            let InkAnnotationElement = _InkAnnotationElement;
            exports2.InkAnnotationElement = InkAnnotationElement;
            const _HighlightAnnotationElement = class _HighlightAnnotationElement extends AnnotationElement {
              constructor(parameters) {
                super(parameters, {
                  isRenderable: true,
                  ignoreBorder: true,
                  createQuadrilaterals: true
                });
              }
              render() {
                if (!this.data.popupRef && this.hasPopupData) {
                  this._createPopup();
                }
                this.container.classList.add("highlightAnnotation");
                return this.container;
              }
            };
            __name(_HighlightAnnotationElement, "HighlightAnnotationElement");
            let HighlightAnnotationElement = _HighlightAnnotationElement;
            const _UnderlineAnnotationElement = class _UnderlineAnnotationElement extends AnnotationElement {
              constructor(parameters) {
                super(parameters, {
                  isRenderable: true,
                  ignoreBorder: true,
                  createQuadrilaterals: true
                });
              }
              render() {
                if (!this.data.popupRef && this.hasPopupData) {
                  this._createPopup();
                }
                this.container.classList.add("underlineAnnotation");
                return this.container;
              }
            };
            __name(_UnderlineAnnotationElement, "UnderlineAnnotationElement");
            let UnderlineAnnotationElement = _UnderlineAnnotationElement;
            const _SquigglyAnnotationElement = class _SquigglyAnnotationElement extends AnnotationElement {
              constructor(parameters) {
                super(parameters, {
                  isRenderable: true,
                  ignoreBorder: true,
                  createQuadrilaterals: true
                });
              }
              render() {
                if (!this.data.popupRef && this.hasPopupData) {
                  this._createPopup();
                }
                this.container.classList.add("squigglyAnnotation");
                return this.container;
              }
            };
            __name(_SquigglyAnnotationElement, "SquigglyAnnotationElement");
            let SquigglyAnnotationElement = _SquigglyAnnotationElement;
            const _StrikeOutAnnotationElement = class _StrikeOutAnnotationElement extends AnnotationElement {
              constructor(parameters) {
                super(parameters, {
                  isRenderable: true,
                  ignoreBorder: true,
                  createQuadrilaterals: true
                });
              }
              render() {
                if (!this.data.popupRef && this.hasPopupData) {
                  this._createPopup();
                }
                this.container.classList.add("strikeoutAnnotation");
                return this.container;
              }
            };
            __name(_StrikeOutAnnotationElement, "StrikeOutAnnotationElement");
            let StrikeOutAnnotationElement = _StrikeOutAnnotationElement;
            const _StampAnnotationElement = class _StampAnnotationElement extends AnnotationElement {
              constructor(parameters) {
                super(parameters, {
                  isRenderable: true,
                  ignoreBorder: true
                });
              }
              render() {
                this.container.classList.add("stampAnnotation");
                if (!this.data.popupRef && this.hasPopupData) {
                  this._createPopup();
                }
                return this.container;
              }
            };
            __name(_StampAnnotationElement, "StampAnnotationElement");
            let StampAnnotationElement = _StampAnnotationElement;
            exports2.StampAnnotationElement = StampAnnotationElement;
            const _FileAttachmentAnnotationElement = class _FileAttachmentAnnotationElement extends AnnotationElement {
              constructor(parameters) {
                var _a3;
                super(parameters, {
                  isRenderable: true
                });
                __privateAdd(this, _download);
                __privateAdd(this, _trigger, null);
                const {
                  filename,
                  content
                } = this.data.file;
                this.filename = (0, _display_utils2.getFilenameFromUrl)(filename, true);
                this.content = content;
                (_a3 = this.linkService.eventBus) == null ? void 0 : _a3.dispatch("fileattachmentannotation", {
                  source: this,
                  filename,
                  content
                });
              }
              render() {
                this.container.classList.add("fileAttachmentAnnotation");
                const {
                  container,
                  data
                } = this;
                let trigger;
                if (data.hasAppearance || data.fillAlpha === 0) {
                  trigger = document.createElement("div");
                } else {
                  trigger = document.createElement("img");
                  trigger.src = `${this.imageResourcesPath}annotation-${/paperclip/i.test(data.name) ? "paperclip" : "pushpin"}.svg`;
                  if (data.fillAlpha && data.fillAlpha < 1) {
                    trigger.style = `filter: opacity(${Math.round(data.fillAlpha * 100)}%);`;
                  }
                }
                trigger.addEventListener("dblclick", __privateMethod(this, _download, download_fn).bind(this));
                __privateSet(this, _trigger, trigger);
                const {
                  isMac
                } = _util2.FeatureTest.platform;
                container.addEventListener("keydown", (evt) => {
                  if (evt.key === "Enter" && (isMac ? evt.metaKey : evt.ctrlKey)) {
                    __privateMethod(this, _download, download_fn).call(this);
                  }
                });
                if (!data.popupRef && this.hasPopupData) {
                  this._createPopup();
                } else {
                  trigger.classList.add("popupTriggerArea");
                }
                container.append(trigger);
                return container;
              }
              getElementsToTriggerPopup() {
                return __privateGet(this, _trigger);
              }
              addHighlightArea() {
                this.container.classList.add("highlightArea");
              }
            };
            _trigger = new WeakMap();
            _download = new WeakSet();
            download_fn = /* @__PURE__ */ __name(function() {
              var _a3;
              (_a3 = this.downloadManager) == null ? void 0 : _a3.openOrDownloadData(this.container, this.content, this.filename);
            }, "#download");
            __name(_FileAttachmentAnnotationElement, "FileAttachmentAnnotationElement");
            let FileAttachmentAnnotationElement = _FileAttachmentAnnotationElement;
            const _AnnotationLayer = class _AnnotationLayer {
              constructor({
                div,
                accessibilityManager,
                annotationCanvasMap,
                l10n,
                page,
                viewport
              }) {
                __privateAdd(this, _appendElement);
                __privateAdd(this, _setAnnotationCanvasMap);
                __privateAdd(this, _accessibilityManager, null);
                __privateAdd(this, _annotationCanvasMap, null);
                __privateAdd(this, _editableAnnotations, /* @__PURE__ */ new Map());
                this.div = div;
                __privateSet(this, _accessibilityManager, accessibilityManager);
                __privateSet(this, _annotationCanvasMap, annotationCanvasMap);
                this.l10n = l10n;
                this.page = page;
                this.viewport = viewport;
                this.zIndex = 0;
                this.l10n || (this.l10n = _displayL10n_utils.NullL10n);
              }
              async render(params) {
                const {
                  annotations
                } = params;
                const layer = this.div;
                (0, _display_utils2.setLayerDimensions)(layer, this.viewport);
                const popupToElements = /* @__PURE__ */ new Map();
                const elementParams = {
                  data: null,
                  layer,
                  linkService: params.linkService,
                  downloadManager: params.downloadManager,
                  imageResourcesPath: params.imageResourcesPath || "",
                  renderForms: params.renderForms !== false,
                  svgFactory: new _display_utils2.DOMSVGFactory(),
                  annotationStorage: params.annotationStorage || new _annotation_storage2.AnnotationStorage(),
                  enableScripting: params.enableScripting === true,
                  hasJSActions: params.hasJSActions,
                  fieldObjects: params.fieldObjects,
                  parent: this,
                  elements: null
                };
                for (const data of annotations) {
                  if (data.noHTML) {
                    continue;
                  }
                  const isPopupAnnotation = data.annotationType === _util2.AnnotationType.POPUP;
                  if (!isPopupAnnotation) {
                    const {
                      width,
                      height
                    } = getRectDims(data.rect);
                    if (width <= 0 || height <= 0) {
                      continue;
                    }
                  } else {
                    const elements = popupToElements.get(data.id);
                    if (!elements) {
                      continue;
                    }
                    elementParams.elements = elements;
                  }
                  elementParams.data = data;
                  const element = AnnotationElementFactory.create(elementParams);
                  if (!element.isRenderable) {
                    continue;
                  }
                  if (!isPopupAnnotation && data.popupRef) {
                    const elements = popupToElements.get(data.popupRef);
                    if (!elements) {
                      popupToElements.set(data.popupRef, [element]);
                    } else {
                      elements.push(element);
                    }
                  }
                  if (element.annotationEditorType > 0) {
                    __privateGet(this, _editableAnnotations).set(element.data.id, element);
                  }
                  const rendered = element.render();
                  if (data.hidden) {
                    rendered.style.visibility = "hidden";
                  }
                  __privateMethod(this, _appendElement, appendElement_fn).call(this, rendered, data.id);
                }
                __privateMethod(this, _setAnnotationCanvasMap, setAnnotationCanvasMap_fn).call(this);
                await this.l10n.translate(layer);
              }
              update({
                viewport
              }) {
                const layer = this.div;
                this.viewport = viewport;
                (0, _display_utils2.setLayerDimensions)(layer, {
                  rotation: viewport.rotation
                });
                __privateMethod(this, _setAnnotationCanvasMap, setAnnotationCanvasMap_fn).call(this);
                layer.hidden = false;
              }
              getEditableAnnotations() {
                return Array.from(__privateGet(this, _editableAnnotations).values());
              }
              getEditableAnnotation(id) {
                return __privateGet(this, _editableAnnotations).get(id);
              }
            };
            _accessibilityManager = new WeakMap();
            _annotationCanvasMap = new WeakMap();
            _editableAnnotations = new WeakMap();
            _appendElement = new WeakSet();
            appendElement_fn = /* @__PURE__ */ __name(function(element, id) {
              var _a3;
              const contentElement = element.firstChild || element;
              contentElement.id = `${_util2.AnnotationPrefix}${id}`;
              this.div.append(element);
              (_a3 = __privateGet(this, _accessibilityManager)) == null ? void 0 : _a3.moveElementInDOM(this.div, element, contentElement, false);
            }, "#appendElement");
            _setAnnotationCanvasMap = new WeakSet();
            setAnnotationCanvasMap_fn = /* @__PURE__ */ __name(function() {
              if (!__privateGet(this, _annotationCanvasMap)) {
                return;
              }
              const layer = this.div;
              for (const [id, canvas] of __privateGet(this, _annotationCanvasMap)) {
                const element = layer.querySelector(`[data-annotation-id="${id}"]`);
                if (!element) {
                  continue;
                }
                const {
                  firstChild
                } = element;
                if (!firstChild) {
                  element.append(canvas);
                } else if (firstChild.nodeName === "CANVAS") {
                  firstChild.replaceWith(canvas);
                } else {
                  firstChild.before(canvas);
                }
              }
              __privateGet(this, _annotationCanvasMap).clear();
            }, "#setAnnotationCanvasMap");
            __name(_AnnotationLayer, "AnnotationLayer");
            let AnnotationLayer = _AnnotationLayer;
            exports2.AnnotationLayer = AnnotationLayer;
          },
          /* 30 */
          /***/
          (__unused_webpack_module2, exports2) => {
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            exports2.ColorConverters = void 0;
            function makeColorComp(n2) {
              return Math.floor(Math.max(0, Math.min(1, n2)) * 255).toString(16).padStart(2, "0");
            }
            __name(makeColorComp, "makeColorComp");
            function scaleAndClamp(x2) {
              return Math.max(0, Math.min(255, 255 * x2));
            }
            __name(scaleAndClamp, "scaleAndClamp");
            const _ColorConverters = class _ColorConverters {
              static CMYK_G([c2, y2, m2, k2]) {
                return ["G", 1 - Math.min(1, 0.3 * c2 + 0.59 * m2 + 0.11 * y2 + k2)];
              }
              static G_CMYK([g2]) {
                return ["CMYK", 0, 0, 0, 1 - g2];
              }
              static G_RGB([g2]) {
                return ["RGB", g2, g2, g2];
              }
              static G_rgb([g2]) {
                g2 = scaleAndClamp(g2);
                return [g2, g2, g2];
              }
              static G_HTML([g2]) {
                const G2 = makeColorComp(g2);
                return `#${G2}${G2}${G2}`;
              }
              static RGB_G([r, g2, b2]) {
                return ["G", 0.3 * r + 0.59 * g2 + 0.11 * b2];
              }
              static RGB_rgb(color2) {
                return color2.map(scaleAndClamp);
              }
              static RGB_HTML(color2) {
                return `#${color2.map(makeColorComp).join("")}`;
              }
              static T_HTML() {
                return "#00000000";
              }
              static T_rgb() {
                return [null];
              }
              static CMYK_RGB([c2, y2, m2, k2]) {
                return ["RGB", 1 - Math.min(1, c2 + k2), 1 - Math.min(1, m2 + k2), 1 - Math.min(1, y2 + k2)];
              }
              static CMYK_rgb([c2, y2, m2, k2]) {
                return [scaleAndClamp(1 - Math.min(1, c2 + k2)), scaleAndClamp(1 - Math.min(1, m2 + k2)), scaleAndClamp(1 - Math.min(1, y2 + k2))];
              }
              static CMYK_HTML(components) {
                const rgb = this.CMYK_RGB(components).slice(1);
                return this.RGB_HTML(rgb);
              }
              static RGB_CMYK([r, g2, b2]) {
                const c2 = 1 - r;
                const m2 = 1 - g2;
                const y2 = 1 - b2;
                const k2 = Math.min(c2, m2, y2);
                return ["CMYK", c2, m2, y2, k2];
              }
            };
            __name(_ColorConverters, "ColorConverters");
            let ColorConverters = _ColorConverters;
            exports2.ColorConverters = ColorConverters;
          },
          /* 31 */
          /***/
          (__unused_webpack_module2, exports2) => {
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            exports2.NullL10n = void 0;
            exports2.getL10nFallback = getL10nFallback;
            const DEFAULT_L10N_STRINGS = {
              of_pages: "of {{pagesCount}}",
              page_of_pages: "({{pageNumber}} of {{pagesCount}})",
              document_properties_kb: "{{size_kb}} KB ({{size_b}} bytes)",
              document_properties_mb: "{{size_mb}} MB ({{size_b}} bytes)",
              document_properties_date_string: "{{date}}, {{time}}",
              document_properties_page_size_unit_inches: "in",
              document_properties_page_size_unit_millimeters: "mm",
              document_properties_page_size_orientation_portrait: "portrait",
              document_properties_page_size_orientation_landscape: "landscape",
              document_properties_page_size_name_a3: "A3",
              document_properties_page_size_name_a4: "A4",
              document_properties_page_size_name_letter: "Letter",
              document_properties_page_size_name_legal: "Legal",
              document_properties_page_size_dimension_string: "{{width}}  {{height}} {{unit}} ({{orientation}})",
              document_properties_page_size_dimension_name_string: "{{width}}  {{height}} {{unit}} ({{name}}, {{orientation}})",
              document_properties_linearized_yes: "Yes",
              document_properties_linearized_no: "No",
              additional_layers: "Additional Layers",
              page_landmark: "Page {{page}}",
              thumb_page_title: "Page {{page}}",
              thumb_page_canvas: "Thumbnail of Page {{page}}",
              find_reached_top: "Reached top of document, continued from bottom",
              find_reached_bottom: "Reached end of document, continued from top",
              "find_match_count[one]": "{{current}} of {{total}} match",
              "find_match_count[other]": "{{current}} of {{total}} matches",
              "find_match_count_limit[one]": "More than {{limit}} match",
              "find_match_count_limit[other]": "More than {{limit}} matches",
              find_not_found: "Phrase not found",
              page_scale_width: "Page Width",
              page_scale_fit: "Page Fit",
              page_scale_auto: "Automatic Zoom",
              page_scale_actual: "Actual Size",
              page_scale_percent: "{{scale}}%",
              loading_error: "An error occurred while loading the PDF.",
              invalid_file_error: "Invalid or corrupted PDF file.",
              missing_file_error: "Missing PDF file.",
              unexpected_response_error: "Unexpected server response.",
              rendering_error: "An error occurred while rendering the page.",
              annotation_date_string: "{{date}}, {{time}}",
              printing_not_supported: "Warning: Printing is not fully supported by this browser.",
              printing_not_ready: "Warning: The PDF is not fully loaded for printing.",
              web_fonts_disabled: "Web fonts are disabled: unable to use embedded PDF fonts.",
              free_text2_default_content: "Start typing",
              editor_free_text2_aria_label: "Text Editor",
              editor_ink2_aria_label: "Draw Editor",
              editor_ink_canvas_aria_label: "User-created image",
              editor_alt_text_button_label: "Alt text",
              editor_alt_text_edit_button_label: "Edit alt text",
              editor_alt_text_decorative_tooltip: "Marked as decorative"
            };
            {
              DEFAULT_L10N_STRINGS.print_progress_percent = "{{progress}}%";
            }
            function getL10nFallback(key, args) {
              switch (key) {
                case "find_match_count":
                  key = `find_match_count[${args.total === 1 ? "one" : "other"}]`;
                  break;
                case "find_match_count_limit":
                  key = `find_match_count_limit[${args.limit === 1 ? "one" : "other"}]`;
                  break;
              }
              return DEFAULT_L10N_STRINGS[key] || "";
            }
            __name(getL10nFallback, "getL10nFallback");
            function formatL10nValue(text, args) {
              if (!args) {
                return text;
              }
              return text.replaceAll(/\{\{\s*(\w+)\s*\}\}/g, (all, name) => {
                return name in args ? args[name] : "{{" + name + "}}";
              });
            }
            __name(formatL10nValue, "formatL10nValue");
            const NullL10n = {
              async getLanguage() {
                return "en-us";
              },
              async getDirection() {
                return "ltr";
              },
              async get(key, args = null, fallback = getL10nFallback(key, args)) {
                return formatL10nValue(fallback, args);
              },
              async translate(element) {
              }
            };
            exports2.NullL10n = NullL10n;
          },
          /* 32 */
          /***/
          (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            exports2.XfaLayer = void 0;
            var _xfa_text2 = __w_pdfjs_require__2(25);
            const _XfaLayer = class _XfaLayer {
              static setupStorage(html, id, element, storage, intent) {
                const storedData = storage.getValue(id, {
                  value: null
                });
                switch (element.name) {
                  case "textarea":
                    if (storedData.value !== null) {
                      html.textContent = storedData.value;
                    }
                    if (intent === "print") {
                      break;
                    }
                    html.addEventListener("input", (event) => {
                      storage.setValue(id, {
                        value: event.target.value
                      });
                    });
                    break;
                  case "input":
                    if (element.attributes.type === "radio" || element.attributes.type === "checkbox") {
                      if (storedData.value === element.attributes.xfaOn) {
                        html.setAttribute("checked", true);
                      } else if (storedData.value === element.attributes.xfaOff) {
                        html.removeAttribute("checked");
                      }
                      if (intent === "print") {
                        break;
                      }
                      html.addEventListener("change", (event) => {
                        storage.setValue(id, {
                          value: event.target.checked ? event.target.getAttribute("xfaOn") : event.target.getAttribute("xfaOff")
                        });
                      });
                    } else {
                      if (storedData.value !== null) {
                        html.setAttribute("value", storedData.value);
                      }
                      if (intent === "print") {
                        break;
                      }
                      html.addEventListener("input", (event) => {
                        storage.setValue(id, {
                          value: event.target.value
                        });
                      });
                    }
                    break;
                  case "select":
                    if (storedData.value !== null) {
                      html.setAttribute("value", storedData.value);
                      for (const option of element.children) {
                        if (option.attributes.value === storedData.value) {
                          option.attributes.selected = true;
                        } else if (option.attributes.hasOwnProperty("selected")) {
                          delete option.attributes.selected;
                        }
                      }
                    }
                    html.addEventListener("input", (event) => {
                      const options = event.target.options;
                      const value = options.selectedIndex === -1 ? "" : options[options.selectedIndex].value;
                      storage.setValue(id, {
                        value
                      });
                    });
                    break;
                }
              }
              static setAttributes({
                html,
                element,
                storage = null,
                intent,
                linkService
              }) {
                const {
                  attributes
                } = element;
                const isHTMLAnchorElement = html instanceof HTMLAnchorElement;
                if (attributes.type === "radio") {
                  attributes.name = `${attributes.name}-${intent}`;
                }
                for (const [key, value] of Object.entries(attributes)) {
                  if (value === null || value === void 0) {
                    continue;
                  }
                  switch (key) {
                    case "class":
                      if (value.length) {
                        html.setAttribute(key, value.join(" "));
                      }
                      break;
                    case "dataId":
                      break;
                    case "id":
                      html.setAttribute("data-element-id", value);
                      break;
                    case "style":
                      Object.assign(html.style, value);
                      break;
                    case "textContent":
                      html.textContent = value;
                      break;
                    default:
                      if (!isHTMLAnchorElement || key !== "href" && key !== "newWindow") {
                        html.setAttribute(key, value);
                      }
                  }
                }
                if (isHTMLAnchorElement) {
                  linkService.addLinkAttributes(html, attributes.href, attributes.newWindow);
                }
                if (storage && attributes.dataId) {
                  this.setupStorage(html, attributes.dataId, element, storage);
                }
              }
              static render(parameters) {
                var _a3;
                const storage = parameters.annotationStorage;
                const linkService = parameters.linkService;
                const root = parameters.xfaHtml;
                const intent = parameters.intent || "display";
                const rootHtml = document.createElement(root.name);
                if (root.attributes) {
                  this.setAttributes({
                    html: rootHtml,
                    element: root,
                    intent,
                    linkService
                  });
                }
                const stack = [[root, -1, rootHtml]];
                const rootDiv = parameters.div;
                rootDiv.append(rootHtml);
                if (parameters.viewport) {
                  const transform = `matrix(${parameters.viewport.transform.join(",")})`;
                  rootDiv.style.transform = transform;
                }
                if (intent !== "richText") {
                  rootDiv.setAttribute("class", "xfaLayer xfaFont");
                }
                const textDivs = [];
                while (stack.length > 0) {
                  const [parent, i2, html] = stack.at(-1);
                  if (i2 + 1 === parent.children.length) {
                    stack.pop();
                    continue;
                  }
                  const child = parent.children[++stack.at(-1)[1]];
                  if (child === null) {
                    continue;
                  }
                  const {
                    name
                  } = child;
                  if (name === "#text") {
                    const node = document.createTextNode(child.value);
                    textDivs.push(node);
                    html.append(node);
                    continue;
                  }
                  const childHtml = ((_a3 = child == null ? void 0 : child.attributes) == null ? void 0 : _a3.xmlns) ? document.createElementNS(child.attributes.xmlns, name) : document.createElement(name);
                  html.append(childHtml);
                  if (child.attributes) {
                    this.setAttributes({
                      html: childHtml,
                      element: child,
                      storage,
                      intent,
                      linkService
                    });
                  }
                  if (child.children && child.children.length > 0) {
                    stack.push([child, -1, childHtml]);
                  } else if (child.value) {
                    const node = document.createTextNode(child.value);
                    if (_xfa_text2.XfaText.shouldBuildText(name)) {
                      textDivs.push(node);
                    }
                    childHtml.append(node);
                  }
                }
                for (const el of rootDiv.querySelectorAll(".xfaNonInteractive input, .xfaNonInteractive textarea")) {
                  el.setAttribute("readOnly", true);
                }
                return {
                  textDivs
                };
              }
              static update(parameters) {
                const transform = `matrix(${parameters.viewport.transform.join(",")})`;
                parameters.div.style.transform = transform;
                parameters.div.hidden = false;
              }
            };
            __name(_XfaLayer, "XfaLayer");
            let XfaLayer = _XfaLayer;
            exports2.XfaLayer = XfaLayer;
          },
          /* 33 */
          /***/
          (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
            var _baseHeight, _baseWidth, _boundCanvasPointermove, _boundCanvasPointerleave, _boundCanvasPointerup, _boundCanvasPointerdown, _currentPath2D, _disableEditing, _hasSomethingToDraw, _isCanvasInitialized, _observer, _realWidth, _realHeight, _requestFrameCallback, _updateThickness, updateThickness_fn, _updateColor, updateColor_fn, _updateOpacity, updateOpacity_fn, _getInitialBBox, getInitialBBox_fn, _setStroke, setStroke_fn, _startDrawing, startDrawing_fn, _draw, draw_fn, _endPath, endPath_fn, _stopDrawing, stopDrawing_fn, _drawPoints, drawPoints_fn, _makeBezierCurve, makeBezierCurve_fn, _generateBezierPoints, generateBezierPoints_fn, _redraw, redraw_fn, _endDrawing, endDrawing_fn, _createCanvas, createCanvas_fn, _createObserver, createObserver_fn, _setCanvasDims, setCanvasDims_fn, _setScaleFactor, setScaleFactor_fn, _updateTransform, updateTransform_fn, _buildPath2D, buildPath2D_fn, _toPDFCoordinates, toPDFCoordinates_fn, _fromPDFCoordinates, fromPDFCoordinates_fn, _serializePaths, serializePaths_fn, _getBbox, getBbox_fn, _getPadding, getPadding_fn, _fitToContent, fitToContent_fn;
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            exports2.InkEditor = void 0;
            var _util2 = __w_pdfjs_require__2(1);
            var _editor = __w_pdfjs_require__2(4);
            var _annotation_layer = __w_pdfjs_require__2(29);
            var _display_utils2 = __w_pdfjs_require__2(6);
            var _tools = __w_pdfjs_require__2(5);
            const _InkEditor = class _InkEditor extends _editor.AnnotationEditor {
              constructor(params) {
                super({
                  ...params,
                  name: "inkEditor"
                });
                __privateAdd(this, _updateThickness);
                __privateAdd(this, _updateColor);
                __privateAdd(this, _updateOpacity);
                __privateAdd(this, _getInitialBBox);
                __privateAdd(this, _setStroke);
                __privateAdd(this, _startDrawing);
                __privateAdd(this, _draw);
                __privateAdd(this, _endPath);
                __privateAdd(this, _stopDrawing);
                __privateAdd(this, _drawPoints);
                __privateAdd(this, _makeBezierCurve);
                __privateAdd(this, _generateBezierPoints);
                __privateAdd(this, _redraw);
                __privateAdd(this, _endDrawing);
                __privateAdd(this, _createCanvas);
                __privateAdd(this, _createObserver);
                __privateAdd(this, _setCanvasDims);
                __privateAdd(this, _setScaleFactor);
                __privateAdd(this, _updateTransform);
                __privateAdd(this, _serializePaths);
                __privateAdd(this, _getBbox);
                __privateAdd(this, _getPadding);
                __privateAdd(this, _fitToContent);
                __privateAdd(this, _baseHeight, 0);
                __privateAdd(this, _baseWidth, 0);
                __privateAdd(this, _boundCanvasPointermove, this.canvasPointermove.bind(this));
                __privateAdd(this, _boundCanvasPointerleave, this.canvasPointerleave.bind(this));
                __privateAdd(this, _boundCanvasPointerup, this.canvasPointerup.bind(this));
                __privateAdd(this, _boundCanvasPointerdown, this.canvasPointerdown.bind(this));
                __privateAdd(this, _currentPath2D, new Path2D());
                __privateAdd(this, _disableEditing, false);
                __privateAdd(this, _hasSomethingToDraw, false);
                __privateAdd(this, _isCanvasInitialized, false);
                __privateAdd(this, _observer, null);
                __privateAdd(this, _realWidth, 0);
                __privateAdd(this, _realHeight, 0);
                __privateAdd(this, _requestFrameCallback, null);
                this.color = params.color || null;
                this.thickness = params.thickness || null;
                this.opacity = params.opacity || null;
                this.paths = [];
                this.bezierPath2D = [];
                this.allRawPaths = [];
                this.currentPath = [];
                this.scaleFactor = 1;
                this.translationX = this.translationY = 0;
                this.x = 0;
                this.y = 0;
                this._willKeepAspectRatio = true;
              }
              static initialize(l10n) {
                _editor.AnnotationEditor.initialize(l10n, {
                  strings: ["editor_ink_canvas_aria_label", "editor_ink2_aria_label"]
                });
              }
              static updateDefaultParams(type, value) {
                switch (type) {
                  case _util2.AnnotationEditorParamsType.INK_THICKNESS:
                    _InkEditor._defaultThickness = value;
                    break;
                  case _util2.AnnotationEditorParamsType.INK_COLOR:
                    _InkEditor._defaultColor = value;
                    break;
                  case _util2.AnnotationEditorParamsType.INK_OPACITY:
                    _InkEditor._defaultOpacity = value / 100;
                    break;
                }
              }
              updateParams(type, value) {
                switch (type) {
                  case _util2.AnnotationEditorParamsType.INK_THICKNESS:
                    __privateMethod(this, _updateThickness, updateThickness_fn).call(this, value);
                    break;
                  case _util2.AnnotationEditorParamsType.INK_COLOR:
                    __privateMethod(this, _updateColor, updateColor_fn).call(this, value);
                    break;
                  case _util2.AnnotationEditorParamsType.INK_OPACITY:
                    __privateMethod(this, _updateOpacity, updateOpacity_fn).call(this, value);
                    break;
                }
              }
              static get defaultPropertiesToUpdate() {
                return [[_util2.AnnotationEditorParamsType.INK_THICKNESS, _InkEditor._defaultThickness], [_util2.AnnotationEditorParamsType.INK_COLOR, _InkEditor._defaultColor || _editor.AnnotationEditor._defaultLineColor], [_util2.AnnotationEditorParamsType.INK_OPACITY, Math.round(_InkEditor._defaultOpacity * 100)]];
              }
              get propertiesToUpdate() {
                return [[_util2.AnnotationEditorParamsType.INK_THICKNESS, this.thickness || _InkEditor._defaultThickness], [_util2.AnnotationEditorParamsType.INK_COLOR, this.color || _InkEditor._defaultColor || _editor.AnnotationEditor._defaultLineColor], [_util2.AnnotationEditorParamsType.INK_OPACITY, Math.round(100 * (this.opacity ?? _InkEditor._defaultOpacity))]];
              }
              rebuild() {
                if (!this.parent) {
                  return;
                }
                super.rebuild();
                if (this.div === null) {
                  return;
                }
                if (!this.canvas) {
                  __privateMethod(this, _createCanvas, createCanvas_fn).call(this);
                  __privateMethod(this, _createObserver, createObserver_fn).call(this);
                }
                if (!this.isAttachedToDOM) {
                  this.parent.add(this);
                  __privateMethod(this, _setCanvasDims, setCanvasDims_fn).call(this);
                }
                __privateMethod(this, _fitToContent, fitToContent_fn).call(this);
              }
              remove() {
                if (this.canvas === null) {
                  return;
                }
                if (!this.isEmpty()) {
                  this.commit();
                }
                this.canvas.width = this.canvas.height = 0;
                this.canvas.remove();
                this.canvas = null;
                __privateGet(this, _observer).disconnect();
                __privateSet(this, _observer, null);
                super.remove();
              }
              setParent(parent) {
                if (!this.parent && parent) {
                  this._uiManager.removeShouldRescale(this);
                } else if (this.parent && parent === null) {
                  this._uiManager.addShouldRescale(this);
                }
                super.setParent(parent);
              }
              onScaleChanging() {
                const [parentWidth, parentHeight] = this.parentDimensions;
                const width = this.width * parentWidth;
                const height = this.height * parentHeight;
                this.setDimensions(width, height);
              }
              enableEditMode() {
                if (__privateGet(this, _disableEditing) || this.canvas === null) {
                  return;
                }
                super.enableEditMode();
                this._isDraggable = false;
                this.canvas.addEventListener("pointerdown", __privateGet(this, _boundCanvasPointerdown));
              }
              disableEditMode() {
                if (!this.isInEditMode() || this.canvas === null) {
                  return;
                }
                super.disableEditMode();
                this._isDraggable = !this.isEmpty();
                this.div.classList.remove("editing");
                this.canvas.removeEventListener("pointerdown", __privateGet(this, _boundCanvasPointerdown));
              }
              onceAdded() {
                this._isDraggable = !this.isEmpty();
              }
              isEmpty() {
                return this.paths.length === 0 || this.paths.length === 1 && this.paths[0].length === 0;
              }
              commit() {
                if (__privateGet(this, _disableEditing)) {
                  return;
                }
                super.commit();
                this.isEditing = false;
                this.disableEditMode();
                this.setInForeground();
                __privateSet(this, _disableEditing, true);
                this.div.classList.add("disabled");
                __privateMethod(this, _fitToContent, fitToContent_fn).call(this, true);
                this.makeResizable();
                this.parent.addInkEditorIfNeeded(true);
                this.moveInDOM();
                this.div.focus({
                  preventScroll: true
                });
              }
              focusin(event) {
                if (!this._focusEventsAllowed) {
                  return;
                }
                super.focusin(event);
                this.enableEditMode();
              }
              canvasPointerdown(event) {
                if (event.button !== 0 || !this.isInEditMode() || __privateGet(this, _disableEditing)) {
                  return;
                }
                this.setInForeground();
                event.preventDefault();
                if (event.type !== "mouse") {
                  this.div.focus();
                }
                __privateMethod(this, _startDrawing, startDrawing_fn).call(this, event.offsetX, event.offsetY);
              }
              canvasPointermove(event) {
                event.preventDefault();
                __privateMethod(this, _draw, draw_fn).call(this, event.offsetX, event.offsetY);
              }
              canvasPointerup(event) {
                event.preventDefault();
                __privateMethod(this, _endDrawing, endDrawing_fn).call(this, event);
              }
              canvasPointerleave(event) {
                __privateMethod(this, _endDrawing, endDrawing_fn).call(this, event);
              }
              get isResizable() {
                return !this.isEmpty() && __privateGet(this, _disableEditing);
              }
              render() {
                if (this.div) {
                  return this.div;
                }
                let baseX, baseY;
                if (this.width) {
                  baseX = this.x;
                  baseY = this.y;
                }
                super.render();
                _editor.AnnotationEditor._l10nPromise.get("editor_ink2_aria_label").then((msg) => {
                  var _a3;
                  return (_a3 = this.div) == null ? void 0 : _a3.setAttribute("aria-label", msg);
                });
                const [x2, y2, w2, h3] = __privateMethod(this, _getInitialBBox, getInitialBBox_fn).call(this);
                this.setAt(x2, y2, 0, 0);
                this.setDims(w2, h3);
                __privateMethod(this, _createCanvas, createCanvas_fn).call(this);
                if (this.width) {
                  const [parentWidth, parentHeight] = this.parentDimensions;
                  this.setAspectRatio(this.width * parentWidth, this.height * parentHeight);
                  this.setAt(baseX * parentWidth, baseY * parentHeight, this.width * parentWidth, this.height * parentHeight);
                  __privateSet(this, _isCanvasInitialized, true);
                  __privateMethod(this, _setCanvasDims, setCanvasDims_fn).call(this);
                  this.setDims(this.width * parentWidth, this.height * parentHeight);
                  __privateMethod(this, _redraw, redraw_fn).call(this);
                  this.div.classList.add("disabled");
                } else {
                  this.div.classList.add("editing");
                  this.enableEditMode();
                }
                __privateMethod(this, _createObserver, createObserver_fn).call(this);
                return this.div;
              }
              setDimensions(width, height) {
                const roundedWidth = Math.round(width);
                const roundedHeight = Math.round(height);
                if (__privateGet(this, _realWidth) === roundedWidth && __privateGet(this, _realHeight) === roundedHeight) {
                  return;
                }
                __privateSet(this, _realWidth, roundedWidth);
                __privateSet(this, _realHeight, roundedHeight);
                this.canvas.style.visibility = "hidden";
                const [parentWidth, parentHeight] = this.parentDimensions;
                this.width = width / parentWidth;
                this.height = height / parentHeight;
                this.fixAndSetPosition();
                if (__privateGet(this, _disableEditing)) {
                  __privateMethod(this, _setScaleFactor, setScaleFactor_fn).call(this, width, height);
                }
                __privateMethod(this, _setCanvasDims, setCanvasDims_fn).call(this);
                __privateMethod(this, _redraw, redraw_fn).call(this);
                this.canvas.style.visibility = "visible";
                this.fixDims();
              }
              static deserialize(data, parent, uiManager) {
                var _a3, _b2, _c;
                if (data instanceof _annotation_layer.InkAnnotationElement) {
                  return null;
                }
                const editor = super.deserialize(data, parent, uiManager);
                editor.thickness = data.thickness;
                editor.color = _util2.Util.makeHexColor(...data.color);
                editor.opacity = data.opacity;
                const [pageWidth, pageHeight] = editor.pageDimensions;
                const width = editor.width * pageWidth;
                const height = editor.height * pageHeight;
                const scaleFactor = editor.parentScale;
                const padding = data.thickness / 2;
                __privateSet(editor, _disableEditing, true);
                __privateSet(editor, _realWidth, Math.round(width));
                __privateSet(editor, _realHeight, Math.round(height));
                const {
                  paths,
                  rect,
                  rotation
                } = data;
                for (let {
                  bezier
                } of paths) {
                  bezier = __privateMethod(_a3 = _InkEditor, _fromPDFCoordinates, fromPDFCoordinates_fn).call(_a3, bezier, rect, rotation);
                  const path = [];
                  editor.paths.push(path);
                  let p0 = scaleFactor * (bezier[0] - padding);
                  let p1 = scaleFactor * (bezier[1] - padding);
                  for (let i2 = 2, ii = bezier.length; i2 < ii; i2 += 6) {
                    const p10 = scaleFactor * (bezier[i2] - padding);
                    const p11 = scaleFactor * (bezier[i2 + 1] - padding);
                    const p20 = scaleFactor * (bezier[i2 + 2] - padding);
                    const p21 = scaleFactor * (bezier[i2 + 3] - padding);
                    const p30 = scaleFactor * (bezier[i2 + 4] - padding);
                    const p31 = scaleFactor * (bezier[i2 + 5] - padding);
                    path.push([[p0, p1], [p10, p11], [p20, p21], [p30, p31]]);
                    p0 = p30;
                    p1 = p31;
                  }
                  const path2D = __privateMethod(this, _buildPath2D, buildPath2D_fn).call(this, path);
                  editor.bezierPath2D.push(path2D);
                }
                const bbox = __privateMethod(_b2 = editor, _getBbox, getBbox_fn).call(_b2);
                __privateSet(editor, _baseWidth, Math.max(_editor.AnnotationEditor.MIN_SIZE, bbox[2] - bbox[0]));
                __privateSet(editor, _baseHeight, Math.max(_editor.AnnotationEditor.MIN_SIZE, bbox[3] - bbox[1]));
                __privateMethod(_c = editor, _setScaleFactor, setScaleFactor_fn).call(_c, width, height);
                return editor;
              }
              serialize() {
                if (this.isEmpty()) {
                  return null;
                }
                const rect = this.getRect(0, 0);
                const color2 = _editor.AnnotationEditor._colorManager.convert(this.ctx.strokeStyle);
                return {
                  annotationType: _util2.AnnotationEditorType.INK,
                  color: color2,
                  thickness: this.thickness,
                  opacity: this.opacity,
                  paths: __privateMethod(this, _serializePaths, serializePaths_fn).call(this, this.scaleFactor / this.parentScale, this.translationX, this.translationY, rect),
                  pageIndex: this.pageIndex,
                  rect,
                  rotation: this.rotation,
                  structTreeParentId: this._structTreeParentId
                };
              }
            };
            _baseHeight = new WeakMap();
            _baseWidth = new WeakMap();
            _boundCanvasPointermove = new WeakMap();
            _boundCanvasPointerleave = new WeakMap();
            _boundCanvasPointerup = new WeakMap();
            _boundCanvasPointerdown = new WeakMap();
            _currentPath2D = new WeakMap();
            _disableEditing = new WeakMap();
            _hasSomethingToDraw = new WeakMap();
            _isCanvasInitialized = new WeakMap();
            _observer = new WeakMap();
            _realWidth = new WeakMap();
            _realHeight = new WeakMap();
            _requestFrameCallback = new WeakMap();
            _updateThickness = new WeakSet();
            updateThickness_fn = /* @__PURE__ */ __name(function(thickness) {
              const savedThickness = this.thickness;
              this.addCommands({
                cmd: () => {
                  this.thickness = thickness;
                  __privateMethod(this, _fitToContent, fitToContent_fn).call(this);
                },
                undo: () => {
                  this.thickness = savedThickness;
                  __privateMethod(this, _fitToContent, fitToContent_fn).call(this);
                },
                mustExec: true,
                type: _util2.AnnotationEditorParamsType.INK_THICKNESS,
                overwriteIfSameType: true,
                keepUndo: true
              });
            }, "#updateThickness");
            _updateColor = new WeakSet();
            updateColor_fn = /* @__PURE__ */ __name(function(color2) {
              const savedColor = this.color;
              this.addCommands({
                cmd: () => {
                  this.color = color2;
                  __privateMethod(this, _redraw, redraw_fn).call(this);
                },
                undo: () => {
                  this.color = savedColor;
                  __privateMethod(this, _redraw, redraw_fn).call(this);
                },
                mustExec: true,
                type: _util2.AnnotationEditorParamsType.INK_COLOR,
                overwriteIfSameType: true,
                keepUndo: true
              });
            }, "#updateColor");
            _updateOpacity = new WeakSet();
            updateOpacity_fn = /* @__PURE__ */ __name(function(opacity) {
              opacity /= 100;
              const savedOpacity = this.opacity;
              this.addCommands({
                cmd: () => {
                  this.opacity = opacity;
                  __privateMethod(this, _redraw, redraw_fn).call(this);
                },
                undo: () => {
                  this.opacity = savedOpacity;
                  __privateMethod(this, _redraw, redraw_fn).call(this);
                },
                mustExec: true,
                type: _util2.AnnotationEditorParamsType.INK_OPACITY,
                overwriteIfSameType: true,
                keepUndo: true
              });
            }, "#updateOpacity");
            _getInitialBBox = new WeakSet();
            getInitialBBox_fn = /* @__PURE__ */ __name(function() {
              const {
                parentRotation,
                parentDimensions: [width, height]
              } = this;
              switch (parentRotation) {
                case 90:
                  return [0, height, height, width];
                case 180:
                  return [width, height, width, height];
                case 270:
                  return [width, 0, height, width];
                default:
                  return [0, 0, width, height];
              }
            }, "#getInitialBBox");
            _setStroke = new WeakSet();
            setStroke_fn = /* @__PURE__ */ __name(function() {
              const {
                ctx,
                color: color2,
                opacity,
                thickness,
                parentScale,
                scaleFactor
              } = this;
              ctx.lineWidth = thickness * parentScale / scaleFactor;
              ctx.lineCap = "round";
              ctx.lineJoin = "round";
              ctx.miterLimit = 10;
              ctx.strokeStyle = `${color2}${(0, _tools.opacityToHex)(opacity)}`;
            }, "#setStroke");
            _startDrawing = new WeakSet();
            startDrawing_fn = /* @__PURE__ */ __name(function(x2, y2) {
              this.canvas.addEventListener("contextmenu", _display_utils2.noContextMenu);
              this.canvas.addEventListener("pointerleave", __privateGet(this, _boundCanvasPointerleave));
              this.canvas.addEventListener("pointermove", __privateGet(this, _boundCanvasPointermove));
              this.canvas.addEventListener("pointerup", __privateGet(this, _boundCanvasPointerup));
              this.canvas.removeEventListener("pointerdown", __privateGet(this, _boundCanvasPointerdown));
              this.isEditing = true;
              if (!__privateGet(this, _isCanvasInitialized)) {
                __privateSet(this, _isCanvasInitialized, true);
                __privateMethod(this, _setCanvasDims, setCanvasDims_fn).call(this);
                this.thickness || (this.thickness = _InkEditor._defaultThickness);
                this.color || (this.color = _InkEditor._defaultColor || _editor.AnnotationEditor._defaultLineColor);
                this.opacity ?? (this.opacity = _InkEditor._defaultOpacity);
              }
              this.currentPath.push([x2, y2]);
              __privateSet(this, _hasSomethingToDraw, false);
              __privateMethod(this, _setStroke, setStroke_fn).call(this);
              __privateSet(this, _requestFrameCallback, () => {
                __privateMethod(this, _drawPoints, drawPoints_fn).call(this);
                if (__privateGet(this, _requestFrameCallback)) {
                  window.requestAnimationFrame(__privateGet(this, _requestFrameCallback));
                }
              });
              window.requestAnimationFrame(__privateGet(this, _requestFrameCallback));
            }, "#startDrawing");
            _draw = new WeakSet();
            draw_fn = /* @__PURE__ */ __name(function(x2, y2) {
              const [lastX, lastY] = this.currentPath.at(-1);
              if (this.currentPath.length > 1 && x2 === lastX && y2 === lastY) {
                return;
              }
              const currentPath = this.currentPath;
              let path2D = __privateGet(this, _currentPath2D);
              currentPath.push([x2, y2]);
              __privateSet(this, _hasSomethingToDraw, true);
              if (currentPath.length <= 2) {
                path2D.moveTo(...currentPath[0]);
                path2D.lineTo(x2, y2);
                return;
              }
              if (currentPath.length === 3) {
                __privateSet(this, _currentPath2D, path2D = new Path2D());
                path2D.moveTo(...currentPath[0]);
              }
              __privateMethod(this, _makeBezierCurve, makeBezierCurve_fn).call(this, path2D, ...currentPath.at(-3), ...currentPath.at(-2), x2, y2);
            }, "#draw");
            _endPath = new WeakSet();
            endPath_fn = /* @__PURE__ */ __name(function() {
              if (this.currentPath.length === 0) {
                return;
              }
              const lastPoint = this.currentPath.at(-1);
              __privateGet(this, _currentPath2D).lineTo(...lastPoint);
            }, "#endPath");
            _stopDrawing = new WeakSet();
            stopDrawing_fn = /* @__PURE__ */ __name(function(x2, y2) {
              __privateSet(this, _requestFrameCallback, null);
              x2 = Math.min(Math.max(x2, 0), this.canvas.width);
              y2 = Math.min(Math.max(y2, 0), this.canvas.height);
              __privateMethod(this, _draw, draw_fn).call(this, x2, y2);
              __privateMethod(this, _endPath, endPath_fn).call(this);
              let bezier;
              if (this.currentPath.length !== 1) {
                bezier = __privateMethod(this, _generateBezierPoints, generateBezierPoints_fn).call(this);
              } else {
                const xy = [x2, y2];
                bezier = [[xy, xy.slice(), xy.slice(), xy]];
              }
              const path2D = __privateGet(this, _currentPath2D);
              const currentPath = this.currentPath;
              this.currentPath = [];
              __privateSet(this, _currentPath2D, new Path2D());
              const cmd = /* @__PURE__ */ __name(() => {
                this.allRawPaths.push(currentPath);
                this.paths.push(bezier);
                this.bezierPath2D.push(path2D);
                this.rebuild();
              }, "cmd");
              const undo = /* @__PURE__ */ __name(() => {
                this.allRawPaths.pop();
                this.paths.pop();
                this.bezierPath2D.pop();
                if (this.paths.length === 0) {
                  this.remove();
                } else {
                  if (!this.canvas) {
                    __privateMethod(this, _createCanvas, createCanvas_fn).call(this);
                    __privateMethod(this, _createObserver, createObserver_fn).call(this);
                  }
                  __privateMethod(this, _fitToContent, fitToContent_fn).call(this);
                }
              }, "undo");
              this.addCommands({
                cmd,
                undo,
                mustExec: true
              });
            }, "#stopDrawing");
            _drawPoints = new WeakSet();
            drawPoints_fn = /* @__PURE__ */ __name(function() {
              if (!__privateGet(this, _hasSomethingToDraw)) {
                return;
              }
              __privateSet(this, _hasSomethingToDraw, false);
              const thickness = Math.ceil(this.thickness * this.parentScale);
              const lastPoints = this.currentPath.slice(-3);
              const x2 = lastPoints.map((xy) => xy[0]);
              const y2 = lastPoints.map((xy) => xy[1]);
              Math.min(...x2) - thickness;
              Math.max(...x2) + thickness;
              Math.min(...y2) - thickness;
              Math.max(...y2) + thickness;
              const {
                ctx
              } = this;
              ctx.save();
              ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
              for (const path of this.bezierPath2D) {
                ctx.stroke(path);
              }
              ctx.stroke(__privateGet(this, _currentPath2D));
              ctx.restore();
            }, "#drawPoints");
            _makeBezierCurve = new WeakSet();
            makeBezierCurve_fn = /* @__PURE__ */ __name(function(path2D, x0, y0, x1, y1, x2, y2) {
              const prevX = (x0 + x1) / 2;
              const prevY = (y0 + y1) / 2;
              const x3 = (x1 + x2) / 2;
              const y3 = (y1 + y2) / 2;
              path2D.bezierCurveTo(prevX + 2 * (x1 - prevX) / 3, prevY + 2 * (y1 - prevY) / 3, x3 + 2 * (x1 - x3) / 3, y3 + 2 * (y1 - y3) / 3, x3, y3);
            }, "#makeBezierCurve");
            _generateBezierPoints = new WeakSet();
            generateBezierPoints_fn = /* @__PURE__ */ __name(function() {
              const path = this.currentPath;
              if (path.length <= 2) {
                return [[path[0], path[0], path.at(-1), path.at(-1)]];
              }
              const bezierPoints = [];
              let i2;
              let [x0, y0] = path[0];
              for (i2 = 1; i2 < path.length - 2; i2++) {
                const [x12, y12] = path[i2];
                const [x22, y22] = path[i2 + 1];
                const x3 = (x12 + x22) / 2;
                const y3 = (y12 + y22) / 2;
                const control12 = [x0 + 2 * (x12 - x0) / 3, y0 + 2 * (y12 - y0) / 3];
                const control22 = [x3 + 2 * (x12 - x3) / 3, y3 + 2 * (y12 - y3) / 3];
                bezierPoints.push([[x0, y0], control12, control22, [x3, y3]]);
                [x0, y0] = [x3, y3];
              }
              const [x1, y1] = path[i2];
              const [x2, y2] = path[i2 + 1];
              const control1 = [x0 + 2 * (x1 - x0) / 3, y0 + 2 * (y1 - y0) / 3];
              const control2 = [x2 + 2 * (x1 - x2) / 3, y2 + 2 * (y1 - y2) / 3];
              bezierPoints.push([[x0, y0], control1, control2, [x2, y2]]);
              return bezierPoints;
            }, "#generateBezierPoints");
            _redraw = new WeakSet();
            redraw_fn = /* @__PURE__ */ __name(function() {
              if (this.isEmpty()) {
                __privateMethod(this, _updateTransform, updateTransform_fn).call(this);
                return;
              }
              __privateMethod(this, _setStroke, setStroke_fn).call(this);
              const {
                canvas,
                ctx
              } = this;
              ctx.setTransform(1, 0, 0, 1, 0, 0);
              ctx.clearRect(0, 0, canvas.width, canvas.height);
              __privateMethod(this, _updateTransform, updateTransform_fn).call(this);
              for (const path of this.bezierPath2D) {
                ctx.stroke(path);
              }
            }, "#redraw");
            _endDrawing = new WeakSet();
            endDrawing_fn = /* @__PURE__ */ __name(function(event) {
              this.canvas.removeEventListener("pointerleave", __privateGet(this, _boundCanvasPointerleave));
              this.canvas.removeEventListener("pointermove", __privateGet(this, _boundCanvasPointermove));
              this.canvas.removeEventListener("pointerup", __privateGet(this, _boundCanvasPointerup));
              this.canvas.addEventListener("pointerdown", __privateGet(this, _boundCanvasPointerdown));
              setTimeout(() => {
                this.canvas.removeEventListener("contextmenu", _display_utils2.noContextMenu);
              }, 10);
              __privateMethod(this, _stopDrawing, stopDrawing_fn).call(this, event.offsetX, event.offsetY);
              this.addToAnnotationStorage();
              this.setInBackground();
            }, "#endDrawing");
            _createCanvas = new WeakSet();
            createCanvas_fn = /* @__PURE__ */ __name(function() {
              this.canvas = document.createElement("canvas");
              this.canvas.width = this.canvas.height = 0;
              this.canvas.className = "inkEditorCanvas";
              _editor.AnnotationEditor._l10nPromise.get("editor_ink_canvas_aria_label").then((msg) => {
                var _a3;
                return (_a3 = this.canvas) == null ? void 0 : _a3.setAttribute("aria-label", msg);
              });
              this.div.append(this.canvas);
              this.ctx = this.canvas.getContext("2d");
            }, "#createCanvas");
            _createObserver = new WeakSet();
            createObserver_fn = /* @__PURE__ */ __name(function() {
              __privateSet(this, _observer, new ResizeObserver((entries) => {
                const rect = entries[0].contentRect;
                if (rect.width && rect.height) {
                  this.setDimensions(rect.width, rect.height);
                }
              }));
              __privateGet(this, _observer).observe(this.div);
            }, "#createObserver");
            _setCanvasDims = new WeakSet();
            setCanvasDims_fn = /* @__PURE__ */ __name(function() {
              if (!__privateGet(this, _isCanvasInitialized)) {
                return;
              }
              const [parentWidth, parentHeight] = this.parentDimensions;
              this.canvas.width = Math.ceil(this.width * parentWidth);
              this.canvas.height = Math.ceil(this.height * parentHeight);
              __privateMethod(this, _updateTransform, updateTransform_fn).call(this);
            }, "#setCanvasDims");
            _setScaleFactor = new WeakSet();
            setScaleFactor_fn = /* @__PURE__ */ __name(function(width, height) {
              const padding = __privateMethod(this, _getPadding, getPadding_fn).call(this);
              const scaleFactorW = (width - padding) / __privateGet(this, _baseWidth);
              const scaleFactorH = (height - padding) / __privateGet(this, _baseHeight);
              this.scaleFactor = Math.min(scaleFactorW, scaleFactorH);
            }, "#setScaleFactor");
            _updateTransform = new WeakSet();
            updateTransform_fn = /* @__PURE__ */ __name(function() {
              const padding = __privateMethod(this, _getPadding, getPadding_fn).call(this) / 2;
              this.ctx.setTransform(this.scaleFactor, 0, 0, this.scaleFactor, this.translationX * this.scaleFactor + padding, this.translationY * this.scaleFactor + padding);
            }, "#updateTransform");
            _buildPath2D = new WeakSet();
            buildPath2D_fn = /* @__PURE__ */ __name(function(bezier) {
              const path2D = new Path2D();
              for (let i2 = 0, ii = bezier.length; i2 < ii; i2++) {
                const [first, control1, control2, second] = bezier[i2];
                if (i2 === 0) {
                  path2D.moveTo(...first);
                }
                path2D.bezierCurveTo(control1[0], control1[1], control2[0], control2[1], second[0], second[1]);
              }
              return path2D;
            }, "#buildPath2D");
            _toPDFCoordinates = new WeakSet();
            toPDFCoordinates_fn = /* @__PURE__ */ __name(function(points, rect, rotation) {
              const [blX, blY, trX, trY] = rect;
              switch (rotation) {
                case 0:
                  for (let i2 = 0, ii = points.length; i2 < ii; i2 += 2) {
                    points[i2] += blX;
                    points[i2 + 1] = trY - points[i2 + 1];
                  }
                  break;
                case 90:
                  for (let i2 = 0, ii = points.length; i2 < ii; i2 += 2) {
                    const x2 = points[i2];
                    points[i2] = points[i2 + 1] + blX;
                    points[i2 + 1] = x2 + blY;
                  }
                  break;
                case 180:
                  for (let i2 = 0, ii = points.length; i2 < ii; i2 += 2) {
                    points[i2] = trX - points[i2];
                    points[i2 + 1] += blY;
                  }
                  break;
                case 270:
                  for (let i2 = 0, ii = points.length; i2 < ii; i2 += 2) {
                    const x2 = points[i2];
                    points[i2] = trX - points[i2 + 1];
                    points[i2 + 1] = trY - x2;
                  }
                  break;
                default:
                  throw new Error("Invalid rotation");
              }
              return points;
            }, "#toPDFCoordinates");
            _fromPDFCoordinates = new WeakSet();
            fromPDFCoordinates_fn = /* @__PURE__ */ __name(function(points, rect, rotation) {
              const [blX, blY, trX, trY] = rect;
              switch (rotation) {
                case 0:
                  for (let i2 = 0, ii = points.length; i2 < ii; i2 += 2) {
                    points[i2] -= blX;
                    points[i2 + 1] = trY - points[i2 + 1];
                  }
                  break;
                case 90:
                  for (let i2 = 0, ii = points.length; i2 < ii; i2 += 2) {
                    const x2 = points[i2];
                    points[i2] = points[i2 + 1] - blY;
                    points[i2 + 1] = x2 - blX;
                  }
                  break;
                case 180:
                  for (let i2 = 0, ii = points.length; i2 < ii; i2 += 2) {
                    points[i2] = trX - points[i2];
                    points[i2 + 1] -= blY;
                  }
                  break;
                case 270:
                  for (let i2 = 0, ii = points.length; i2 < ii; i2 += 2) {
                    const x2 = points[i2];
                    points[i2] = trY - points[i2 + 1];
                    points[i2 + 1] = trX - x2;
                  }
                  break;
                default:
                  throw new Error("Invalid rotation");
              }
              return points;
            }, "#fromPDFCoordinates");
            _serializePaths = new WeakSet();
            serializePaths_fn = /* @__PURE__ */ __name(function(s2, tx, ty, rect) {
              var _a3, _b2;
              const paths = [];
              const padding = this.thickness / 2;
              const shiftX = s2 * tx + padding;
              const shiftY = s2 * ty + padding;
              for (const bezier of this.paths) {
                const buffer = [];
                const points = [];
                for (let j2 = 0, jj = bezier.length; j2 < jj; j2++) {
                  const [first, control1, control2, second] = bezier[j2];
                  const p10 = s2 * first[0] + shiftX;
                  const p11 = s2 * first[1] + shiftY;
                  const p20 = s2 * control1[0] + shiftX;
                  const p21 = s2 * control1[1] + shiftY;
                  const p30 = s2 * control2[0] + shiftX;
                  const p31 = s2 * control2[1] + shiftY;
                  const p40 = s2 * second[0] + shiftX;
                  const p41 = s2 * second[1] + shiftY;
                  if (j2 === 0) {
                    buffer.push(p10, p11);
                    points.push(p10, p11);
                  }
                  buffer.push(p20, p21, p30, p31, p40, p41);
                  points.push(p20, p21);
                  if (j2 === jj - 1) {
                    points.push(p40, p41);
                  }
                }
                paths.push({
                  bezier: __privateMethod(_a3 = _InkEditor, _toPDFCoordinates, toPDFCoordinates_fn).call(_a3, buffer, rect, this.rotation),
                  points: __privateMethod(_b2 = _InkEditor, _toPDFCoordinates, toPDFCoordinates_fn).call(_b2, points, rect, this.rotation)
                });
              }
              return paths;
            }, "#serializePaths");
            _getBbox = new WeakSet();
            getBbox_fn = /* @__PURE__ */ __name(function() {
              let xMin = Infinity;
              let xMax = -Infinity;
              let yMin = Infinity;
              let yMax = -Infinity;
              for (const path of this.paths) {
                for (const [first, control1, control2, second] of path) {
                  const bbox = _util2.Util.bezierBoundingBox(...first, ...control1, ...control2, ...second);
                  xMin = Math.min(xMin, bbox[0]);
                  yMin = Math.min(yMin, bbox[1]);
                  xMax = Math.max(xMax, bbox[2]);
                  yMax = Math.max(yMax, bbox[3]);
                }
              }
              return [xMin, yMin, xMax, yMax];
            }, "#getBbox");
            _getPadding = new WeakSet();
            getPadding_fn = /* @__PURE__ */ __name(function() {
              return __privateGet(this, _disableEditing) ? Math.ceil(this.thickness * this.parentScale) : 0;
            }, "#getPadding");
            _fitToContent = new WeakSet();
            fitToContent_fn = /* @__PURE__ */ __name(function(firstTime = false) {
              if (this.isEmpty()) {
                return;
              }
              if (!__privateGet(this, _disableEditing)) {
                __privateMethod(this, _redraw, redraw_fn).call(this);
                return;
              }
              const bbox = __privateMethod(this, _getBbox, getBbox_fn).call(this);
              const padding = __privateMethod(this, _getPadding, getPadding_fn).call(this);
              __privateSet(this, _baseWidth, Math.max(_editor.AnnotationEditor.MIN_SIZE, bbox[2] - bbox[0]));
              __privateSet(this, _baseHeight, Math.max(_editor.AnnotationEditor.MIN_SIZE, bbox[3] - bbox[1]));
              const width = Math.ceil(padding + __privateGet(this, _baseWidth) * this.scaleFactor);
              const height = Math.ceil(padding + __privateGet(this, _baseHeight) * this.scaleFactor);
              const [parentWidth, parentHeight] = this.parentDimensions;
              this.width = width / parentWidth;
              this.height = height / parentHeight;
              this.setAspectRatio(width, height);
              const prevTranslationX = this.translationX;
              const prevTranslationY = this.translationY;
              this.translationX = -bbox[0];
              this.translationY = -bbox[1];
              __privateMethod(this, _setCanvasDims, setCanvasDims_fn).call(this);
              __privateMethod(this, _redraw, redraw_fn).call(this);
              __privateSet(this, _realWidth, width);
              __privateSet(this, _realHeight, height);
              this.setDims(width, height);
              const unscaledPadding = firstTime ? padding / this.scaleFactor / 2 : 0;
              this.translate(prevTranslationX - this.translationX - unscaledPadding, prevTranslationY - this.translationY - unscaledPadding);
            }, "#fitToContent");
            __privateAdd(_InkEditor, _buildPath2D);
            __privateAdd(_InkEditor, _toPDFCoordinates);
            __privateAdd(_InkEditor, _fromPDFCoordinates);
            __name(_InkEditor, "InkEditor");
            __publicField(_InkEditor, "_defaultColor", null);
            __publicField(_InkEditor, "_defaultOpacity", 1);
            __publicField(_InkEditor, "_defaultThickness", 1);
            __publicField(_InkEditor, "_type", "ink");
            let InkEditor = _InkEditor;
            exports2.InkEditor = InkEditor;
          },
          /* 34 */
          /***/
          (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
            var _bitmap, _bitmapId, _bitmapPromise, _bitmapUrl, _bitmapFile, _canvas2, _observer, _resizeTimeoutId, _isSvg, _hasBeenAddedInUndoStack, _getBitmapFetched, getBitmapFetched_fn, _getBitmapDone, getBitmapDone_fn, _getBitmap, getBitmap_fn, _createCanvas, createCanvas_fn, _setDimensions, setDimensions_fn, _scaleBitmap, scaleBitmap_fn, _drawBitmap, drawBitmap_fn, _serializeBitmap, serializeBitmap_fn, _createObserver, createObserver_fn;
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            exports2.StampEditor = void 0;
            var _util2 = __w_pdfjs_require__2(1);
            var _editor = __w_pdfjs_require__2(4);
            var _display_utils2 = __w_pdfjs_require__2(6);
            var _annotation_layer = __w_pdfjs_require__2(29);
            const _StampEditor = class _StampEditor extends _editor.AnnotationEditor {
              constructor(params) {
                super({
                  ...params,
                  name: "stampEditor"
                });
                __privateAdd(this, _getBitmapFetched);
                __privateAdd(this, _getBitmapDone);
                __privateAdd(this, _getBitmap);
                __privateAdd(this, _createCanvas);
                __privateAdd(this, _setDimensions);
                __privateAdd(this, _scaleBitmap);
                __privateAdd(this, _drawBitmap);
                __privateAdd(this, _serializeBitmap);
                __privateAdd(this, _createObserver);
                __privateAdd(this, _bitmap, null);
                __privateAdd(this, _bitmapId, null);
                __privateAdd(this, _bitmapPromise, null);
                __privateAdd(this, _bitmapUrl, null);
                __privateAdd(this, _bitmapFile, null);
                __privateAdd(this, _canvas2, null);
                __privateAdd(this, _observer, null);
                __privateAdd(this, _resizeTimeoutId, null);
                __privateAdd(this, _isSvg, false);
                __privateAdd(this, _hasBeenAddedInUndoStack, false);
                __privateSet(this, _bitmapUrl, params.bitmapUrl);
                __privateSet(this, _bitmapFile, params.bitmapFile);
              }
              static initialize(l10n) {
                _editor.AnnotationEditor.initialize(l10n);
              }
              static get supportedTypes() {
                const types = ["apng", "avif", "bmp", "gif", "jpeg", "png", "svg+xml", "webp", "x-icon"];
                return (0, _util2.shadow)(this, "supportedTypes", types.map((type) => `image/${type}`));
              }
              static get supportedTypesStr() {
                return (0, _util2.shadow)(this, "supportedTypesStr", this.supportedTypes.join(","));
              }
              static isHandlingMimeForPasting(mime) {
                return this.supportedTypes.includes(mime);
              }
              static paste(item, parent) {
                parent.pasteEditor(_util2.AnnotationEditorType.STAMP, {
                  bitmapFile: item.getAsFile()
                });
              }
              remove() {
                var _a3, _b2;
                if (__privateGet(this, _bitmapId)) {
                  __privateSet(this, _bitmap, null);
                  this._uiManager.imageManager.deleteId(__privateGet(this, _bitmapId));
                  (_a3 = __privateGet(this, _canvas2)) == null ? void 0 : _a3.remove();
                  __privateSet(this, _canvas2, null);
                  (_b2 = __privateGet(this, _observer)) == null ? void 0 : _b2.disconnect();
                  __privateSet(this, _observer, null);
                }
                super.remove();
              }
              rebuild() {
                if (!this.parent) {
                  if (__privateGet(this, _bitmapId)) {
                    __privateMethod(this, _getBitmap, getBitmap_fn).call(this);
                  }
                  return;
                }
                super.rebuild();
                if (this.div === null) {
                  return;
                }
                if (__privateGet(this, _bitmapId)) {
                  __privateMethod(this, _getBitmap, getBitmap_fn).call(this);
                }
                if (!this.isAttachedToDOM) {
                  this.parent.add(this);
                }
              }
              onceAdded() {
                this._isDraggable = true;
                this.div.focus();
              }
              isEmpty() {
                return !(__privateGet(this, _bitmapPromise) || __privateGet(this, _bitmap) || __privateGet(this, _bitmapUrl) || __privateGet(this, _bitmapFile));
              }
              get isResizable() {
                return true;
              }
              render() {
                if (this.div) {
                  return this.div;
                }
                let baseX, baseY;
                if (this.width) {
                  baseX = this.x;
                  baseY = this.y;
                }
                super.render();
                this.div.hidden = true;
                if (__privateGet(this, _bitmap)) {
                  __privateMethod(this, _createCanvas, createCanvas_fn).call(this);
                } else {
                  __privateMethod(this, _getBitmap, getBitmap_fn).call(this);
                }
                if (this.width) {
                  const [parentWidth, parentHeight] = this.parentDimensions;
                  this.setAt(baseX * parentWidth, baseY * parentHeight, this.width * parentWidth, this.height * parentHeight);
                }
                return this.div;
              }
              static deserialize(data, parent, uiManager) {
                if (data instanceof _annotation_layer.StampAnnotationElement) {
                  return null;
                }
                const editor = super.deserialize(data, parent, uiManager);
                const {
                  rect,
                  bitmapUrl,
                  bitmapId,
                  isSvg,
                  accessibilityData
                } = data;
                if (bitmapId && uiManager.imageManager.isValidId(bitmapId)) {
                  __privateSet(editor, _bitmapId, bitmapId);
                } else {
                  __privateSet(editor, _bitmapUrl, bitmapUrl);
                }
                __privateSet(editor, _isSvg, isSvg);
                const [parentWidth, parentHeight] = editor.pageDimensions;
                editor.width = (rect[2] - rect[0]) / parentWidth;
                editor.height = (rect[3] - rect[1]) / parentHeight;
                if (accessibilityData) {
                  editor.altTextData = accessibilityData;
                }
                return editor;
              }
              serialize(isForCopying = false, context = null) {
                if (this.isEmpty()) {
                  return null;
                }
                const serialized = {
                  annotationType: _util2.AnnotationEditorType.STAMP,
                  bitmapId: __privateGet(this, _bitmapId),
                  pageIndex: this.pageIndex,
                  rect: this.getRect(0, 0),
                  rotation: this.rotation,
                  isSvg: __privateGet(this, _isSvg),
                  structTreeParentId: this._structTreeParentId
                };
                if (isForCopying) {
                  serialized.bitmapUrl = __privateMethod(this, _serializeBitmap, serializeBitmap_fn).call(this, true);
                  serialized.accessibilityData = this.altTextData;
                  return serialized;
                }
                const {
                  decorative,
                  altText
                } = this.altTextData;
                if (!decorative && altText) {
                  serialized.accessibilityData = {
                    type: "Figure",
                    alt: altText
                  };
                }
                if (context === null) {
                  return serialized;
                }
                context.stamps || (context.stamps = /* @__PURE__ */ new Map());
                const area = __privateGet(this, _isSvg) ? (serialized.rect[2] - serialized.rect[0]) * (serialized.rect[3] - serialized.rect[1]) : null;
                if (!context.stamps.has(__privateGet(this, _bitmapId))) {
                  context.stamps.set(__privateGet(this, _bitmapId), {
                    area,
                    serialized
                  });
                  serialized.bitmap = __privateMethod(this, _serializeBitmap, serializeBitmap_fn).call(this, false);
                } else if (__privateGet(this, _isSvg)) {
                  const prevData = context.stamps.get(__privateGet(this, _bitmapId));
                  if (area > prevData.area) {
                    prevData.area = area;
                    prevData.serialized.bitmap.close();
                    prevData.serialized.bitmap = __privateMethod(this, _serializeBitmap, serializeBitmap_fn).call(this, false);
                  }
                }
                return serialized;
              }
            };
            _bitmap = new WeakMap();
            _bitmapId = new WeakMap();
            _bitmapPromise = new WeakMap();
            _bitmapUrl = new WeakMap();
            _bitmapFile = new WeakMap();
            _canvas2 = new WeakMap();
            _observer = new WeakMap();
            _resizeTimeoutId = new WeakMap();
            _isSvg = new WeakMap();
            _hasBeenAddedInUndoStack = new WeakMap();
            _getBitmapFetched = new WeakSet();
            getBitmapFetched_fn = /* @__PURE__ */ __name(function(data, fromId = false) {
              if (!data) {
                this.remove();
                return;
              }
              __privateSet(this, _bitmap, data.bitmap);
              if (!fromId) {
                __privateSet(this, _bitmapId, data.id);
                __privateSet(this, _isSvg, data.isSvg);
              }
              __privateMethod(this, _createCanvas, createCanvas_fn).call(this);
            }, "#getBitmapFetched");
            _getBitmapDone = new WeakSet();
            getBitmapDone_fn = /* @__PURE__ */ __name(function() {
              __privateSet(this, _bitmapPromise, null);
              this._uiManager.enableWaiting(false);
              if (__privateGet(this, _canvas2)) {
                this.div.focus();
              }
            }, "#getBitmapDone");
            _getBitmap = new WeakSet();
            getBitmap_fn = /* @__PURE__ */ __name(function() {
              if (__privateGet(this, _bitmapId)) {
                this._uiManager.enableWaiting(true);
                this._uiManager.imageManager.getFromId(__privateGet(this, _bitmapId)).then((data) => __privateMethod(this, _getBitmapFetched, getBitmapFetched_fn).call(this, data, true)).finally(() => __privateMethod(this, _getBitmapDone, getBitmapDone_fn).call(this));
                return;
              }
              if (__privateGet(this, _bitmapUrl)) {
                const url = __privateGet(this, _bitmapUrl);
                __privateSet(this, _bitmapUrl, null);
                this._uiManager.enableWaiting(true);
                __privateSet(this, _bitmapPromise, this._uiManager.imageManager.getFromUrl(url).then((data) => __privateMethod(this, _getBitmapFetched, getBitmapFetched_fn).call(this, data)).finally(() => __privateMethod(this, _getBitmapDone, getBitmapDone_fn).call(this)));
                return;
              }
              if (__privateGet(this, _bitmapFile)) {
                const file = __privateGet(this, _bitmapFile);
                __privateSet(this, _bitmapFile, null);
                this._uiManager.enableWaiting(true);
                __privateSet(this, _bitmapPromise, this._uiManager.imageManager.getFromFile(file).then((data) => __privateMethod(this, _getBitmapFetched, getBitmapFetched_fn).call(this, data)).finally(() => __privateMethod(this, _getBitmapDone, getBitmapDone_fn).call(this)));
                return;
              }
              const input = document.createElement("input");
              input.type = "file";
              input.accept = _StampEditor.supportedTypesStr;
              __privateSet(this, _bitmapPromise, new Promise((resolve2) => {
                input.addEventListener("change", async () => {
                  if (!input.files || input.files.length === 0) {
                    this.remove();
                  } else {
                    this._uiManager.enableWaiting(true);
                    const data = await this._uiManager.imageManager.getFromFile(input.files[0]);
                    __privateMethod(this, _getBitmapFetched, getBitmapFetched_fn).call(this, data);
                  }
                  resolve2();
                });
                input.addEventListener("cancel", () => {
                  this.remove();
                  resolve2();
                });
              }).finally(() => __privateMethod(this, _getBitmapDone, getBitmapDone_fn).call(this)));
              input.click();
            }, "#getBitmap");
            _createCanvas = new WeakSet();
            createCanvas_fn = /* @__PURE__ */ __name(function() {
              const {
                div
              } = this;
              let {
                width,
                height
              } = __privateGet(this, _bitmap);
              const [pageWidth, pageHeight] = this.pageDimensions;
              const MAX_RATIO = 0.75;
              if (this.width) {
                width = this.width * pageWidth;
                height = this.height * pageHeight;
              } else if (width > MAX_RATIO * pageWidth || height > MAX_RATIO * pageHeight) {
                const factor = Math.min(MAX_RATIO * pageWidth / width, MAX_RATIO * pageHeight / height);
                width *= factor;
                height *= factor;
              }
              const [parentWidth, parentHeight] = this.parentDimensions;
              this.setDims(width * parentWidth / pageWidth, height * parentHeight / pageHeight);
              this._uiManager.enableWaiting(false);
              const canvas = __privateSet(this, _canvas2, document.createElement("canvas"));
              div.append(canvas);
              div.hidden = false;
              __privateMethod(this, _drawBitmap, drawBitmap_fn).call(this, width, height);
              __privateMethod(this, _createObserver, createObserver_fn).call(this);
              if (!__privateGet(this, _hasBeenAddedInUndoStack)) {
                this.parent.addUndoableEditor(this);
                __privateSet(this, _hasBeenAddedInUndoStack, true);
              }
              this._uiManager._eventBus.dispatch("reporttelemetry", {
                source: this,
                details: {
                  type: "editing",
                  subtype: this.editorType,
                  data: {
                    action: "inserted_image"
                  }
                }
              });
              this.addAltTextButton();
            }, "#createCanvas");
            _setDimensions = new WeakSet();
            setDimensions_fn = /* @__PURE__ */ __name(function(width, height) {
              var _a3;
              const [parentWidth, parentHeight] = this.parentDimensions;
              this.width = width / parentWidth;
              this.height = height / parentHeight;
              this.setDims(width, height);
              if ((_a3 = this._initialOptions) == null ? void 0 : _a3.isCentered) {
                this.center();
              } else {
                this.fixAndSetPosition();
              }
              this._initialOptions = null;
              if (__privateGet(this, _resizeTimeoutId) !== null) {
                clearTimeout(__privateGet(this, _resizeTimeoutId));
              }
              const TIME_TO_WAIT = 200;
              __privateSet(this, _resizeTimeoutId, setTimeout(() => {
                __privateSet(this, _resizeTimeoutId, null);
                __privateMethod(this, _drawBitmap, drawBitmap_fn).call(this, width, height);
              }, TIME_TO_WAIT));
            }, "#setDimensions");
            _scaleBitmap = new WeakSet();
            scaleBitmap_fn = /* @__PURE__ */ __name(function(width, height) {
              const {
                width: bitmapWidth,
                height: bitmapHeight
              } = __privateGet(this, _bitmap);
              let newWidth = bitmapWidth;
              let newHeight = bitmapHeight;
              let bitmap = __privateGet(this, _bitmap);
              while (newWidth > 2 * width || newHeight > 2 * height) {
                const prevWidth = newWidth;
                const prevHeight = newHeight;
                if (newWidth > 2 * width) {
                  newWidth = newWidth >= 16384 ? Math.floor(newWidth / 2) - 1 : Math.ceil(newWidth / 2);
                }
                if (newHeight > 2 * height) {
                  newHeight = newHeight >= 16384 ? Math.floor(newHeight / 2) - 1 : Math.ceil(newHeight / 2);
                }
                const offscreen = new OffscreenCanvas(newWidth, newHeight);
                const ctx = offscreen.getContext("2d");
                ctx.drawImage(bitmap, 0, 0, prevWidth, prevHeight, 0, 0, newWidth, newHeight);
                bitmap = offscreen.transferToImageBitmap();
              }
              return bitmap;
            }, "#scaleBitmap");
            _drawBitmap = new WeakSet();
            drawBitmap_fn = /* @__PURE__ */ __name(function(width, height) {
              width = Math.ceil(width);
              height = Math.ceil(height);
              const canvas = __privateGet(this, _canvas2);
              if (!canvas || canvas.width === width && canvas.height === height) {
                return;
              }
              canvas.width = width;
              canvas.height = height;
              const bitmap = __privateGet(this, _isSvg) ? __privateGet(this, _bitmap) : __privateMethod(this, _scaleBitmap, scaleBitmap_fn).call(this, width, height);
              const ctx = canvas.getContext("2d");
              ctx.filter = this._uiManager.hcmFilter;
              ctx.drawImage(bitmap, 0, 0, bitmap.width, bitmap.height, 0, 0, width, height);
            }, "#drawBitmap");
            _serializeBitmap = new WeakSet();
            serializeBitmap_fn = /* @__PURE__ */ __name(function(toUrl) {
              if (toUrl) {
                if (__privateGet(this, _isSvg)) {
                  const url = this._uiManager.imageManager.getSvgUrl(__privateGet(this, _bitmapId));
                  if (url) {
                    return url;
                  }
                }
                const canvas = document.createElement("canvas");
                ({
                  width: canvas.width,
                  height: canvas.height
                } = __privateGet(this, _bitmap));
                const ctx = canvas.getContext("2d");
                ctx.drawImage(__privateGet(this, _bitmap), 0, 0);
                return canvas.toDataURL();
              }
              if (__privateGet(this, _isSvg)) {
                const [pageWidth, pageHeight] = this.pageDimensions;
                const width = Math.round(this.width * pageWidth * _display_utils2.PixelsPerInch.PDF_TO_CSS_UNITS);
                const height = Math.round(this.height * pageHeight * _display_utils2.PixelsPerInch.PDF_TO_CSS_UNITS);
                const offscreen = new OffscreenCanvas(width, height);
                const ctx = offscreen.getContext("2d");
                ctx.drawImage(__privateGet(this, _bitmap), 0, 0, __privateGet(this, _bitmap).width, __privateGet(this, _bitmap).height, 0, 0, width, height);
                return offscreen.transferToImageBitmap();
              }
              return structuredClone(__privateGet(this, _bitmap));
            }, "#serializeBitmap");
            _createObserver = new WeakSet();
            createObserver_fn = /* @__PURE__ */ __name(function() {
              __privateSet(this, _observer, new ResizeObserver((entries) => {
                const rect = entries[0].contentRect;
                if (rect.width && rect.height) {
                  __privateMethod(this, _setDimensions, setDimensions_fn).call(this, rect.width, rect.height);
                }
              }));
              __privateGet(this, _observer).observe(this.div);
            }, "#createObserver");
            __name(_StampEditor, "StampEditor");
            __publicField(_StampEditor, "_type", "stamp");
            let StampEditor = _StampEditor;
            exports2.StampEditor = StampEditor;
          }
          /******/
        ];
        var __webpack_module_cache__ = {};
        function __w_pdfjs_require__(moduleId) {
          var cachedModule = __webpack_module_cache__[moduleId];
          if (cachedModule !== void 0) {
            return cachedModule.exports;
          }
          var module2 = __webpack_module_cache__[moduleId] = {
            /******/
            // no module.id needed
            /******/
            // no module.loaded needed
            /******/
            exports: {}
            /******/
          };
          __webpack_modules__[moduleId](module2, module2.exports, __w_pdfjs_require__);
          return module2.exports;
        }
        __name(__w_pdfjs_require__, "__w_pdfjs_require__");
        var __webpack_exports__ = {};
        (() => {
          var exports2 = __webpack_exports__;
          Object.defineProperty(exports2, "__esModule", {
            value: true
          });
          Object.defineProperty(exports2, "AbortException", {
            enumerable: true,
            get: function() {
              return _util2.AbortException;
            }
          });
          Object.defineProperty(exports2, "AnnotationEditorLayer", {
            enumerable: true,
            get: function() {
              return _annotation_editor_layer.AnnotationEditorLayer;
            }
          });
          Object.defineProperty(exports2, "AnnotationEditorParamsType", {
            enumerable: true,
            get: function() {
              return _util2.AnnotationEditorParamsType;
            }
          });
          Object.defineProperty(exports2, "AnnotationEditorType", {
            enumerable: true,
            get: function() {
              return _util2.AnnotationEditorType;
            }
          });
          Object.defineProperty(exports2, "AnnotationEditorUIManager", {
            enumerable: true,
            get: function() {
              return _tools.AnnotationEditorUIManager;
            }
          });
          Object.defineProperty(exports2, "AnnotationLayer", {
            enumerable: true,
            get: function() {
              return _annotation_layer.AnnotationLayer;
            }
          });
          Object.defineProperty(exports2, "AnnotationMode", {
            enumerable: true,
            get: function() {
              return _util2.AnnotationMode;
            }
          });
          Object.defineProperty(exports2, "CMapCompressionType", {
            enumerable: true,
            get: function() {
              return _util2.CMapCompressionType;
            }
          });
          Object.defineProperty(exports2, "DOMSVGFactory", {
            enumerable: true,
            get: function() {
              return _display_utils2.DOMSVGFactory;
            }
          });
          Object.defineProperty(exports2, "FeatureTest", {
            enumerable: true,
            get: function() {
              return _util2.FeatureTest;
            }
          });
          Object.defineProperty(exports2, "GlobalWorkerOptions", {
            enumerable: true,
            get: function() {
              return _worker_options2.GlobalWorkerOptions;
            }
          });
          Object.defineProperty(exports2, "ImageKind", {
            enumerable: true,
            get: function() {
              return _util2.ImageKind;
            }
          });
          Object.defineProperty(exports2, "InvalidPDFException", {
            enumerable: true,
            get: function() {
              return _util2.InvalidPDFException;
            }
          });
          Object.defineProperty(exports2, "MissingPDFException", {
            enumerable: true,
            get: function() {
              return _util2.MissingPDFException;
            }
          });
          Object.defineProperty(exports2, "OPS", {
            enumerable: true,
            get: function() {
              return _util2.OPS;
            }
          });
          Object.defineProperty(exports2, "PDFDataRangeTransport", {
            enumerable: true,
            get: function() {
              return _api.PDFDataRangeTransport;
            }
          });
          Object.defineProperty(exports2, "PDFDateString", {
            enumerable: true,
            get: function() {
              return _display_utils2.PDFDateString;
            }
          });
          Object.defineProperty(exports2, "PDFWorker", {
            enumerable: true,
            get: function() {
              return _api.PDFWorker;
            }
          });
          Object.defineProperty(exports2, "PasswordResponses", {
            enumerable: true,
            get: function() {
              return _util2.PasswordResponses;
            }
          });
          Object.defineProperty(exports2, "PermissionFlag", {
            enumerable: true,
            get: function() {
              return _util2.PermissionFlag;
            }
          });
          Object.defineProperty(exports2, "PixelsPerInch", {
            enumerable: true,
            get: function() {
              return _display_utils2.PixelsPerInch;
            }
          });
          Object.defineProperty(exports2, "PromiseCapability", {
            enumerable: true,
            get: function() {
              return _util2.PromiseCapability;
            }
          });
          Object.defineProperty(exports2, "RenderingCancelledException", {
            enumerable: true,
            get: function() {
              return _display_utils2.RenderingCancelledException;
            }
          });
          Object.defineProperty(exports2, "SVGGraphics", {
            enumerable: true,
            get: function() {
              return _api.SVGGraphics;
            }
          });
          Object.defineProperty(exports2, "UnexpectedResponseException", {
            enumerable: true,
            get: function() {
              return _util2.UnexpectedResponseException;
            }
          });
          Object.defineProperty(exports2, "Util", {
            enumerable: true,
            get: function() {
              return _util2.Util;
            }
          });
          Object.defineProperty(exports2, "VerbosityLevel", {
            enumerable: true,
            get: function() {
              return _util2.VerbosityLevel;
            }
          });
          Object.defineProperty(exports2, "XfaLayer", {
            enumerable: true,
            get: function() {
              return _xfa_layer.XfaLayer;
            }
          });
          Object.defineProperty(exports2, "build", {
            enumerable: true,
            get: function() {
              return _api.build;
            }
          });
          Object.defineProperty(exports2, "createValidAbsoluteUrl", {
            enumerable: true,
            get: function() {
              return _util2.createValidAbsoluteUrl;
            }
          });
          Object.defineProperty(exports2, "getDocument", {
            enumerable: true,
            get: function() {
              return _api.getDocument;
            }
          });
          Object.defineProperty(exports2, "getFilenameFromUrl", {
            enumerable: true,
            get: function() {
              return _display_utils2.getFilenameFromUrl;
            }
          });
          Object.defineProperty(exports2, "getPdfFilenameFromUrl", {
            enumerable: true,
            get: function() {
              return _display_utils2.getPdfFilenameFromUrl;
            }
          });
          Object.defineProperty(exports2, "getXfaPageViewport", {
            enumerable: true,
            get: function() {
              return _display_utils2.getXfaPageViewport;
            }
          });
          Object.defineProperty(exports2, "isDataScheme", {
            enumerable: true,
            get: function() {
              return _display_utils2.isDataScheme;
            }
          });
          Object.defineProperty(exports2, "isPdfFile", {
            enumerable: true,
            get: function() {
              return _display_utils2.isPdfFile;
            }
          });
          Object.defineProperty(exports2, "loadScript", {
            enumerable: true,
            get: function() {
              return _display_utils2.loadScript;
            }
          });
          Object.defineProperty(exports2, "noContextMenu", {
            enumerable: true,
            get: function() {
              return _display_utils2.noContextMenu;
            }
          });
          Object.defineProperty(exports2, "normalizeUnicode", {
            enumerable: true,
            get: function() {
              return _util2.normalizeUnicode;
            }
          });
          Object.defineProperty(exports2, "renderTextLayer", {
            enumerable: true,
            get: function() {
              return _text_layer.renderTextLayer;
            }
          });
          Object.defineProperty(exports2, "setLayerDimensions", {
            enumerable: true,
            get: function() {
              return _display_utils2.setLayerDimensions;
            }
          });
          Object.defineProperty(exports2, "shadow", {
            enumerable: true,
            get: function() {
              return _util2.shadow;
            }
          });
          Object.defineProperty(exports2, "updateTextLayer", {
            enumerable: true,
            get: function() {
              return _text_layer.updateTextLayer;
            }
          });
          Object.defineProperty(exports2, "version", {
            enumerable: true,
            get: function() {
              return _api.version;
            }
          });
          var _util2 = __w_pdfjs_require__(1);
          var _api = __w_pdfjs_require__(2);
          var _display_utils2 = __w_pdfjs_require__(6);
          var _text_layer = __w_pdfjs_require__(26);
          var _annotation_editor_layer = __w_pdfjs_require__(27);
          var _tools = __w_pdfjs_require__(5);
          var _annotation_layer = __w_pdfjs_require__(29);
          var _worker_options2 = __w_pdfjs_require__(14);
          var _xfa_layer = __w_pdfjs_require__(32);
        })();
        return __webpack_exports__;
      })()
    );
  });
})(pdf);
var pdfExports = pdf.exports;
const pdfjsWorker = "/assets/pdf.worker-e3f005b2.js";
pdfExports.GlobalWorkerOptions.workerSrc = pdfjsWorker;
function Statements() {
  const { query } = useDatabase();
  const { user } = useAuth();
  const [statements, setStatements] = reactExports.useState([]);
  const [companies, setCompanies] = reactExports.useState([]);
  const [loading, setLoading] = reactExports.useState(true);
  const [processing, setProcessing] = reactExports.useState(false);
  const [searchTerm, setSearchTerm] = reactExports.useState("");
  const [showUploadModal, setShowUploadModal] = reactExports.useState(false);
  const [uploadMethod, setUploadMethod] = reactExports.useState("file");
  const [formData, setFormData] = reactExports.useState({
    company_id: "",
    statement_type: "income_statement",
    year: (/* @__PURE__ */ new Date()).getFullYear(),
    quarter: "",
    file: null,
    url: ""
  });
  reactExports.useEffect(() => {
    loadStatements();
    loadCompanies();
  }, []);
  const loadStatements = /* @__PURE__ */ __name(async () => {
    try {
      const result = await query(`
        SELECT 
          fs.*,
          c.name as company_name,
          COUNT(i.id) as inconsistency_count,
          COUNT(fm.id) as metrics_count
        FROM financial_statements fs
        JOIN companies c ON fs.company_id = c.id
        LEFT JOIN inconsistencies i ON fs.id = i.statement_id
        LEFT JOIN financial_metrics fm ON fs.id = fm.statement_id
        GROUP BY fs.id, c.name
        ORDER BY fs.processed_at DESC NULLS LAST, fs.year DESC, fs.quarter DESC
      `);
      setStatements(result.data || []);
    } catch (error) {
      console.error("Error loading statements:", error);
    } finally {
      setLoading(false);
    }
  }, "loadStatements");
  const loadCompanies = /* @__PURE__ */ __name(async () => {
    try {
      const result = await query("SELECT id, name FROM companies ORDER BY name");
      setCompanies(result.data || []);
    } catch (error) {
      console.error("Error loading companies:", error);
    }
  }, "loadCompanies");
  const extractTextFromPDF = /* @__PURE__ */ __name(async (file) => {
    try {
      const arrayBuffer = await file.arrayBuffer();
      const pdf2 = await pdfExports.getDocument({ data: arrayBuffer }).promise;
      let fullText = "";
      for (let i2 = 1; i2 <= pdf2.numPages; i2++) {
        const page = await pdf2.getPage(i2);
        const textContent = await page.getTextContent();
        const pageText = textContent.items.map((item) => item.str).join(" ");
        fullText += pageText + "\n";
      }
      return fullText;
    } catch (error) {
      console.error("Error extracting PDF text:", error);
      throw new Error("Failed to extract text from PDF");
    }
  }, "extractTextFromPDF");
  const extractFinancialData = /* @__PURE__ */ __name(async (text) => {
    try {
      const response = await fetch("https://builder.empromptu.ai/api_tools/apply_prompt_to_data", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          "Authorization": "Bearer 4b82f096e899fe27871d083ae66ddd01",
          "X-Generated-App-ID": "ae40c6ff-a693-48ae-ae9d-f44b3831f48e",
          "X-Usage-Key": "2b0185b0bd6d7d7ebe2369814e91bb81"
        },
        body: JSON.stringify({
          prompt_name: "extract_financial_data",
          input_data: {
            pdf_text: text
          },
          return_type: "structured"
        })
      });
      const result = await response.json();
      return result.value;
    } catch (error) {
      console.error("Error extracting financial data:", error);
      throw new Error("Failed to extract financial data");
    }
  }, "extractFinancialData");
  const detectInconsistencies = /* @__PURE__ */ __name(async (financialData) => {
    try {
      const response = await fetch("https://builder.empromptu.ai/api_tools/apply_prompt_to_data", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          "Authorization": "Bearer 4b82f096e899fe27871d083ae66ddd01",
          "X-Generated-App-ID": "ae40c6ff-a693-48ae-ae9d-f44b3831f48e",
          "X-Usage-Key": "2b0185b0bd6d7d7ebe2369814e91bb81"
        },
        body: JSON.stringify({
          prompt_name: "detect_inconsistencies",
          input_data: {
            financial_data: JSON.stringify(financialData)
          },
          return_type: "structured"
        })
      });
      const result = await response.json();
      return result.value;
    } catch (error) {
      console.error("Error detecting inconsistencies:", error);
      return [];
    }
  }, "detectInconsistencies");
  const uploadToArchive = /* @__PURE__ */ __name(async (file) => {
    var _a3;
    try {
      const formData2 = new FormData();
      formData2.append("file", file);
      const response = await fetch("https://builder.empromptu.ai/api_tools/archives/4cacbd0f-3edf-4b45-b788-f1f6907579e1", {
        method: "POST",
        headers: {
          "Authorization": "Bearer 4b82f096e899fe27871d083ae66ddd01",
          "X-Generated-App-ID": "ae40c6ff-a693-48ae-ae9d-f44b3831f48e",
          "X-Usage-Key": "2b0185b0bd6d7d7ebe2369814e91bb81"
        },
        body: formData2
      });
      const result = await response.json();
      return ((_a3 = result[0]) == null ? void 0 : _a3.status) === "success" ? file.name : null;
    } catch (error) {
      console.error("Error uploading to archive:", error);
      return null;
    }
  }, "uploadToArchive");
  const handleSubmit = /* @__PURE__ */ __name(async (e) => {
    e.preventDefault();
    setProcessing(true);
    try {
      let pdfText = "";
      let filePath = null;
      if (uploadMethod === "file" && formData.file) {
        filePath = await uploadToArchive(formData.file);
        if (!filePath) {
          throw new Error("Failed to upload file to archive");
        }
        pdfText = await extractTextFromPDF(formData.file);
      } else if (uploadMethod === "url" && formData.url) {
        const response = await fetch("https://builder.empromptu.ai/api_tools/get_data_from_url", {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            "Authorization": "Bearer 4b82f096e899fe27871d083ae66ddd01",
            "X-Generated-App-ID": "ae40c6ff-a693-48ae-ae9d-f44b3831f48e",
            "X-Usage-Key": "2b0185b0bd6d7d7ebe2369814e91bb81"
          },
          body: JSON.stringify({
            input_data: formData.url
          })
        });
        const urlResult = await response.json();
        pdfText = urlResult.text;
        filePath = formData.url;
      }
      const statementResult = await query(`
        INSERT INTO financial_statements 
        (company_id, statement_type, period, year, quarter, file_path, uploaded_by, processed_at)
        VALUES ($1, $2, $3, $4, $5, $6, $7, NOW())
        RETURNING id
      `, [
        formData.company_id,
        formData.statement_type,
        formData.quarter ? `Q${formData.quarter}` : "Annual",
        formData.year,
        formData.quarter || null,
        filePath,
        user == null ? void 0 : user.id
      ]);
      const statementId = statementResult.data[0].id;
      const financialData = await extractFinancialData(pdfText);
      if (financialData && Array.isArray(financialData)) {
        for (const metric of financialData) {
          if (metric.metric_name && metric.metric_value !== void 0) {
            await query(`
              INSERT INTO financial_metrics (statement_id, metric_name, metric_value, metric_category)
              VALUES ($1, $2, $3, $4)
            `, [
              statementId,
              metric.metric_name,
              parseFloat(metric.metric_value) || 0,
              metric.metric_category || "general"
            ]);
          }
        }
      }
      const inconsistencies = await detectInconsistencies(financialData);
      if (inconsistencies && Array.isArray(inconsistencies)) {
        for (const inconsistency of inconsistencies) {
          if (inconsistency.inconsistency_type && inconsistency.description) {
            await query(`
              INSERT INTO inconsistencies (statement_id, inconsistency_type, description, severity)
              VALUES ($1, $2, $3, $4)
            `, [
              statementId,
              inconsistency.inconsistency_type,
              inconsistency.description,
              inconsistency.severity || "medium"
            ]);
          }
        }
      }
      setFormData({
        company_id: "",
        statement_type: "income_statement",
        year: (/* @__PURE__ */ new Date()).getFullYear(),
        quarter: "",
        file: null,
        url: ""
      });
      setShowUploadModal(false);
      loadStatements();
    } catch (error) {
      console.error("Error processing statement:", error);
      alert("Error processing financial statement: " + error.message);
    } finally {
      setProcessing(false);
    }
  }, "handleSubmit");
  const getStatusIcon = /* @__PURE__ */ __name((statement) => {
    if (!statement.processed_at) {
      return /* @__PURE__ */ jsxRuntimeExports.jsx(Clock, { className: "h-5 w-5 text-yellow-500" });
    }
    if (statement.inconsistency_count > 0) {
      return /* @__PURE__ */ jsxRuntimeExports.jsx(AlertTriangle, { className: "h-5 w-5 text-red-500" });
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsx(CheckCircle, { className: "h-5 w-5 text-green-500" });
  }, "getStatusIcon");
  const getStatusText = /* @__PURE__ */ __name((statement) => {
    if (!statement.processed_at)
      return "Processing";
    if (statement.inconsistency_count > 0)
      return `${statement.inconsistency_count} Issues`;
    return "Processed";
  }, "getStatusText");
  const filteredStatements = statements.filter(
    (statement) => statement.company_name.toLowerCase().includes(searchTerm.toLowerCase()) || statement.statement_type.toLowerCase().includes(searchTerm.toLowerCase())
  );
  if (loading) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex items-center justify-center h-64", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "animate-spin rounded-full h-32 w-32 border-b-2 border-primary-600" }) });
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-6", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex justify-between items-center", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h1", { className: "text-3xl font-bold text-gray-900 dark:text-white", children: "Financial Statements" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "mt-2 text-gray-600 dark:text-gray-400", children: "Upload and analyze financial statements" })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(
        "button",
        {
          onClick: () => setShowUploadModal(true),
          className: "btn-primary flex items-center space-x-2",
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(Upload, { className: "h-4 w-4" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "Upload Statement" })
          ]
        }
      )
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "relative", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Search, { className: "absolute left-3 top-1/2 transform -translate-y-1/2 h-4 w-4 text-gray-400" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "input",
        {
          type: "text",
          placeholder: "Search statements...",
          value: searchTerm,
          onChange: (e) => setSearchTerm(e.target.value),
          className: "input-field pl-10"
        }
      )
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "card overflow-hidden", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "overflow-x-auto", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("table", { className: "min-w-full divide-y divide-gray-200 dark:divide-gray-700", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("thead", { className: "bg-gray-50 dark:bg-gray-800", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("tr", { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("th", { className: "px-6 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wider", children: "Company" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("th", { className: "px-6 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wider", children: "Type" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("th", { className: "px-6 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wider", children: "Period" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("th", { className: "px-6 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wider", children: "Status" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("th", { className: "px-6 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wider", children: "Metrics" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("th", { className: "px-6 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wider", children: "Processed" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("th", { className: "px-6 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wider", children: "Actions" })
      ] }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("tbody", { className: "bg-white dark:bg-gray-900 divide-y divide-gray-200 dark:divide-gray-700", children: filteredStatements.map((statement) => /* @__PURE__ */ jsxRuntimeExports.jsxs("tr", { className: "hover:bg-gray-50 dark:hover:bg-gray-800", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("td", { className: "px-6 py-4 whitespace-nowrap", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(FileText, { className: "h-5 w-5 text-gray-400 mr-3" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-sm font-medium text-gray-900 dark:text-white", children: statement.company_name }) })
        ] }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("td", { className: "px-6 py-4 whitespace-nowrap text-sm text-gray-900 dark:text-white", children: statement.statement_type.replace("_", " ").replace(/\b\w/g, (l2) => l2.toUpperCase()) }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("td", { className: "px-6 py-4 whitespace-nowrap text-sm text-gray-900 dark:text-white", children: [
          statement.quarter ? `Q${statement.quarter} ` : "",
          statement.year
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("td", { className: "px-6 py-4 whitespace-nowrap", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center space-x-2", children: [
          getStatusIcon(statement),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-sm text-gray-900 dark:text-white", children: getStatusText(statement) })
        ] }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("td", { className: "px-6 py-4 whitespace-nowrap text-sm text-gray-900 dark:text-white", children: [
          statement.metrics_count,
          " metrics"
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("td", { className: "px-6 py-4 whitespace-nowrap text-sm text-gray-500 dark:text-gray-400", children: statement.processed_at ? new Date(statement.processed_at).toLocaleDateString() : "-" }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("td", { className: "px-6 py-4 whitespace-nowrap text-sm font-medium", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "text-primary-600 hover:text-primary-900 mr-3", children: "View" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "text-gray-400 hover:text-gray-600", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Download, { className: "h-4 w-4" }) })
        ] })
      ] }, statement.id)) })
    ] }) }) }),
    filteredStatements.length === 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "text-center py-12", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(FileText, { className: "mx-auto h-12 w-12 text-gray-400" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "mt-2 text-sm font-medium text-gray-900 dark:text-white", children: "No statements" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "mt-1 text-sm text-gray-500 dark:text-gray-400", children: "Get started by uploading a financial statement." })
    ] }),
    showUploadModal && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center p-4 z-50", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-white dark:bg-gray-800 rounded-lg p-6 w-full max-w-md", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: "text-lg font-semibold text-gray-900 dark:text-white mb-4", children: "Upload Financial Statement" }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex space-x-1 mb-4 bg-gray-100 dark:bg-gray-700 rounded-lg p-1", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs(
          "button",
          {
            onClick: () => setUploadMethod("file"),
            className: `flex-1 py-2 px-3 rounded-md text-sm font-medium transition-colors ${uploadMethod === "file" ? "bg-white dark:bg-gray-800 text-gray-900 dark:text-white shadow-sm" : "text-gray-600 dark:text-gray-400"}`,
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(Upload, { className: "h-4 w-4 inline mr-1" }),
              "File Upload"
            ]
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(
          "button",
          {
            onClick: () => setUploadMethod("url"),
            className: `flex-1 py-2 px-3 rounded-md text-sm font-medium transition-colors ${uploadMethod === "url" ? "bg-white dark:bg-gray-800 text-gray-900 dark:text-white shadow-sm" : "text-gray-600 dark:text-gray-400"}`,
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(Link, { className: "h-4 w-4 inline mr-1" }),
              "URL"
            ]
          }
        )
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("form", { onSubmit: handleSubmit, className: "space-y-4", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1", children: "Company" }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(
            "select",
            {
              required: true,
              value: formData.company_id,
              onChange: (e) => setFormData({ ...formData, company_id: e.target.value }),
              className: "input-field",
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "", children: "Select a company" }),
                companies.map((company) => /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: company.id, children: company.name }, company.id))
              ]
            }
          )
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1", children: "Statement Type" }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(
            "select",
            {
              value: formData.statement_type,
              onChange: (e) => setFormData({ ...formData, statement_type: e.target.value }),
              className: "input-field",
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "income_statement", children: "Income Statement" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "balance_sheet", children: "Balance Sheet" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "cash_flow", children: "Cash Flow Statement" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "annual_report", children: "Annual Report" })
              ]
            }
          )
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-2 gap-4", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1", children: "Year" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "input",
              {
                type: "number",
                required: true,
                min: "2000",
                max: "2030",
                value: formData.year,
                onChange: (e) => setFormData({ ...formData, year: parseInt(e.target.value) }),
                className: "input-field"
              }
            )
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1", children: "Quarter (Optional)" }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs(
              "select",
              {
                value: formData.quarter,
                onChange: (e) => setFormData({ ...formData, quarter: e.target.value }),
                className: "input-field",
                children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "", children: "Annual" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "1", children: "Q1" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "2", children: "Q2" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "3", children: "Q3" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "4", children: "Q4" })
                ]
              }
            )
          ] })
        ] }),
        uploadMethod === "file" ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1", children: "PDF File" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "input",
            {
              type: "file",
              accept: ".pdf",
              required: true,
              onChange: (e) => setFormData({ ...formData, file: e.target.files[0] }),
              className: "input-field"
            }
          )
        ] }) : /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1", children: "PDF URL" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "input",
            {
              type: "url",
              required: true,
              value: formData.url,
              onChange: (e) => setFormData({ ...formData, url: e.target.value }),
              className: "input-field",
              placeholder: "https://example.com/statement.pdf"
            }
          )
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex space-x-3 pt-4", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "button",
            {
              type: "button",
              onClick: () => {
                setShowUploadModal(false);
                setFormData({
                  company_id: "",
                  statement_type: "income_statement",
                  year: (/* @__PURE__ */ new Date()).getFullYear(),
                  quarter: "",
                  file: null,
                  url: ""
                });
              },
              className: "btn-secondary flex-1",
              disabled: processing,
              children: "Cancel"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "button",
            {
              type: "submit",
              className: "btn-primary flex-1 disabled:opacity-50",
              disabled: processing,
              children: processing ? "Processing..." : "Upload & Analyze"
            }
          )
        ] })
      ] })
    ] }) })
  ] });
}
__name(Statements, "Statements");
function Analytics() {
  const { query } = useDatabase();
  const [analyticsData, setAnalyticsData] = reactExports.useState({
    revenueComparison: null,
    profitabilityTrends: null,
    inconsistencyAnalysis: null,
    financialRatios: null
  });
  const [selectedCompanies, setSelectedCompanies] = reactExports.useState([]);
  const [companies, setCompanies] = reactExports.useState([]);
  const [loading, setLoading] = reactExports.useState(true);
  reactExports.useEffect(() => {
    loadCompanies();
  }, []);
  reactExports.useEffect(() => {
    if (selectedCompanies.length > 0) {
      loadAnalyticsData();
    }
  }, [selectedCompanies]);
  const loadCompanies = /* @__PURE__ */ __name(async () => {
    try {
      const result = await query(`
        SELECT c.id, c.name, COUNT(fs.id) as statement_count
        FROM companies c
        LEFT JOIN financial_statements fs ON c.id = fs.company_id
        GROUP BY c.id, c.name
        HAVING COUNT(fs.id) > 0
        ORDER BY c.name
      `);
      const companiesList = result.data || [];
      setCompanies(companiesList);
      if (companiesList.length > 0) {
        setSelectedCompanies(companiesList.slice(0, Math.min(3, companiesList.length)).map((c2) => c2.id));
      }
    } catch (error) {
      console.error("Error loading companies:", error);
    } finally {
      setLoading(false);
    }
  }, "loadCompanies");
  const loadAnalyticsData = /* @__PURE__ */ __name(async () => {
    try {
      const revenueResult = await query(`
        SELECT 
          c.name as company,
          fm.metric_value as revenue,
          fs.year,
          fs.quarter
        FROM financial_metrics fm
        JOIN financial_statements fs ON fm.statement_id = fs.id
        JOIN companies c ON fs.company_id = c.id
        WHERE fm.metric_name = 'total_revenue' 
        AND c.id = ANY($1)
        ORDER BY fs.year, fs.quarter NULLS LAST
      `, [selectedCompanies]);
      const profitResult = await query(`
        SELECT 
          c.name as company,
          fm.metric_value as profit,
          fs.year,
          fs.quarter,
          fm.metric_name
        FROM financial_metrics fm
        JOIN financial_statements fs ON fm.statement_id = fs.id
        JOIN companies c ON fs.company_id = c.id
        WHERE fm.metric_name IN ('net_income', 'gross_profit', 'operating_profit')
        AND c.id = ANY($1)
        ORDER BY fs.year, fs.quarter NULLS LAST
      `, [selectedCompanies]);
      const inconsistencyResult = await query(`
        SELECT 
          c.name as company,
          i.severity,
          COUNT(*) as count
        FROM inconsistencies i
        JOIN financial_statements fs ON i.statement_id = fs.id
        JOIN companies c ON fs.company_id = c.id
        WHERE c.id = ANY($1)
        GROUP BY c.name, i.severity
        ORDER BY c.name, i.severity
      `, [selectedCompanies]);
      const ratiosResult = await query(`
        SELECT 
          c.name as company,
          fm.metric_name,
          fm.metric_value,
          fs.year
        FROM financial_metrics fm
        JOIN financial_statements fs ON fm.statement_id = fs.id
        JOIN companies c ON fs.company_id = c.id
        WHERE fm.metric_name IN ('current_ratio', 'debt_to_equity', 'return_on_equity', 'return_on_assets')
        AND c.id = ANY($1)
        ORDER BY c.name, fs.year DESC
      `, [selectedCompanies]);
      setAnalyticsData({
        revenueComparison: processRevenueData(revenueResult.data || []),
        profitabilityTrends: processProfitabilityData(profitResult.data || []),
        inconsistencyAnalysis: processInconsistencyData(inconsistencyResult.data || []),
        financialRatios: processRatiosData(ratiosResult.data || [])
      });
    } catch (error) {
      console.error("Error loading analytics data:", error);
    }
  }, "loadAnalyticsData");
  const processRevenueData = /* @__PURE__ */ __name((data) => {
    const companies2 = [...new Set(data.map((d2) => d2.company))];
    const periods = [...new Set(data.map((d2) => `${d2.year}${d2.quarter ? `-Q${d2.quarter}` : ""}`))].sort();
    return {
      labels: periods,
      datasets: companies2.map((company, index2) => ({
        label: company,
        data: periods.map((period) => {
          const [year, quarter] = period.split("-Q");
          const item = data.find(
            (d2) => {
              var _a3;
              return d2.company === company && d2.year.toString() === year && (quarter ? ((_a3 = d2.quarter) == null ? void 0 : _a3.toString()) === quarter : !d2.quarter);
            }
          );
          return item ? parseFloat(item.revenue) / 1e6 : null;
        }),
        borderColor: `hsl(${index2 * 137.5 % 360}, 70%, 50%)`,
        backgroundColor: `hsla(${index2 * 137.5 % 360}, 70%, 50%, 0.1)`,
        tension: 0.1
      }))
    };
  }, "processRevenueData");
  const processProfitabilityData = /* @__PURE__ */ __name((data) => {
    const companies2 = [...new Set(data.map((d2) => d2.company))];
    const metrics = ["net_income", "gross_profit", "operating_profit"];
    return {
      labels: companies2,
      datasets: metrics.map((metric, index2) => ({
        label: metric.replace("_", " ").replace(/\b\w/g, (l2) => l2.toUpperCase()),
        data: companies2.map((company) => {
          const items = data.filter((d2) => d2.company === company && d2.metric_name === metric);
          const latest = items.sort((a2, b2) => b2.year - a2.year)[0];
          return latest ? parseFloat(latest.profit) / 1e6 : 0;
        }),
        backgroundColor: `hsla(${index2 * 120}, 70%, 50%, 0.8)`
      }))
    };
  }, "processProfitabilityData");
  const processInconsistencyData = /* @__PURE__ */ __name((data) => {
    const companies2 = [...new Set(data.map((d2) => d2.company))];
    const severities = ["low", "medium", "high"];
    return {
      labels: companies2,
      datasets: severities.map((severity, index2) => ({
        label: severity.charAt(0).toUpperCase() + severity.slice(1),
        data: companies2.map((company) => {
          const item = data.find((d2) => d2.company === company && d2.severity === severity);
          return item ? parseInt(item.count) : 0;
        }),
        backgroundColor: severity === "high" ? "rgba(239, 68, 68, 0.8)" : severity === "medium" ? "rgba(245, 158, 11, 0.8)" : "rgba(34, 197, 94, 0.8)"
      }))
    };
  }, "processInconsistencyData");
  const processRatiosData = /* @__PURE__ */ __name((data) => {
    const companies2 = [...new Set(data.map((d2) => d2.company))];
    const ratios = ["current_ratio", "debt_to_equity", "return_on_equity", "return_on_assets"];
    return {
      labels: ratios.map((r) => r.replace("_", " ").replace(/\b\w/g, (l2) => l2.toUpperCase())),
      datasets: companies2.map((company, index2) => ({
        label: company,
        data: ratios.map((ratio) => {
          const items = data.filter((d2) => d2.company === company && d2.metric_name === ratio);
          const latest = items.sort((a2, b2) => b2.year - a2.year)[0];
          return latest ? parseFloat(latest.metric_value) : 0;
        }),
        borderColor: `hsl(${index2 * 137.5 % 360}, 70%, 50%)`,
        backgroundColor: `hsla(${index2 * 137.5 % 360}, 70%, 50%, 0.2)`,
        pointBackgroundColor: `hsl(${index2 * 137.5 % 360}, 70%, 50%)`
      }))
    };
  }, "processRatiosData");
  if (loading) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex items-center justify-center h-64", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "animate-spin rounded-full h-32 w-32 border-b-2 border-primary-600" }) });
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-6", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h1", { className: "text-3xl font-bold text-gray-900 dark:text-white", children: "Analytics" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "mt-2 text-gray-600 dark:text-gray-400", children: "Compare financial performance across companies" })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "card p-6", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "text-lg font-semibold text-gray-900 dark:text-white mb-4", children: "Select Companies to Compare" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "grid grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-3", children: companies.map((company) => /* @__PURE__ */ jsxRuntimeExports.jsxs("label", { className: "flex items-center space-x-2 cursor-pointer", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "input",
          {
            type: "checkbox",
            checked: selectedCompanies.includes(company.id),
            onChange: (e) => {
              if (e.target.checked) {
                setSelectedCompanies([...selectedCompanies, company.id]);
              } else {
                setSelectedCompanies(selectedCompanies.filter((id) => id !== company.id));
              }
            },
            className: "rounded border-gray-300 text-primary-600 focus:ring-primary-500"
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-sm text-gray-900 dark:text-white", children: company.name })
      ] }, company.id)) })
    ] }),
    selectedCompanies.length === 0 ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "text-center py-12", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(BarChart3, { className: "mx-auto h-12 w-12 text-gray-400" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "mt-2 text-sm font-medium text-gray-900 dark:text-white", children: "No companies selected" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "mt-1 text-sm text-gray-500 dark:text-gray-400", children: "Select companies above to view analytics." })
    ] }) : /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-1 lg:grid-cols-2 gap-6", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "card p-6", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center space-x-2 mb-4", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(DollarSign, { className: "h-5 w-5 text-green-600" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "text-lg font-semibold text-gray-900 dark:text-white", children: "Revenue Trends" })
        ] }),
        analyticsData.revenueComparison ? /* @__PURE__ */ jsxRuntimeExports.jsx(
          Line,
          {
            data: analyticsData.revenueComparison,
            options: {
              responsive: true,
              plugins: {
                legend: {
                  position: "top"
                }
              },
              scales: {
                y: {
                  beginAtZero: true,
                  title: {
                    display: true,
                    text: "Revenue (Millions USD)"
                  }
                }
              }
            }
          }
        ) : /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "h-64 flex items-center justify-center text-gray-500", children: "No revenue data available" })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "card p-6", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center space-x-2 mb-4", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(TrendingUp, { className: "h-5 w-5 text-blue-600" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "text-lg font-semibold text-gray-900 dark:text-white", children: "Profitability Comparison" })
        ] }),
        analyticsData.profitabilityTrends ? /* @__PURE__ */ jsxRuntimeExports.jsx(
          Bar,
          {
            data: analyticsData.profitabilityTrends,
            options: {
              responsive: true,
              plugins: {
                legend: {
                  position: "top"
                }
              },
              scales: {
                y: {
                  beginAtZero: true,
                  title: {
                    display: true,
                    text: "Profit (Millions USD)"
                  }
                }
              }
            }
          }
        ) : /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "h-64 flex items-center justify-center text-gray-500", children: "No profitability data available" })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "card p-6", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center space-x-2 mb-4", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(AlertTriangle, { className: "h-5 w-5 text-red-600" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "text-lg font-semibold text-gray-900 dark:text-white", children: "Data Quality Issues" })
        ] }),
        analyticsData.inconsistencyAnalysis ? /* @__PURE__ */ jsxRuntimeExports.jsx(
          Bar,
          {
            data: analyticsData.inconsistencyAnalysis,
            options: {
              responsive: true,
              plugins: {
                legend: {
                  position: "top"
                }
              },
              scales: {
                y: {
                  beginAtZero: true,
                  title: {
                    display: true,
                    text: "Number of Issues"
                  }
                }
              }
            }
          }
        ) : /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "h-64 flex items-center justify-center text-gray-500", children: "No inconsistency data available" })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "card p-6", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center space-x-2 mb-4", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(BarChart3, { className: "h-5 w-5 text-purple-600" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "text-lg font-semibold text-gray-900 dark:text-white", children: "Financial Ratios" })
        ] }),
        analyticsData.financialRatios ? /* @__PURE__ */ jsxRuntimeExports.jsx(
          Radar,
          {
            data: analyticsData.financialRatios,
            options: {
              responsive: true,
              plugins: {
                legend: {
                  position: "top"
                }
              },
              scales: {
                r: {
                  beginAtZero: true
                }
              }
            }
          }
        ) : /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "h-64 flex items-center justify-center text-gray-500", children: "No financial ratios available" })
      ] })
    ] })
  ] });
}
__name(Analytics, "Analytics");
function UserManagement() {
  const { query } = useDatabase();
  const { user } = useAuth();
  const [users, setUsers] = reactExports.useState([]);
  const [teams, setTeams] = reactExports.useState([]);
  const [loading, setLoading] = reactExports.useState(true);
  const [searchTerm, setSearchTerm] = reactExports.useState("");
  const [showAddModal, setShowAddModal] = reactExports.useState(false);
  const [editingUser, setEditingUser] = reactExports.useState(null);
  const [formData, setFormData] = reactExports.useState({
    email: "",
    password: "",
    role: "user",
    team_id: ""
  });
  reactExports.useEffect(() => {
    loadUsers();
    loadTeams();
  }, []);
  const loadUsers = /* @__PURE__ */ __name(async () => {
    try {
      const result = await query(`
        SELECT u.*, t.name as team_name
        FROM users u
        LEFT JOIN teams t ON u.team_id = t.id
        ORDER BY u.created_at DESC
      `);
      setUsers(result.data || []);
    } catch (error) {
      console.error("Error loading users:", error);
    } finally {
      setLoading(false);
    }
  }, "loadUsers");
  const loadTeams = /* @__PURE__ */ __name(async () => {
    try {
      const result = await query("SELECT * FROM teams ORDER BY name");
      setTeams(result.data || []);
    } catch (error) {
      console.error("Error loading teams:", error);
    }
  }, "loadTeams");
  const handleSubmit = /* @__PURE__ */ __name(async (e) => {
    e.preventDefault();
    try {
      if (editingUser) {
        const updateFields = ["role", "team_id"];
        const updateValues = [formData.role, formData.team_id || null];
        let updateQuery = "UPDATE users SET role = $1, team_id = $2";
        if (formData.password) {
          updateQuery += ", password_hash = $3 WHERE id = $4";
          updateValues.push(formData.password, editingUser.id);
        } else {
          updateQuery += " WHERE id = $3";
          updateValues.push(editingUser.id);
        }
        await query(updateQuery, updateValues);
      } else {
        await query(`
          INSERT INTO users (email, password_hash, role, team_id)
          VALUES ($1, $2, $3, $4)
        `, [formData.email, formData.password, formData.role, formData.team_id || null]);
      }
      setFormData({ email: "", password: "", role: "user", team_id: "" });
      setShowAddModal(false);
      setEditingUser(null);
      loadUsers();
    } catch (error) {
      console.error("Error saving user:", error);
      alert("Error saving user: " + error.message);
    }
  }, "handleSubmit");
  const handleEdit = /* @__PURE__ */ __name((userToEdit) => {
    setEditingUser(userToEdit);
    setFormData({
      email: userToEdit.email,
      password: "",
      role: userToEdit.role,
      team_id: userToEdit.team_id || ""
    });
    setShowAddModal(true);
  }, "handleEdit");
  const handleDelete = /* @__PURE__ */ __name(async (userId) => {
    if (userId === (user == null ? void 0 : user.id)) {
      alert("You cannot delete your own account");
      return;
    }
    if (window.confirm("Are you sure you want to delete this user?")) {
      try {
        await query("DELETE FROM users WHERE id = $1", [userId]);
        loadUsers();
      } catch (error) {
        console.error("Error deleting user:", error);
        alert("Error deleting user: " + error.message);
      }
    }
  }, "handleDelete");
  const getRoleIcon = /* @__PURE__ */ __name((role) => {
    switch (role) {
      case "admin":
        return /* @__PURE__ */ jsxRuntimeExports.jsx(Shield, { className: "h-4 w-4 text-red-500" });
      case "manager":
        return /* @__PURE__ */ jsxRuntimeExports.jsx(Shield, { className: "h-4 w-4 text-yellow-500" });
      default:
        return /* @__PURE__ */ jsxRuntimeExports.jsx(Users, { className: "h-4 w-4 text-gray-500" });
    }
  }, "getRoleIcon");
  const getRoleBadge = /* @__PURE__ */ __name((role) => {
    const colors2 = {
      admin: "bg-red-100 text-red-800 dark:bg-red-900/20 dark:text-red-400",
      manager: "bg-yellow-100 text-yellow-800 dark:bg-yellow-900/20 dark:text-yellow-400",
      user: "bg-gray-100 text-gray-800 dark:bg-gray-700 dark:text-gray-300"
    };
    return /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: `inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium ${colors2[role]}`, children: role.charAt(0).toUpperCase() + role.slice(1) });
  }, "getRoleBadge");
  const filteredUsers = users.filter(
    (u2) => u2.email.toLowerCase().includes(searchTerm.toLowerCase()) || u2.role.toLowerCase().includes(searchTerm.toLowerCase()) || u2.team_name && u2.team_name.toLowerCase().includes(searchTerm.toLowerCase())
  );
  if (loading) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex items-center justify-center h-64", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "animate-spin rounded-full h-32 w-32 border-b-2 border-primary-600" }) });
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-6", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex justify-between items-center", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h1", { className: "text-3xl font-bold text-gray-900 dark:text-white", children: "User Management" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "mt-2 text-gray-600 dark:text-gray-400", children: "Manage user accounts and permissions" })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(
        "button",
        {
          onClick: () => {
            setEditingUser(null);
            setFormData({ email: "", password: "", role: "user", team_id: "" });
            setShowAddModal(true);
          },
          className: "btn-primary flex items-center space-x-2",
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(Plus, { className: "h-4 w-4" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "Add User" })
          ]
        }
      )
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "relative", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Search, { className: "absolute left-3 top-1/2 transform -translate-y-1/2 h-4 w-4 text-gray-400" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "input",
        {
          type: "text",
          placeholder: "Search users...",
          value: searchTerm,
          onChange: (e) => setSearchTerm(e.target.value),
          className: "input-field pl-10"
        }
      )
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "card overflow-hidden", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "overflow-x-auto", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("table", { className: "min-w-full divide-y divide-gray-200 dark:divide-gray-700", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("thead", { className: "bg-gray-50 dark:bg-gray-800", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("tr", { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("th", { className: "px-6 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wider", children: "User" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("th", { className: "px-6 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wider", children: "Role" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("th", { className: "px-6 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wider", children: "Team" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("th", { className: "px-6 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wider", children: "Created" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("th", { className: "px-6 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wider", children: "Last Login" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("th", { className: "px-6 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wider", children: "Actions" })
      ] }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("tbody", { className: "bg-white dark:bg-gray-900 divide-y divide-gray-200 dark:divide-gray-700", children: filteredUsers.map((u2) => /* @__PURE__ */ jsxRuntimeExports.jsxs("tr", { className: "hover:bg-gray-50 dark:hover:bg-gray-800", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("td", { className: "px-6 py-4 whitespace-nowrap", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex-shrink-0 h-10 w-10", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "h-10 w-10 rounded-full bg-primary-100 dark:bg-primary-900/20 flex items-center justify-center", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Users, { className: "h-5 w-5 text-primary-600" }) }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "ml-4", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-sm font-medium text-gray-900 dark:text-white", children: u2.email }),
            u2.id === (user == null ? void 0 : user.id) && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-xs text-primary-600", children: "You" })
          ] })
        ] }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("td", { className: "px-6 py-4 whitespace-nowrap", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center space-x-2", children: [
          getRoleIcon(u2.role),
          getRoleBadge(u2.role)
        ] }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("td", { className: "px-6 py-4 whitespace-nowrap text-sm text-gray-900 dark:text-white", children: u2.team_name || "No team" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("td", { className: "px-6 py-4 whitespace-nowrap text-sm text-gray-500 dark:text-gray-400", children: new Date(u2.created_at).toLocaleDateString() }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("td", { className: "px-6 py-4 whitespace-nowrap text-sm text-gray-500 dark:text-gray-400", children: u2.last_login ? new Date(u2.last_login).toLocaleDateString() : "Never" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("td", { className: "px-6 py-4 whitespace-nowrap text-sm font-medium", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex space-x-2", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "button",
            {
              onClick: () => handleEdit(u2),
              className: "text-primary-600 hover:text-primary-900",
              children: /* @__PURE__ */ jsxRuntimeExports.jsx(PenSquare, { className: "h-4 w-4" })
            }
          ),
          u2.id !== (user == null ? void 0 : user.id) && /* @__PURE__ */ jsxRuntimeExports.jsx(
            "button",
            {
              onClick: () => handleDelete(u2.id),
              className: "text-red-600 hover:text-red-900",
              children: /* @__PURE__ */ jsxRuntimeExports.jsx(Trash2, { className: "h-4 w-4" })
            }
          )
        ] }) })
      ] }, u2.id)) })
    ] }) }) }),
    filteredUsers.length === 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "text-center py-12", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Users, { className: "mx-auto h-12 w-12 text-gray-400" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "mt-2 text-sm font-medium text-gray-900 dark:text-white", children: "No users found" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "mt-1 text-sm text-gray-500 dark:text-gray-400", children: "Try adjusting your search criteria." })
    ] }),
    showAddModal && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center p-4 z-50", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-white dark:bg-gray-800 rounded-lg p-6 w-full max-w-md", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: "text-lg font-semibold text-gray-900 dark:text-white mb-4", children: editingUser ? "Edit User" : "Add New User" }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("form", { onSubmit: handleSubmit, className: "space-y-4", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1", children: "Email" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "input",
            {
              type: "email",
              required: !editingUser,
              disabled: !!editingUser,
              value: formData.email,
              onChange: (e) => setFormData({ ...formData, email: e.target.value }),
              className: "input-field disabled:bg-gray-100 dark:disabled:bg-gray-700",
              placeholder: "user@example.com"
            }
          )
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("label", { className: "block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1", children: [
            "Password ",
            editingUser && "(leave blank to keep current)"
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "input",
            {
              type: "password",
              required: !editingUser,
              value: formData.password,
              onChange: (e) => setFormData({ ...formData, password: e.target.value }),
              className: "input-field",
              placeholder: editingUser ? "Leave blank to keep current" : "Enter password"
            }
          )
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1", children: "Role" }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(
            "select",
            {
              value: formData.role,
              onChange: (e) => setFormData({ ...formData, role: e.target.value }),
              className: "input-field",
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "user", children: "User" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "manager", children: "Manager" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "admin", children: "Admin" })
              ]
            }
          )
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1", children: "Team" }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(
            "select",
            {
              value: formData.team_id,
              onChange: (e) => setFormData({ ...formData, team_id: e.target.value }),
              className: "input-field",
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "", children: "No team" }),
                teams.map((team) => /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: team.id, children: team.name }, team.id))
              ]
            }
          )
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex space-x-3 pt-4", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "button",
            {
              type: "button",
              onClick: () => {
                setShowAddModal(false);
                setEditingUser(null);
                setFormData({ email: "", password: "", role: "user", team_id: "" });
              },
              className: "btn-secondary flex-1",
              children: "Cancel"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("button", { type: "submit", className: "btn-primary flex-1", children: [
            editingUser ? "Update" : "Add",
            " User"
          ] })
        ] })
      ] })
    ] }) })
  ] });
}
__name(UserManagement, "UserManagement");
/*! xlsx.js (C) 2013-present SheetJS -- http://sheetjs.com */
var XLSX = {};
XLSX.version = "0.18.5";
var current_ansi = 1252;
var VALID_ANSI = [874, 932, 936, 949, 950, 1250, 1251, 1252, 1253, 1254, 1255, 1256, 1257, 1258, 1e4];
var set_ansi = /* @__PURE__ */ __name(function(cp) {
  if (VALID_ANSI.indexOf(cp) == -1)
    return;
  current_ansi = cp;
}, "set_ansi");
function reset_ansi() {
  set_ansi(1252);
}
__name(reset_ansi, "reset_ansi");
var set_cp = /* @__PURE__ */ __name(function(cp) {
  set_ansi(cp);
}, "set_cp");
function reset_cp() {
  set_cp(1200);
  reset_ansi();
}
__name(reset_cp, "reset_cp");
function utf16beread(data) {
  var o2 = [];
  for (var i2 = 0; i2 < data.length >> 1; ++i2)
    o2[i2] = String.fromCharCode(data.charCodeAt(2 * i2 + 1) + (data.charCodeAt(2 * i2) << 8));
  return o2.join("");
}
__name(utf16beread, "utf16beread");
var _getchar = /* @__PURE__ */ __name(function _gc1(x2) {
  return String.fromCharCode(x2);
}, "_gc1");
var _getansi = /* @__PURE__ */ __name(function _ga1(x2) {
  return String.fromCharCode(x2);
}, "_ga1");
var $cptable;
var Base64_map = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
function Base64_encode(input) {
  var o2 = "";
  var c1 = 0, c2 = 0, c3 = 0, e1 = 0, e2 = 0, e3 = 0, e4 = 0;
  for (var i2 = 0; i2 < input.length; ) {
    c1 = input.charCodeAt(i2++);
    e1 = c1 >> 2;
    c2 = input.charCodeAt(i2++);
    e2 = (c1 & 3) << 4 | c2 >> 4;
    c3 = input.charCodeAt(i2++);
    e3 = (c2 & 15) << 2 | c3 >> 6;
    e4 = c3 & 63;
    if (isNaN(c2)) {
      e3 = e4 = 64;
    } else if (isNaN(c3)) {
      e4 = 64;
    }
    o2 += Base64_map.charAt(e1) + Base64_map.charAt(e2) + Base64_map.charAt(e3) + Base64_map.charAt(e4);
  }
  return o2;
}
__name(Base64_encode, "Base64_encode");
function Base64_decode(input) {
  var o2 = "";
  var c1 = 0, c2 = 0, c3 = 0, e1 = 0, e2 = 0, e3 = 0, e4 = 0;
  input = input.replace(/[^\w\+\/\=]/g, "");
  for (var i2 = 0; i2 < input.length; ) {
    e1 = Base64_map.indexOf(input.charAt(i2++));
    e2 = Base64_map.indexOf(input.charAt(i2++));
    c1 = e1 << 2 | e2 >> 4;
    o2 += String.fromCharCode(c1);
    e3 = Base64_map.indexOf(input.charAt(i2++));
    c2 = (e2 & 15) << 4 | e3 >> 2;
    if (e3 !== 64) {
      o2 += String.fromCharCode(c2);
    }
    e4 = Base64_map.indexOf(input.charAt(i2++));
    c3 = (e3 & 3) << 6 | e4;
    if (e4 !== 64) {
      o2 += String.fromCharCode(c3);
    }
  }
  return o2;
}
__name(Base64_decode, "Base64_decode");
var has_buf = /* @__PURE__ */ function() {
  return typeof Buffer !== "undefined" && typeof process !== "undefined" && typeof process.versions !== "undefined" && !!process.versions.node;
}();
var Buffer_from = /* @__PURE__ */ function() {
  if (typeof Buffer !== "undefined") {
    var nbfs = !Buffer.from;
    if (!nbfs)
      try {
        Buffer.from("foo", "utf8");
      } catch (e) {
        nbfs = true;
      }
    return nbfs ? function(buf, enc) {
      return enc ? new Buffer(buf, enc) : new Buffer(buf);
    } : Buffer.from.bind(Buffer);
  }
  return function() {
  };
}();
function new_raw_buf(len) {
  if (has_buf)
    return Buffer.alloc ? Buffer.alloc(len) : new Buffer(len);
  return typeof Uint8Array != "undefined" ? new Uint8Array(len) : new Array(len);
}
__name(new_raw_buf, "new_raw_buf");
function new_unsafe_buf(len) {
  if (has_buf)
    return Buffer.allocUnsafe ? Buffer.allocUnsafe(len) : new Buffer(len);
  return typeof Uint8Array != "undefined" ? new Uint8Array(len) : new Array(len);
}
__name(new_unsafe_buf, "new_unsafe_buf");
var s2a = /* @__PURE__ */ __name(function s2a2(s2) {
  if (has_buf)
    return Buffer_from(s2, "binary");
  return s2.split("").map(function(x2) {
    return x2.charCodeAt(0) & 255;
  });
}, "s2a");
function s2ab(s2) {
  if (typeof ArrayBuffer === "undefined")
    return s2a(s2);
  var buf = new ArrayBuffer(s2.length), view = new Uint8Array(buf);
  for (var i2 = 0; i2 != s2.length; ++i2)
    view[i2] = s2.charCodeAt(i2) & 255;
  return buf;
}
__name(s2ab, "s2ab");
function a2s(data) {
  if (Array.isArray(data))
    return data.map(function(c2) {
      return String.fromCharCode(c2);
    }).join("");
  var o2 = [];
  for (var i2 = 0; i2 < data.length; ++i2)
    o2[i2] = String.fromCharCode(data[i2]);
  return o2.join("");
}
__name(a2s, "a2s");
function a2u(data) {
  if (typeof Uint8Array === "undefined")
    throw new Error("Unsupported");
  return new Uint8Array(data);
}
__name(a2u, "a2u");
var bconcat = has_buf ? function(bufs) {
  return Buffer.concat(bufs.map(function(buf) {
    return Buffer.isBuffer(buf) ? buf : Buffer_from(buf);
  }));
} : function(bufs) {
  if (typeof Uint8Array !== "undefined") {
    var i2 = 0, maxlen = 0;
    for (i2 = 0; i2 < bufs.length; ++i2)
      maxlen += bufs[i2].length;
    var o2 = new Uint8Array(maxlen);
    var len = 0;
    for (i2 = 0, maxlen = 0; i2 < bufs.length; maxlen += len, ++i2) {
      len = bufs[i2].length;
      if (bufs[i2] instanceof Uint8Array)
        o2.set(bufs[i2], maxlen);
      else if (typeof bufs[i2] == "string") {
        throw "wtf";
      } else
        o2.set(new Uint8Array(bufs[i2]), maxlen);
    }
    return o2;
  }
  return [].concat.apply([], bufs.map(function(buf) {
    return Array.isArray(buf) ? buf : [].slice.call(buf);
  }));
};
function utf8decode(content) {
  var out = [], widx = 0, L2 = content.length + 250;
  var o2 = new_raw_buf(content.length + 255);
  for (var ridx = 0; ridx < content.length; ++ridx) {
    var c2 = content.charCodeAt(ridx);
    if (c2 < 128)
      o2[widx++] = c2;
    else if (c2 < 2048) {
      o2[widx++] = 192 | c2 >> 6 & 31;
      o2[widx++] = 128 | c2 & 63;
    } else if (c2 >= 55296 && c2 < 57344) {
      c2 = (c2 & 1023) + 64;
      var d2 = content.charCodeAt(++ridx) & 1023;
      o2[widx++] = 240 | c2 >> 8 & 7;
      o2[widx++] = 128 | c2 >> 2 & 63;
      o2[widx++] = 128 | d2 >> 6 & 15 | (c2 & 3) << 4;
      o2[widx++] = 128 | d2 & 63;
    } else {
      o2[widx++] = 224 | c2 >> 12 & 15;
      o2[widx++] = 128 | c2 >> 6 & 63;
      o2[widx++] = 128 | c2 & 63;
    }
    if (widx > L2) {
      out.push(o2.slice(0, widx));
      widx = 0;
      o2 = new_raw_buf(65535);
      L2 = 65530;
    }
  }
  out.push(o2.slice(0, widx));
  return bconcat(out);
}
__name(utf8decode, "utf8decode");
var chr0 = /\u0000/g, chr1 = /[\u0001-\u0006]/g;
function _strrev(x2) {
  var o2 = "", i2 = x2.length - 1;
  while (i2 >= 0)
    o2 += x2.charAt(i2--);
  return o2;
}
__name(_strrev, "_strrev");
function pad0(v2, d2) {
  var t2 = "" + v2;
  return t2.length >= d2 ? t2 : fill("0", d2 - t2.length) + t2;
}
__name(pad0, "pad0");
function pad_(v2, d2) {
  var t2 = "" + v2;
  return t2.length >= d2 ? t2 : fill(" ", d2 - t2.length) + t2;
}
__name(pad_, "pad_");
function rpad_(v2, d2) {
  var t2 = "" + v2;
  return t2.length >= d2 ? t2 : t2 + fill(" ", d2 - t2.length);
}
__name(rpad_, "rpad_");
function pad0r1(v2, d2) {
  var t2 = "" + Math.round(v2);
  return t2.length >= d2 ? t2 : fill("0", d2 - t2.length) + t2;
}
__name(pad0r1, "pad0r1");
function pad0r2(v2, d2) {
  var t2 = "" + v2;
  return t2.length >= d2 ? t2 : fill("0", d2 - t2.length) + t2;
}
__name(pad0r2, "pad0r2");
var p2_32 = /* @__PURE__ */ Math.pow(2, 32);
function pad0r(v2, d2) {
  if (v2 > p2_32 || v2 < -p2_32)
    return pad0r1(v2, d2);
  var i2 = Math.round(v2);
  return pad0r2(i2, d2);
}
__name(pad0r, "pad0r");
function SSF_isgeneral(s2, i2) {
  i2 = i2 || 0;
  return s2.length >= 7 + i2 && (s2.charCodeAt(i2) | 32) === 103 && (s2.charCodeAt(i2 + 1) | 32) === 101 && (s2.charCodeAt(i2 + 2) | 32) === 110 && (s2.charCodeAt(i2 + 3) | 32) === 101 && (s2.charCodeAt(i2 + 4) | 32) === 114 && (s2.charCodeAt(i2 + 5) | 32) === 97 && (s2.charCodeAt(i2 + 6) | 32) === 108;
}
__name(SSF_isgeneral, "SSF_isgeneral");
var days = [
  ["Sun", "Sunday"],
  ["Mon", "Monday"],
  ["Tue", "Tuesday"],
  ["Wed", "Wednesday"],
  ["Thu", "Thursday"],
  ["Fri", "Friday"],
  ["Sat", "Saturday"]
];
var months = [
  ["J", "Jan", "January"],
  ["F", "Feb", "February"],
  ["M", "Mar", "March"],
  ["A", "Apr", "April"],
  ["M", "May", "May"],
  ["J", "Jun", "June"],
  ["J", "Jul", "July"],
  ["A", "Aug", "August"],
  ["S", "Sep", "September"],
  ["O", "Oct", "October"],
  ["N", "Nov", "November"],
  ["D", "Dec", "December"]
];
function SSF_init_table(t2) {
  if (!t2)
    t2 = {};
  t2[0] = "General";
  t2[1] = "0";
  t2[2] = "0.00";
  t2[3] = "#,##0";
  t2[4] = "#,##0.00";
  t2[9] = "0%";
  t2[10] = "0.00%";
  t2[11] = "0.00E+00";
  t2[12] = "# ?/?";
  t2[13] = "# ??/??";
  t2[14] = "m/d/yy";
  t2[15] = "d-mmm-yy";
  t2[16] = "d-mmm";
  t2[17] = "mmm-yy";
  t2[18] = "h:mm AM/PM";
  t2[19] = "h:mm:ss AM/PM";
  t2[20] = "h:mm";
  t2[21] = "h:mm:ss";
  t2[22] = "m/d/yy h:mm";
  t2[37] = "#,##0 ;(#,##0)";
  t2[38] = "#,##0 ;[Red](#,##0)";
  t2[39] = "#,##0.00;(#,##0.00)";
  t2[40] = "#,##0.00;[Red](#,##0.00)";
  t2[45] = "mm:ss";
  t2[46] = "[h]:mm:ss";
  t2[47] = "mmss.0";
  t2[48] = "##0.0E+0";
  t2[49] = "@";
  t2[56] = '"/ "hh""mm""ss" "';
  return t2;
}
__name(SSF_init_table, "SSF_init_table");
var table_fmt = {
  0: "General",
  1: "0",
  2: "0.00",
  3: "#,##0",
  4: "#,##0.00",
  9: "0%",
  10: "0.00%",
  11: "0.00E+00",
  12: "# ?/?",
  13: "# ??/??",
  14: "m/d/yy",
  15: "d-mmm-yy",
  16: "d-mmm",
  17: "mmm-yy",
  18: "h:mm AM/PM",
  19: "h:mm:ss AM/PM",
  20: "h:mm",
  21: "h:mm:ss",
  22: "m/d/yy h:mm",
  37: "#,##0 ;(#,##0)",
  38: "#,##0 ;[Red](#,##0)",
  39: "#,##0.00;(#,##0.00)",
  40: "#,##0.00;[Red](#,##0.00)",
  45: "mm:ss",
  46: "[h]:mm:ss",
  47: "mmss.0",
  48: "##0.0E+0",
  49: "@",
  56: '"/ "hh""mm""ss" "'
};
var SSF_default_map = {
  5: 37,
  6: 38,
  7: 39,
  8: 40,
  //  5 -> 37 ...  8 -> 40
  23: 0,
  24: 0,
  25: 0,
  26: 0,
  // 23 ->  0 ... 26 ->  0
  27: 14,
  28: 14,
  29: 14,
  30: 14,
  31: 14,
  // 27 -> 14 ... 31 -> 14
  50: 14,
  51: 14,
  52: 14,
  53: 14,
  54: 14,
  // 50 -> 14 ... 58 -> 14
  55: 14,
  56: 14,
  57: 14,
  58: 14,
  59: 1,
  60: 2,
  61: 3,
  62: 4,
  // 59 ->  1 ... 62 ->  4
  67: 9,
  68: 10,
  // 67 ->  9 ... 68 -> 10
  69: 12,
  70: 13,
  71: 14,
  // 69 -> 12 ... 71 -> 14
  72: 14,
  73: 15,
  74: 16,
  75: 17,
  // 72 -> 14 ... 75 -> 17
  76: 20,
  77: 21,
  78: 22,
  // 76 -> 20 ... 78 -> 22
  79: 45,
  80: 46,
  81: 47,
  // 79 -> 45 ... 81 -> 47
  82: 0
  // 82 ->  0 ... 65536 -> 0 (omitted)
};
var SSF_default_str = {
  //  5 -- Currency,   0 decimal, black negative
  5: '"$"#,##0_);\\("$"#,##0\\)',
  63: '"$"#,##0_);\\("$"#,##0\\)',
  //  6 -- Currency,   0 decimal, red   negative
  6: '"$"#,##0_);[Red]\\("$"#,##0\\)',
  64: '"$"#,##0_);[Red]\\("$"#,##0\\)',
  //  7 -- Currency,   2 decimal, black negative
  7: '"$"#,##0.00_);\\("$"#,##0.00\\)',
  65: '"$"#,##0.00_);\\("$"#,##0.00\\)',
  //  8 -- Currency,   2 decimal, red   negative
  8: '"$"#,##0.00_);[Red]\\("$"#,##0.00\\)',
  66: '"$"#,##0.00_);[Red]\\("$"#,##0.00\\)',
  // 41 -- Accounting, 0 decimal, No Symbol
  41: '_(* #,##0_);_(* \\(#,##0\\);_(* "-"_);_(@_)',
  // 42 -- Accounting, 0 decimal, $  Symbol
  42: '_("$"* #,##0_);_("$"* \\(#,##0\\);_("$"* "-"_);_(@_)',
  // 43 -- Accounting, 2 decimal, No Symbol
  43: '_(* #,##0.00_);_(* \\(#,##0.00\\);_(* "-"??_);_(@_)',
  // 44 -- Accounting, 2 decimal, $  Symbol
  44: '_("$"* #,##0.00_);_("$"* \\(#,##0.00\\);_("$"* "-"??_);_(@_)'
};
function SSF_frac(x2, D2, mixed) {
  var sgn = x2 < 0 ? -1 : 1;
  var B2 = x2 * sgn;
  var P_2 = 0, P_1 = 1, P2 = 0;
  var Q_2 = 1, Q_1 = 0, Q2 = 0;
  var A2 = Math.floor(B2);
  while (Q_1 < D2) {
    A2 = Math.floor(B2);
    P2 = A2 * P_1 + P_2;
    Q2 = A2 * Q_1 + Q_2;
    if (B2 - A2 < 5e-8)
      break;
    B2 = 1 / (B2 - A2);
    P_2 = P_1;
    P_1 = P2;
    Q_2 = Q_1;
    Q_1 = Q2;
  }
  if (Q2 > D2) {
    if (Q_1 > D2) {
      Q2 = Q_2;
      P2 = P_2;
    } else {
      Q2 = Q_1;
      P2 = P_1;
    }
  }
  if (!mixed)
    return [0, sgn * P2, Q2];
  var q2 = Math.floor(sgn * P2 / Q2);
  return [q2, sgn * P2 - q2 * Q2, Q2];
}
__name(SSF_frac, "SSF_frac");
function SSF_parse_date_code(v2, opts, b2) {
  if (v2 > 2958465 || v2 < 0)
    return null;
  var date = v2 | 0, time = Math.floor(86400 * (v2 - date)), dow = 0;
  var dout = [];
  var out = { D: date, T: time, u: 86400 * (v2 - date) - time, y: 0, m: 0, d: 0, H: 0, M: 0, S: 0, q: 0 };
  if (Math.abs(out.u) < 1e-6)
    out.u = 0;
  if (opts && opts.date1904)
    date += 1462;
  if (out.u > 0.9999) {
    out.u = 0;
    if (++time == 86400) {
      out.T = time = 0;
      ++date;
      ++out.D;
    }
  }
  if (date === 60) {
    dout = b2 ? [1317, 10, 29] : [1900, 2, 29];
    dow = 3;
  } else if (date === 0) {
    dout = b2 ? [1317, 8, 29] : [1900, 1, 0];
    dow = 6;
  } else {
    if (date > 60)
      --date;
    var d2 = new Date(1900, 0, 1);
    d2.setDate(d2.getDate() + date - 1);
    dout = [d2.getFullYear(), d2.getMonth() + 1, d2.getDate()];
    dow = d2.getDay();
    if (date < 60)
      dow = (dow + 6) % 7;
    if (b2)
      dow = SSF_fix_hijri(d2, dout);
  }
  out.y = dout[0];
  out.m = dout[1];
  out.d = dout[2];
  out.S = time % 60;
  time = Math.floor(time / 60);
  out.M = time % 60;
  time = Math.floor(time / 60);
  out.H = time;
  out.q = dow;
  return out;
}
__name(SSF_parse_date_code, "SSF_parse_date_code");
var SSFbasedate = /* @__PURE__ */ new Date(1899, 11, 31, 0, 0, 0);
var SSFdnthresh = /* @__PURE__ */ SSFbasedate.getTime();
var SSFbase1904 = /* @__PURE__ */ new Date(1900, 2, 1, 0, 0, 0);
function datenum_local(v2, date1904) {
  var epoch = /* @__PURE__ */ v2.getTime();
  if (date1904)
    epoch -= 1461 * 24 * 60 * 60 * 1e3;
  else if (v2 >= SSFbase1904)
    epoch += 24 * 60 * 60 * 1e3;
  return (epoch - (SSFdnthresh + (/* @__PURE__ */ v2.getTimezoneOffset() - /* @__PURE__ */ SSFbasedate.getTimezoneOffset()) * 6e4)) / (24 * 60 * 60 * 1e3);
}
__name(datenum_local, "datenum_local");
function SSF_strip_decimal(o2) {
  return o2.indexOf(".") == -1 ? o2 : o2.replace(/(?:\.0*|(\.\d*[1-9])0+)$/, "$1");
}
__name(SSF_strip_decimal, "SSF_strip_decimal");
function SSF_normalize_exp(o2) {
  if (o2.indexOf("E") == -1)
    return o2;
  return o2.replace(/(?:\.0*|(\.\d*[1-9])0+)[Ee]/, "$1E").replace(/(E[+-])(\d)$/, "$10$2");
}
__name(SSF_normalize_exp, "SSF_normalize_exp");
function SSF_small_exp(v2) {
  var w2 = v2 < 0 ? 12 : 11;
  var o2 = SSF_strip_decimal(v2.toFixed(12));
  if (o2.length <= w2)
    return o2;
  o2 = v2.toPrecision(10);
  if (o2.length <= w2)
    return o2;
  return v2.toExponential(5);
}
__name(SSF_small_exp, "SSF_small_exp");
function SSF_large_exp(v2) {
  var o2 = SSF_strip_decimal(v2.toFixed(11));
  return o2.length > (v2 < 0 ? 12 : 11) || o2 === "0" || o2 === "-0" ? v2.toPrecision(6) : o2;
}
__name(SSF_large_exp, "SSF_large_exp");
function SSF_general_num(v2) {
  var V2 = Math.floor(Math.log(Math.abs(v2)) * Math.LOG10E), o2;
  if (V2 >= -4 && V2 <= -1)
    o2 = v2.toPrecision(10 + V2);
  else if (Math.abs(V2) <= 9)
    o2 = SSF_small_exp(v2);
  else if (V2 === 10)
    o2 = v2.toFixed(10).substr(0, 12);
  else
    o2 = SSF_large_exp(v2);
  return SSF_strip_decimal(SSF_normalize_exp(o2.toUpperCase()));
}
__name(SSF_general_num, "SSF_general_num");
function SSF_general(v2, opts) {
  switch (typeof v2) {
    case "string":
      return v2;
    case "boolean":
      return v2 ? "TRUE" : "FALSE";
    case "number":
      return (v2 | 0) === v2 ? v2.toString(10) : SSF_general_num(v2);
    case "undefined":
      return "";
    case "object":
      if (v2 == null)
        return "";
      if (v2 instanceof Date)
        return SSF_format(14, datenum_local(v2, opts && opts.date1904), opts);
  }
  throw new Error("unsupported value in General format: " + v2);
}
__name(SSF_general, "SSF_general");
function SSF_fix_hijri(date, o2) {
  o2[0] -= 581;
  var dow = date.getDay();
  if (date < 60)
    dow = (dow + 6) % 7;
  return dow;
}
__name(SSF_fix_hijri, "SSF_fix_hijri");
function SSF_write_date(type, fmt, val, ss0) {
  var o2 = "", ss = 0, tt2 = 0, y2 = val.y, out, outl = 0;
  switch (type) {
    case 98:
      y2 = val.y + 543;
    case 121:
      switch (fmt.length) {
        case 1:
        case 2:
          out = y2 % 100;
          outl = 2;
          break;
        default:
          out = y2 % 1e4;
          outl = 4;
          break;
      }
      break;
    case 109:
      switch (fmt.length) {
        case 1:
        case 2:
          out = val.m;
          outl = fmt.length;
          break;
        case 3:
          return months[val.m - 1][1];
        case 5:
          return months[val.m - 1][0];
        default:
          return months[val.m - 1][2];
      }
      break;
    case 100:
      switch (fmt.length) {
        case 1:
        case 2:
          out = val.d;
          outl = fmt.length;
          break;
        case 3:
          return days[val.q][0];
        default:
          return days[val.q][1];
      }
      break;
    case 104:
      switch (fmt.length) {
        case 1:
        case 2:
          out = 1 + (val.H + 11) % 12;
          outl = fmt.length;
          break;
        default:
          throw "bad hour format: " + fmt;
      }
      break;
    case 72:
      switch (fmt.length) {
        case 1:
        case 2:
          out = val.H;
          outl = fmt.length;
          break;
        default:
          throw "bad hour format: " + fmt;
      }
      break;
    case 77:
      switch (fmt.length) {
        case 1:
        case 2:
          out = val.M;
          outl = fmt.length;
          break;
        default:
          throw "bad minute format: " + fmt;
      }
      break;
    case 115:
      if (fmt != "s" && fmt != "ss" && fmt != ".0" && fmt != ".00" && fmt != ".000")
        throw "bad second format: " + fmt;
      if (val.u === 0 && (fmt == "s" || fmt == "ss"))
        return pad0(val.S, fmt.length);
      if (ss0 >= 2)
        tt2 = ss0 === 3 ? 1e3 : 100;
      else
        tt2 = ss0 === 1 ? 10 : 1;
      ss = Math.round(tt2 * (val.S + val.u));
      if (ss >= 60 * tt2)
        ss = 0;
      if (fmt === "s")
        return ss === 0 ? "0" : "" + ss / tt2;
      o2 = pad0(ss, 2 + ss0);
      if (fmt === "ss")
        return o2.substr(0, 2);
      return "." + o2.substr(2, fmt.length - 1);
    case 90:
      switch (fmt) {
        case "[h]":
        case "[hh]":
          out = val.D * 24 + val.H;
          break;
        case "[m]":
        case "[mm]":
          out = (val.D * 24 + val.H) * 60 + val.M;
          break;
        case "[s]":
        case "[ss]":
          out = ((val.D * 24 + val.H) * 60 + val.M) * 60 + Math.round(val.S + val.u);
          break;
        default:
          throw "bad abstime format: " + fmt;
      }
      outl = fmt.length === 3 ? 1 : 2;
      break;
    case 101:
      out = y2;
      outl = 1;
      break;
  }
  var outstr = outl > 0 ? pad0(out, outl) : "";
  return outstr;
}
__name(SSF_write_date, "SSF_write_date");
function commaify(s2) {
  var w2 = 3;
  if (s2.length <= w2)
    return s2;
  var j2 = s2.length % w2, o2 = s2.substr(0, j2);
  for (; j2 != s2.length; j2 += w2)
    o2 += (o2.length > 0 ? "," : "") + s2.substr(j2, w2);
  return o2;
}
__name(commaify, "commaify");
var pct1 = /%/g;
function write_num_pct(type, fmt, val) {
  var sfmt = fmt.replace(pct1, ""), mul = fmt.length - sfmt.length;
  return write_num(type, sfmt, val * Math.pow(10, 2 * mul)) + fill("%", mul);
}
__name(write_num_pct, "write_num_pct");
function write_num_cm(type, fmt, val) {
  var idx = fmt.length - 1;
  while (fmt.charCodeAt(idx - 1) === 44)
    --idx;
  return write_num(type, fmt.substr(0, idx), val / Math.pow(10, 3 * (fmt.length - idx)));
}
__name(write_num_cm, "write_num_cm");
function write_num_exp(fmt, val) {
  var o2;
  var idx = fmt.indexOf("E") - fmt.indexOf(".") - 1;
  if (fmt.match(/^#+0.0E\+0$/)) {
    if (val == 0)
      return "0.0E+0";
    else if (val < 0)
      return "-" + write_num_exp(fmt, -val);
    var period = fmt.indexOf(".");
    if (period === -1)
      period = fmt.indexOf("E");
    var ee2 = Math.floor(Math.log(val) * Math.LOG10E) % period;
    if (ee2 < 0)
      ee2 += period;
    o2 = (val / Math.pow(10, ee2)).toPrecision(idx + 1 + (period + ee2) % period);
    if (o2.indexOf("e") === -1) {
      var fakee = Math.floor(Math.log(val) * Math.LOG10E);
      if (o2.indexOf(".") === -1)
        o2 = o2.charAt(0) + "." + o2.substr(1) + "E+" + (fakee - o2.length + ee2);
      else
        o2 += "E+" + (fakee - ee2);
      while (o2.substr(0, 2) === "0.") {
        o2 = o2.charAt(0) + o2.substr(2, period) + "." + o2.substr(2 + period);
        o2 = o2.replace(/^0+([1-9])/, "$1").replace(/^0+\./, "0.");
      }
      o2 = o2.replace(/\+-/, "-");
    }
    o2 = o2.replace(/^([+-]?)(\d*)\.(\d*)[Ee]/, function($$, $1, $2, $3) {
      return $1 + $2 + $3.substr(0, (period + ee2) % period) + "." + $3.substr(ee2) + "E";
    });
  } else
    o2 = val.toExponential(idx);
  if (fmt.match(/E\+00$/) && o2.match(/e[+-]\d$/))
    o2 = o2.substr(0, o2.length - 1) + "0" + o2.charAt(o2.length - 1);
  if (fmt.match(/E\-/) && o2.match(/e\+/))
    o2 = o2.replace(/e\+/, "e");
  return o2.replace("e", "E");
}
__name(write_num_exp, "write_num_exp");
var frac1 = /# (\?+)( ?)\/( ?)(\d+)/;
function write_num_f1(r, aval, sign2) {
  var den = parseInt(r[4], 10), rr = Math.round(aval * den), base = Math.floor(rr / den);
  var myn = rr - base * den, myd = den;
  return sign2 + (base === 0 ? "" : "" + base) + " " + (myn === 0 ? fill(" ", r[1].length + 1 + r[4].length) : pad_(myn, r[1].length) + r[2] + "/" + r[3] + pad0(myd, r[4].length));
}
__name(write_num_f1, "write_num_f1");
function write_num_f2(r, aval, sign2) {
  return sign2 + (aval === 0 ? "" : "" + aval) + fill(" ", r[1].length + 2 + r[4].length);
}
__name(write_num_f2, "write_num_f2");
var dec1 = /^#*0*\.([0#]+)/;
var closeparen = /\).*[0#]/;
var phone = /\(###\) ###\\?-####/;
function hashq(str) {
  var o2 = "", cc;
  for (var i2 = 0; i2 != str.length; ++i2)
    switch (cc = str.charCodeAt(i2)) {
      case 35:
        break;
      case 63:
        o2 += " ";
        break;
      case 48:
        o2 += "0";
        break;
      default:
        o2 += String.fromCharCode(cc);
    }
  return o2;
}
__name(hashq, "hashq");
function rnd(val, d2) {
  var dd = Math.pow(10, d2);
  return "" + Math.round(val * dd) / dd;
}
__name(rnd, "rnd");
function dec(val, d2) {
  var _frac = val - Math.floor(val), dd = Math.pow(10, d2);
  if (d2 < ("" + Math.round(_frac * dd)).length)
    return 0;
  return Math.round(_frac * dd);
}
__name(dec, "dec");
function carry(val, d2) {
  if (d2 < ("" + Math.round((val - Math.floor(val)) * Math.pow(10, d2))).length) {
    return 1;
  }
  return 0;
}
__name(carry, "carry");
function flr(val) {
  if (val < 2147483647 && val > -2147483648)
    return "" + (val >= 0 ? val | 0 : val - 1 | 0);
  return "" + Math.floor(val);
}
__name(flr, "flr");
function write_num_flt(type, fmt, val) {
  if (type.charCodeAt(0) === 40 && !fmt.match(closeparen)) {
    var ffmt = fmt.replace(/\( */, "").replace(/ \)/, "").replace(/\)/, "");
    if (val >= 0)
      return write_num_flt("n", ffmt, val);
    return "(" + write_num_flt("n", ffmt, -val) + ")";
  }
  if (fmt.charCodeAt(fmt.length - 1) === 44)
    return write_num_cm(type, fmt, val);
  if (fmt.indexOf("%") !== -1)
    return write_num_pct(type, fmt, val);
  if (fmt.indexOf("E") !== -1)
    return write_num_exp(fmt, val);
  if (fmt.charCodeAt(0) === 36)
    return "$" + write_num_flt(type, fmt.substr(fmt.charAt(1) == " " ? 2 : 1), val);
  var o2;
  var r, ri, ff, aval = Math.abs(val), sign2 = val < 0 ? "-" : "";
  if (fmt.match(/^00+$/))
    return sign2 + pad0r(aval, fmt.length);
  if (fmt.match(/^[#?]+$/)) {
    o2 = pad0r(val, 0);
    if (o2 === "0")
      o2 = "";
    return o2.length > fmt.length ? o2 : hashq(fmt.substr(0, fmt.length - o2.length)) + o2;
  }
  if (r = fmt.match(frac1))
    return write_num_f1(r, aval, sign2);
  if (fmt.match(/^#+0+$/))
    return sign2 + pad0r(aval, fmt.length - fmt.indexOf("0"));
  if (r = fmt.match(dec1)) {
    o2 = rnd(val, r[1].length).replace(/^([^\.]+)$/, "$1." + hashq(r[1])).replace(/\.$/, "." + hashq(r[1])).replace(/\.(\d*)$/, function($$, $1) {
      return "." + $1 + fill("0", hashq(
        /*::(*/
        r[1]
      ).length - $1.length);
    });
    return fmt.indexOf("0.") !== -1 ? o2 : o2.replace(/^0\./, ".");
  }
  fmt = fmt.replace(/^#+([0.])/, "$1");
  if (r = fmt.match(/^(0*)\.(#*)$/)) {
    return sign2 + rnd(aval, r[2].length).replace(/\.(\d*[1-9])0*$/, ".$1").replace(/^(-?\d*)$/, "$1.").replace(/^0\./, r[1].length ? "0." : ".");
  }
  if (r = fmt.match(/^#{1,3},##0(\.?)$/))
    return sign2 + commaify(pad0r(aval, 0));
  if (r = fmt.match(/^#,##0\.([#0]*0)$/)) {
    return val < 0 ? "-" + write_num_flt(type, fmt, -val) : commaify("" + (Math.floor(val) + carry(val, r[1].length))) + "." + pad0(dec(val, r[1].length), r[1].length);
  }
  if (r = fmt.match(/^#,#*,#0/))
    return write_num_flt(type, fmt.replace(/^#,#*,/, ""), val);
  if (r = fmt.match(/^([0#]+)(\\?-([0#]+))+$/)) {
    o2 = _strrev(write_num_flt(type, fmt.replace(/[\\-]/g, ""), val));
    ri = 0;
    return _strrev(_strrev(fmt.replace(/\\/g, "")).replace(/[0#]/g, function(x3) {
      return ri < o2.length ? o2.charAt(ri++) : x3 === "0" ? "0" : "";
    }));
  }
  if (fmt.match(phone)) {
    o2 = write_num_flt(type, "##########", val);
    return "(" + o2.substr(0, 3) + ") " + o2.substr(3, 3) + "-" + o2.substr(6);
  }
  var oa = "";
  if (r = fmt.match(/^([#0?]+)( ?)\/( ?)([#0?]+)/)) {
    ri = Math.min(
      /*::String(*/
      r[4].length,
      7
    );
    ff = SSF_frac(aval, Math.pow(10, ri) - 1, false);
    o2 = "" + sign2;
    oa = write_num(
      "n",
      /*::String(*/
      r[1],
      ff[1]
    );
    if (oa.charAt(oa.length - 1) == " ")
      oa = oa.substr(0, oa.length - 1) + "0";
    o2 += oa + /*::String(*/
    r[2] + "/" + /*::String(*/
    r[3];
    oa = rpad_(ff[2], ri);
    if (oa.length < r[4].length)
      oa = hashq(r[4].substr(r[4].length - oa.length)) + oa;
    o2 += oa;
    return o2;
  }
  if (r = fmt.match(/^# ([#0?]+)( ?)\/( ?)([#0?]+)/)) {
    ri = Math.min(Math.max(r[1].length, r[4].length), 7);
    ff = SSF_frac(aval, Math.pow(10, ri) - 1, true);
    return sign2 + (ff[0] || (ff[1] ? "" : "0")) + " " + (ff[1] ? pad_(ff[1], ri) + r[2] + "/" + r[3] + rpad_(ff[2], ri) : fill(" ", 2 * ri + 1 + r[2].length + r[3].length));
  }
  if (r = fmt.match(/^[#0?]+$/)) {
    o2 = pad0r(val, 0);
    if (fmt.length <= o2.length)
      return o2;
    return hashq(fmt.substr(0, fmt.length - o2.length)) + o2;
  }
  if (r = fmt.match(/^([#0?]+)\.([#0]+)$/)) {
    o2 = "" + val.toFixed(Math.min(r[2].length, 10)).replace(/([^0])0+$/, "$1");
    ri = o2.indexOf(".");
    var lres = fmt.indexOf(".") - ri, rres = fmt.length - o2.length - lres;
    return hashq(fmt.substr(0, lres) + o2 + fmt.substr(fmt.length - rres));
  }
  if (r = fmt.match(/^00,000\.([#0]*0)$/)) {
    ri = dec(val, r[1].length);
    return val < 0 ? "-" + write_num_flt(type, fmt, -val) : commaify(flr(val)).replace(/^\d,\d{3}$/, "0$&").replace(/^\d*$/, function($$) {
      return "00," + ($$.length < 3 ? pad0(0, 3 - $$.length) : "") + $$;
    }) + "." + pad0(ri, r[1].length);
  }
  switch (fmt) {
    case "###,##0.00":
      return write_num_flt(type, "#,##0.00", val);
    case "###,###":
    case "##,###":
    case "#,###":
      var x2 = commaify(pad0r(aval, 0));
      return x2 !== "0" ? sign2 + x2 : "";
    case "###,###.00":
      return write_num_flt(type, "###,##0.00", val).replace(/^0\./, ".");
    case "#,###.00":
      return write_num_flt(type, "#,##0.00", val).replace(/^0\./, ".");
  }
  throw new Error("unsupported format |" + fmt + "|");
}
__name(write_num_flt, "write_num_flt");
function write_num_cm2(type, fmt, val) {
  var idx = fmt.length - 1;
  while (fmt.charCodeAt(idx - 1) === 44)
    --idx;
  return write_num(type, fmt.substr(0, idx), val / Math.pow(10, 3 * (fmt.length - idx)));
}
__name(write_num_cm2, "write_num_cm2");
function write_num_pct2(type, fmt, val) {
  var sfmt = fmt.replace(pct1, ""), mul = fmt.length - sfmt.length;
  return write_num(type, sfmt, val * Math.pow(10, 2 * mul)) + fill("%", mul);
}
__name(write_num_pct2, "write_num_pct2");
function write_num_exp2(fmt, val) {
  var o2;
  var idx = fmt.indexOf("E") - fmt.indexOf(".") - 1;
  if (fmt.match(/^#+0.0E\+0$/)) {
    if (val == 0)
      return "0.0E+0";
    else if (val < 0)
      return "-" + write_num_exp2(fmt, -val);
    var period = fmt.indexOf(".");
    if (period === -1)
      period = fmt.indexOf("E");
    var ee2 = Math.floor(Math.log(val) * Math.LOG10E) % period;
    if (ee2 < 0)
      ee2 += period;
    o2 = (val / Math.pow(10, ee2)).toPrecision(idx + 1 + (period + ee2) % period);
    if (!o2.match(/[Ee]/)) {
      var fakee = Math.floor(Math.log(val) * Math.LOG10E);
      if (o2.indexOf(".") === -1)
        o2 = o2.charAt(0) + "." + o2.substr(1) + "E+" + (fakee - o2.length + ee2);
      else
        o2 += "E+" + (fakee - ee2);
      o2 = o2.replace(/\+-/, "-");
    }
    o2 = o2.replace(/^([+-]?)(\d*)\.(\d*)[Ee]/, function($$, $1, $2, $3) {
      return $1 + $2 + $3.substr(0, (period + ee2) % period) + "." + $3.substr(ee2) + "E";
    });
  } else
    o2 = val.toExponential(idx);
  if (fmt.match(/E\+00$/) && o2.match(/e[+-]\d$/))
    o2 = o2.substr(0, o2.length - 1) + "0" + o2.charAt(o2.length - 1);
  if (fmt.match(/E\-/) && o2.match(/e\+/))
    o2 = o2.replace(/e\+/, "e");
  return o2.replace("e", "E");
}
__name(write_num_exp2, "write_num_exp2");
function write_num_int(type, fmt, val) {
  if (type.charCodeAt(0) === 40 && !fmt.match(closeparen)) {
    var ffmt = fmt.replace(/\( */, "").replace(/ \)/, "").replace(/\)/, "");
    if (val >= 0)
      return write_num_int("n", ffmt, val);
    return "(" + write_num_int("n", ffmt, -val) + ")";
  }
  if (fmt.charCodeAt(fmt.length - 1) === 44)
    return write_num_cm2(type, fmt, val);
  if (fmt.indexOf("%") !== -1)
    return write_num_pct2(type, fmt, val);
  if (fmt.indexOf("E") !== -1)
    return write_num_exp2(fmt, val);
  if (fmt.charCodeAt(0) === 36)
    return "$" + write_num_int(type, fmt.substr(fmt.charAt(1) == " " ? 2 : 1), val);
  var o2;
  var r, ri, ff, aval = Math.abs(val), sign2 = val < 0 ? "-" : "";
  if (fmt.match(/^00+$/))
    return sign2 + pad0(aval, fmt.length);
  if (fmt.match(/^[#?]+$/)) {
    o2 = "" + val;
    if (val === 0)
      o2 = "";
    return o2.length > fmt.length ? o2 : hashq(fmt.substr(0, fmt.length - o2.length)) + o2;
  }
  if (r = fmt.match(frac1))
    return write_num_f2(r, aval, sign2);
  if (fmt.match(/^#+0+$/))
    return sign2 + pad0(aval, fmt.length - fmt.indexOf("0"));
  if (r = fmt.match(dec1)) {
    o2 = ("" + val).replace(/^([^\.]+)$/, "$1." + hashq(r[1])).replace(/\.$/, "." + hashq(r[1]));
    o2 = o2.replace(/\.(\d*)$/, function($$, $1) {
      return "." + $1 + fill("0", hashq(r[1]).length - $1.length);
    });
    return fmt.indexOf("0.") !== -1 ? o2 : o2.replace(/^0\./, ".");
  }
  fmt = fmt.replace(/^#+([0.])/, "$1");
  if (r = fmt.match(/^(0*)\.(#*)$/)) {
    return sign2 + ("" + aval).replace(/\.(\d*[1-9])0*$/, ".$1").replace(/^(-?\d*)$/, "$1.").replace(/^0\./, r[1].length ? "0." : ".");
  }
  if (r = fmt.match(/^#{1,3},##0(\.?)$/))
    return sign2 + commaify("" + aval);
  if (r = fmt.match(/^#,##0\.([#0]*0)$/)) {
    return val < 0 ? "-" + write_num_int(type, fmt, -val) : commaify("" + val) + "." + fill("0", r[1].length);
  }
  if (r = fmt.match(/^#,#*,#0/))
    return write_num_int(type, fmt.replace(/^#,#*,/, ""), val);
  if (r = fmt.match(/^([0#]+)(\\?-([0#]+))+$/)) {
    o2 = _strrev(write_num_int(type, fmt.replace(/[\\-]/g, ""), val));
    ri = 0;
    return _strrev(_strrev(fmt.replace(/\\/g, "")).replace(/[0#]/g, function(x3) {
      return ri < o2.length ? o2.charAt(ri++) : x3 === "0" ? "0" : "";
    }));
  }
  if (fmt.match(phone)) {
    o2 = write_num_int(type, "##########", val);
    return "(" + o2.substr(0, 3) + ") " + o2.substr(3, 3) + "-" + o2.substr(6);
  }
  var oa = "";
  if (r = fmt.match(/^([#0?]+)( ?)\/( ?)([#0?]+)/)) {
    ri = Math.min(
      /*::String(*/
      r[4].length,
      7
    );
    ff = SSF_frac(aval, Math.pow(10, ri) - 1, false);
    o2 = "" + sign2;
    oa = write_num(
      "n",
      /*::String(*/
      r[1],
      ff[1]
    );
    if (oa.charAt(oa.length - 1) == " ")
      oa = oa.substr(0, oa.length - 1) + "0";
    o2 += oa + /*::String(*/
    r[2] + "/" + /*::String(*/
    r[3];
    oa = rpad_(ff[2], ri);
    if (oa.length < r[4].length)
      oa = hashq(r[4].substr(r[4].length - oa.length)) + oa;
    o2 += oa;
    return o2;
  }
  if (r = fmt.match(/^# ([#0?]+)( ?)\/( ?)([#0?]+)/)) {
    ri = Math.min(Math.max(r[1].length, r[4].length), 7);
    ff = SSF_frac(aval, Math.pow(10, ri) - 1, true);
    return sign2 + (ff[0] || (ff[1] ? "" : "0")) + " " + (ff[1] ? pad_(ff[1], ri) + r[2] + "/" + r[3] + rpad_(ff[2], ri) : fill(" ", 2 * ri + 1 + r[2].length + r[3].length));
  }
  if (r = fmt.match(/^[#0?]+$/)) {
    o2 = "" + val;
    if (fmt.length <= o2.length)
      return o2;
    return hashq(fmt.substr(0, fmt.length - o2.length)) + o2;
  }
  if (r = fmt.match(/^([#0]+)\.([#0]+)$/)) {
    o2 = "" + val.toFixed(Math.min(r[2].length, 10)).replace(/([^0])0+$/, "$1");
    ri = o2.indexOf(".");
    var lres = fmt.indexOf(".") - ri, rres = fmt.length - o2.length - lres;
    return hashq(fmt.substr(0, lres) + o2 + fmt.substr(fmt.length - rres));
  }
  if (r = fmt.match(/^00,000\.([#0]*0)$/)) {
    return val < 0 ? "-" + write_num_int(type, fmt, -val) : commaify("" + val).replace(/^\d,\d{3}$/, "0$&").replace(/^\d*$/, function($$) {
      return "00," + ($$.length < 3 ? pad0(0, 3 - $$.length) : "") + $$;
    }) + "." + pad0(0, r[1].length);
  }
  switch (fmt) {
    case "###,###":
    case "##,###":
    case "#,###":
      var x2 = commaify("" + aval);
      return x2 !== "0" ? sign2 + x2 : "";
    default:
      if (fmt.match(/\.[0#?]*$/))
        return write_num_int(type, fmt.slice(0, fmt.lastIndexOf(".")), val) + hashq(fmt.slice(fmt.lastIndexOf(".")));
  }
  throw new Error("unsupported format |" + fmt + "|");
}
__name(write_num_int, "write_num_int");
function write_num(type, fmt, val) {
  return (val | 0) === val ? write_num_int(type, fmt, val) : write_num_flt(type, fmt, val);
}
__name(write_num, "write_num");
function SSF_split_fmt(fmt) {
  var out = [];
  var in_str = false;
  for (var i2 = 0, j2 = 0; i2 < fmt.length; ++i2)
    switch (
      /*cc=*/
      fmt.charCodeAt(i2)
    ) {
      case 34:
        in_str = !in_str;
        break;
      case 95:
      case 42:
      case 92:
        ++i2;
        break;
      case 59:
        out[out.length] = fmt.substr(j2, i2 - j2);
        j2 = i2 + 1;
    }
  out[out.length] = fmt.substr(j2);
  if (in_str === true)
    throw new Error("Format |" + fmt + "| unterminated string ");
  return out;
}
__name(SSF_split_fmt, "SSF_split_fmt");
var SSF_abstime = /\[[HhMmSs\u0E0A\u0E19\u0E17]*\]/;
function fmt_is_date(fmt) {
  var i2 = 0, c2 = "", o2 = "";
  while (i2 < fmt.length) {
    switch (c2 = fmt.charAt(i2)) {
      case "G":
        if (SSF_isgeneral(fmt, i2))
          i2 += 6;
        i2++;
        break;
      case '"':
        for (
          ;
          /*cc=*/
          fmt.charCodeAt(++i2) !== 34 && i2 < fmt.length;
        ) {
        }
        ++i2;
        break;
      case "\\":
        i2 += 2;
        break;
      case "_":
        i2 += 2;
        break;
      case "@":
        ++i2;
        break;
      case "B":
      case "b":
        if (fmt.charAt(i2 + 1) === "1" || fmt.charAt(i2 + 1) === "2")
          return true;
      case "M":
      case "D":
      case "Y":
      case "H":
      case "S":
      case "E":
      case "m":
      case "d":
      case "y":
      case "h":
      case "s":
      case "e":
      case "g":
        return true;
      case "A":
      case "a":
      case "":
        if (fmt.substr(i2, 3).toUpperCase() === "A/P")
          return true;
        if (fmt.substr(i2, 5).toUpperCase() === "AM/PM")
          return true;
        if (fmt.substr(i2, 5).toUpperCase() === "/")
          return true;
        ++i2;
        break;
      case "[":
        o2 = c2;
        while (fmt.charAt(i2++) !== "]" && i2 < fmt.length)
          o2 += fmt.charAt(i2);
        if (o2.match(SSF_abstime))
          return true;
        break;
      case ".":
      case "0":
      case "#":
        while (i2 < fmt.length && ("0#?.,E+-%".indexOf(c2 = fmt.charAt(++i2)) > -1 || c2 == "\\" && fmt.charAt(i2 + 1) == "-" && "0#".indexOf(fmt.charAt(i2 + 2)) > -1)) {
        }
        break;
      case "?":
        while (fmt.charAt(++i2) === c2) {
        }
        break;
      case "*":
        ++i2;
        if (fmt.charAt(i2) == " " || fmt.charAt(i2) == "*")
          ++i2;
        break;
      case "(":
      case ")":
        ++i2;
        break;
      case "1":
      case "2":
      case "3":
      case "4":
      case "5":
      case "6":
      case "7":
      case "8":
      case "9":
        while (i2 < fmt.length && "0123456789".indexOf(fmt.charAt(++i2)) > -1) {
        }
        break;
      case " ":
        ++i2;
        break;
      default:
        ++i2;
        break;
    }
  }
  return false;
}
__name(fmt_is_date, "fmt_is_date");
function eval_fmt(fmt, v2, opts, flen) {
  var out = [], o2 = "", i2 = 0, c2 = "", lst = "t", dt2, j2, cc;
  var hr = "H";
  while (i2 < fmt.length) {
    switch (c2 = fmt.charAt(i2)) {
      case "G":
        if (!SSF_isgeneral(fmt, i2))
          throw new Error("unrecognized character " + c2 + " in " + fmt);
        out[out.length] = { t: "G", v: "General" };
        i2 += 7;
        break;
      case '"':
        for (o2 = ""; (cc = fmt.charCodeAt(++i2)) !== 34 && i2 < fmt.length; )
          o2 += String.fromCharCode(cc);
        out[out.length] = { t: "t", v: o2 };
        ++i2;
        break;
      case "\\":
        var w2 = fmt.charAt(++i2), t2 = w2 === "(" || w2 === ")" ? w2 : "t";
        out[out.length] = { t: t2, v: w2 };
        ++i2;
        break;
      case "_":
        out[out.length] = { t: "t", v: " " };
        i2 += 2;
        break;
      case "@":
        out[out.length] = { t: "T", v: v2 };
        ++i2;
        break;
      case "B":
      case "b":
        if (fmt.charAt(i2 + 1) === "1" || fmt.charAt(i2 + 1) === "2") {
          if (dt2 == null) {
            dt2 = SSF_parse_date_code(v2, opts, fmt.charAt(i2 + 1) === "2");
            if (dt2 == null)
              return "";
          }
          out[out.length] = { t: "X", v: fmt.substr(i2, 2) };
          lst = c2;
          i2 += 2;
          break;
        }
      case "M":
      case "D":
      case "Y":
      case "H":
      case "S":
      case "E":
        c2 = c2.toLowerCase();
      case "m":
      case "d":
      case "y":
      case "h":
      case "s":
      case "e":
      case "g":
        if (v2 < 0)
          return "";
        if (dt2 == null) {
          dt2 = SSF_parse_date_code(v2, opts);
          if (dt2 == null)
            return "";
        }
        o2 = c2;
        while (++i2 < fmt.length && fmt.charAt(i2).toLowerCase() === c2)
          o2 += c2;
        if (c2 === "m" && lst.toLowerCase() === "h")
          c2 = "M";
        if (c2 === "h")
          c2 = hr;
        out[out.length] = { t: c2, v: o2 };
        lst = c2;
        break;
      case "A":
      case "a":
      case "":
        var q2 = { t: c2, v: c2 };
        if (dt2 == null)
          dt2 = SSF_parse_date_code(v2, opts);
        if (fmt.substr(i2, 3).toUpperCase() === "A/P") {
          if (dt2 != null)
            q2.v = dt2.H >= 12 ? "P" : "A";
          q2.t = "T";
          hr = "h";
          i2 += 3;
        } else if (fmt.substr(i2, 5).toUpperCase() === "AM/PM") {
          if (dt2 != null)
            q2.v = dt2.H >= 12 ? "PM" : "AM";
          q2.t = "T";
          i2 += 5;
          hr = "h";
        } else if (fmt.substr(i2, 5).toUpperCase() === "/") {
          if (dt2 != null)
            q2.v = dt2.H >= 12 ? "" : "";
          q2.t = "T";
          i2 += 5;
          hr = "h";
        } else {
          q2.t = "t";
          ++i2;
        }
        if (dt2 == null && q2.t === "T")
          return "";
        out[out.length] = q2;
        lst = c2;
        break;
      case "[":
        o2 = c2;
        while (fmt.charAt(i2++) !== "]" && i2 < fmt.length)
          o2 += fmt.charAt(i2);
        if (o2.slice(-1) !== "]")
          throw 'unterminated "[" block: |' + o2 + "|";
        if (o2.match(SSF_abstime)) {
          if (dt2 == null) {
            dt2 = SSF_parse_date_code(v2, opts);
            if (dt2 == null)
              return "";
          }
          out[out.length] = { t: "Z", v: o2.toLowerCase() };
          lst = o2.charAt(1);
        } else if (o2.indexOf("$") > -1) {
          o2 = (o2.match(/\$([^-\[\]]*)/) || [])[1] || "$";
          if (!fmt_is_date(fmt))
            out[out.length] = { t: "t", v: o2 };
        }
        break;
      case ".":
        if (dt2 != null) {
          o2 = c2;
          while (++i2 < fmt.length && (c2 = fmt.charAt(i2)) === "0")
            o2 += c2;
          out[out.length] = { t: "s", v: o2 };
          break;
        }
      case "0":
      case "#":
        o2 = c2;
        while (++i2 < fmt.length && "0#?.,E+-%".indexOf(c2 = fmt.charAt(i2)) > -1)
          o2 += c2;
        out[out.length] = { t: "n", v: o2 };
        break;
      case "?":
        o2 = c2;
        while (fmt.charAt(++i2) === c2)
          o2 += c2;
        out[out.length] = { t: c2, v: o2 };
        lst = c2;
        break;
      case "*":
        ++i2;
        if (fmt.charAt(i2) == " " || fmt.charAt(i2) == "*")
          ++i2;
        break;
      case "(":
      case ")":
        out[out.length] = { t: flen === 1 ? "t" : c2, v: c2 };
        ++i2;
        break;
      case "1":
      case "2":
      case "3":
      case "4":
      case "5":
      case "6":
      case "7":
      case "8":
      case "9":
        o2 = c2;
        while (i2 < fmt.length && "0123456789".indexOf(fmt.charAt(++i2)) > -1)
          o2 += fmt.charAt(i2);
        out[out.length] = { t: "D", v: o2 };
        break;
      case " ":
        out[out.length] = { t: c2, v: c2 };
        ++i2;
        break;
      case "$":
        out[out.length] = { t: "t", v: "$" };
        ++i2;
        break;
      default:
        if (",$-+/():!^&'~{}<>=acfijklopqrtuvwxzP".indexOf(c2) === -1)
          throw new Error("unrecognized character " + c2 + " in " + fmt);
        out[out.length] = { t: "t", v: c2 };
        ++i2;
        break;
    }
  }
  var bt2 = 0, ss0 = 0, ssm;
  for (i2 = out.length - 1, lst = "t"; i2 >= 0; --i2) {
    switch (out[i2].t) {
      case "h":
      case "H":
        out[i2].t = hr;
        lst = "h";
        if (bt2 < 1)
          bt2 = 1;
        break;
      case "s":
        if (ssm = out[i2].v.match(/\.0+$/))
          ss0 = Math.max(ss0, ssm[0].length - 1);
        if (bt2 < 3)
          bt2 = 3;
      case "d":
      case "y":
      case "M":
      case "e":
        lst = out[i2].t;
        break;
      case "m":
        if (lst === "s") {
          out[i2].t = "M";
          if (bt2 < 2)
            bt2 = 2;
        }
        break;
      case "X":
        break;
      case "Z":
        if (bt2 < 1 && out[i2].v.match(/[Hh]/))
          bt2 = 1;
        if (bt2 < 2 && out[i2].v.match(/[Mm]/))
          bt2 = 2;
        if (bt2 < 3 && out[i2].v.match(/[Ss]/))
          bt2 = 3;
    }
  }
  switch (bt2) {
    case 0:
      break;
    case 1:
      if (dt2.u >= 0.5) {
        dt2.u = 0;
        ++dt2.S;
      }
      if (dt2.S >= 60) {
        dt2.S = 0;
        ++dt2.M;
      }
      if (dt2.M >= 60) {
        dt2.M = 0;
        ++dt2.H;
      }
      break;
    case 2:
      if (dt2.u >= 0.5) {
        dt2.u = 0;
        ++dt2.S;
      }
      if (dt2.S >= 60) {
        dt2.S = 0;
        ++dt2.M;
      }
      break;
  }
  var nstr = "", jj;
  for (i2 = 0; i2 < out.length; ++i2) {
    switch (out[i2].t) {
      case "t":
      case "T":
      case " ":
      case "D":
        break;
      case "X":
        out[i2].v = "";
        out[i2].t = ";";
        break;
      case "d":
      case "m":
      case "y":
      case "h":
      case "H":
      case "M":
      case "s":
      case "e":
      case "b":
      case "Z":
        out[i2].v = SSF_write_date(out[i2].t.charCodeAt(0), out[i2].v, dt2, ss0);
        out[i2].t = "t";
        break;
      case "n":
      case "?":
        jj = i2 + 1;
        while (out[jj] != null && ((c2 = out[jj].t) === "?" || c2 === "D" || (c2 === " " || c2 === "t") && out[jj + 1] != null && (out[jj + 1].t === "?" || out[jj + 1].t === "t" && out[jj + 1].v === "/") || out[i2].t === "(" && (c2 === " " || c2 === "n" || c2 === ")") || c2 === "t" && (out[jj].v === "/" || out[jj].v === " " && out[jj + 1] != null && out[jj + 1].t == "?"))) {
          out[i2].v += out[jj].v;
          out[jj] = { v: "", t: ";" };
          ++jj;
        }
        nstr += out[i2].v;
        i2 = jj - 1;
        break;
      case "G":
        out[i2].t = "t";
        out[i2].v = SSF_general(v2, opts);
        break;
    }
  }
  var vv = "", myv, ostr;
  if (nstr.length > 0) {
    if (nstr.charCodeAt(0) == 40) {
      myv = v2 < 0 && nstr.charCodeAt(0) === 45 ? -v2 : v2;
      ostr = write_num("n", nstr, myv);
    } else {
      myv = v2 < 0 && flen > 1 ? -v2 : v2;
      ostr = write_num("n", nstr, myv);
      if (myv < 0 && out[0] && out[0].t == "t") {
        ostr = ostr.substr(1);
        out[0].v = "-" + out[0].v;
      }
    }
    jj = ostr.length - 1;
    var decpt = out.length;
    for (i2 = 0; i2 < out.length; ++i2)
      if (out[i2] != null && out[i2].t != "t" && out[i2].v.indexOf(".") > -1) {
        decpt = i2;
        break;
      }
    var lasti = out.length;
    if (decpt === out.length && ostr.indexOf("E") === -1) {
      for (i2 = out.length - 1; i2 >= 0; --i2) {
        if (out[i2] == null || "n?".indexOf(out[i2].t) === -1)
          continue;
        if (jj >= out[i2].v.length - 1) {
          jj -= out[i2].v.length;
          out[i2].v = ostr.substr(jj + 1, out[i2].v.length);
        } else if (jj < 0)
          out[i2].v = "";
        else {
          out[i2].v = ostr.substr(0, jj + 1);
          jj = -1;
        }
        out[i2].t = "t";
        lasti = i2;
      }
      if (jj >= 0 && lasti < out.length)
        out[lasti].v = ostr.substr(0, jj + 1) + out[lasti].v;
    } else if (decpt !== out.length && ostr.indexOf("E") === -1) {
      jj = ostr.indexOf(".") - 1;
      for (i2 = decpt; i2 >= 0; --i2) {
        if (out[i2] == null || "n?".indexOf(out[i2].t) === -1)
          continue;
        j2 = out[i2].v.indexOf(".") > -1 && i2 === decpt ? out[i2].v.indexOf(".") - 1 : out[i2].v.length - 1;
        vv = out[i2].v.substr(j2 + 1);
        for (; j2 >= 0; --j2) {
          if (jj >= 0 && (out[i2].v.charAt(j2) === "0" || out[i2].v.charAt(j2) === "#"))
            vv = ostr.charAt(jj--) + vv;
        }
        out[i2].v = vv;
        out[i2].t = "t";
        lasti = i2;
      }
      if (jj >= 0 && lasti < out.length)
        out[lasti].v = ostr.substr(0, jj + 1) + out[lasti].v;
      jj = ostr.indexOf(".") + 1;
      for (i2 = decpt; i2 < out.length; ++i2) {
        if (out[i2] == null || "n?(".indexOf(out[i2].t) === -1 && i2 !== decpt)
          continue;
        j2 = out[i2].v.indexOf(".") > -1 && i2 === decpt ? out[i2].v.indexOf(".") + 1 : 0;
        vv = out[i2].v.substr(0, j2);
        for (; j2 < out[i2].v.length; ++j2) {
          if (jj < ostr.length)
            vv += ostr.charAt(jj++);
        }
        out[i2].v = vv;
        out[i2].t = "t";
        lasti = i2;
      }
    }
  }
  for (i2 = 0; i2 < out.length; ++i2)
    if (out[i2] != null && "n?".indexOf(out[i2].t) > -1) {
      myv = flen > 1 && v2 < 0 && i2 > 0 && out[i2 - 1].v === "-" ? -v2 : v2;
      out[i2].v = write_num(out[i2].t, out[i2].v, myv);
      out[i2].t = "t";
    }
  var retval = "";
  for (i2 = 0; i2 !== out.length; ++i2)
    if (out[i2] != null)
      retval += out[i2].v;
  return retval;
}
__name(eval_fmt, "eval_fmt");
var cfregex2 = /\[(=|>[=]?|<[>=]?)(-?\d+(?:\.\d*)?)\]/;
function chkcond(v2, rr) {
  if (rr == null)
    return false;
  var thresh = parseFloat(rr[2]);
  switch (rr[1]) {
    case "=":
      if (v2 == thresh)
        return true;
      break;
    case ">":
      if (v2 > thresh)
        return true;
      break;
    case "<":
      if (v2 < thresh)
        return true;
      break;
    case "<>":
      if (v2 != thresh)
        return true;
      break;
    case ">=":
      if (v2 >= thresh)
        return true;
      break;
    case "<=":
      if (v2 <= thresh)
        return true;
      break;
  }
  return false;
}
__name(chkcond, "chkcond");
function choose_fmt(f2, v2) {
  var fmt = SSF_split_fmt(f2);
  var l2 = fmt.length, lat = fmt[l2 - 1].indexOf("@");
  if (l2 < 4 && lat > -1)
    --l2;
  if (fmt.length > 4)
    throw new Error("cannot find right format for |" + fmt.join("|") + "|");
  if (typeof v2 !== "number")
    return [4, fmt.length === 4 || lat > -1 ? fmt[fmt.length - 1] : "@"];
  switch (fmt.length) {
    case 1:
      fmt = lat > -1 ? ["General", "General", "General", fmt[0]] : [fmt[0], fmt[0], fmt[0], "@"];
      break;
    case 2:
      fmt = lat > -1 ? [fmt[0], fmt[0], fmt[0], fmt[1]] : [fmt[0], fmt[1], fmt[0], "@"];
      break;
    case 3:
      fmt = lat > -1 ? [fmt[0], fmt[1], fmt[0], fmt[2]] : [fmt[0], fmt[1], fmt[2], "@"];
      break;
  }
  var ff = v2 > 0 ? fmt[0] : v2 < 0 ? fmt[1] : fmt[2];
  if (fmt[0].indexOf("[") === -1 && fmt[1].indexOf("[") === -1)
    return [l2, ff];
  if (fmt[0].match(/\[[=<>]/) != null || fmt[1].match(/\[[=<>]/) != null) {
    var m1 = fmt[0].match(cfregex2);
    var m2 = fmt[1].match(cfregex2);
    return chkcond(v2, m1) ? [l2, fmt[0]] : chkcond(v2, m2) ? [l2, fmt[1]] : [l2, fmt[m1 != null && m2 != null ? 2 : 1]];
  }
  return [l2, ff];
}
__name(choose_fmt, "choose_fmt");
function SSF_format(fmt, v2, o2) {
  if (o2 == null)
    o2 = {};
  var sfmt = "";
  switch (typeof fmt) {
    case "string":
      if (fmt == "m/d/yy" && o2.dateNF)
        sfmt = o2.dateNF;
      else
        sfmt = fmt;
      break;
    case "number":
      if (fmt == 14 && o2.dateNF)
        sfmt = o2.dateNF;
      else
        sfmt = (o2.table != null ? o2.table : table_fmt)[fmt];
      if (sfmt == null)
        sfmt = o2.table && o2.table[SSF_default_map[fmt]] || table_fmt[SSF_default_map[fmt]];
      if (sfmt == null)
        sfmt = SSF_default_str[fmt] || "General";
      break;
  }
  if (SSF_isgeneral(sfmt, 0))
    return SSF_general(v2, o2);
  if (v2 instanceof Date)
    v2 = datenum_local(v2, o2.date1904);
  var f2 = choose_fmt(sfmt, v2);
  if (SSF_isgeneral(f2[1]))
    return SSF_general(v2, o2);
  if (v2 === true)
    v2 = "TRUE";
  else if (v2 === false)
    v2 = "FALSE";
  else if (v2 === "" || v2 == null)
    return "";
  return eval_fmt(f2[1], v2, o2, f2[0]);
}
__name(SSF_format, "SSF_format");
function SSF_load(fmt, idx) {
  if (typeof idx != "number") {
    idx = +idx || -1;
    for (var i2 = 0; i2 < 392; ++i2) {
      if (table_fmt[i2] == void 0) {
        if (idx < 0)
          idx = i2;
        continue;
      }
      if (table_fmt[i2] == fmt) {
        idx = i2;
        break;
      }
    }
    if (idx < 0)
      idx = 391;
  }
  table_fmt[idx] = fmt;
  return idx;
}
__name(SSF_load, "SSF_load");
function SSF_load_table(tbl) {
  for (var i2 = 0; i2 != 392; ++i2)
    if (tbl[i2] !== void 0)
      SSF_load(tbl[i2], i2);
}
__name(SSF_load_table, "SSF_load_table");
function make_ssf() {
  table_fmt = SSF_init_table();
}
__name(make_ssf, "make_ssf");
var dateNFregex = /[dD]+|[mM]+|[yYeE]+|[Hh]+|[Ss]+/g;
function dateNF_regex(dateNF) {
  var fmt = typeof dateNF == "number" ? table_fmt[dateNF] : dateNF;
  fmt = fmt.replace(dateNFregex, "(\\d+)");
  return new RegExp("^" + fmt + "$");
}
__name(dateNF_regex, "dateNF_regex");
function dateNF_fix(str, dateNF, match) {
  var Y2 = -1, m2 = -1, d2 = -1, H2 = -1, M2 = -1, S2 = -1;
  (dateNF.match(dateNFregex) || []).forEach(function(n2, i2) {
    var v2 = parseInt(match[i2 + 1], 10);
    switch (n2.toLowerCase().charAt(0)) {
      case "y":
        Y2 = v2;
        break;
      case "d":
        d2 = v2;
        break;
      case "h":
        H2 = v2;
        break;
      case "s":
        S2 = v2;
        break;
      case "m":
        if (H2 >= 0)
          M2 = v2;
        else
          m2 = v2;
        break;
    }
  });
  if (S2 >= 0 && M2 == -1 && m2 >= 0) {
    M2 = m2;
    m2 = -1;
  }
  var datestr = ("" + (Y2 >= 0 ? Y2 : (/* @__PURE__ */ new Date()).getFullYear())).slice(-4) + "-" + ("00" + (m2 >= 1 ? m2 : 1)).slice(-2) + "-" + ("00" + (d2 >= 1 ? d2 : 1)).slice(-2);
  if (datestr.length == 7)
    datestr = "0" + datestr;
  if (datestr.length == 8)
    datestr = "20" + datestr;
  var timestr = ("00" + (H2 >= 0 ? H2 : 0)).slice(-2) + ":" + ("00" + (M2 >= 0 ? M2 : 0)).slice(-2) + ":" + ("00" + (S2 >= 0 ? S2 : 0)).slice(-2);
  if (H2 == -1 && M2 == -1 && S2 == -1)
    return datestr;
  if (Y2 == -1 && m2 == -1 && d2 == -1)
    return timestr;
  return datestr + "T" + timestr;
}
__name(dateNF_fix, "dateNF_fix");
var CRC32 = /* @__PURE__ */ function() {
  var CRC322 = {};
  CRC322.version = "1.2.0";
  function signed_crc_table() {
    var c2 = 0, table = new Array(256);
    for (var n2 = 0; n2 != 256; ++n2) {
      c2 = n2;
      c2 = c2 & 1 ? -306674912 ^ c2 >>> 1 : c2 >>> 1;
      c2 = c2 & 1 ? -306674912 ^ c2 >>> 1 : c2 >>> 1;
      c2 = c2 & 1 ? -306674912 ^ c2 >>> 1 : c2 >>> 1;
      c2 = c2 & 1 ? -306674912 ^ c2 >>> 1 : c2 >>> 1;
      c2 = c2 & 1 ? -306674912 ^ c2 >>> 1 : c2 >>> 1;
      c2 = c2 & 1 ? -306674912 ^ c2 >>> 1 : c2 >>> 1;
      c2 = c2 & 1 ? -306674912 ^ c2 >>> 1 : c2 >>> 1;
      c2 = c2 & 1 ? -306674912 ^ c2 >>> 1 : c2 >>> 1;
      table[n2] = c2;
    }
    return typeof Int32Array !== "undefined" ? new Int32Array(table) : table;
  }
  __name(signed_crc_table, "signed_crc_table");
  var T0 = signed_crc_table();
  function slice_by_16_tables(T10) {
    var c2 = 0, v2 = 0, n2 = 0, table = typeof Int32Array !== "undefined" ? new Int32Array(4096) : new Array(4096);
    for (n2 = 0; n2 != 256; ++n2)
      table[n2] = T10[n2];
    for (n2 = 0; n2 != 256; ++n2) {
      v2 = T10[n2];
      for (c2 = 256 + n2; c2 < 4096; c2 += 256)
        v2 = table[c2] = v2 >>> 8 ^ T10[v2 & 255];
    }
    var out = [];
    for (n2 = 1; n2 != 16; ++n2)
      out[n2 - 1] = typeof Int32Array !== "undefined" ? table.subarray(n2 * 256, n2 * 256 + 256) : table.slice(n2 * 256, n2 * 256 + 256);
    return out;
  }
  __name(slice_by_16_tables, "slice_by_16_tables");
  var TT = slice_by_16_tables(T0);
  var T1 = TT[0], T2 = TT[1], T3 = TT[2], T4 = TT[3], T5 = TT[4];
  var T6 = TT[5], T7 = TT[6], T8 = TT[7], T9 = TT[8], Ta = TT[9];
  var Tb = TT[10], Tc = TT[11], Td = TT[12], Te = TT[13], Tf = TT[14];
  function crc32_bstr(bstr, seed) {
    var C2 = seed ^ -1;
    for (var i2 = 0, L2 = bstr.length; i2 < L2; )
      C2 = C2 >>> 8 ^ T0[(C2 ^ bstr.charCodeAt(i2++)) & 255];
    return ~C2;
  }
  __name(crc32_bstr, "crc32_bstr");
  function crc32_buf(B2, seed) {
    var C2 = seed ^ -1, L2 = B2.length - 15, i2 = 0;
    for (; i2 < L2; )
      C2 = Tf[B2[i2++] ^ C2 & 255] ^ Te[B2[i2++] ^ C2 >> 8 & 255] ^ Td[B2[i2++] ^ C2 >> 16 & 255] ^ Tc[B2[i2++] ^ C2 >>> 24] ^ Tb[B2[i2++]] ^ Ta[B2[i2++]] ^ T9[B2[i2++]] ^ T8[B2[i2++]] ^ T7[B2[i2++]] ^ T6[B2[i2++]] ^ T5[B2[i2++]] ^ T4[B2[i2++]] ^ T3[B2[i2++]] ^ T2[B2[i2++]] ^ T1[B2[i2++]] ^ T0[B2[i2++]];
    L2 += 15;
    while (i2 < L2)
      C2 = C2 >>> 8 ^ T0[(C2 ^ B2[i2++]) & 255];
    return ~C2;
  }
  __name(crc32_buf, "crc32_buf");
  function crc32_str(str, seed) {
    var C2 = seed ^ -1;
    for (var i2 = 0, L2 = str.length, c2 = 0, d2 = 0; i2 < L2; ) {
      c2 = str.charCodeAt(i2++);
      if (c2 < 128) {
        C2 = C2 >>> 8 ^ T0[(C2 ^ c2) & 255];
      } else if (c2 < 2048) {
        C2 = C2 >>> 8 ^ T0[(C2 ^ (192 | c2 >> 6 & 31)) & 255];
        C2 = C2 >>> 8 ^ T0[(C2 ^ (128 | c2 & 63)) & 255];
      } else if (c2 >= 55296 && c2 < 57344) {
        c2 = (c2 & 1023) + 64;
        d2 = str.charCodeAt(i2++) & 1023;
        C2 = C2 >>> 8 ^ T0[(C2 ^ (240 | c2 >> 8 & 7)) & 255];
        C2 = C2 >>> 8 ^ T0[(C2 ^ (128 | c2 >> 2 & 63)) & 255];
        C2 = C2 >>> 8 ^ T0[(C2 ^ (128 | d2 >> 6 & 15 | (c2 & 3) << 4)) & 255];
        C2 = C2 >>> 8 ^ T0[(C2 ^ (128 | d2 & 63)) & 255];
      } else {
        C2 = C2 >>> 8 ^ T0[(C2 ^ (224 | c2 >> 12 & 15)) & 255];
        C2 = C2 >>> 8 ^ T0[(C2 ^ (128 | c2 >> 6 & 63)) & 255];
        C2 = C2 >>> 8 ^ T0[(C2 ^ (128 | c2 & 63)) & 255];
      }
    }
    return ~C2;
  }
  __name(crc32_str, "crc32_str");
  CRC322.table = T0;
  CRC322.bstr = crc32_bstr;
  CRC322.buf = crc32_buf;
  CRC322.str = crc32_str;
  return CRC322;
}();
var CFB = /* @__PURE__ */ (/* @__PURE__ */ __name(function _CFB() {
  var exports2 = {};
  exports2.version = "1.2.1";
  function namecmp(l2, r) {
    var L2 = l2.split("/"), R2 = r.split("/");
    for (var i3 = 0, c2 = 0, Z2 = Math.min(L2.length, R2.length); i3 < Z2; ++i3) {
      if (c2 = L2[i3].length - R2[i3].length)
        return c2;
      if (L2[i3] != R2[i3])
        return L2[i3] < R2[i3] ? -1 : 1;
    }
    return L2.length - R2.length;
  }
  __name(namecmp, "namecmp");
  function dirname(p2) {
    if (p2.charAt(p2.length - 1) == "/")
      return p2.slice(0, -1).indexOf("/") === -1 ? p2 : dirname(p2.slice(0, -1));
    var c2 = p2.lastIndexOf("/");
    return c2 === -1 ? p2 : p2.slice(0, c2 + 1);
  }
  __name(dirname, "dirname");
  function filename(p2) {
    if (p2.charAt(p2.length - 1) == "/")
      return filename(p2.slice(0, -1));
    var c2 = p2.lastIndexOf("/");
    return c2 === -1 ? p2 : p2.slice(c2 + 1);
  }
  __name(filename, "filename");
  function write_dos_date(buf, date) {
    if (typeof date === "string")
      date = new Date(date);
    var hms = date.getHours();
    hms = hms << 6 | date.getMinutes();
    hms = hms << 5 | date.getSeconds() >>> 1;
    buf.write_shift(2, hms);
    var ymd = date.getFullYear() - 1980;
    ymd = ymd << 4 | date.getMonth() + 1;
    ymd = ymd << 5 | date.getDate();
    buf.write_shift(2, ymd);
  }
  __name(write_dos_date, "write_dos_date");
  function parse_dos_date(buf) {
    var hms = buf.read_shift(2) & 65535;
    var ymd = buf.read_shift(2) & 65535;
    var val = /* @__PURE__ */ new Date();
    var d2 = ymd & 31;
    ymd >>>= 5;
    var m2 = ymd & 15;
    ymd >>>= 4;
    val.setMilliseconds(0);
    val.setFullYear(ymd + 1980);
    val.setMonth(m2 - 1);
    val.setDate(d2);
    var S2 = hms & 31;
    hms >>>= 5;
    var M2 = hms & 63;
    hms >>>= 6;
    val.setHours(hms);
    val.setMinutes(M2);
    val.setSeconds(S2 << 1);
    return val;
  }
  __name(parse_dos_date, "parse_dos_date");
  function parse_extra_field(blob) {
    prep_blob(blob, 0);
    var o2 = (
      /*::(*/
      {}
    );
    var flags = 0;
    while (blob.l <= blob.length - 4) {
      var type = blob.read_shift(2);
      var sz = blob.read_shift(2), tgt = blob.l + sz;
      var p2 = {};
      switch (type) {
        case 21589:
          {
            flags = blob.read_shift(1);
            if (flags & 1)
              p2.mtime = blob.read_shift(4);
            if (sz > 5) {
              if (flags & 2)
                p2.atime = blob.read_shift(4);
              if (flags & 4)
                p2.ctime = blob.read_shift(4);
            }
            if (p2.mtime)
              p2.mt = new Date(p2.mtime * 1e3);
          }
          break;
      }
      blob.l = tgt;
      o2[type] = p2;
    }
    return o2;
  }
  __name(parse_extra_field, "parse_extra_field");
  var fs;
  function get_fs() {
    return fs || (fs = {});
  }
  __name(get_fs, "get_fs");
  function parse2(file, options) {
    if (file[0] == 80 && file[1] == 75)
      return parse_zip(file, options);
    if ((file[0] | 32) == 109 && (file[1] | 32) == 105)
      return parse_mad(file, options);
    if (file.length < 512)
      throw new Error("CFB file size " + file.length + " < 512");
    var mver = 3;
    var ssz = 512;
    var nmfs = 0;
    var difat_sec_cnt = 0;
    var dir_start = 0;
    var minifat_start = 0;
    var difat_start = 0;
    var fat_addrs = [];
    var blob = (
      /*::(*/
      file.slice(0, 512)
    );
    prep_blob(blob, 0);
    var mv = check_get_mver(blob);
    mver = mv[0];
    switch (mver) {
      case 3:
        ssz = 512;
        break;
      case 4:
        ssz = 4096;
        break;
      case 0:
        if (mv[1] == 0)
          return parse_zip(file, options);
      default:
        throw new Error("Major Version: Expected 3 or 4 saw " + mver);
    }
    if (ssz !== 512) {
      blob = /*::(*/
      file.slice(0, ssz);
      prep_blob(
        blob,
        28
        /* blob.l */
      );
    }
    var header = file.slice(0, ssz);
    check_shifts(blob, mver);
    var dir_cnt = blob.read_shift(4, "i");
    if (mver === 3 && dir_cnt !== 0)
      throw new Error("# Directory Sectors: Expected 0 saw " + dir_cnt);
    blob.l += 4;
    dir_start = blob.read_shift(4, "i");
    blob.l += 4;
    blob.chk("00100000", "Mini Stream Cutoff Size: ");
    minifat_start = blob.read_shift(4, "i");
    nmfs = blob.read_shift(4, "i");
    difat_start = blob.read_shift(4, "i");
    difat_sec_cnt = blob.read_shift(4, "i");
    for (var q3 = -1, j2 = 0; j2 < 109; ++j2) {
      q3 = blob.read_shift(4, "i");
      if (q3 < 0)
        break;
      fat_addrs[j2] = q3;
    }
    var sectors = sectorify(file, ssz);
    sleuth_fat(difat_start, difat_sec_cnt, sectors, ssz, fat_addrs);
    var sector_list = make_sector_list(sectors, dir_start, fat_addrs, ssz);
    sector_list[dir_start].name = "!Directory";
    if (nmfs > 0 && minifat_start !== ENDOFCHAIN)
      sector_list[minifat_start].name = "!MiniFAT";
    sector_list[fat_addrs[0]].name = "!FAT";
    sector_list.fat_addrs = fat_addrs;
    sector_list.ssz = ssz;
    var files = {}, Paths = [], FileIndex = [], FullPaths = [];
    read_directory(dir_start, sector_list, sectors, Paths, nmfs, files, FileIndex, minifat_start);
    build_full_paths(FileIndex, FullPaths, Paths);
    Paths.shift();
    var o2 = {
      FileIndex,
      FullPaths
    };
    if (options && options.raw)
      o2.raw = { header, sectors };
    return o2;
  }
  __name(parse2, "parse");
  function check_get_mver(blob) {
    if (blob[blob.l] == 80 && blob[blob.l + 1] == 75)
      return [0, 0];
    blob.chk(HEADER_SIGNATURE, "Header Signature: ");
    blob.l += 16;
    var mver = blob.read_shift(2, "u");
    return [blob.read_shift(2, "u"), mver];
  }
  __name(check_get_mver, "check_get_mver");
  function check_shifts(blob, mver) {
    var shift = 9;
    blob.l += 2;
    switch (shift = blob.read_shift(2)) {
      case 9:
        if (mver != 3)
          throw new Error("Sector Shift: Expected 9 saw " + shift);
        break;
      case 12:
        if (mver != 4)
          throw new Error("Sector Shift: Expected 12 saw " + shift);
        break;
      default:
        throw new Error("Sector Shift: Expected 9 or 12 saw " + shift);
    }
    blob.chk("0600", "Mini Sector Shift: ");
    blob.chk("000000000000", "Reserved: ");
  }
  __name(check_shifts, "check_shifts");
  function sectorify(file, ssz) {
    var nsectors = Math.ceil(file.length / ssz) - 1;
    var sectors = [];
    for (var i3 = 1; i3 < nsectors; ++i3)
      sectors[i3 - 1] = file.slice(i3 * ssz, (i3 + 1) * ssz);
    sectors[nsectors - 1] = file.slice(nsectors * ssz);
    return sectors;
  }
  __name(sectorify, "sectorify");
  function build_full_paths(FI, FP, Paths) {
    var i3 = 0, L2 = 0, R2 = 0, C2 = 0, j2 = 0, pl = Paths.length;
    var dad = [], q3 = [];
    for (; i3 < pl; ++i3) {
      dad[i3] = q3[i3] = i3;
      FP[i3] = Paths[i3];
    }
    for (; j2 < q3.length; ++j2) {
      i3 = q3[j2];
      L2 = FI[i3].L;
      R2 = FI[i3].R;
      C2 = FI[i3].C;
      if (dad[i3] === i3) {
        if (L2 !== -1 && dad[L2] !== L2)
          dad[i3] = dad[L2];
        if (R2 !== -1 && dad[R2] !== R2)
          dad[i3] = dad[R2];
      }
      if (C2 !== -1)
        dad[C2] = i3;
      if (L2 !== -1 && i3 != dad[i3]) {
        dad[L2] = dad[i3];
        if (q3.lastIndexOf(L2) < j2)
          q3.push(L2);
      }
      if (R2 !== -1 && i3 != dad[i3]) {
        dad[R2] = dad[i3];
        if (q3.lastIndexOf(R2) < j2)
          q3.push(R2);
      }
    }
    for (i3 = 1; i3 < pl; ++i3)
      if (dad[i3] === i3) {
        if (R2 !== -1 && dad[R2] !== R2)
          dad[i3] = dad[R2];
        else if (L2 !== -1 && dad[L2] !== L2)
          dad[i3] = dad[L2];
      }
    for (i3 = 1; i3 < pl; ++i3) {
      if (FI[i3].type === 0)
        continue;
      j2 = i3;
      if (j2 != dad[j2])
        do {
          j2 = dad[j2];
          FP[i3] = FP[j2] + "/" + FP[i3];
        } while (j2 !== 0 && -1 !== dad[j2] && j2 != dad[j2]);
      dad[i3] = -1;
    }
    FP[0] += "/";
    for (i3 = 1; i3 < pl; ++i3) {
      if (FI[i3].type !== 2)
        FP[i3] += "/";
    }
  }
  __name(build_full_paths, "build_full_paths");
  function get_mfat_entry(entry, payload, mini) {
    var start = entry.start, size = entry.size;
    var o2 = [];
    var idx = start;
    while (mini && size > 0 && idx >= 0) {
      o2.push(payload.slice(idx * MSSZ, idx * MSSZ + MSSZ));
      size -= MSSZ;
      idx = __readInt32LE(mini, idx * 4);
    }
    if (o2.length === 0)
      return new_buf(0);
    return bconcat(o2).slice(0, entry.size);
  }
  __name(get_mfat_entry, "get_mfat_entry");
  function sleuth_fat(idx, cnt, sectors, ssz, fat_addrs) {
    var q3 = ENDOFCHAIN;
    if (idx === ENDOFCHAIN) {
      if (cnt !== 0)
        throw new Error("DIFAT chain shorter than expected");
    } else if (idx !== -1) {
      var sector = sectors[idx], m2 = (ssz >>> 2) - 1;
      if (!sector)
        return;
      for (var i3 = 0; i3 < m2; ++i3) {
        if ((q3 = __readInt32LE(sector, i3 * 4)) === ENDOFCHAIN)
          break;
        fat_addrs.push(q3);
      }
      sleuth_fat(__readInt32LE(sector, ssz - 4), cnt - 1, sectors, ssz, fat_addrs);
    }
  }
  __name(sleuth_fat, "sleuth_fat");
  function get_sector_list(sectors, start, fat_addrs, ssz, chkd) {
    var buf = [], buf_chain = [];
    if (!chkd)
      chkd = [];
    var modulus = ssz - 1, j2 = 0, jj = 0;
    for (j2 = start; j2 >= 0; ) {
      chkd[j2] = true;
      buf[buf.length] = j2;
      buf_chain.push(sectors[j2]);
      var addr = fat_addrs[Math.floor(j2 * 4 / ssz)];
      jj = j2 * 4 & modulus;
      if (ssz < 4 + jj)
        throw new Error("FAT boundary crossed: " + j2 + " 4 " + ssz);
      if (!sectors[addr])
        break;
      j2 = __readInt32LE(sectors[addr], jj);
    }
    return { nodes: buf, data: __toBuffer([buf_chain]) };
  }
  __name(get_sector_list, "get_sector_list");
  function make_sector_list(sectors, dir_start, fat_addrs, ssz) {
    var sl = sectors.length, sector_list = [];
    var chkd = [], buf = [], buf_chain = [];
    var modulus = ssz - 1, i3 = 0, j2 = 0, k2 = 0, jj = 0;
    for (i3 = 0; i3 < sl; ++i3) {
      buf = [];
      k2 = i3 + dir_start;
      if (k2 >= sl)
        k2 -= sl;
      if (chkd[k2])
        continue;
      buf_chain = [];
      var seen2 = [];
      for (j2 = k2; j2 >= 0; ) {
        seen2[j2] = true;
        chkd[j2] = true;
        buf[buf.length] = j2;
        buf_chain.push(sectors[j2]);
        var addr = fat_addrs[Math.floor(j2 * 4 / ssz)];
        jj = j2 * 4 & modulus;
        if (ssz < 4 + jj)
          throw new Error("FAT boundary crossed: " + j2 + " 4 " + ssz);
        if (!sectors[addr])
          break;
        j2 = __readInt32LE(sectors[addr], jj);
        if (seen2[j2])
          break;
      }
      sector_list[k2] = { nodes: buf, data: __toBuffer([buf_chain]) };
    }
    return sector_list;
  }
  __name(make_sector_list, "make_sector_list");
  function read_directory(dir_start, sector_list, sectors, Paths, nmfs, files, FileIndex, mini) {
    var minifat_store = 0, pl = Paths.length ? 2 : 0;
    var sector = sector_list[dir_start].data;
    var i3 = 0, namelen = 0, name;
    for (; i3 < sector.length; i3 += 128) {
      var blob = (
        /*::(*/
        sector.slice(i3, i3 + 128)
      );
      prep_blob(blob, 64);
      namelen = blob.read_shift(2);
      name = __utf16le(blob, 0, namelen - pl);
      Paths.push(name);
      var o2 = {
        name,
        type: blob.read_shift(1),
        color: blob.read_shift(1),
        L: blob.read_shift(4, "i"),
        R: blob.read_shift(4, "i"),
        C: blob.read_shift(4, "i"),
        clsid: blob.read_shift(16),
        state: blob.read_shift(4, "i"),
        start: 0,
        size: 0
      };
      var ctime = blob.read_shift(2) + blob.read_shift(2) + blob.read_shift(2) + blob.read_shift(2);
      if (ctime !== 0)
        o2.ct = read_date(blob, blob.l - 8);
      var mtime = blob.read_shift(2) + blob.read_shift(2) + blob.read_shift(2) + blob.read_shift(2);
      if (mtime !== 0)
        o2.mt = read_date(blob, blob.l - 8);
      o2.start = blob.read_shift(4, "i");
      o2.size = blob.read_shift(4, "i");
      if (o2.size < 0 && o2.start < 0) {
        o2.size = o2.type = 0;
        o2.start = ENDOFCHAIN;
        o2.name = "";
      }
      if (o2.type === 5) {
        minifat_store = o2.start;
        if (nmfs > 0 && minifat_store !== ENDOFCHAIN)
          sector_list[minifat_store].name = "!StreamData";
      } else if (o2.size >= 4096) {
        o2.storage = "fat";
        if (sector_list[o2.start] === void 0)
          sector_list[o2.start] = get_sector_list(sectors, o2.start, sector_list.fat_addrs, sector_list.ssz);
        sector_list[o2.start].name = o2.name;
        o2.content = sector_list[o2.start].data.slice(0, o2.size);
      } else {
        o2.storage = "minifat";
        if (o2.size < 0)
          o2.size = 0;
        else if (minifat_store !== ENDOFCHAIN && o2.start !== ENDOFCHAIN && sector_list[minifat_store]) {
          o2.content = get_mfat_entry(o2, sector_list[minifat_store].data, (sector_list[mini] || {}).data);
        }
      }
      if (o2.content)
        prep_blob(o2.content, 0);
      files[name] = o2;
      FileIndex.push(o2);
    }
  }
  __name(read_directory, "read_directory");
  function read_date(blob, offset) {
    return new Date((__readUInt32LE(blob, offset + 4) / 1e7 * Math.pow(2, 32) + __readUInt32LE(blob, offset) / 1e7 - 11644473600) * 1e3);
  }
  __name(read_date, "read_date");
  function read_file(filename2, options) {
    get_fs();
    return parse2(fs.readFileSync(filename2), options);
  }
  __name(read_file, "read_file");
  function read(blob, options) {
    var type = options && options.type;
    if (!type) {
      if (has_buf && Buffer.isBuffer(blob))
        type = "buffer";
    }
    switch (type || "base64") {
      case "file":
        return read_file(blob, options);
      case "base64":
        return parse2(s2a(Base64_decode(blob)), options);
      case "binary":
        return parse2(s2a(blob), options);
    }
    return parse2(
      /*::typeof blob == 'string' ? new Buffer(blob, 'utf-8') : */
      blob,
      options
    );
  }
  __name(read, "read");
  function init_cfb(cfb, opts) {
    var o2 = opts || {}, root = o2.root || "Root Entry";
    if (!cfb.FullPaths)
      cfb.FullPaths = [];
    if (!cfb.FileIndex)
      cfb.FileIndex = [];
    if (cfb.FullPaths.length !== cfb.FileIndex.length)
      throw new Error("inconsistent CFB structure");
    if (cfb.FullPaths.length === 0) {
      cfb.FullPaths[0] = root + "/";
      cfb.FileIndex[0] = { name: root, type: 5 };
    }
    if (o2.CLSID)
      cfb.FileIndex[0].clsid = o2.CLSID;
    seed_cfb(cfb);
  }
  __name(init_cfb, "init_cfb");
  function seed_cfb(cfb) {
    var nm = "Sh33tJ5";
    if (CFB.find(cfb, "/" + nm))
      return;
    var p2 = new_buf(4);
    p2[0] = 55;
    p2[1] = p2[3] = 50;
    p2[2] = 54;
    cfb.FileIndex.push({ name: nm, type: 2, content: p2, size: 4, L: 69, R: 69, C: 69 });
    cfb.FullPaths.push(cfb.FullPaths[0] + nm);
    rebuild_cfb(cfb);
  }
  __name(seed_cfb, "seed_cfb");
  function rebuild_cfb(cfb, f2) {
    init_cfb(cfb);
    var gc = false, s2 = false;
    for (var i3 = cfb.FullPaths.length - 1; i3 >= 0; --i3) {
      var _file = cfb.FileIndex[i3];
      switch (_file.type) {
        case 0:
          if (s2)
            gc = true;
          else {
            cfb.FileIndex.pop();
            cfb.FullPaths.pop();
          }
          break;
        case 1:
        case 2:
        case 5:
          s2 = true;
          if (isNaN(_file.R * _file.L * _file.C))
            gc = true;
          if (_file.R > -1 && _file.L > -1 && _file.R == _file.L)
            gc = true;
          break;
        default:
          gc = true;
          break;
      }
    }
    if (!gc && !f2)
      return;
    var now = new Date(1987, 1, 19), j2 = 0;
    var fullPaths = Object.create ? /* @__PURE__ */ Object.create(null) : {};
    var data = [];
    for (i3 = 0; i3 < cfb.FullPaths.length; ++i3) {
      fullPaths[cfb.FullPaths[i3]] = true;
      if (cfb.FileIndex[i3].type === 0)
        continue;
      data.push([cfb.FullPaths[i3], cfb.FileIndex[i3]]);
    }
    for (i3 = 0; i3 < data.length; ++i3) {
      var dad = dirname(data[i3][0]);
      s2 = fullPaths[dad];
      if (!s2) {
        data.push([dad, {
          name: filename(dad).replace("/", ""),
          type: 1,
          clsid: HEADER_CLSID,
          ct: now,
          mt: now,
          content: null
        }]);
        fullPaths[dad] = true;
      }
    }
    data.sort(function(x2, y2) {
      return namecmp(x2[0], y2[0]);
    });
    cfb.FullPaths = [];
    cfb.FileIndex = [];
    for (i3 = 0; i3 < data.length; ++i3) {
      cfb.FullPaths[i3] = data[i3][0];
      cfb.FileIndex[i3] = data[i3][1];
    }
    for (i3 = 0; i3 < data.length; ++i3) {
      var elt = cfb.FileIndex[i3];
      var nm = cfb.FullPaths[i3];
      elt.name = filename(nm).replace("/", "");
      elt.L = elt.R = elt.C = -(elt.color = 1);
      elt.size = elt.content ? elt.content.length : 0;
      elt.start = 0;
      elt.clsid = elt.clsid || HEADER_CLSID;
      if (i3 === 0) {
        elt.C = data.length > 1 ? 1 : -1;
        elt.size = 0;
        elt.type = 5;
      } else if (nm.slice(-1) == "/") {
        for (j2 = i3 + 1; j2 < data.length; ++j2)
          if (dirname(cfb.FullPaths[j2]) == nm)
            break;
        elt.C = j2 >= data.length ? -1 : j2;
        for (j2 = i3 + 1; j2 < data.length; ++j2)
          if (dirname(cfb.FullPaths[j2]) == dirname(nm))
            break;
        elt.R = j2 >= data.length ? -1 : j2;
        elt.type = 1;
      } else {
        if (dirname(cfb.FullPaths[i3 + 1] || "") == dirname(nm))
          elt.R = i3 + 1;
        elt.type = 2;
      }
    }
  }
  __name(rebuild_cfb, "rebuild_cfb");
  function _write(cfb, options) {
    var _opts = options || {};
    if (_opts.fileType == "mad")
      return write_mad(cfb, _opts);
    rebuild_cfb(cfb);
    switch (_opts.fileType) {
      case "zip":
        return write_zip2(cfb, _opts);
    }
    var L2 = function(cfb2) {
      var mini_size = 0, fat_size = 0;
      for (var i4 = 0; i4 < cfb2.FileIndex.length; ++i4) {
        var file2 = cfb2.FileIndex[i4];
        if (!file2.content)
          continue;
        var flen2 = file2.content.length;
        if (flen2 > 0) {
          if (flen2 < 4096)
            mini_size += flen2 + 63 >> 6;
          else
            fat_size += flen2 + 511 >> 9;
        }
      }
      var dir_cnt = cfb2.FullPaths.length + 3 >> 2;
      var mini_cnt = mini_size + 7 >> 3;
      var mfat_cnt = mini_size + 127 >> 7;
      var fat_base = mini_cnt + fat_size + dir_cnt + mfat_cnt;
      var fat_cnt = fat_base + 127 >> 7;
      var difat_cnt = fat_cnt <= 109 ? 0 : Math.ceil((fat_cnt - 109) / 127);
      while (fat_base + fat_cnt + difat_cnt + 127 >> 7 > fat_cnt)
        difat_cnt = ++fat_cnt <= 109 ? 0 : Math.ceil((fat_cnt - 109) / 127);
      var L3 = [1, difat_cnt, fat_cnt, mfat_cnt, dir_cnt, fat_size, mini_size, 0];
      cfb2.FileIndex[0].size = mini_size << 6;
      L3[7] = (cfb2.FileIndex[0].start = L3[0] + L3[1] + L3[2] + L3[3] + L3[4] + L3[5]) + (L3[6] + 7 >> 3);
      return L3;
    }(cfb);
    var o2 = new_buf(L2[7] << 9);
    var i3 = 0, T2 = 0;
    {
      for (i3 = 0; i3 < 8; ++i3)
        o2.write_shift(1, HEADER_SIG[i3]);
      for (i3 = 0; i3 < 8; ++i3)
        o2.write_shift(2, 0);
      o2.write_shift(2, 62);
      o2.write_shift(2, 3);
      o2.write_shift(2, 65534);
      o2.write_shift(2, 9);
      o2.write_shift(2, 6);
      for (i3 = 0; i3 < 3; ++i3)
        o2.write_shift(2, 0);
      o2.write_shift(4, 0);
      o2.write_shift(4, L2[2]);
      o2.write_shift(4, L2[0] + L2[1] + L2[2] + L2[3] - 1);
      o2.write_shift(4, 0);
      o2.write_shift(4, 1 << 12);
      o2.write_shift(4, L2[3] ? L2[0] + L2[1] + L2[2] - 1 : ENDOFCHAIN);
      o2.write_shift(4, L2[3]);
      o2.write_shift(-4, L2[1] ? L2[0] - 1 : ENDOFCHAIN);
      o2.write_shift(4, L2[1]);
      for (i3 = 0; i3 < 109; ++i3)
        o2.write_shift(-4, i3 < L2[2] ? L2[1] + i3 : -1);
    }
    if (L2[1]) {
      for (T2 = 0; T2 < L2[1]; ++T2) {
        for (; i3 < 236 + T2 * 127; ++i3)
          o2.write_shift(-4, i3 < L2[2] ? L2[1] + i3 : -1);
        o2.write_shift(-4, T2 === L2[1] - 1 ? ENDOFCHAIN : T2 + 1);
      }
    }
    var chainit = /* @__PURE__ */ __name(function(w2) {
      for (T2 += w2; i3 < T2 - 1; ++i3)
        o2.write_shift(-4, i3 + 1);
      if (w2) {
        ++i3;
        o2.write_shift(-4, ENDOFCHAIN);
      }
    }, "chainit");
    T2 = i3 = 0;
    for (T2 += L2[1]; i3 < T2; ++i3)
      o2.write_shift(-4, consts.DIFSECT);
    for (T2 += L2[2]; i3 < T2; ++i3)
      o2.write_shift(-4, consts.FATSECT);
    chainit(L2[3]);
    chainit(L2[4]);
    var j2 = 0, flen = 0;
    var file = cfb.FileIndex[0];
    for (; j2 < cfb.FileIndex.length; ++j2) {
      file = cfb.FileIndex[j2];
      if (!file.content)
        continue;
      flen = file.content.length;
      if (flen < 4096)
        continue;
      file.start = T2;
      chainit(flen + 511 >> 9);
    }
    chainit(L2[6] + 7 >> 3);
    while (o2.l & 511)
      o2.write_shift(-4, consts.ENDOFCHAIN);
    T2 = i3 = 0;
    for (j2 = 0; j2 < cfb.FileIndex.length; ++j2) {
      file = cfb.FileIndex[j2];
      if (!file.content)
        continue;
      flen = file.content.length;
      if (!flen || flen >= 4096)
        continue;
      file.start = T2;
      chainit(flen + 63 >> 6);
    }
    while (o2.l & 511)
      o2.write_shift(-4, consts.ENDOFCHAIN);
    for (i3 = 0; i3 < L2[4] << 2; ++i3) {
      var nm = cfb.FullPaths[i3];
      if (!nm || nm.length === 0) {
        for (j2 = 0; j2 < 17; ++j2)
          o2.write_shift(4, 0);
        for (j2 = 0; j2 < 3; ++j2)
          o2.write_shift(4, -1);
        for (j2 = 0; j2 < 12; ++j2)
          o2.write_shift(4, 0);
        continue;
      }
      file = cfb.FileIndex[i3];
      if (i3 === 0)
        file.start = file.size ? file.start - 1 : ENDOFCHAIN;
      var _nm = i3 === 0 && _opts.root || file.name;
      flen = 2 * (_nm.length + 1);
      o2.write_shift(64, _nm, "utf16le");
      o2.write_shift(2, flen);
      o2.write_shift(1, file.type);
      o2.write_shift(1, file.color);
      o2.write_shift(-4, file.L);
      o2.write_shift(-4, file.R);
      o2.write_shift(-4, file.C);
      if (!file.clsid)
        for (j2 = 0; j2 < 4; ++j2)
          o2.write_shift(4, 0);
      else
        o2.write_shift(16, file.clsid, "hex");
      o2.write_shift(4, file.state || 0);
      o2.write_shift(4, 0);
      o2.write_shift(4, 0);
      o2.write_shift(4, 0);
      o2.write_shift(4, 0);
      o2.write_shift(4, file.start);
      o2.write_shift(4, file.size);
      o2.write_shift(4, 0);
    }
    for (i3 = 1; i3 < cfb.FileIndex.length; ++i3) {
      file = cfb.FileIndex[i3];
      if (file.size >= 4096) {
        o2.l = file.start + 1 << 9;
        if (has_buf && Buffer.isBuffer(file.content)) {
          file.content.copy(o2, o2.l, 0, file.size);
          o2.l += file.size + 511 & -512;
        } else {
          for (j2 = 0; j2 < file.size; ++j2)
            o2.write_shift(1, file.content[j2]);
          for (; j2 & 511; ++j2)
            o2.write_shift(1, 0);
        }
      }
    }
    for (i3 = 1; i3 < cfb.FileIndex.length; ++i3) {
      file = cfb.FileIndex[i3];
      if (file.size > 0 && file.size < 4096) {
        if (has_buf && Buffer.isBuffer(file.content)) {
          file.content.copy(o2, o2.l, 0, file.size);
          o2.l += file.size + 63 & -64;
        } else {
          for (j2 = 0; j2 < file.size; ++j2)
            o2.write_shift(1, file.content[j2]);
          for (; j2 & 63; ++j2)
            o2.write_shift(1, 0);
        }
      }
    }
    if (has_buf) {
      o2.l = o2.length;
    } else {
      while (o2.l < o2.length)
        o2.write_shift(1, 0);
    }
    return o2;
  }
  __name(_write, "_write");
  function find(cfb, path) {
    var UCFullPaths = cfb.FullPaths.map(function(x2) {
      return x2.toUpperCase();
    });
    var UCPaths = UCFullPaths.map(function(x2) {
      var y2 = x2.split("/");
      return y2[y2.length - (x2.slice(-1) == "/" ? 2 : 1)];
    });
    var k2 = false;
    if (path.charCodeAt(0) === 47) {
      k2 = true;
      path = UCFullPaths[0].slice(0, -1) + path;
    } else
      k2 = path.indexOf("/") !== -1;
    var UCPath = path.toUpperCase();
    var w2 = k2 === true ? UCFullPaths.indexOf(UCPath) : UCPaths.indexOf(UCPath);
    if (w2 !== -1)
      return cfb.FileIndex[w2];
    var m2 = !UCPath.match(chr1);
    UCPath = UCPath.replace(chr0, "");
    if (m2)
      UCPath = UCPath.replace(chr1, "!");
    for (w2 = 0; w2 < UCFullPaths.length; ++w2) {
      if ((m2 ? UCFullPaths[w2].replace(chr1, "!") : UCFullPaths[w2]).replace(chr0, "") == UCPath)
        return cfb.FileIndex[w2];
      if ((m2 ? UCPaths[w2].replace(chr1, "!") : UCPaths[w2]).replace(chr0, "") == UCPath)
        return cfb.FileIndex[w2];
    }
    return null;
  }
  __name(find, "find");
  var MSSZ = 64;
  var ENDOFCHAIN = -2;
  var HEADER_SIGNATURE = "d0cf11e0a1b11ae1";
  var HEADER_SIG = [208, 207, 17, 224, 161, 177, 26, 225];
  var HEADER_CLSID = "00000000000000000000000000000000";
  var consts = {
    /* 2.1 Compund File Sector Numbers and Types */
    MAXREGSECT: -6,
    DIFSECT: -4,
    FATSECT: -3,
    ENDOFCHAIN,
    FREESECT: -1,
    /* 2.2 Compound File Header */
    HEADER_SIGNATURE,
    HEADER_MINOR_VERSION: "3e00",
    MAXREGSID: -6,
    NOSTREAM: -1,
    HEADER_CLSID,
    /* 2.6.1 Compound File Directory Entry */
    EntryTypes: ["unknown", "storage", "stream", "lockbytes", "property", "root"]
  };
  function write_file(cfb, filename2, options) {
    get_fs();
    var o2 = _write(cfb, options);
    fs.writeFileSync(filename2, o2);
  }
  __name(write_file, "write_file");
  function a2s2(o2) {
    var out = new Array(o2.length);
    for (var i3 = 0; i3 < o2.length; ++i3)
      out[i3] = String.fromCharCode(o2[i3]);
    return out.join("");
  }
  __name(a2s2, "a2s");
  function write(cfb, options) {
    var o2 = _write(cfb, options);
    switch (options && options.type || "buffer") {
      case "file":
        get_fs();
        fs.writeFileSync(options.filename, o2);
        return o2;
      case "binary":
        return typeof o2 == "string" ? o2 : a2s2(o2);
      case "base64":
        return Base64_encode(typeof o2 == "string" ? o2 : a2s2(o2));
      case "buffer":
        if (has_buf)
          return Buffer.isBuffer(o2) ? o2 : Buffer_from(o2);
      case "array":
        return typeof o2 == "string" ? s2a(o2) : o2;
    }
    return o2;
  }
  __name(write, "write");
  var _zlib;
  function use_zlib(zlib) {
    try {
      var InflateRaw = zlib.InflateRaw;
      var InflRaw = new InflateRaw();
      InflRaw._processChunk(new Uint8Array([3, 0]), InflRaw._finishFlushFlag);
      if (InflRaw.bytesRead)
        _zlib = zlib;
      else
        throw new Error("zlib does not expose bytesRead");
    } catch (e) {
      console.error("cannot use native zlib: " + (e.message || e));
    }
  }
  __name(use_zlib, "use_zlib");
  function _inflateRawSync(payload, usz) {
    if (!_zlib)
      return _inflate(payload, usz);
    var InflateRaw = _zlib.InflateRaw;
    var InflRaw = new InflateRaw();
    var out = InflRaw._processChunk(payload.slice(payload.l), InflRaw._finishFlushFlag);
    payload.l += InflRaw.bytesRead;
    return out;
  }
  __name(_inflateRawSync, "_inflateRawSync");
  function _deflateRawSync(payload) {
    return _zlib ? _zlib.deflateRawSync(payload) : _deflate(payload);
  }
  __name(_deflateRawSync, "_deflateRawSync");
  var CLEN_ORDER = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
  var LEN_LN = [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258];
  var DST_LN = [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577];
  function bit_swap_8(n2) {
    var t2 = (n2 << 1 | n2 << 11) & 139536 | (n2 << 5 | n2 << 15) & 558144;
    return (t2 >> 16 | t2 >> 8 | t2) & 255;
  }
  __name(bit_swap_8, "bit_swap_8");
  var use_typed_arrays = typeof Uint8Array !== "undefined";
  var bitswap8 = use_typed_arrays ? new Uint8Array(1 << 8) : [];
  for (var q2 = 0; q2 < 1 << 8; ++q2)
    bitswap8[q2] = bit_swap_8(q2);
  function bit_swap_n(n2, b2) {
    var rev2 = bitswap8[n2 & 255];
    if (b2 <= 8)
      return rev2 >>> 8 - b2;
    rev2 = rev2 << 8 | bitswap8[n2 >> 8 & 255];
    if (b2 <= 16)
      return rev2 >>> 16 - b2;
    rev2 = rev2 << 8 | bitswap8[n2 >> 16 & 255];
    return rev2 >>> 24 - b2;
  }
  __name(bit_swap_n, "bit_swap_n");
  function read_bits_2(buf, bl) {
    var w2 = bl & 7, h3 = bl >>> 3;
    return (buf[h3] | (w2 <= 6 ? 0 : buf[h3 + 1] << 8)) >>> w2 & 3;
  }
  __name(read_bits_2, "read_bits_2");
  function read_bits_3(buf, bl) {
    var w2 = bl & 7, h3 = bl >>> 3;
    return (buf[h3] | (w2 <= 5 ? 0 : buf[h3 + 1] << 8)) >>> w2 & 7;
  }
  __name(read_bits_3, "read_bits_3");
  function read_bits_4(buf, bl) {
    var w2 = bl & 7, h3 = bl >>> 3;
    return (buf[h3] | (w2 <= 4 ? 0 : buf[h3 + 1] << 8)) >>> w2 & 15;
  }
  __name(read_bits_4, "read_bits_4");
  function read_bits_5(buf, bl) {
    var w2 = bl & 7, h3 = bl >>> 3;
    return (buf[h3] | (w2 <= 3 ? 0 : buf[h3 + 1] << 8)) >>> w2 & 31;
  }
  __name(read_bits_5, "read_bits_5");
  function read_bits_7(buf, bl) {
    var w2 = bl & 7, h3 = bl >>> 3;
    return (buf[h3] | (w2 <= 1 ? 0 : buf[h3 + 1] << 8)) >>> w2 & 127;
  }
  __name(read_bits_7, "read_bits_7");
  function read_bits_n(buf, bl, n2) {
    var w2 = bl & 7, h3 = bl >>> 3, f2 = (1 << n2) - 1;
    var v2 = buf[h3] >>> w2;
    if (n2 < 8 - w2)
      return v2 & f2;
    v2 |= buf[h3 + 1] << 8 - w2;
    if (n2 < 16 - w2)
      return v2 & f2;
    v2 |= buf[h3 + 2] << 16 - w2;
    if (n2 < 24 - w2)
      return v2 & f2;
    v2 |= buf[h3 + 3] << 24 - w2;
    return v2 & f2;
  }
  __name(read_bits_n, "read_bits_n");
  function write_bits_3(buf, bl, v2) {
    var w2 = bl & 7, h3 = bl >>> 3;
    if (w2 <= 5)
      buf[h3] |= (v2 & 7) << w2;
    else {
      buf[h3] |= v2 << w2 & 255;
      buf[h3 + 1] = (v2 & 7) >> 8 - w2;
    }
    return bl + 3;
  }
  __name(write_bits_3, "write_bits_3");
  function write_bits_1(buf, bl, v2) {
    var w2 = bl & 7, h3 = bl >>> 3;
    v2 = (v2 & 1) << w2;
    buf[h3] |= v2;
    return bl + 1;
  }
  __name(write_bits_1, "write_bits_1");
  function write_bits_8(buf, bl, v2) {
    var w2 = bl & 7, h3 = bl >>> 3;
    v2 <<= w2;
    buf[h3] |= v2 & 255;
    v2 >>>= 8;
    buf[h3 + 1] = v2;
    return bl + 8;
  }
  __name(write_bits_8, "write_bits_8");
  function write_bits_16(buf, bl, v2) {
    var w2 = bl & 7, h3 = bl >>> 3;
    v2 <<= w2;
    buf[h3] |= v2 & 255;
    v2 >>>= 8;
    buf[h3 + 1] = v2 & 255;
    buf[h3 + 2] = v2 >>> 8;
    return bl + 16;
  }
  __name(write_bits_16, "write_bits_16");
  function realloc(b2, sz) {
    var L2 = b2.length, M2 = 2 * L2 > sz ? 2 * L2 : sz + 5, i3 = 0;
    if (L2 >= sz)
      return b2;
    if (has_buf) {
      var o2 = new_unsafe_buf(M2);
      if (b2.copy)
        b2.copy(o2);
      else
        for (; i3 < b2.length; ++i3)
          o2[i3] = b2[i3];
      return o2;
    } else if (use_typed_arrays) {
      var a2 = new Uint8Array(M2);
      if (a2.set)
        a2.set(b2);
      else
        for (; i3 < L2; ++i3)
          a2[i3] = b2[i3];
      return a2;
    }
    b2.length = M2;
    return b2;
  }
  __name(realloc, "realloc");
  function zero_fill_array(n2) {
    var o2 = new Array(n2);
    for (var i3 = 0; i3 < n2; ++i3)
      o2[i3] = 0;
    return o2;
  }
  __name(zero_fill_array, "zero_fill_array");
  function build_tree(clens, cmap, MAX) {
    var maxlen = 1, w2 = 0, i3 = 0, j2 = 0, ccode = 0, L2 = clens.length;
    var bl_count = use_typed_arrays ? new Uint16Array(32) : zero_fill_array(32);
    for (i3 = 0; i3 < 32; ++i3)
      bl_count[i3] = 0;
    for (i3 = L2; i3 < MAX; ++i3)
      clens[i3] = 0;
    L2 = clens.length;
    var ctree = use_typed_arrays ? new Uint16Array(L2) : zero_fill_array(L2);
    for (i3 = 0; i3 < L2; ++i3) {
      bl_count[w2 = clens[i3]]++;
      if (maxlen < w2)
        maxlen = w2;
      ctree[i3] = 0;
    }
    bl_count[0] = 0;
    for (i3 = 1; i3 <= maxlen; ++i3)
      bl_count[i3 + 16] = ccode = ccode + bl_count[i3 - 1] << 1;
    for (i3 = 0; i3 < L2; ++i3) {
      ccode = clens[i3];
      if (ccode != 0)
        ctree[i3] = bl_count[ccode + 16]++;
    }
    var cleni = 0;
    for (i3 = 0; i3 < L2; ++i3) {
      cleni = clens[i3];
      if (cleni != 0) {
        ccode = bit_swap_n(ctree[i3], maxlen) >> maxlen - cleni;
        for (j2 = (1 << maxlen + 4 - cleni) - 1; j2 >= 0; --j2)
          cmap[ccode | j2 << cleni] = cleni & 15 | i3 << 4;
      }
    }
    return maxlen;
  }
  __name(build_tree, "build_tree");
  var fix_lmap = use_typed_arrays ? new Uint16Array(512) : zero_fill_array(512);
  var fix_dmap = use_typed_arrays ? new Uint16Array(32) : zero_fill_array(32);
  if (!use_typed_arrays) {
    for (var i2 = 0; i2 < 512; ++i2)
      fix_lmap[i2] = 0;
    for (i2 = 0; i2 < 32; ++i2)
      fix_dmap[i2] = 0;
  }
  (function() {
    var dlens = [];
    var i3 = 0;
    for (; i3 < 32; i3++)
      dlens.push(5);
    build_tree(dlens, fix_dmap, 32);
    var clens = [];
    i3 = 0;
    for (; i3 <= 143; i3++)
      clens.push(8);
    for (; i3 <= 255; i3++)
      clens.push(9);
    for (; i3 <= 279; i3++)
      clens.push(7);
    for (; i3 <= 287; i3++)
      clens.push(8);
    build_tree(clens, fix_lmap, 288);
  })();
  var _deflateRaw = /* @__PURE__ */ (/* @__PURE__ */ __name(function _deflateRawIIFE() {
    var DST_LN_RE = use_typed_arrays ? new Uint8Array(32768) : [];
    var j2 = 0, k2 = 0;
    for (; j2 < DST_LN.length - 1; ++j2) {
      for (; k2 < DST_LN[j2 + 1]; ++k2)
        DST_LN_RE[k2] = j2;
    }
    for (; k2 < 32768; ++k2)
      DST_LN_RE[k2] = 29;
    var LEN_LN_RE = use_typed_arrays ? new Uint8Array(259) : [];
    for (j2 = 0, k2 = 0; j2 < LEN_LN.length - 1; ++j2) {
      for (; k2 < LEN_LN[j2 + 1]; ++k2)
        LEN_LN_RE[k2] = j2;
    }
    function write_stored(data, out) {
      var boff = 0;
      while (boff < data.length) {
        var L2 = Math.min(65535, data.length - boff);
        var h3 = boff + L2 == data.length;
        out.write_shift(1, +h3);
        out.write_shift(2, L2);
        out.write_shift(2, ~L2 & 65535);
        while (L2-- > 0)
          out[out.l++] = data[boff++];
      }
      return out.l;
    }
    __name(write_stored, "write_stored");
    function write_huff_fixed(data, out) {
      var bl = 0;
      var boff = 0;
      var addrs = use_typed_arrays ? new Uint16Array(32768) : [];
      while (boff < data.length) {
        var L2 = (
          /* data.length - boff; */
          Math.min(65535, data.length - boff)
        );
        if (L2 < 10) {
          bl = write_bits_3(out, bl, +!!(boff + L2 == data.length));
          if (bl & 7)
            bl += 8 - (bl & 7);
          out.l = bl / 8 | 0;
          out.write_shift(2, L2);
          out.write_shift(2, ~L2 & 65535);
          while (L2-- > 0)
            out[out.l++] = data[boff++];
          bl = out.l * 8;
          continue;
        }
        bl = write_bits_3(out, bl, +!!(boff + L2 == data.length) + 2);
        var hash = 0;
        while (L2-- > 0) {
          var d2 = data[boff];
          hash = (hash << 5 ^ d2) & 32767;
          var match = -1, mlen = 0;
          if (match = addrs[hash]) {
            match |= boff & ~32767;
            if (match > boff)
              match -= 32768;
            if (match < boff)
              while (data[match + mlen] == data[boff + mlen] && mlen < 250)
                ++mlen;
          }
          if (mlen > 2) {
            d2 = LEN_LN_RE[mlen];
            if (d2 <= 22)
              bl = write_bits_8(out, bl, bitswap8[d2 + 1] >> 1) - 1;
            else {
              write_bits_8(out, bl, 3);
              bl += 5;
              write_bits_8(out, bl, bitswap8[d2 - 23] >> 5);
              bl += 3;
            }
            var len_eb = d2 < 8 ? 0 : d2 - 4 >> 2;
            if (len_eb > 0) {
              write_bits_16(out, bl, mlen - LEN_LN[d2]);
              bl += len_eb;
            }
            d2 = DST_LN_RE[boff - match];
            bl = write_bits_8(out, bl, bitswap8[d2] >> 3);
            bl -= 3;
            var dst_eb = d2 < 4 ? 0 : d2 - 2 >> 1;
            if (dst_eb > 0) {
              write_bits_16(out, bl, boff - match - DST_LN[d2]);
              bl += dst_eb;
            }
            for (var q3 = 0; q3 < mlen; ++q3) {
              addrs[hash] = boff & 32767;
              hash = (hash << 5 ^ data[boff]) & 32767;
              ++boff;
            }
            L2 -= mlen - 1;
          } else {
            if (d2 <= 143)
              d2 = d2 + 48;
            else
              bl = write_bits_1(out, bl, 1);
            bl = write_bits_8(out, bl, bitswap8[d2]);
            addrs[hash] = boff & 32767;
            ++boff;
          }
        }
        bl = write_bits_8(out, bl, 0) - 1;
      }
      out.l = (bl + 7) / 8 | 0;
      return out.l;
    }
    __name(write_huff_fixed, "write_huff_fixed");
    return /* @__PURE__ */ __name(function _deflateRaw2(data, out) {
      if (data.length < 8)
        return write_stored(data, out);
      return write_huff_fixed(data, out);
    }, "_deflateRaw");
  }, "_deflateRawIIFE"))();
  function _deflate(data) {
    var buf = new_buf(50 + Math.floor(data.length * 1.1));
    var off = _deflateRaw(data, buf);
    return buf.slice(0, off);
  }
  __name(_deflate, "_deflate");
  var dyn_lmap = use_typed_arrays ? new Uint16Array(32768) : zero_fill_array(32768);
  var dyn_dmap = use_typed_arrays ? new Uint16Array(32768) : zero_fill_array(32768);
  var dyn_cmap = use_typed_arrays ? new Uint16Array(128) : zero_fill_array(128);
  var dyn_len_1 = 1, dyn_len_2 = 1;
  function dyn(data, boff) {
    var _HLIT = read_bits_5(data, boff) + 257;
    boff += 5;
    var _HDIST = read_bits_5(data, boff) + 1;
    boff += 5;
    var _HCLEN = read_bits_4(data, boff) + 4;
    boff += 4;
    var w2 = 0;
    var clens = use_typed_arrays ? new Uint8Array(19) : zero_fill_array(19);
    var ctree = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
    var maxlen = 1;
    var bl_count = use_typed_arrays ? new Uint8Array(8) : zero_fill_array(8);
    var next_code = use_typed_arrays ? new Uint8Array(8) : zero_fill_array(8);
    var L2 = clens.length;
    for (var i3 = 0; i3 < _HCLEN; ++i3) {
      clens[CLEN_ORDER[i3]] = w2 = read_bits_3(data, boff);
      if (maxlen < w2)
        maxlen = w2;
      bl_count[w2]++;
      boff += 3;
    }
    var ccode = 0;
    bl_count[0] = 0;
    for (i3 = 1; i3 <= maxlen; ++i3)
      next_code[i3] = ccode = ccode + bl_count[i3 - 1] << 1;
    for (i3 = 0; i3 < L2; ++i3)
      if ((ccode = clens[i3]) != 0)
        ctree[i3] = next_code[ccode]++;
    var cleni = 0;
    for (i3 = 0; i3 < L2; ++i3) {
      cleni = clens[i3];
      if (cleni != 0) {
        ccode = bitswap8[ctree[i3]] >> 8 - cleni;
        for (var j2 = (1 << 7 - cleni) - 1; j2 >= 0; --j2)
          dyn_cmap[ccode | j2 << cleni] = cleni & 7 | i3 << 3;
      }
    }
    var hcodes = [];
    maxlen = 1;
    for (; hcodes.length < _HLIT + _HDIST; ) {
      ccode = dyn_cmap[read_bits_7(data, boff)];
      boff += ccode & 7;
      switch (ccode >>>= 3) {
        case 16:
          w2 = 3 + read_bits_2(data, boff);
          boff += 2;
          ccode = hcodes[hcodes.length - 1];
          while (w2-- > 0)
            hcodes.push(ccode);
          break;
        case 17:
          w2 = 3 + read_bits_3(data, boff);
          boff += 3;
          while (w2-- > 0)
            hcodes.push(0);
          break;
        case 18:
          w2 = 11 + read_bits_7(data, boff);
          boff += 7;
          while (w2-- > 0)
            hcodes.push(0);
          break;
        default:
          hcodes.push(ccode);
          if (maxlen < ccode)
            maxlen = ccode;
          break;
      }
    }
    var h12 = hcodes.slice(0, _HLIT), h22 = hcodes.slice(_HLIT);
    for (i3 = _HLIT; i3 < 286; ++i3)
      h12[i3] = 0;
    for (i3 = _HDIST; i3 < 30; ++i3)
      h22[i3] = 0;
    dyn_len_1 = build_tree(h12, dyn_lmap, 286);
    dyn_len_2 = build_tree(h22, dyn_dmap, 30);
    return boff;
  }
  __name(dyn, "dyn");
  function inflate(data, usz) {
    if (data[0] == 3 && !(data[1] & 3)) {
      return [new_raw_buf(usz), 2];
    }
    var boff = 0;
    var header = 0;
    var outbuf = new_unsafe_buf(usz ? usz : 1 << 18);
    var woff = 0;
    var OL = outbuf.length >>> 0;
    var max_len_1 = 0, max_len_2 = 0;
    while ((header & 1) == 0) {
      header = read_bits_3(data, boff);
      boff += 3;
      if (header >>> 1 == 0) {
        if (boff & 7)
          boff += 8 - (boff & 7);
        var sz = data[boff >>> 3] | data[(boff >>> 3) + 1] << 8;
        boff += 32;
        if (sz > 0) {
          if (!usz && OL < woff + sz) {
            outbuf = realloc(outbuf, woff + sz);
            OL = outbuf.length;
          }
          while (sz-- > 0) {
            outbuf[woff++] = data[boff >>> 3];
            boff += 8;
          }
        }
        continue;
      } else if (header >> 1 == 1) {
        max_len_1 = 9;
        max_len_2 = 5;
      } else {
        boff = dyn(data, boff);
        max_len_1 = dyn_len_1;
        max_len_2 = dyn_len_2;
      }
      for (; ; ) {
        if (!usz && OL < woff + 32767) {
          outbuf = realloc(outbuf, woff + 32767);
          OL = outbuf.length;
        }
        var bits2 = read_bits_n(data, boff, max_len_1);
        var code = header >>> 1 == 1 ? fix_lmap[bits2] : dyn_lmap[bits2];
        boff += code & 15;
        code >>>= 4;
        if ((code >>> 8 & 255) === 0)
          outbuf[woff++] = code;
        else if (code == 256)
          break;
        else {
          code -= 257;
          var len_eb = code < 8 ? 0 : code - 4 >> 2;
          if (len_eb > 5)
            len_eb = 0;
          var tgt = woff + LEN_LN[code];
          if (len_eb > 0) {
            tgt += read_bits_n(data, boff, len_eb);
            boff += len_eb;
          }
          bits2 = read_bits_n(data, boff, max_len_2);
          code = header >>> 1 == 1 ? fix_dmap[bits2] : dyn_dmap[bits2];
          boff += code & 15;
          code >>>= 4;
          var dst_eb = code < 4 ? 0 : code - 2 >> 1;
          var dst = DST_LN[code];
          if (dst_eb > 0) {
            dst += read_bits_n(data, boff, dst_eb);
            boff += dst_eb;
          }
          if (!usz && OL < tgt) {
            outbuf = realloc(outbuf, tgt + 100);
            OL = outbuf.length;
          }
          while (woff < tgt) {
            outbuf[woff] = outbuf[woff - dst];
            ++woff;
          }
        }
      }
    }
    if (usz)
      return [outbuf, boff + 7 >>> 3];
    return [outbuf.slice(0, woff), boff + 7 >>> 3];
  }
  __name(inflate, "inflate");
  function _inflate(payload, usz) {
    var data = payload.slice(payload.l || 0);
    var out = inflate(data, usz);
    payload.l += out[1];
    return out[0];
  }
  __name(_inflate, "_inflate");
  function warn_or_throw(wrn, msg) {
    if (wrn) {
      if (typeof console !== "undefined")
        console.error(msg);
    } else
      throw new Error(msg);
  }
  __name(warn_or_throw, "warn_or_throw");
  function parse_zip(file, options) {
    var blob = (
      /*::(*/
      file
    );
    prep_blob(blob, 0);
    var FileIndex = [], FullPaths = [];
    var o2 = {
      FileIndex,
      FullPaths
    };
    init_cfb(o2, { root: options.root });
    var i3 = blob.length - 4;
    while ((blob[i3] != 80 || blob[i3 + 1] != 75 || blob[i3 + 2] != 5 || blob[i3 + 3] != 6) && i3 >= 0)
      --i3;
    blob.l = i3 + 4;
    blob.l += 4;
    var fcnt = blob.read_shift(2);
    blob.l += 6;
    var start_cd = blob.read_shift(4);
    blob.l = start_cd;
    for (i3 = 0; i3 < fcnt; ++i3) {
      blob.l += 20;
      var csz = blob.read_shift(4);
      var usz = blob.read_shift(4);
      var namelen = blob.read_shift(2);
      var efsz = blob.read_shift(2);
      var fcsz = blob.read_shift(2);
      blob.l += 8;
      var offset = blob.read_shift(4);
      var EF = parse_extra_field(
        /*::(*/
        blob.slice(blob.l + namelen, blob.l + namelen + efsz)
        /*:: :any)*/
      );
      blob.l += namelen + efsz + fcsz;
      var L2 = blob.l;
      blob.l = offset + 4;
      parse_local_file(blob, csz, usz, o2, EF);
      blob.l = L2;
    }
    return o2;
  }
  __name(parse_zip, "parse_zip");
  function parse_local_file(blob, csz, usz, o2, EF) {
    blob.l += 2;
    var flags = blob.read_shift(2);
    var meth = blob.read_shift(2);
    var date = parse_dos_date(blob);
    if (flags & 8257)
      throw new Error("Unsupported ZIP encryption");
    var crc32 = blob.read_shift(4);
    var _csz = blob.read_shift(4);
    var _usz = blob.read_shift(4);
    var namelen = blob.read_shift(2);
    var efsz = blob.read_shift(2);
    var name = "";
    for (var i3 = 0; i3 < namelen; ++i3)
      name += String.fromCharCode(blob[blob.l++]);
    if (efsz) {
      var ef = parse_extra_field(
        /*::(*/
        blob.slice(blob.l, blob.l + efsz)
        /*:: :any)*/
      );
      if ((ef[21589] || {}).mt)
        date = ef[21589].mt;
      if (((EF || {})[21589] || {}).mt)
        date = EF[21589].mt;
    }
    blob.l += efsz;
    var data = blob.slice(blob.l, blob.l + _csz);
    switch (meth) {
      case 8:
        data = _inflateRawSync(blob, _usz);
        break;
      case 0:
        break;
      default:
        throw new Error("Unsupported ZIP Compression method " + meth);
    }
    var wrn = false;
    if (flags & 8) {
      crc32 = blob.read_shift(4);
      if (crc32 == 134695760) {
        crc32 = blob.read_shift(4);
        wrn = true;
      }
      _csz = blob.read_shift(4);
      _usz = blob.read_shift(4);
    }
    if (_csz != csz)
      warn_or_throw(wrn, "Bad compressed size: " + csz + " != " + _csz);
    if (_usz != usz)
      warn_or_throw(wrn, "Bad uncompressed size: " + usz + " != " + _usz);
    cfb_add(o2, name, data, { unsafe: true, mt: date });
  }
  __name(parse_local_file, "parse_local_file");
  function write_zip2(cfb, options) {
    var _opts = options || {};
    var out = [], cdirs = [];
    var o2 = new_buf(1);
    var method = _opts.compression ? 8 : 0, flags = 0;
    var i3 = 0, j2 = 0;
    var start_cd = 0, fcnt = 0;
    var root = cfb.FullPaths[0], fp = root, fi = cfb.FileIndex[0];
    var crcs = [];
    var sz_cd = 0;
    for (i3 = 1; i3 < cfb.FullPaths.length; ++i3) {
      fp = cfb.FullPaths[i3].slice(root.length);
      fi = cfb.FileIndex[i3];
      if (!fi.size || !fi.content || fp == "Sh33tJ5")
        continue;
      var start = start_cd;
      var namebuf = new_buf(fp.length);
      for (j2 = 0; j2 < fp.length; ++j2)
        namebuf.write_shift(1, fp.charCodeAt(j2) & 127);
      namebuf = namebuf.slice(0, namebuf.l);
      crcs[fcnt] = CRC32.buf(
        /*::((*/
        fi.content,
        0
      );
      var outbuf = fi.content;
      if (method == 8)
        outbuf = _deflateRawSync(outbuf);
      o2 = new_buf(30);
      o2.write_shift(4, 67324752);
      o2.write_shift(2, 20);
      o2.write_shift(2, flags);
      o2.write_shift(2, method);
      if (fi.mt)
        write_dos_date(o2, fi.mt);
      else
        o2.write_shift(4, 0);
      o2.write_shift(-4, crcs[fcnt]);
      o2.write_shift(4, outbuf.length);
      o2.write_shift(
        4,
        /*::(*/
        fi.content.length
      );
      o2.write_shift(2, namebuf.length);
      o2.write_shift(2, 0);
      start_cd += o2.length;
      out.push(o2);
      start_cd += namebuf.length;
      out.push(namebuf);
      start_cd += outbuf.length;
      out.push(outbuf);
      o2 = new_buf(46);
      o2.write_shift(4, 33639248);
      o2.write_shift(2, 0);
      o2.write_shift(2, 20);
      o2.write_shift(2, flags);
      o2.write_shift(2, method);
      o2.write_shift(4, 0);
      o2.write_shift(-4, crcs[fcnt]);
      o2.write_shift(4, outbuf.length);
      o2.write_shift(
        4,
        /*::(*/
        fi.content.length
      );
      o2.write_shift(2, namebuf.length);
      o2.write_shift(2, 0);
      o2.write_shift(2, 0);
      o2.write_shift(2, 0);
      o2.write_shift(2, 0);
      o2.write_shift(4, 0);
      o2.write_shift(4, start);
      sz_cd += o2.l;
      cdirs.push(o2);
      sz_cd += namebuf.length;
      cdirs.push(namebuf);
      ++fcnt;
    }
    o2 = new_buf(22);
    o2.write_shift(4, 101010256);
    o2.write_shift(2, 0);
    o2.write_shift(2, 0);
    o2.write_shift(2, fcnt);
    o2.write_shift(2, fcnt);
    o2.write_shift(4, sz_cd);
    o2.write_shift(4, start_cd);
    o2.write_shift(2, 0);
    return bconcat([bconcat(out), bconcat(cdirs), o2]);
  }
  __name(write_zip2, "write_zip");
  var ContentTypeMap = {
    "htm": "text/html",
    "xml": "text/xml",
    "gif": "image/gif",
    "jpg": "image/jpeg",
    "png": "image/png",
    "mso": "application/x-mso",
    "thmx": "application/vnd.ms-officetheme",
    "sh33tj5": "application/octet-stream"
  };
  function get_content_type(fi, fp) {
    if (fi.ctype)
      return fi.ctype;
    var ext = fi.name || "", m2 = ext.match(/\.([^\.]+)$/);
    if (m2 && ContentTypeMap[m2[1]])
      return ContentTypeMap[m2[1]];
    if (fp) {
      m2 = (ext = fp).match(/[\.\\]([^\.\\])+$/);
      if (m2 && ContentTypeMap[m2[1]])
        return ContentTypeMap[m2[1]];
    }
    return "application/octet-stream";
  }
  __name(get_content_type, "get_content_type");
  function write_base64_76(bstr) {
    var data = Base64_encode(bstr);
    var o2 = [];
    for (var i3 = 0; i3 < data.length; i3 += 76)
      o2.push(data.slice(i3, i3 + 76));
    return o2.join("\r\n") + "\r\n";
  }
  __name(write_base64_76, "write_base64_76");
  function write_quoted_printable(text) {
    var encoded = text.replace(/[\x00-\x08\x0B\x0C\x0E-\x1F\x7E-\xFF=]/g, function(c2) {
      var w2 = c2.charCodeAt(0).toString(16).toUpperCase();
      return "=" + (w2.length == 1 ? "0" + w2 : w2);
    });
    encoded = encoded.replace(/ $/mg, "=20").replace(/\t$/mg, "=09");
    if (encoded.charAt(0) == "\n")
      encoded = "=0D" + encoded.slice(1);
    encoded = encoded.replace(/\r(?!\n)/mg, "=0D").replace(/\n\n/mg, "\n=0A").replace(/([^\r\n])\n/mg, "$1=0A");
    var o2 = [], split = encoded.split("\r\n");
    for (var si = 0; si < split.length; ++si) {
      var str = split[si];
      if (str.length == 0) {
        o2.push("");
        continue;
      }
      for (var i3 = 0; i3 < str.length; ) {
        var end = 76;
        var tmp = str.slice(i3, i3 + end);
        if (tmp.charAt(end - 1) == "=")
          end--;
        else if (tmp.charAt(end - 2) == "=")
          end -= 2;
        else if (tmp.charAt(end - 3) == "=")
          end -= 3;
        tmp = str.slice(i3, i3 + end);
        i3 += end;
        if (i3 < str.length)
          tmp += "=";
        o2.push(tmp);
      }
    }
    return o2.join("\r\n");
  }
  __name(write_quoted_printable, "write_quoted_printable");
  function parse_quoted_printable(data) {
    var o2 = [];
    for (var di = 0; di < data.length; ++di) {
      var line = data[di];
      while (di <= data.length && line.charAt(line.length - 1) == "=")
        line = line.slice(0, line.length - 1) + data[++di];
      o2.push(line);
    }
    for (var oi = 0; oi < o2.length; ++oi)
      o2[oi] = o2[oi].replace(/[=][0-9A-Fa-f]{2}/g, function($$) {
        return String.fromCharCode(parseInt($$.slice(1), 16));
      });
    return s2a(o2.join("\r\n"));
  }
  __name(parse_quoted_printable, "parse_quoted_printable");
  function parse_mime(cfb, data, root) {
    var fname = "", cte = "", ctype = "", fdata;
    var di = 0;
    for (; di < 10; ++di) {
      var line = data[di];
      if (!line || line.match(/^\s*$/))
        break;
      var m2 = line.match(/^(.*?):\s*([^\s].*)$/);
      if (m2)
        switch (m2[1].toLowerCase()) {
          case "content-location":
            fname = m2[2].trim();
            break;
          case "content-type":
            ctype = m2[2].trim();
            break;
          case "content-transfer-encoding":
            cte = m2[2].trim();
            break;
        }
    }
    ++di;
    switch (cte.toLowerCase()) {
      case "base64":
        fdata = s2a(Base64_decode(data.slice(di).join("")));
        break;
      case "quoted-printable":
        fdata = parse_quoted_printable(data.slice(di));
        break;
      default:
        throw new Error("Unsupported Content-Transfer-Encoding " + cte);
    }
    var file = cfb_add(cfb, fname.slice(root.length), fdata, { unsafe: true });
    if (ctype)
      file.ctype = ctype;
  }
  __name(parse_mime, "parse_mime");
  function parse_mad(file, options) {
    if (a2s2(file.slice(0, 13)).toLowerCase() != "mime-version:")
      throw new Error("Unsupported MAD header");
    var root = options && options.root || "";
    var data = (has_buf && Buffer.isBuffer(file) ? file.toString("binary") : a2s2(file)).split("\r\n");
    var di = 0, row = "";
    for (di = 0; di < data.length; ++di) {
      row = data[di];
      if (!/^Content-Location:/i.test(row))
        continue;
      row = row.slice(row.indexOf("file"));
      if (!root)
        root = row.slice(0, row.lastIndexOf("/") + 1);
      if (row.slice(0, root.length) == root)
        continue;
      while (root.length > 0) {
        root = root.slice(0, root.length - 1);
        root = root.slice(0, root.lastIndexOf("/") + 1);
        if (row.slice(0, root.length) == root)
          break;
      }
    }
    var mboundary = (data[1] || "").match(/boundary="(.*?)"/);
    if (!mboundary)
      throw new Error("MAD cannot find boundary");
    var boundary = "--" + (mboundary[1] || "");
    var FileIndex = [], FullPaths = [];
    var o2 = {
      FileIndex,
      FullPaths
    };
    init_cfb(o2);
    var start_di, fcnt = 0;
    for (di = 0; di < data.length; ++di) {
      var line = data[di];
      if (line !== boundary && line !== boundary + "--")
        continue;
      if (fcnt++)
        parse_mime(o2, data.slice(start_di, di), root);
      start_di = di;
    }
    return o2;
  }
  __name(parse_mad, "parse_mad");
  function write_mad(cfb, options) {
    var opts = options || {};
    var boundary = opts.boundary || "SheetJS";
    boundary = "------=" + boundary;
    var out = [
      "MIME-Version: 1.0",
      'Content-Type: multipart/related; boundary="' + boundary.slice(2) + '"',
      "",
      "",
      ""
    ];
    var root = cfb.FullPaths[0], fp = root, fi = cfb.FileIndex[0];
    for (var i3 = 1; i3 < cfb.FullPaths.length; ++i3) {
      fp = cfb.FullPaths[i3].slice(root.length);
      fi = cfb.FileIndex[i3];
      if (!fi.size || !fi.content || fp == "Sh33tJ5")
        continue;
      fp = fp.replace(/[\x00-\x08\x0B\x0C\x0E-\x1F\x7E-\xFF]/g, function(c2) {
        return "_x" + c2.charCodeAt(0).toString(16) + "_";
      }).replace(/[\u0080-\uFFFF]/g, function(u2) {
        return "_u" + u2.charCodeAt(0).toString(16) + "_";
      });
      var ca = fi.content;
      var cstr = has_buf && Buffer.isBuffer(ca) ? ca.toString("binary") : a2s2(ca);
      var dispcnt = 0, L2 = Math.min(1024, cstr.length), cc = 0;
      for (var csl = 0; csl <= L2; ++csl)
        if ((cc = cstr.charCodeAt(csl)) >= 32 && cc < 128)
          ++dispcnt;
      var qp = dispcnt >= L2 * 4 / 5;
      out.push(boundary);
      out.push("Content-Location: " + (opts.root || "file:///C:/SheetJS/") + fp);
      out.push("Content-Transfer-Encoding: " + (qp ? "quoted-printable" : "base64"));
      out.push("Content-Type: " + get_content_type(fi, fp));
      out.push("");
      out.push(qp ? write_quoted_printable(cstr) : write_base64_76(cstr));
    }
    out.push(boundary + "--\r\n");
    return out.join("\r\n");
  }
  __name(write_mad, "write_mad");
  function cfb_new(opts) {
    var o2 = {};
    init_cfb(o2, opts);
    return o2;
  }
  __name(cfb_new, "cfb_new");
  function cfb_add(cfb, name, content, opts) {
    var unsafe = opts && opts.unsafe;
    if (!unsafe)
      init_cfb(cfb);
    var file = !unsafe && CFB.find(cfb, name);
    if (!file) {
      var fpath = cfb.FullPaths[0];
      if (name.slice(0, fpath.length) == fpath)
        fpath = name;
      else {
        if (fpath.slice(-1) != "/")
          fpath += "/";
        fpath = (fpath + name).replace("//", "/");
      }
      file = { name: filename(name), type: 2 };
      cfb.FileIndex.push(file);
      cfb.FullPaths.push(fpath);
      if (!unsafe)
        CFB.utils.cfb_gc(cfb);
    }
    file.content = content;
    file.size = content ? content.length : 0;
    if (opts) {
      if (opts.CLSID)
        file.clsid = opts.CLSID;
      if (opts.mt)
        file.mt = opts.mt;
      if (opts.ct)
        file.ct = opts.ct;
    }
    return file;
  }
  __name(cfb_add, "cfb_add");
  function cfb_del(cfb, name) {
    init_cfb(cfb);
    var file = CFB.find(cfb, name);
    if (file) {
      for (var j2 = 0; j2 < cfb.FileIndex.length; ++j2)
        if (cfb.FileIndex[j2] == file) {
          cfb.FileIndex.splice(j2, 1);
          cfb.FullPaths.splice(j2, 1);
          return true;
        }
    }
    return false;
  }
  __name(cfb_del, "cfb_del");
  function cfb_mov(cfb, old_name, new_name) {
    init_cfb(cfb);
    var file = CFB.find(cfb, old_name);
    if (file) {
      for (var j2 = 0; j2 < cfb.FileIndex.length; ++j2)
        if (cfb.FileIndex[j2] == file) {
          cfb.FileIndex[j2].name = filename(new_name);
          cfb.FullPaths[j2] = new_name;
          return true;
        }
    }
    return false;
  }
  __name(cfb_mov, "cfb_mov");
  function cfb_gc(cfb) {
    rebuild_cfb(cfb, true);
  }
  __name(cfb_gc, "cfb_gc");
  exports2.find = find;
  exports2.read = read;
  exports2.parse = parse2;
  exports2.write = write;
  exports2.writeFile = write_file;
  exports2.utils = {
    cfb_new,
    cfb_add,
    cfb_del,
    cfb_mov,
    cfb_gc,
    ReadShift,
    CheckField,
    prep_blob,
    bconcat,
    use_zlib,
    _deflateRaw: _deflate,
    _inflateRaw: _inflate,
    consts
  };
  return exports2;
}, "_CFB"))();
function blobify(data) {
  if (typeof data === "string")
    return s2ab(data);
  if (Array.isArray(data))
    return a2u(data);
  return data;
}
__name(blobify, "blobify");
function write_dl(fname, payload, enc) {
  if (typeof Deno !== "undefined") {
    if (enc && typeof payload == "string")
      switch (enc) {
        case "utf8":
          payload = new TextEncoder(enc).encode(payload);
          break;
        case "binary":
          payload = s2ab(payload);
          break;
        default:
          throw new Error("Unsupported encoding " + enc);
      }
    return Deno.writeFileSync(fname, payload);
  }
  var data = enc == "utf8" ? utf8write(payload) : payload;
  if (typeof IE_SaveFile !== "undefined")
    return IE_SaveFile(data, fname);
  if (typeof Blob !== "undefined") {
    var blob = new Blob([blobify(data)], { type: "application/octet-stream" });
    if (typeof navigator !== "undefined" && navigator.msSaveBlob)
      return navigator.msSaveBlob(blob, fname);
    if (typeof saveAs !== "undefined")
      return saveAs(blob, fname);
    if (typeof URL !== "undefined" && typeof document !== "undefined" && document.createElement && URL.createObjectURL) {
      var url = URL.createObjectURL(blob);
      if (typeof chrome === "object" && typeof (chrome.downloads || {}).download == "function") {
        if (URL.revokeObjectURL && typeof setTimeout !== "undefined")
          setTimeout(function() {
            URL.revokeObjectURL(url);
          }, 6e4);
        return chrome.downloads.download({ url, filename: fname, saveAs: true });
      }
      var a2 = document.createElement("a");
      if (a2.download != null) {
        a2.download = fname;
        a2.href = url;
        document.body.appendChild(a2);
        a2.click();
        document.body.removeChild(a2);
        if (URL.revokeObjectURL && typeof setTimeout !== "undefined")
          setTimeout(function() {
            URL.revokeObjectURL(url);
          }, 6e4);
        return url;
      }
    }
  }
  if (typeof $ !== "undefined" && typeof File !== "undefined" && typeof Folder !== "undefined")
    try {
      var out = File(fname);
      out.open("w");
      out.encoding = "binary";
      if (Array.isArray(payload))
        payload = a2s(payload);
      out.write(payload);
      out.close();
      return payload;
    } catch (e) {
      if (!e.message || !e.message.match(/onstruct/))
        throw e;
    }
  throw new Error("cannot save file " + fname);
}
__name(write_dl, "write_dl");
function keys(o2) {
  var ks = Object.keys(o2), o22 = [];
  for (var i2 = 0; i2 < ks.length; ++i2)
    if (Object.prototype.hasOwnProperty.call(o2, ks[i2]))
      o22.push(ks[i2]);
  return o22;
}
__name(keys, "keys");
function evert_key(obj, key) {
  var o2 = [], K2 = keys(obj);
  for (var i2 = 0; i2 !== K2.length; ++i2)
    if (o2[obj[K2[i2]][key]] == null)
      o2[obj[K2[i2]][key]] = K2[i2];
  return o2;
}
__name(evert_key, "evert_key");
function evert(obj) {
  var o2 = [], K2 = keys(obj);
  for (var i2 = 0; i2 !== K2.length; ++i2)
    o2[obj[K2[i2]]] = K2[i2];
  return o2;
}
__name(evert, "evert");
function evert_num(obj) {
  var o2 = [], K2 = keys(obj);
  for (var i2 = 0; i2 !== K2.length; ++i2)
    o2[obj[K2[i2]]] = parseInt(K2[i2], 10);
  return o2;
}
__name(evert_num, "evert_num");
function evert_arr(obj) {
  var o2 = [], K2 = keys(obj);
  for (var i2 = 0; i2 !== K2.length; ++i2) {
    if (o2[obj[K2[i2]]] == null)
      o2[obj[K2[i2]]] = [];
    o2[obj[K2[i2]]].push(K2[i2]);
  }
  return o2;
}
__name(evert_arr, "evert_arr");
var basedate = /* @__PURE__ */ new Date(1899, 11, 30, 0, 0, 0);
function datenum(v2, date1904) {
  var epoch = /* @__PURE__ */ v2.getTime();
  if (date1904)
    epoch -= 1462 * 24 * 60 * 60 * 1e3;
  var dnthresh2 = /* @__PURE__ */ basedate.getTime() + (/* @__PURE__ */ v2.getTimezoneOffset() - /* @__PURE__ */ basedate.getTimezoneOffset()) * 6e4;
  return (epoch - dnthresh2) / (24 * 60 * 60 * 1e3);
}
__name(datenum, "datenum");
var refdate = /* @__PURE__ */ new Date();
var dnthresh = /* @__PURE__ */ basedate.getTime() + (/* @__PURE__ */ refdate.getTimezoneOffset() - /* @__PURE__ */ basedate.getTimezoneOffset()) * 6e4;
var refoffset = /* @__PURE__ */ refdate.getTimezoneOffset();
function numdate(v2) {
  var out = /* @__PURE__ */ new Date();
  out.setTime(v2 * 24 * 60 * 60 * 1e3 + dnthresh);
  if (out.getTimezoneOffset() !== refoffset) {
    out.setTime(out.getTime() + (out.getTimezoneOffset() - refoffset) * 6e4);
  }
  return out;
}
__name(numdate, "numdate");
var good_pd_date_1 = /* @__PURE__ */ new Date("2017-02-19T19:06:09.000Z");
var good_pd_date = /* @__PURE__ */ isNaN(/* @__PURE__ */ good_pd_date_1.getFullYear()) ? /* @__PURE__ */ new Date("2/19/17") : good_pd_date_1;
var good_pd = /* @__PURE__ */ good_pd_date.getFullYear() == 2017;
function parseDate(str, fixdate) {
  var d2 = new Date(str);
  if (good_pd) {
    if (fixdate > 0)
      d2.setTime(d2.getTime() + d2.getTimezoneOffset() * 60 * 1e3);
    else if (fixdate < 0)
      d2.setTime(d2.getTime() - d2.getTimezoneOffset() * 60 * 1e3);
    return d2;
  }
  if (str instanceof Date)
    return str;
  if (good_pd_date.getFullYear() == 1917 && !isNaN(d2.getFullYear())) {
    var s2 = d2.getFullYear();
    if (str.indexOf("" + s2) > -1)
      return d2;
    d2.setFullYear(d2.getFullYear() + 100);
    return d2;
  }
  var n2 = str.match(/\d+/g) || ["2017", "2", "19", "0", "0", "0"];
  var out = new Date(+n2[0], +n2[1] - 1, +n2[2], +n2[3] || 0, +n2[4] || 0, +n2[5] || 0);
  if (str.indexOf("Z") > -1)
    out = new Date(out.getTime() - out.getTimezoneOffset() * 60 * 1e3);
  return out;
}
__name(parseDate, "parseDate");
function cc2str(arr, debomit) {
  if (has_buf && Buffer.isBuffer(arr)) {
    if (debomit) {
      if (arr[0] == 255 && arr[1] == 254)
        return utf8write(arr.slice(2).toString("utf16le"));
      if (arr[1] == 254 && arr[2] == 255)
        return utf8write(utf16beread(arr.slice(2).toString("binary")));
    }
    return arr.toString("binary");
  }
  if (typeof TextDecoder !== "undefined")
    try {
      if (debomit) {
        if (arr[0] == 255 && arr[1] == 254)
          return utf8write(new TextDecoder("utf-16le").decode(arr.slice(2)));
        if (arr[0] == 254 && arr[1] == 255)
          return utf8write(new TextDecoder("utf-16be").decode(arr.slice(2)));
      }
      var rev2 = {
        "": "",
        "": "",
        "": "",
        "": "",
        "": "",
        "": "",
        "": "",
        "": "",
        "": "",
        "": "",
        "": "",
        "": "",
        "": "",
        "": "",
        "": "",
        "": "",
        "": "",
        "": "",
        "": "",
        "": "",
        "": "",
        "": "",
        "": "",
        "": "",
        "": "",
        "": "",
        "": ""
      };
      if (Array.isArray(arr))
        arr = new Uint8Array(arr);
      return new TextDecoder("latin1").decode(arr).replace(/[]/g, function(c2) {
        return rev2[c2] || c2;
      });
    } catch (e) {
    }
  var o2 = [];
  for (var i2 = 0; i2 != arr.length; ++i2)
    o2.push(String.fromCharCode(arr[i2]));
  return o2.join("");
}
__name(cc2str, "cc2str");
function dup(o2) {
  if (typeof JSON != "undefined" && !Array.isArray(o2))
    return JSON.parse(JSON.stringify(o2));
  if (typeof o2 != "object" || o2 == null)
    return o2;
  if (o2 instanceof Date)
    return new Date(o2.getTime());
  var out = {};
  for (var k2 in o2)
    if (Object.prototype.hasOwnProperty.call(o2, k2))
      out[k2] = dup(o2[k2]);
  return out;
}
__name(dup, "dup");
function fill(c2, l2) {
  var o2 = "";
  while (o2.length < l2)
    o2 += c2;
  return o2;
}
__name(fill, "fill");
function fuzzynum(s2) {
  var v2 = Number(s2);
  if (!isNaN(v2))
    return isFinite(v2) ? v2 : NaN;
  if (!/\d/.test(s2))
    return v2;
  var wt2 = 1;
  var ss = s2.replace(/([\d]),([\d])/g, "$1$2").replace(/[$]/g, "").replace(/[%]/g, function() {
    wt2 *= 100;
    return "";
  });
  if (!isNaN(v2 = Number(ss)))
    return v2 / wt2;
  ss = ss.replace(/[(](.*)[)]/, function($$, $1) {
    wt2 = -wt2;
    return $1;
  });
  if (!isNaN(v2 = Number(ss)))
    return v2 / wt2;
  return v2;
}
__name(fuzzynum, "fuzzynum");
var lower_months = ["january", "february", "march", "april", "may", "june", "july", "august", "september", "october", "november", "december"];
function fuzzydate(s2) {
  var o2 = new Date(s2), n2 = /* @__PURE__ */ new Date(NaN);
  var y2 = o2.getYear(), m2 = o2.getMonth(), d2 = o2.getDate();
  if (isNaN(d2))
    return n2;
  var lower = s2.toLowerCase();
  if (lower.match(/jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec/)) {
    lower = lower.replace(/[^a-z]/g, "").replace(/([^a-z]|^)[ap]m?([^a-z]|$)/, "");
    if (lower.length > 3 && lower_months.indexOf(lower) == -1)
      return n2;
  } else if (lower.match(/[a-z]/))
    return n2;
  if (y2 < 0 || y2 > 8099)
    return n2;
  if ((m2 > 0 || d2 > 1) && y2 != 101)
    return o2;
  if (s2.match(/[^-0-9:,\/\\]/))
    return n2;
  return o2;
}
__name(fuzzydate, "fuzzydate");
function zip_add_file(zip, path, content) {
  if (zip.FullPaths) {
    if (typeof content == "string") {
      var res;
      if (has_buf)
        res = Buffer_from(content);
      else
        res = utf8decode(content);
      return CFB.utils.cfb_add(zip, path, res);
    }
    CFB.utils.cfb_add(zip, path, content);
  } else
    zip.file(path, content);
}
__name(zip_add_file, "zip_add_file");
function zip_new() {
  return CFB.utils.cfb_new();
}
__name(zip_new, "zip_new");
var XML_HEADER = '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>\r\n';
var encodings = {
  "&quot;": '"',
  "&apos;": "'",
  "&gt;": ">",
  "&lt;": "<",
  "&amp;": "&"
};
var rencoding = /* @__PURE__ */ evert(encodings);
var decregex = /[&<>'"]/g, charegex = /[\u0000-\u0008\u000b-\u001f]/g;
function escapexml(text) {
  var s2 = text + "";
  return s2.replace(decregex, function(y2) {
    return rencoding[y2];
  }).replace(charegex, function(s3) {
    return "_x" + ("000" + s3.charCodeAt(0).toString(16)).slice(-4) + "_";
  });
}
__name(escapexml, "escapexml");
function escapexmltag(text) {
  return escapexml(text).replace(/ /g, "_x0020_");
}
__name(escapexmltag, "escapexmltag");
var htmlcharegex = /[\u0000-\u001f]/g;
function escapehtml(text) {
  var s2 = text + "";
  return s2.replace(decregex, function(y2) {
    return rencoding[y2];
  }).replace(/\n/g, "<br/>").replace(htmlcharegex, function(s3) {
    return "&#x" + ("000" + s3.charCodeAt(0).toString(16)).slice(-4) + ";";
  });
}
__name(escapehtml, "escapehtml");
function escapexlml(text) {
  var s2 = text + "";
  return s2.replace(decregex, function(y2) {
    return rencoding[y2];
  }).replace(htmlcharegex, function(s3) {
    return "&#x" + s3.charCodeAt(0).toString(16).toUpperCase() + ";";
  });
}
__name(escapexlml, "escapexlml");
function xlml_unfixstr(str) {
  return str.replace(/(\r\n|[\r\n])/g, "&#10;");
}
__name(xlml_unfixstr, "xlml_unfixstr");
function parsexmlbool(value) {
  switch (value) {
    case 1:
    case true:
    case "1":
    case "true":
    case "TRUE":
      return true;
    default:
      return false;
  }
}
__name(parsexmlbool, "parsexmlbool");
function utf8reada(orig) {
  var out = "", i2 = 0, c2 = 0, d2 = 0, e = 0, f2 = 0, w2 = 0;
  while (i2 < orig.length) {
    c2 = orig.charCodeAt(i2++);
    if (c2 < 128) {
      out += String.fromCharCode(c2);
      continue;
    }
    d2 = orig.charCodeAt(i2++);
    if (c2 > 191 && c2 < 224) {
      f2 = (c2 & 31) << 6;
      f2 |= d2 & 63;
      out += String.fromCharCode(f2);
      continue;
    }
    e = orig.charCodeAt(i2++);
    if (c2 < 240) {
      out += String.fromCharCode((c2 & 15) << 12 | (d2 & 63) << 6 | e & 63);
      continue;
    }
    f2 = orig.charCodeAt(i2++);
    w2 = ((c2 & 7) << 18 | (d2 & 63) << 12 | (e & 63) << 6 | f2 & 63) - 65536;
    out += String.fromCharCode(55296 + (w2 >>> 10 & 1023));
    out += String.fromCharCode(56320 + (w2 & 1023));
  }
  return out;
}
__name(utf8reada, "utf8reada");
function utf8readb(data) {
  var out = new_raw_buf(2 * data.length), w2, i2, j2 = 1, k2 = 0, ww = 0, c2;
  for (i2 = 0; i2 < data.length; i2 += j2) {
    j2 = 1;
    if ((c2 = data.charCodeAt(i2)) < 128)
      w2 = c2;
    else if (c2 < 224) {
      w2 = (c2 & 31) * 64 + (data.charCodeAt(i2 + 1) & 63);
      j2 = 2;
    } else if (c2 < 240) {
      w2 = (c2 & 15) * 4096 + (data.charCodeAt(i2 + 1) & 63) * 64 + (data.charCodeAt(i2 + 2) & 63);
      j2 = 3;
    } else {
      j2 = 4;
      w2 = (c2 & 7) * 262144 + (data.charCodeAt(i2 + 1) & 63) * 4096 + (data.charCodeAt(i2 + 2) & 63) * 64 + (data.charCodeAt(i2 + 3) & 63);
      w2 -= 65536;
      ww = 55296 + (w2 >>> 10 & 1023);
      w2 = 56320 + (w2 & 1023);
    }
    if (ww !== 0) {
      out[k2++] = ww & 255;
      out[k2++] = ww >>> 8;
      ww = 0;
    }
    out[k2++] = w2 % 256;
    out[k2++] = w2 >>> 8;
  }
  return out.slice(0, k2).toString("ucs2");
}
__name(utf8readb, "utf8readb");
function utf8readc(data) {
  return Buffer_from(data, "binary").toString("utf8");
}
__name(utf8readc, "utf8readc");
var utf8corpus = "foo bar baz";
var utf8read = has_buf && (/* @__PURE__ */ utf8readc(utf8corpus) == /* @__PURE__ */ utf8reada(utf8corpus) && utf8readc || /* @__PURE__ */ utf8readb(utf8corpus) == /* @__PURE__ */ utf8reada(utf8corpus) && utf8readb) || utf8reada;
var utf8write = has_buf ? function(data) {
  return Buffer_from(data, "utf8").toString("binary");
} : function(orig) {
  var out = [], i2 = 0, c2 = 0, d2 = 0;
  while (i2 < orig.length) {
    c2 = orig.charCodeAt(i2++);
    switch (true) {
      case c2 < 128:
        out.push(String.fromCharCode(c2));
        break;
      case c2 < 2048:
        out.push(String.fromCharCode(192 + (c2 >> 6)));
        out.push(String.fromCharCode(128 + (c2 & 63)));
        break;
      case (c2 >= 55296 && c2 < 57344):
        c2 -= 55296;
        d2 = orig.charCodeAt(i2++) - 56320 + (c2 << 10);
        out.push(String.fromCharCode(240 + (d2 >> 18 & 7)));
        out.push(String.fromCharCode(144 + (d2 >> 12 & 63)));
        out.push(String.fromCharCode(128 + (d2 >> 6 & 63)));
        out.push(String.fromCharCode(128 + (d2 & 63)));
        break;
      default:
        out.push(String.fromCharCode(224 + (c2 >> 12)));
        out.push(String.fromCharCode(128 + (c2 >> 6 & 63)));
        out.push(String.fromCharCode(128 + (c2 & 63)));
    }
  }
  return out.join("");
};
var htmldecode = /* @__PURE__ */ function() {
  var entities = [
    ["nbsp", " "],
    ["middot", ""],
    ["quot", '"'],
    ["apos", "'"],
    ["gt", ">"],
    ["lt", "<"],
    ["amp", "&"]
  ].map(function(x2) {
    return [new RegExp("&" + x2[0] + ";", "ig"), x2[1]];
  });
  return /* @__PURE__ */ __name(function htmldecode2(str) {
    var o2 = str.replace(/^[\t\n\r ]+/, "").replace(/[\t\n\r ]+$/, "").replace(/>\s+/g, ">").replace(/\s+</g, "<").replace(/[\t\n\r ]+/g, " ").replace(/<\s*[bB][rR]\s*\/?>/g, "\n").replace(/<[^>]*>/g, "");
    for (var i2 = 0; i2 < entities.length; ++i2)
      o2 = o2.replace(entities[i2][0], entities[i2][1]);
    return o2;
  }, "htmldecode");
}();
var wtregex = /(^\s|\s$|\n)/;
function writetag(f2, g2) {
  return "<" + f2 + (g2.match(wtregex) ? ' xml:space="preserve"' : "") + ">" + g2 + "</" + f2 + ">";
}
__name(writetag, "writetag");
function wxt_helper(h3) {
  return keys(h3).map(function(k2) {
    return " " + k2 + '="' + h3[k2] + '"';
  }).join("");
}
__name(wxt_helper, "wxt_helper");
function writextag(f2, g2, h3) {
  return "<" + f2 + (h3 != null ? wxt_helper(h3) : "") + (g2 != null ? (g2.match(wtregex) ? ' xml:space="preserve"' : "") + ">" + g2 + "</" + f2 : "/") + ">";
}
__name(writextag, "writextag");
function write_w3cdtf(d2, t2) {
  try {
    return d2.toISOString().replace(/\.\d*/, "");
  } catch (e) {
    if (t2)
      throw e;
  }
  return "";
}
__name(write_w3cdtf, "write_w3cdtf");
function write_vt(s2, xlsx) {
  switch (typeof s2) {
    case "string":
      var o2 = writextag("vt:lpwstr", escapexml(s2));
      if (xlsx)
        o2 = o2.replace(/&quot;/g, "_x0022_");
      return o2;
    case "number":
      return writextag((s2 | 0) == s2 ? "vt:i4" : "vt:r8", escapexml(String(s2)));
    case "boolean":
      return writextag("vt:bool", s2 ? "true" : "false");
  }
  if (s2 instanceof Date)
    return writextag("vt:filetime", write_w3cdtf(s2));
  throw new Error("Unable to serialize " + s2);
}
__name(write_vt, "write_vt");
var XMLNS = {
  CORE_PROPS: "http://schemas.openxmlformats.org/package/2006/metadata/core-properties",
  CUST_PROPS: "http://schemas.openxmlformats.org/officeDocument/2006/custom-properties",
  EXT_PROPS: "http://schemas.openxmlformats.org/officeDocument/2006/extended-properties",
  CT: "http://schemas.openxmlformats.org/package/2006/content-types",
  RELS: "http://schemas.openxmlformats.org/package/2006/relationships",
  TCMNT: "http://schemas.microsoft.com/office/spreadsheetml/2018/threadedcomments",
  "dc": "http://purl.org/dc/elements/1.1/",
  "dcterms": "http://purl.org/dc/terms/",
  "dcmitype": "http://purl.org/dc/dcmitype/",
  "mx": "http://schemas.microsoft.com/office/mac/excel/2008/main",
  "r": "http://schemas.openxmlformats.org/officeDocument/2006/relationships",
  "sjs": "http://schemas.openxmlformats.org/package/2006/sheetjs/core-properties",
  "vt": "http://schemas.openxmlformats.org/officeDocument/2006/docPropsVTypes",
  "xsi": "http://www.w3.org/2001/XMLSchema-instance",
  "xsd": "http://www.w3.org/2001/XMLSchema"
};
var XMLNS_main = [
  "http://schemas.openxmlformats.org/spreadsheetml/2006/main",
  "http://purl.oclc.org/ooxml/spreadsheetml/main",
  "http://schemas.microsoft.com/office/excel/2006/main",
  "http://schemas.microsoft.com/office/excel/2006/2"
];
var XLMLNS = {
  "o": "urn:schemas-microsoft-com:office:office",
  "x": "urn:schemas-microsoft-com:office:excel",
  "ss": "urn:schemas-microsoft-com:office:spreadsheet",
  "dt": "uuid:C2F41010-65B3-11d1-A29F-00AA00C14882",
  "mv": "http://macVmlSchemaUri",
  "v": "urn:schemas-microsoft-com:vml",
  "html": "http://www.w3.org/TR/REC-html40"
};
function read_double_le(b2, idx) {
  var s2 = 1 - 2 * (b2[idx + 7] >>> 7);
  var e = ((b2[idx + 7] & 127) << 4) + (b2[idx + 6] >>> 4 & 15);
  var m2 = b2[idx + 6] & 15;
  for (var i2 = 5; i2 >= 0; --i2)
    m2 = m2 * 256 + b2[idx + i2];
  if (e == 2047)
    return m2 == 0 ? s2 * Infinity : NaN;
  if (e == 0)
    e = -1022;
  else {
    e -= 1023;
    m2 += Math.pow(2, 52);
  }
  return s2 * Math.pow(2, e - 52) * m2;
}
__name(read_double_le, "read_double_le");
function write_double_le(b2, v2, idx) {
  var bs = (v2 < 0 || 1 / v2 == -Infinity ? 1 : 0) << 7, e = 0, m2 = 0;
  var av = bs ? -v2 : v2;
  if (!isFinite(av)) {
    e = 2047;
    m2 = isNaN(v2) ? 26985 : 0;
  } else if (av == 0)
    e = m2 = 0;
  else {
    e = Math.floor(Math.log(av) / Math.LN2);
    m2 = av * Math.pow(2, 52 - e);
    if (e <= -1023 && (!isFinite(m2) || m2 < Math.pow(2, 52))) {
      e = -1022;
    } else {
      m2 -= Math.pow(2, 52);
      e += 1023;
    }
  }
  for (var i2 = 0; i2 <= 5; ++i2, m2 /= 256)
    b2[idx + i2] = m2 & 255;
  b2[idx + 6] = (e & 15) << 4 | m2 & 15;
  b2[idx + 7] = e >> 4 | bs;
}
__name(write_double_le, "write_double_le");
var ___toBuffer = /* @__PURE__ */ __name(function(bufs) {
  var x2 = [], w2 = 10240;
  for (var i2 = 0; i2 < bufs[0].length; ++i2)
    if (bufs[0][i2])
      for (var j2 = 0, L2 = bufs[0][i2].length; j2 < L2; j2 += w2)
        x2.push.apply(x2, bufs[0][i2].slice(j2, j2 + w2));
  return x2;
}, "___toBuffer");
var __toBuffer = has_buf ? function(bufs) {
  return bufs[0].length > 0 && Buffer.isBuffer(bufs[0][0]) ? Buffer.concat(bufs[0].map(function(x2) {
    return Buffer.isBuffer(x2) ? x2 : Buffer_from(x2);
  })) : ___toBuffer(bufs);
} : ___toBuffer;
var ___utf16le = /* @__PURE__ */ __name(function(b2, s2, e) {
  var ss = [];
  for (var i2 = s2; i2 < e; i2 += 2)
    ss.push(String.fromCharCode(__readUInt16LE(b2, i2)));
  return ss.join("").replace(chr0, "");
}, "___utf16le");
var __utf16le = has_buf ? function(b2, s2, e) {
  if (!Buffer.isBuffer(b2))
    return ___utf16le(b2, s2, e);
  return b2.toString("utf16le", s2, e).replace(chr0, "");
} : ___utf16le;
var ___hexlify = /* @__PURE__ */ __name(function(b2, s2, l2) {
  var ss = [];
  for (var i2 = s2; i2 < s2 + l2; ++i2)
    ss.push(("0" + b2[i2].toString(16)).slice(-2));
  return ss.join("");
}, "___hexlify");
var __hexlify = has_buf ? function(b2, s2, l2) {
  return Buffer.isBuffer(b2) ? b2.toString("hex", s2, s2 + l2) : ___hexlify(b2, s2, l2);
} : ___hexlify;
var ___utf8 = /* @__PURE__ */ __name(function(b2, s2, e) {
  var ss = [];
  for (var i2 = s2; i2 < e; i2++)
    ss.push(String.fromCharCode(__readUInt8(b2, i2)));
  return ss.join("");
}, "___utf8");
var __utf8 = has_buf ? /* @__PURE__ */ __name(function utf8_b(b2, s2, e) {
  return Buffer.isBuffer(b2) ? b2.toString("utf8", s2, e) : ___utf8(b2, s2, e);
}, "utf8_b") : ___utf8;
var ___lpstr = /* @__PURE__ */ __name(function(b2, i2) {
  var len = __readUInt32LE(b2, i2);
  return len > 0 ? __utf8(b2, i2 + 4, i2 + 4 + len - 1) : "";
}, "___lpstr");
var __lpstr = ___lpstr;
var ___cpstr = /* @__PURE__ */ __name(function(b2, i2) {
  var len = __readUInt32LE(b2, i2);
  return len > 0 ? __utf8(b2, i2 + 4, i2 + 4 + len - 1) : "";
}, "___cpstr");
var __cpstr = ___cpstr;
var ___lpwstr = /* @__PURE__ */ __name(function(b2, i2) {
  var len = 2 * __readUInt32LE(b2, i2);
  return len > 0 ? __utf8(b2, i2 + 4, i2 + 4 + len - 1) : "";
}, "___lpwstr");
var __lpwstr = ___lpwstr;
var ___lpp4 = /* @__PURE__ */ __name(function lpp4_(b2, i2) {
  var len = __readUInt32LE(b2, i2);
  return len > 0 ? __utf16le(b2, i2 + 4, i2 + 4 + len) : "";
}, "lpp4_");
var __lpp4 = ___lpp4;
var ___8lpp4 = /* @__PURE__ */ __name(function(b2, i2) {
  var len = __readUInt32LE(b2, i2);
  return len > 0 ? __utf8(b2, i2 + 4, i2 + 4 + len) : "";
}, "___8lpp4");
var __8lpp4 = ___8lpp4;
var ___double = /* @__PURE__ */ __name(function(b2, idx) {
  return read_double_le(b2, idx);
}, "___double");
var __double = ___double;
var is_buf = /* @__PURE__ */ __name(function is_buf_a(a2) {
  return Array.isArray(a2) || typeof Uint8Array !== "undefined" && a2 instanceof Uint8Array;
}, "is_buf_a");
if (has_buf) {
  __lpstr = /* @__PURE__ */ __name(function lpstr_b(b2, i2) {
    if (!Buffer.isBuffer(b2))
      return ___lpstr(b2, i2);
    var len = b2.readUInt32LE(i2);
    return len > 0 ? b2.toString("utf8", i2 + 4, i2 + 4 + len - 1) : "";
  }, "lpstr_b");
  __cpstr = /* @__PURE__ */ __name(function cpstr_b(b2, i2) {
    if (!Buffer.isBuffer(b2))
      return ___cpstr(b2, i2);
    var len = b2.readUInt32LE(i2);
    return len > 0 ? b2.toString("utf8", i2 + 4, i2 + 4 + len - 1) : "";
  }, "cpstr_b");
  __lpwstr = /* @__PURE__ */ __name(function lpwstr_b(b2, i2) {
    if (!Buffer.isBuffer(b2))
      return ___lpwstr(b2, i2);
    var len = 2 * b2.readUInt32LE(i2);
    return b2.toString("utf16le", i2 + 4, i2 + 4 + len - 1);
  }, "lpwstr_b");
  __lpp4 = /* @__PURE__ */ __name(function lpp4_b(b2, i2) {
    if (!Buffer.isBuffer(b2))
      return ___lpp4(b2, i2);
    var len = b2.readUInt32LE(i2);
    return b2.toString("utf16le", i2 + 4, i2 + 4 + len);
  }, "lpp4_b");
  __8lpp4 = /* @__PURE__ */ __name(function lpp4_8b(b2, i2) {
    if (!Buffer.isBuffer(b2))
      return ___8lpp4(b2, i2);
    var len = b2.readUInt32LE(i2);
    return b2.toString("utf8", i2 + 4, i2 + 4 + len);
  }, "lpp4_8b");
  __double = /* @__PURE__ */ __name(function double_(b2, i2) {
    if (Buffer.isBuffer(b2))
      return b2.readDoubleLE(i2);
    return ___double(b2, i2);
  }, "double_");
  is_buf = /* @__PURE__ */ __name(function is_buf_b(a2) {
    return Buffer.isBuffer(a2) || Array.isArray(a2) || typeof Uint8Array !== "undefined" && a2 instanceof Uint8Array;
  }, "is_buf_b");
}
var __readUInt8 = /* @__PURE__ */ __name(function(b2, idx) {
  return b2[idx];
}, "__readUInt8");
var __readUInt16LE = /* @__PURE__ */ __name(function(b2, idx) {
  return b2[idx + 1] * (1 << 8) + b2[idx];
}, "__readUInt16LE");
var __readInt16LE = /* @__PURE__ */ __name(function(b2, idx) {
  var u2 = b2[idx + 1] * (1 << 8) + b2[idx];
  return u2 < 32768 ? u2 : (65535 - u2 + 1) * -1;
}, "__readInt16LE");
var __readUInt32LE = /* @__PURE__ */ __name(function(b2, idx) {
  return b2[idx + 3] * (1 << 24) + (b2[idx + 2] << 16) + (b2[idx + 1] << 8) + b2[idx];
}, "__readUInt32LE");
var __readInt32LE = /* @__PURE__ */ __name(function(b2, idx) {
  return b2[idx + 3] << 24 | b2[idx + 2] << 16 | b2[idx + 1] << 8 | b2[idx];
}, "__readInt32LE");
var __readInt32BE = /* @__PURE__ */ __name(function(b2, idx) {
  return b2[idx] << 24 | b2[idx + 1] << 16 | b2[idx + 2] << 8 | b2[idx + 3];
}, "__readInt32BE");
function ReadShift(size, t2) {
  var o2 = "", oI, oR, oo = [], w2, vv, i2, loc;
  switch (t2) {
    case "dbcs":
      loc = this.l;
      if (has_buf && Buffer.isBuffer(this))
        o2 = this.slice(this.l, this.l + 2 * size).toString("utf16le");
      else
        for (i2 = 0; i2 < size; ++i2) {
          o2 += String.fromCharCode(__readUInt16LE(this, loc));
          loc += 2;
        }
      size *= 2;
      break;
    case "utf8":
      o2 = __utf8(this, this.l, this.l + size);
      break;
    case "utf16le":
      size *= 2;
      o2 = __utf16le(this, this.l, this.l + size);
      break;
    case "wstr":
      return ReadShift.call(this, size, "dbcs");
    case "lpstr-ansi":
      o2 = __lpstr(this, this.l);
      size = 4 + __readUInt32LE(this, this.l);
      break;
    case "lpstr-cp":
      o2 = __cpstr(this, this.l);
      size = 4 + __readUInt32LE(this, this.l);
      break;
    case "lpwstr":
      o2 = __lpwstr(this, this.l);
      size = 4 + 2 * __readUInt32LE(this, this.l);
      break;
    case "lpp4":
      size = 4 + __readUInt32LE(this, this.l);
      o2 = __lpp4(this, this.l);
      if (size & 2)
        size += 2;
      break;
    case "8lpp4":
      size = 4 + __readUInt32LE(this, this.l);
      o2 = __8lpp4(this, this.l);
      if (size & 3)
        size += 4 - (size & 3);
      break;
    case "cstr":
      size = 0;
      o2 = "";
      while ((w2 = __readUInt8(this, this.l + size++)) !== 0)
        oo.push(_getchar(w2));
      o2 = oo.join("");
      break;
    case "_wstr":
      size = 0;
      o2 = "";
      while ((w2 = __readUInt16LE(this, this.l + size)) !== 0) {
        oo.push(_getchar(w2));
        size += 2;
      }
      size += 2;
      o2 = oo.join("");
      break;
    case "dbcs-cont":
      o2 = "";
      loc = this.l;
      for (i2 = 0; i2 < size; ++i2) {
        if (this.lens && this.lens.indexOf(loc) !== -1) {
          w2 = __readUInt8(this, loc);
          this.l = loc + 1;
          vv = ReadShift.call(this, size - i2, w2 ? "dbcs-cont" : "sbcs-cont");
          return oo.join("") + vv;
        }
        oo.push(_getchar(__readUInt16LE(this, loc)));
        loc += 2;
      }
      o2 = oo.join("");
      size *= 2;
      break;
    case "cpstr":
    case "sbcs-cont":
      o2 = "";
      loc = this.l;
      for (i2 = 0; i2 != size; ++i2) {
        if (this.lens && this.lens.indexOf(loc) !== -1) {
          w2 = __readUInt8(this, loc);
          this.l = loc + 1;
          vv = ReadShift.call(this, size - i2, w2 ? "dbcs-cont" : "sbcs-cont");
          return oo.join("") + vv;
        }
        oo.push(_getchar(__readUInt8(this, loc)));
        loc += 1;
      }
      o2 = oo.join("");
      break;
    default:
      switch (size) {
        case 1:
          oI = __readUInt8(this, this.l);
          this.l++;
          return oI;
        case 2:
          oI = (t2 === "i" ? __readInt16LE : __readUInt16LE)(this, this.l);
          this.l += 2;
          return oI;
        case 4:
        case -4:
          if (t2 === "i" || (this[this.l + 3] & 128) === 0) {
            oI = (size > 0 ? __readInt32LE : __readInt32BE)(this, this.l);
            this.l += 4;
            return oI;
          } else {
            oR = __readUInt32LE(this, this.l);
            this.l += 4;
          }
          return oR;
        case 8:
        case -8:
          if (t2 === "f") {
            if (size == 8)
              oR = __double(this, this.l);
            else
              oR = __double([this[this.l + 7], this[this.l + 6], this[this.l + 5], this[this.l + 4], this[this.l + 3], this[this.l + 2], this[this.l + 1], this[this.l + 0]], 0);
            this.l += 8;
            return oR;
          } else
            size = 8;
        case 16:
          o2 = __hexlify(this, this.l, size);
          break;
      }
  }
  this.l += size;
  return o2;
}
__name(ReadShift, "ReadShift");
var __writeUInt32LE = /* @__PURE__ */ __name(function(b2, val, idx) {
  b2[idx] = val & 255;
  b2[idx + 1] = val >>> 8 & 255;
  b2[idx + 2] = val >>> 16 & 255;
  b2[idx + 3] = val >>> 24 & 255;
}, "__writeUInt32LE");
var __writeInt32LE = /* @__PURE__ */ __name(function(b2, val, idx) {
  b2[idx] = val & 255;
  b2[idx + 1] = val >> 8 & 255;
  b2[idx + 2] = val >> 16 & 255;
  b2[idx + 3] = val >> 24 & 255;
}, "__writeInt32LE");
var __writeUInt16LE = /* @__PURE__ */ __name(function(b2, val, idx) {
  b2[idx] = val & 255;
  b2[idx + 1] = val >>> 8 & 255;
}, "__writeUInt16LE");
function WriteShift(t2, val, f2) {
  var size = 0, i2 = 0;
  if (f2 === "dbcs") {
    for (i2 = 0; i2 != val.length; ++i2)
      __writeUInt16LE(this, val.charCodeAt(i2), this.l + 2 * i2);
    size = 2 * val.length;
  } else if (f2 === "sbcs") {
    {
      val = val.replace(/[^\x00-\x7F]/g, "_");
      for (i2 = 0; i2 != val.length; ++i2)
        this[this.l + i2] = val.charCodeAt(i2) & 255;
    }
    size = val.length;
  } else if (f2 === "hex") {
    for (; i2 < t2; ++i2) {
      this[this.l++] = parseInt(val.slice(2 * i2, 2 * i2 + 2), 16) || 0;
    }
    return this;
  } else if (f2 === "utf16le") {
    var end = Math.min(this.l + t2, this.length);
    for (i2 = 0; i2 < Math.min(val.length, t2); ++i2) {
      var cc = val.charCodeAt(i2);
      this[this.l++] = cc & 255;
      this[this.l++] = cc >> 8;
    }
    while (this.l < end)
      this[this.l++] = 0;
    return this;
  } else
    switch (t2) {
      case 1:
        size = 1;
        this[this.l] = val & 255;
        break;
      case 2:
        size = 2;
        this[this.l] = val & 255;
        val >>>= 8;
        this[this.l + 1] = val & 255;
        break;
      case 3:
        size = 3;
        this[this.l] = val & 255;
        val >>>= 8;
        this[this.l + 1] = val & 255;
        val >>>= 8;
        this[this.l + 2] = val & 255;
        break;
      case 4:
        size = 4;
        __writeUInt32LE(this, val, this.l);
        break;
      case 8:
        size = 8;
        if (f2 === "f") {
          write_double_le(this, val, this.l);
          break;
        }
      case 16:
        break;
      case -4:
        size = 4;
        __writeInt32LE(this, val, this.l);
        break;
    }
  this.l += size;
  return this;
}
__name(WriteShift, "WriteShift");
function CheckField(hexstr, fld) {
  var m2 = __hexlify(this, this.l, hexstr.length >> 1);
  if (m2 !== hexstr)
    throw new Error(fld + "Expected " + hexstr + " saw " + m2);
  this.l += hexstr.length >> 1;
}
__name(CheckField, "CheckField");
function prep_blob(blob, pos) {
  blob.l = pos;
  blob.read_shift = /*::(*/
  ReadShift;
  blob.chk = CheckField;
  blob.write_shift = WriteShift;
}
__name(prep_blob, "prep_blob");
function parsenoop(blob, length) {
  blob.l += length;
}
__name(parsenoop, "parsenoop");
function new_buf(sz) {
  var o2 = new_raw_buf(sz);
  prep_blob(o2, 0);
  return o2;
}
__name(new_buf, "new_buf");
function buf_array() {
  var bufs = [], blksz = has_buf ? 256 : 2048;
  var newblk = /* @__PURE__ */ __name(function ba_newblk(sz) {
    var o2 = new_buf(sz);
    prep_blob(o2, 0);
    return o2;
  }, "ba_newblk");
  var curbuf = newblk(blksz);
  var endbuf = /* @__PURE__ */ __name(function ba_endbuf() {
    if (!curbuf)
      return;
    if (curbuf.length > curbuf.l) {
      curbuf = curbuf.slice(0, curbuf.l);
      curbuf.l = curbuf.length;
    }
    if (curbuf.length > 0)
      bufs.push(curbuf);
    curbuf = null;
  }, "ba_endbuf");
  var next = /* @__PURE__ */ __name(function ba_next(sz) {
    if (curbuf && sz < curbuf.length - curbuf.l)
      return curbuf;
    endbuf();
    return curbuf = newblk(Math.max(sz + 1, blksz));
  }, "ba_next");
  var end = /* @__PURE__ */ __name(function ba_end() {
    endbuf();
    return bconcat(bufs);
  }, "ba_end");
  var push = /* @__PURE__ */ __name(function ba_push(buf) {
    endbuf();
    curbuf = buf;
    if (curbuf.l == null)
      curbuf.l = curbuf.length;
    next(blksz);
  }, "ba_push");
  return { next, push, end, _bufs: bufs };
}
__name(buf_array, "buf_array");
function write_record(ba, type, payload, length) {
  var t2 = +type, l2;
  if (isNaN(t2))
    return;
  if (!length)
    length = XLSBRecordEnum[t2].p || (payload || []).length || 0;
  l2 = 1 + (t2 >= 128 ? 1 : 0) + 1;
  if (length >= 128)
    ++l2;
  if (length >= 16384)
    ++l2;
  if (length >= 2097152)
    ++l2;
  var o2 = ba.next(l2);
  if (t2 <= 127)
    o2.write_shift(1, t2);
  else {
    o2.write_shift(1, (t2 & 127) + 128);
    o2.write_shift(1, t2 >> 7);
  }
  for (var i2 = 0; i2 != 4; ++i2) {
    if (length >= 128) {
      o2.write_shift(1, (length & 127) + 128);
      length >>= 7;
    } else {
      o2.write_shift(1, length);
      break;
    }
  }
  if (
    /*:: length != null &&*/
    length > 0 && is_buf(payload)
  )
    ba.push(payload);
}
__name(write_record, "write_record");
function shift_cell_xls(cell, tgt, opts) {
  var out = dup(cell);
  if (tgt.s) {
    if (out.cRel)
      out.c += tgt.s.c;
    if (out.rRel)
      out.r += tgt.s.r;
  } else {
    if (out.cRel)
      out.c += tgt.c;
    if (out.rRel)
      out.r += tgt.r;
  }
  if (!opts || opts.biff < 12) {
    while (out.c >= 256)
      out.c -= 256;
    while (out.r >= 65536)
      out.r -= 65536;
  }
  return out;
}
__name(shift_cell_xls, "shift_cell_xls");
function shift_range_xls(cell, range, opts) {
  var out = dup(cell);
  out.s = shift_cell_xls(out.s, range.s, opts);
  out.e = shift_cell_xls(out.e, range.s, opts);
  return out;
}
__name(shift_range_xls, "shift_range_xls");
function encode_cell_xls(c2, biff) {
  if (c2.cRel && c2.c < 0) {
    c2 = dup(c2);
    while (c2.c < 0)
      c2.c += biff > 8 ? 16384 : 256;
  }
  if (c2.rRel && c2.r < 0) {
    c2 = dup(c2);
    while (c2.r < 0)
      c2.r += biff > 8 ? 1048576 : biff > 5 ? 65536 : 16384;
  }
  var s2 = encode_cell(c2);
  if (!c2.cRel && c2.cRel != null)
    s2 = fix_col(s2);
  if (!c2.rRel && c2.rRel != null)
    s2 = fix_row(s2);
  return s2;
}
__name(encode_cell_xls, "encode_cell_xls");
function encode_range_xls(r, opts) {
  if (r.s.r == 0 && !r.s.rRel) {
    if (r.e.r == (opts.biff >= 12 ? 1048575 : opts.biff >= 8 ? 65536 : 16384) && !r.e.rRel) {
      return (r.s.cRel ? "" : "$") + encode_col(r.s.c) + ":" + (r.e.cRel ? "" : "$") + encode_col(r.e.c);
    }
  }
  if (r.s.c == 0 && !r.s.cRel) {
    if (r.e.c == (opts.biff >= 12 ? 16383 : 255) && !r.e.cRel) {
      return (r.s.rRel ? "" : "$") + encode_row(r.s.r) + ":" + (r.e.rRel ? "" : "$") + encode_row(r.e.r);
    }
  }
  return encode_cell_xls(r.s, opts.biff) + ":" + encode_cell_xls(r.e, opts.biff);
}
__name(encode_range_xls, "encode_range_xls");
function decode_row(rowstr) {
  return parseInt(unfix_row(rowstr), 10) - 1;
}
__name(decode_row, "decode_row");
function encode_row(row) {
  return "" + (row + 1);
}
__name(encode_row, "encode_row");
function fix_row(cstr) {
  return cstr.replace(/([A-Z]|^)(\d+)$/, "$1$$$2");
}
__name(fix_row, "fix_row");
function unfix_row(cstr) {
  return cstr.replace(/\$(\d+)$/, "$1");
}
__name(unfix_row, "unfix_row");
function decode_col(colstr) {
  var c2 = unfix_col(colstr), d2 = 0, i2 = 0;
  for (; i2 !== c2.length; ++i2)
    d2 = 26 * d2 + c2.charCodeAt(i2) - 64;
  return d2 - 1;
}
__name(decode_col, "decode_col");
function encode_col(col) {
  if (col < 0)
    throw new Error("invalid column " + col);
  var s2 = "";
  for (++col; col; col = Math.floor((col - 1) / 26))
    s2 = String.fromCharCode((col - 1) % 26 + 65) + s2;
  return s2;
}
__name(encode_col, "encode_col");
function fix_col(cstr) {
  return cstr.replace(/^([A-Z])/, "$$$1");
}
__name(fix_col, "fix_col");
function unfix_col(cstr) {
  return cstr.replace(/^\$([A-Z])/, "$1");
}
__name(unfix_col, "unfix_col");
function split_cell(cstr) {
  return cstr.replace(/(\$?[A-Z]*)(\$?\d*)/, "$1,$2").split(",");
}
__name(split_cell, "split_cell");
function decode_cell(cstr) {
  var R2 = 0, C2 = 0;
  for (var i2 = 0; i2 < cstr.length; ++i2) {
    var cc = cstr.charCodeAt(i2);
    if (cc >= 48 && cc <= 57)
      R2 = 10 * R2 + (cc - 48);
    else if (cc >= 65 && cc <= 90)
      C2 = 26 * C2 + (cc - 64);
  }
  return { c: C2 - 1, r: R2 - 1 };
}
__name(decode_cell, "decode_cell");
function encode_cell(cell) {
  var col = cell.c + 1;
  var s2 = "";
  for (; col; col = (col - 1) / 26 | 0)
    s2 = String.fromCharCode((col - 1) % 26 + 65) + s2;
  return s2 + (cell.r + 1);
}
__name(encode_cell, "encode_cell");
function decode_range(range) {
  var idx = range.indexOf(":");
  if (idx == -1)
    return { s: decode_cell(range), e: decode_cell(range) };
  return { s: decode_cell(range.slice(0, idx)), e: decode_cell(range.slice(idx + 1)) };
}
__name(decode_range, "decode_range");
function encode_range(cs, ce2) {
  if (typeof ce2 === "undefined" || typeof ce2 === "number") {
    return encode_range(cs.s, cs.e);
  }
  if (typeof cs !== "string")
    cs = encode_cell(cs);
  if (typeof ce2 !== "string")
    ce2 = encode_cell(ce2);
  return cs == ce2 ? cs : cs + ":" + ce2;
}
__name(encode_range, "encode_range");
function safe_decode_range(range) {
  var o2 = { s: { c: 0, r: 0 }, e: { c: 0, r: 0 } };
  var idx = 0, i2 = 0, cc = 0;
  var len = range.length;
  for (idx = 0; i2 < len; ++i2) {
    if ((cc = range.charCodeAt(i2) - 64) < 1 || cc > 26)
      break;
    idx = 26 * idx + cc;
  }
  o2.s.c = --idx;
  for (idx = 0; i2 < len; ++i2) {
    if ((cc = range.charCodeAt(i2) - 48) < 0 || cc > 9)
      break;
    idx = 10 * idx + cc;
  }
  o2.s.r = --idx;
  if (i2 === len || cc != 10) {
    o2.e.c = o2.s.c;
    o2.e.r = o2.s.r;
    return o2;
  }
  ++i2;
  for (idx = 0; i2 != len; ++i2) {
    if ((cc = range.charCodeAt(i2) - 64) < 1 || cc > 26)
      break;
    idx = 26 * idx + cc;
  }
  o2.e.c = --idx;
  for (idx = 0; i2 != len; ++i2) {
    if ((cc = range.charCodeAt(i2) - 48) < 0 || cc > 9)
      break;
    idx = 10 * idx + cc;
  }
  o2.e.r = --idx;
  return o2;
}
__name(safe_decode_range, "safe_decode_range");
function safe_format_cell(cell, v2) {
  var q2 = cell.t == "d" && v2 instanceof Date;
  if (cell.z != null)
    try {
      return cell.w = SSF_format(cell.z, q2 ? datenum(v2) : v2);
    } catch (e) {
    }
  try {
    return cell.w = SSF_format((cell.XF || {}).numFmtId || (q2 ? 14 : 0), q2 ? datenum(v2) : v2);
  } catch (e) {
    return "" + v2;
  }
}
__name(safe_format_cell, "safe_format_cell");
function format_cell(cell, v2, o2) {
  if (cell == null || cell.t == null || cell.t == "z")
    return "";
  if (cell.w !== void 0)
    return cell.w;
  if (cell.t == "d" && !cell.z && o2 && o2.dateNF)
    cell.z = o2.dateNF;
  if (cell.t == "e")
    return BErr[cell.v] || cell.v;
  if (v2 == void 0)
    return safe_format_cell(cell, cell.v);
  return safe_format_cell(cell, v2);
}
__name(format_cell, "format_cell");
function sheet_to_workbook(sheet, opts) {
  var n2 = opts && opts.sheet ? opts.sheet : "Sheet1";
  var sheets = {};
  sheets[n2] = sheet;
  return { SheetNames: [n2], Sheets: sheets };
}
__name(sheet_to_workbook, "sheet_to_workbook");
function sheet_add_aoa(_ws, data, opts) {
  var o2 = opts || {};
  var dense = _ws ? Array.isArray(_ws) : o2.dense;
  var ws = _ws || (dense ? [] : {});
  var _R = 0, _C = 0;
  if (ws && o2.origin != null) {
    if (typeof o2.origin == "number")
      _R = o2.origin;
    else {
      var _origin = typeof o2.origin == "string" ? decode_cell(o2.origin) : o2.origin;
      _R = _origin.r;
      _C = _origin.c;
    }
    if (!ws["!ref"])
      ws["!ref"] = "A1:A1";
  }
  var range = { s: { c: 1e7, r: 1e7 }, e: { c: 0, r: 0 } };
  if (ws["!ref"]) {
    var _range = safe_decode_range(ws["!ref"]);
    range.s.c = _range.s.c;
    range.s.r = _range.s.r;
    range.e.c = Math.max(range.e.c, _range.e.c);
    range.e.r = Math.max(range.e.r, _range.e.r);
    if (_R == -1)
      range.e.r = _R = _range.e.r + 1;
  }
  for (var R2 = 0; R2 != data.length; ++R2) {
    if (!data[R2])
      continue;
    if (!Array.isArray(data[R2]))
      throw new Error("aoa_to_sheet expects an array of arrays");
    for (var C2 = 0; C2 != data[R2].length; ++C2) {
      if (typeof data[R2][C2] === "undefined")
        continue;
      var cell = { v: data[R2][C2] };
      var __R = _R + R2, __C = _C + C2;
      if (range.s.r > __R)
        range.s.r = __R;
      if (range.s.c > __C)
        range.s.c = __C;
      if (range.e.r < __R)
        range.e.r = __R;
      if (range.e.c < __C)
        range.e.c = __C;
      if (data[R2][C2] && typeof data[R2][C2] === "object" && !Array.isArray(data[R2][C2]) && !(data[R2][C2] instanceof Date))
        cell = data[R2][C2];
      else {
        if (Array.isArray(cell.v)) {
          cell.f = data[R2][C2][1];
          cell.v = cell.v[0];
        }
        if (cell.v === null) {
          if (cell.f)
            cell.t = "n";
          else if (o2.nullError) {
            cell.t = "e";
            cell.v = 0;
          } else if (!o2.sheetStubs)
            continue;
          else
            cell.t = "z";
        } else if (typeof cell.v === "number")
          cell.t = "n";
        else if (typeof cell.v === "boolean")
          cell.t = "b";
        else if (cell.v instanceof Date) {
          cell.z = o2.dateNF || table_fmt[14];
          if (o2.cellDates) {
            cell.t = "d";
            cell.w = SSF_format(cell.z, datenum(cell.v));
          } else {
            cell.t = "n";
            cell.v = datenum(cell.v);
            cell.w = SSF_format(cell.z, cell.v);
          }
        } else
          cell.t = "s";
      }
      if (dense) {
        if (!ws[__R])
          ws[__R] = [];
        if (ws[__R][__C] && ws[__R][__C].z)
          cell.z = ws[__R][__C].z;
        ws[__R][__C] = cell;
      } else {
        var cell_ref = encode_cell({ c: __C, r: __R });
        if (ws[cell_ref] && ws[cell_ref].z)
          cell.z = ws[cell_ref].z;
        ws[cell_ref] = cell;
      }
    }
  }
  if (range.s.c < 1e7)
    ws["!ref"] = encode_range(range);
  return ws;
}
__name(sheet_add_aoa, "sheet_add_aoa");
function aoa_to_sheet(data, opts) {
  return sheet_add_aoa(null, data, opts);
}
__name(aoa_to_sheet, "aoa_to_sheet");
function parse_Int32LE(data) {
  return data.read_shift(4, "i");
}
__name(parse_Int32LE, "parse_Int32LE");
function write_UInt32LE(x2, o2) {
  if (!o2)
    o2 = new_buf(4);
  o2.write_shift(4, x2);
  return o2;
}
__name(write_UInt32LE, "write_UInt32LE");
function parse_XLWideString(data) {
  var cchCharacters = data.read_shift(4);
  return cchCharacters === 0 ? "" : data.read_shift(cchCharacters, "dbcs");
}
__name(parse_XLWideString, "parse_XLWideString");
function write_XLWideString(data, o2) {
  var _null = false;
  if (o2 == null) {
    _null = true;
    o2 = new_buf(4 + 2 * data.length);
  }
  o2.write_shift(4, data.length);
  if (data.length > 0)
    o2.write_shift(0, data, "dbcs");
  return _null ? o2.slice(0, o2.l) : o2;
}
__name(write_XLWideString, "write_XLWideString");
function parse_StrRun(data) {
  return { ich: data.read_shift(2), ifnt: data.read_shift(2) };
}
__name(parse_StrRun, "parse_StrRun");
function write_StrRun(run, o2) {
  if (!o2)
    o2 = new_buf(4);
  o2.write_shift(2, run.ich || 0);
  o2.write_shift(2, run.ifnt || 0);
  return o2;
}
__name(write_StrRun, "write_StrRun");
function parse_RichStr(data, length) {
  var start = data.l;
  var flags = data.read_shift(1);
  var str = parse_XLWideString(data);
  var rgsStrRun = [];
  var z2 = { t: str, h: str };
  if ((flags & 1) !== 0) {
    var dwSizeStrRun = data.read_shift(4);
    for (var i2 = 0; i2 != dwSizeStrRun; ++i2)
      rgsStrRun.push(parse_StrRun(data));
    z2.r = rgsStrRun;
  } else
    z2.r = [{ ich: 0, ifnt: 0 }];
  data.l = start + length;
  return z2;
}
__name(parse_RichStr, "parse_RichStr");
function write_RichStr(str, o2) {
  var _null = false;
  if (o2 == null) {
    _null = true;
    o2 = new_buf(15 + 4 * str.t.length);
  }
  o2.write_shift(1, 0);
  write_XLWideString(str.t, o2);
  return _null ? o2.slice(0, o2.l) : o2;
}
__name(write_RichStr, "write_RichStr");
var parse_BrtCommentText = parse_RichStr;
function write_BrtCommentText(str, o2) {
  var _null = false;
  if (o2 == null) {
    _null = true;
    o2 = new_buf(23 + 4 * str.t.length);
  }
  o2.write_shift(1, 1);
  write_XLWideString(str.t, o2);
  o2.write_shift(4, 1);
  write_StrRun({ ich: 0, ifnt: 0 }, o2);
  return _null ? o2.slice(0, o2.l) : o2;
}
__name(write_BrtCommentText, "write_BrtCommentText");
function parse_XLSBCell(data) {
  var col = data.read_shift(4);
  var iStyleRef = data.read_shift(2);
  iStyleRef += data.read_shift(1) << 16;
  data.l++;
  return { c: col, iStyleRef };
}
__name(parse_XLSBCell, "parse_XLSBCell");
function write_XLSBCell(cell, o2) {
  if (o2 == null)
    o2 = new_buf(8);
  o2.write_shift(-4, cell.c);
  o2.write_shift(3, cell.iStyleRef || cell.s);
  o2.write_shift(1, 0);
  return o2;
}
__name(write_XLSBCell, "write_XLSBCell");
function parse_XLSBShortCell(data) {
  var iStyleRef = data.read_shift(2);
  iStyleRef += data.read_shift(1) << 16;
  data.l++;
  return { c: -1, iStyleRef };
}
__name(parse_XLSBShortCell, "parse_XLSBShortCell");
function write_XLSBShortCell(cell, o2) {
  if (o2 == null)
    o2 = new_buf(4);
  o2.write_shift(3, cell.iStyleRef || cell.s);
  o2.write_shift(1, 0);
  return o2;
}
__name(write_XLSBShortCell, "write_XLSBShortCell");
var parse_XLSBCodeName = parse_XLWideString;
var write_XLSBCodeName = write_XLWideString;
function parse_XLNullableWideString(data) {
  var cchCharacters = data.read_shift(4);
  return cchCharacters === 0 || cchCharacters === 4294967295 ? "" : data.read_shift(cchCharacters, "dbcs");
}
__name(parse_XLNullableWideString, "parse_XLNullableWideString");
function write_XLNullableWideString(data, o2) {
  var _null = false;
  if (o2 == null) {
    _null = true;
    o2 = new_buf(127);
  }
  o2.write_shift(4, data.length > 0 ? data.length : 4294967295);
  if (data.length > 0)
    o2.write_shift(0, data, "dbcs");
  return _null ? o2.slice(0, o2.l) : o2;
}
__name(write_XLNullableWideString, "write_XLNullableWideString");
var parse_XLNameWideString = parse_XLWideString;
var parse_RelID = parse_XLNullableWideString;
var write_RelID = write_XLNullableWideString;
function parse_RkNumber(data) {
  var b2 = data.slice(data.l, data.l + 4);
  var fX100 = b2[0] & 1, fInt = b2[0] & 2;
  data.l += 4;
  var RK = fInt === 0 ? __double([0, 0, 0, 0, b2[0] & 252, b2[1], b2[2], b2[3]], 0) : __readInt32LE(b2, 0) >> 2;
  return fX100 ? RK / 100 : RK;
}
__name(parse_RkNumber, "parse_RkNumber");
function write_RkNumber(data, o2) {
  if (o2 == null)
    o2 = new_buf(4);
  var fX100 = 0, fInt = 0, d100 = data * 100;
  if (data == (data | 0) && data >= -(1 << 29) && data < 1 << 29) {
    fInt = 1;
  } else if (d100 == (d100 | 0) && d100 >= -(1 << 29) && d100 < 1 << 29) {
    fInt = 1;
    fX100 = 1;
  }
  if (fInt)
    o2.write_shift(-4, ((fX100 ? d100 : data) << 2) + (fX100 + 2));
  else
    throw new Error("unsupported RkNumber " + data);
}
__name(write_RkNumber, "write_RkNumber");
function parse_RfX(data) {
  var cell = { s: {}, e: {} };
  cell.s.r = data.read_shift(4);
  cell.e.r = data.read_shift(4);
  cell.s.c = data.read_shift(4);
  cell.e.c = data.read_shift(4);
  return cell;
}
__name(parse_RfX, "parse_RfX");
function write_RfX(r, o2) {
  if (!o2)
    o2 = new_buf(16);
  o2.write_shift(4, r.s.r);
  o2.write_shift(4, r.e.r);
  o2.write_shift(4, r.s.c);
  o2.write_shift(4, r.e.c);
  return o2;
}
__name(write_RfX, "write_RfX");
var parse_UncheckedRfX = parse_RfX;
var write_UncheckedRfX = write_RfX;
function parse_Xnum(data) {
  if (data.length - data.l < 8)
    throw "XLS Xnum Buffer underflow";
  return data.read_shift(8, "f");
}
__name(parse_Xnum, "parse_Xnum");
function write_Xnum(data, o2) {
  return (o2 || new_buf(8)).write_shift(8, data, "f");
}
__name(write_Xnum, "write_Xnum");
function parse_BrtColor(data) {
  var out = {};
  var d2 = data.read_shift(1);
  var xColorType = d2 >>> 1;
  var index2 = data.read_shift(1);
  var nTS = data.read_shift(2, "i");
  var bR = data.read_shift(1);
  var bG = data.read_shift(1);
  var bB = data.read_shift(1);
  data.l++;
  switch (xColorType) {
    case 0:
      out.auto = 1;
      break;
    case 1:
      out.index = index2;
      var icv = XLSIcv[index2];
      if (icv)
        out.rgb = rgb2Hex(icv);
      break;
    case 2:
      out.rgb = rgb2Hex([bR, bG, bB]);
      break;
    case 3:
      out.theme = index2;
      break;
  }
  if (nTS != 0)
    out.tint = nTS > 0 ? nTS / 32767 : nTS / 32768;
  return out;
}
__name(parse_BrtColor, "parse_BrtColor");
function write_BrtColor(color2, o2) {
  if (!o2)
    o2 = new_buf(8);
  if (!color2 || color2.auto) {
    o2.write_shift(4, 0);
    o2.write_shift(4, 0);
    return o2;
  }
  if (color2.index != null) {
    o2.write_shift(1, 2);
    o2.write_shift(1, color2.index);
  } else if (color2.theme != null) {
    o2.write_shift(1, 6);
    o2.write_shift(1, color2.theme);
  } else {
    o2.write_shift(1, 5);
    o2.write_shift(1, 0);
  }
  var nTS = color2.tint || 0;
  if (nTS > 0)
    nTS *= 32767;
  else if (nTS < 0)
    nTS *= 32768;
  o2.write_shift(2, nTS);
  if (!color2.rgb || color2.theme != null) {
    o2.write_shift(2, 0);
    o2.write_shift(1, 0);
    o2.write_shift(1, 0);
  } else {
    var rgb = color2.rgb || "FFFFFF";
    if (typeof rgb == "number")
      rgb = ("000000" + rgb.toString(16)).slice(-6);
    o2.write_shift(1, parseInt(rgb.slice(0, 2), 16));
    o2.write_shift(1, parseInt(rgb.slice(2, 4), 16));
    o2.write_shift(1, parseInt(rgb.slice(4, 6), 16));
    o2.write_shift(1, 255);
  }
  return o2;
}
__name(write_BrtColor, "write_BrtColor");
function parse_FontFlags(data) {
  var d2 = data.read_shift(1);
  data.l++;
  var out = {
    fBold: d2 & 1,
    fItalic: d2 & 2,
    fUnderline: d2 & 4,
    fStrikeout: d2 & 8,
    fOutline: d2 & 16,
    fShadow: d2 & 32,
    fCondense: d2 & 64,
    fExtend: d2 & 128
  };
  return out;
}
__name(parse_FontFlags, "parse_FontFlags");
function write_FontFlags(font, o2) {
  if (!o2)
    o2 = new_buf(2);
  var grbit = (font.italic ? 2 : 0) | (font.strike ? 8 : 0) | (font.outline ? 16 : 0) | (font.shadow ? 32 : 0) | (font.condense ? 64 : 0) | (font.extend ? 128 : 0);
  o2.write_shift(1, grbit);
  o2.write_shift(1, 0);
  return o2;
}
__name(write_FontFlags, "write_FontFlags");
var VT_I2 = 2;
var VT_I4 = 3;
var VT_BOOL = 11;
var VT_UI4 = 19;
var VT_FILETIME = 64;
var VT_BLOB = 65;
var VT_CF = 71;
var VT_VECTOR_VARIANT = 4108;
var VT_VECTOR_LPSTR = 4126;
var VT_STRING = 80;
var DocSummaryPIDDSI = {
  /*::[*/
  1: { n: "CodePage", t: VT_I2 },
  /*::[*/
  2: { n: "Category", t: VT_STRING },
  /*::[*/
  3: { n: "PresentationFormat", t: VT_STRING },
  /*::[*/
  4: { n: "ByteCount", t: VT_I4 },
  /*::[*/
  5: { n: "LineCount", t: VT_I4 },
  /*::[*/
  6: { n: "ParagraphCount", t: VT_I4 },
  /*::[*/
  7: { n: "SlideCount", t: VT_I4 },
  /*::[*/
  8: { n: "NoteCount", t: VT_I4 },
  /*::[*/
  9: { n: "HiddenCount", t: VT_I4 },
  /*::[*/
  10: { n: "MultimediaClipCount", t: VT_I4 },
  /*::[*/
  11: { n: "ScaleCrop", t: VT_BOOL },
  /*::[*/
  12: {
    n: "HeadingPairs",
    t: VT_VECTOR_VARIANT
    /* VT_VECTOR | VT_VARIANT */
  },
  /*::[*/
  13: {
    n: "TitlesOfParts",
    t: VT_VECTOR_LPSTR
    /* VT_VECTOR | VT_LPSTR */
  },
  /*::[*/
  14: { n: "Manager", t: VT_STRING },
  /*::[*/
  15: { n: "Company", t: VT_STRING },
  /*::[*/
  16: { n: "LinksUpToDate", t: VT_BOOL },
  /*::[*/
  17: { n: "CharacterCount", t: VT_I4 },
  /*::[*/
  19: { n: "SharedDoc", t: VT_BOOL },
  /*::[*/
  22: { n: "HyperlinksChanged", t: VT_BOOL },
  /*::[*/
  23: { n: "AppVersion", t: VT_I4, p: "version" },
  /*::[*/
  24: { n: "DigSig", t: VT_BLOB },
  /*::[*/
  26: { n: "ContentType", t: VT_STRING },
  /*::[*/
  27: { n: "ContentStatus", t: VT_STRING },
  /*::[*/
  28: { n: "Language", t: VT_STRING },
  /*::[*/
  29: { n: "Version", t: VT_STRING },
  /*::[*/
  255: {},
  /* [MS-OLEPS] 2.18 */
  /*::[*/
  2147483648: { n: "Locale", t: VT_UI4 },
  /*::[*/
  2147483651: { n: "Behavior", t: VT_UI4 },
  /*::[*/
  1919054434: {}
};
var SummaryPIDSI = {
  /*::[*/
  1: { n: "CodePage", t: VT_I2 },
  /*::[*/
  2: { n: "Title", t: VT_STRING },
  /*::[*/
  3: { n: "Subject", t: VT_STRING },
  /*::[*/
  4: { n: "Author", t: VT_STRING },
  /*::[*/
  5: { n: "Keywords", t: VT_STRING },
  /*::[*/
  6: { n: "Comments", t: VT_STRING },
  /*::[*/
  7: { n: "Template", t: VT_STRING },
  /*::[*/
  8: { n: "LastAuthor", t: VT_STRING },
  /*::[*/
  9: { n: "RevNumber", t: VT_STRING },
  /*::[*/
  10: { n: "EditTime", t: VT_FILETIME },
  /*::[*/
  11: { n: "LastPrinted", t: VT_FILETIME },
  /*::[*/
  12: { n: "CreatedDate", t: VT_FILETIME },
  /*::[*/
  13: { n: "ModifiedDate", t: VT_FILETIME },
  /*::[*/
  14: { n: "PageCount", t: VT_I4 },
  /*::[*/
  15: { n: "WordCount", t: VT_I4 },
  /*::[*/
  16: { n: "CharCount", t: VT_I4 },
  /*::[*/
  17: { n: "Thumbnail", t: VT_CF },
  /*::[*/
  18: { n: "Application", t: VT_STRING },
  /*::[*/
  19: { n: "DocSecurity", t: VT_I4 },
  /*::[*/
  255: {},
  /* [MS-OLEPS] 2.18 */
  /*::[*/
  2147483648: { n: "Locale", t: VT_UI4 },
  /*::[*/
  2147483651: { n: "Behavior", t: VT_UI4 },
  /*::[*/
  1919054434: {}
};
function rgbify(arr) {
  return arr.map(function(x2) {
    return [x2 >> 16 & 255, x2 >> 8 & 255, x2 & 255];
  });
}
__name(rgbify, "rgbify");
var _XLSIcv = /* @__PURE__ */ rgbify([
  /* Color Constants */
  0,
  16777215,
  16711680,
  65280,
  255,
  16776960,
  16711935,
  65535,
  /* Overridable Defaults */
  0,
  16777215,
  16711680,
  65280,
  255,
  16776960,
  16711935,
  65535,
  8388608,
  32768,
  128,
  8421376,
  8388736,
  32896,
  12632256,
  8421504,
  10066431,
  10040166,
  16777164,
  13434879,
  6684774,
  16744576,
  26316,
  13421823,
  128,
  16711935,
  16776960,
  65535,
  8388736,
  8388608,
  32896,
  255,
  52479,
  13434879,
  13434828,
  16777113,
  10079487,
  16751052,
  13408767,
  16764057,
  3368703,
  3394764,
  10079232,
  16763904,
  16750848,
  16737792,
  6710937,
  9868950,
  13158,
  3381606,
  13056,
  3355392,
  10040064,
  10040166,
  3355545,
  3355443,
  /* Other entries to appease BIFF8/12 */
  16777215,
  /* 0x40 icvForeground ?? */
  0,
  /* 0x41 icvBackground ?? */
  0,
  /* 0x42 icvFrame ?? */
  0,
  /* 0x43 icv3D ?? */
  0,
  /* 0x44 icv3DText ?? */
  0,
  /* 0x45 icv3DHilite ?? */
  0,
  /* 0x46 icv3DShadow ?? */
  0,
  /* 0x47 icvHilite ?? */
  0,
  /* 0x48 icvCtlText ?? */
  0,
  /* 0x49 icvCtlScrl ?? */
  0,
  /* 0x4A icvCtlInv ?? */
  0,
  /* 0x4B icvCtlBody ?? */
  0,
  /* 0x4C icvCtlFrame ?? */
  0,
  /* 0x4D icvCtlFore ?? */
  0,
  /* 0x4E icvCtlBack ?? */
  0,
  /* 0x4F icvCtlNeutral */
  0,
  /* 0x50 icvInfoBk ?? */
  0
  /* 0x51 icvInfoText ?? */
]);
var XLSIcv = /* @__PURE__ */ dup(_XLSIcv);
var BErr = {
  /*::[*/
  0: "#NULL!",
  /*::[*/
  7: "#DIV/0!",
  /*::[*/
  15: "#VALUE!",
  /*::[*/
  23: "#REF!",
  /*::[*/
  29: "#NAME?",
  /*::[*/
  36: "#NUM!",
  /*::[*/
  42: "#N/A",
  /*::[*/
  43: "#GETTING_DATA",
  /*::[*/
  255: "#WTF?"
};
var ct2type = {
  /* Workbook */
  "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml": "workbooks",
  "application/vnd.ms-excel.sheet.macroEnabled.main+xml": "workbooks",
  "application/vnd.ms-excel.sheet.binary.macroEnabled.main": "workbooks",
  "application/vnd.ms-excel.addin.macroEnabled.main+xml": "workbooks",
  "application/vnd.openxmlformats-officedocument.spreadsheetml.template.main+xml": "workbooks",
  /* Worksheet */
  "application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml": "sheets",
  "application/vnd.ms-excel.worksheet": "sheets",
  "application/vnd.ms-excel.binIndexWs": "TODO",
  /* Binary Index */
  /* Chartsheet */
  "application/vnd.openxmlformats-officedocument.spreadsheetml.chartsheet+xml": "charts",
  "application/vnd.ms-excel.chartsheet": "charts",
  /* Macrosheet */
  "application/vnd.ms-excel.macrosheet+xml": "macros",
  "application/vnd.ms-excel.macrosheet": "macros",
  "application/vnd.ms-excel.intlmacrosheet": "TODO",
  "application/vnd.ms-excel.binIndexMs": "TODO",
  /* Binary Index */
  /* Dialogsheet */
  "application/vnd.openxmlformats-officedocument.spreadsheetml.dialogsheet+xml": "dialogs",
  "application/vnd.ms-excel.dialogsheet": "dialogs",
  /* Shared Strings */
  "application/vnd.openxmlformats-officedocument.spreadsheetml.sharedStrings+xml": "strs",
  "application/vnd.ms-excel.sharedStrings": "strs",
  /* Styles */
  "application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml": "styles",
  "application/vnd.ms-excel.styles": "styles",
  /* File Properties */
  "application/vnd.openxmlformats-package.core-properties+xml": "coreprops",
  "application/vnd.openxmlformats-officedocument.custom-properties+xml": "custprops",
  "application/vnd.openxmlformats-officedocument.extended-properties+xml": "extprops",
  /* Custom Data Properties */
  "application/vnd.openxmlformats-officedocument.customXmlProperties+xml": "TODO",
  "application/vnd.openxmlformats-officedocument.spreadsheetml.customProperty": "TODO",
  /* Comments */
  "application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml": "comments",
  "application/vnd.ms-excel.comments": "comments",
  "application/vnd.ms-excel.threadedcomments+xml": "threadedcomments",
  "application/vnd.ms-excel.person+xml": "people",
  /* Metadata (Stock/Geography and Dynamic Array) */
  "application/vnd.openxmlformats-officedocument.spreadsheetml.sheetMetadata+xml": "metadata",
  "application/vnd.ms-excel.sheetMetadata": "metadata",
  /* PivotTable */
  "application/vnd.ms-excel.pivotTable": "TODO",
  "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotTable+xml": "TODO",
  /* Chart Objects */
  "application/vnd.openxmlformats-officedocument.drawingml.chart+xml": "TODO",
  /* Chart Colors */
  "application/vnd.ms-office.chartcolorstyle+xml": "TODO",
  /* Chart Style */
  "application/vnd.ms-office.chartstyle+xml": "TODO",
  /* Chart Advanced */
  "application/vnd.ms-office.chartex+xml": "TODO",
  /* Calculation Chain */
  "application/vnd.ms-excel.calcChain": "calcchains",
  "application/vnd.openxmlformats-officedocument.spreadsheetml.calcChain+xml": "calcchains",
  /* Printer Settings */
  "application/vnd.openxmlformats-officedocument.spreadsheetml.printerSettings": "TODO",
  /* ActiveX */
  "application/vnd.ms-office.activeX": "TODO",
  "application/vnd.ms-office.activeX+xml": "TODO",
  /* Custom Toolbars */
  "application/vnd.ms-excel.attachedToolbars": "TODO",
  /* External Data Connections */
  "application/vnd.ms-excel.connections": "TODO",
  "application/vnd.openxmlformats-officedocument.spreadsheetml.connections+xml": "TODO",
  /* External Links */
  "application/vnd.ms-excel.externalLink": "links",
  "application/vnd.openxmlformats-officedocument.spreadsheetml.externalLink+xml": "links",
  /* PivotCache */
  "application/vnd.ms-excel.pivotCacheDefinition": "TODO",
  "application/vnd.ms-excel.pivotCacheRecords": "TODO",
  "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotCacheDefinition+xml": "TODO",
  "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotCacheRecords+xml": "TODO",
  /* Query Table */
  "application/vnd.ms-excel.queryTable": "TODO",
  "application/vnd.openxmlformats-officedocument.spreadsheetml.queryTable+xml": "TODO",
  /* Shared Workbook */
  "application/vnd.ms-excel.userNames": "TODO",
  "application/vnd.ms-excel.revisionHeaders": "TODO",
  "application/vnd.ms-excel.revisionLog": "TODO",
  "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionHeaders+xml": "TODO",
  "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionLog+xml": "TODO",
  "application/vnd.openxmlformats-officedocument.spreadsheetml.userNames+xml": "TODO",
  /* Single Cell Table */
  "application/vnd.ms-excel.tableSingleCells": "TODO",
  "application/vnd.openxmlformats-officedocument.spreadsheetml.tableSingleCells+xml": "TODO",
  /* Slicer */
  "application/vnd.ms-excel.slicer": "TODO",
  "application/vnd.ms-excel.slicerCache": "TODO",
  "application/vnd.ms-excel.slicer+xml": "TODO",
  "application/vnd.ms-excel.slicerCache+xml": "TODO",
  /* Sort Map */
  "application/vnd.ms-excel.wsSortMap": "TODO",
  /* Table */
  "application/vnd.ms-excel.table": "TODO",
  "application/vnd.openxmlformats-officedocument.spreadsheetml.table+xml": "TODO",
  /* Themes */
  "application/vnd.openxmlformats-officedocument.theme+xml": "themes",
  /* Theme Override */
  "application/vnd.openxmlformats-officedocument.themeOverride+xml": "TODO",
  /* Timeline */
  "application/vnd.ms-excel.Timeline+xml": "TODO",
  /* verify */
  "application/vnd.ms-excel.TimelineCache+xml": "TODO",
  /* verify */
  /* VBA */
  "application/vnd.ms-office.vbaProject": "vba",
  "application/vnd.ms-office.vbaProjectSignature": "TODO",
  /* Volatile Dependencies */
  "application/vnd.ms-office.volatileDependencies": "TODO",
  "application/vnd.openxmlformats-officedocument.spreadsheetml.volatileDependencies+xml": "TODO",
  /* Control Properties */
  "application/vnd.ms-excel.controlproperties+xml": "TODO",
  /* Data Model */
  "application/vnd.openxmlformats-officedocument.model+data": "TODO",
  /* Survey */
  "application/vnd.ms-excel.Survey+xml": "TODO",
  /* Drawing */
  "application/vnd.openxmlformats-officedocument.drawing+xml": "drawings",
  "application/vnd.openxmlformats-officedocument.drawingml.chartshapes+xml": "TODO",
  "application/vnd.openxmlformats-officedocument.drawingml.diagramColors+xml": "TODO",
  "application/vnd.openxmlformats-officedocument.drawingml.diagramData+xml": "TODO",
  "application/vnd.openxmlformats-officedocument.drawingml.diagramLayout+xml": "TODO",
  "application/vnd.openxmlformats-officedocument.drawingml.diagramStyle+xml": "TODO",
  /* VML */
  "application/vnd.openxmlformats-officedocument.vmlDrawing": "TODO",
  "application/vnd.openxmlformats-package.relationships+xml": "rels",
  "application/vnd.openxmlformats-officedocument.oleObject": "TODO",
  /* Image */
  "image/png": "TODO",
  "sheet": "js"
};
var CT_LIST = {
  workbooks: {
    xlsx: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml",
    xlsm: "application/vnd.ms-excel.sheet.macroEnabled.main+xml",
    xlsb: "application/vnd.ms-excel.sheet.binary.macroEnabled.main",
    xlam: "application/vnd.ms-excel.addin.macroEnabled.main+xml",
    xltx: "application/vnd.openxmlformats-officedocument.spreadsheetml.template.main+xml"
  },
  strs: {
    /* Shared Strings */
    xlsx: "application/vnd.openxmlformats-officedocument.spreadsheetml.sharedStrings+xml",
    xlsb: "application/vnd.ms-excel.sharedStrings"
  },
  comments: {
    /* Comments */
    xlsx: "application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml",
    xlsb: "application/vnd.ms-excel.comments"
  },
  sheets: {
    /* Worksheet */
    xlsx: "application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml",
    xlsb: "application/vnd.ms-excel.worksheet"
  },
  charts: {
    /* Chartsheet */
    xlsx: "application/vnd.openxmlformats-officedocument.spreadsheetml.chartsheet+xml",
    xlsb: "application/vnd.ms-excel.chartsheet"
  },
  dialogs: {
    /* Dialogsheet */
    xlsx: "application/vnd.openxmlformats-officedocument.spreadsheetml.dialogsheet+xml",
    xlsb: "application/vnd.ms-excel.dialogsheet"
  },
  macros: {
    /* Macrosheet (Excel 4.0 Macros) */
    xlsx: "application/vnd.ms-excel.macrosheet+xml",
    xlsb: "application/vnd.ms-excel.macrosheet"
  },
  metadata: {
    /* Metadata (Stock/Geography and Dynamic Array) */
    xlsx: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheetMetadata+xml",
    xlsb: "application/vnd.ms-excel.sheetMetadata"
  },
  styles: {
    /* Styles */
    xlsx: "application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml",
    xlsb: "application/vnd.ms-excel.styles"
  }
};
function new_ct() {
  return {
    workbooks: [],
    sheets: [],
    charts: [],
    dialogs: [],
    macros: [],
    rels: [],
    strs: [],
    comments: [],
    threadedcomments: [],
    links: [],
    coreprops: [],
    extprops: [],
    custprops: [],
    themes: [],
    styles: [],
    calcchains: [],
    vba: [],
    drawings: [],
    metadata: [],
    people: [],
    TODO: [],
    xmlns: ""
  };
}
__name(new_ct, "new_ct");
function write_ct(ct2, opts) {
  var type2ct = evert_arr(ct2type);
  var o2 = [], v2;
  o2[o2.length] = XML_HEADER;
  o2[o2.length] = writextag("Types", null, {
    "xmlns": XMLNS.CT,
    "xmlns:xsd": XMLNS.xsd,
    "xmlns:xsi": XMLNS.xsi
  });
  o2 = o2.concat([
    ["xml", "application/xml"],
    ["bin", "application/vnd.ms-excel.sheet.binary.macroEnabled.main"],
    ["vml", "application/vnd.openxmlformats-officedocument.vmlDrawing"],
    ["data", "application/vnd.openxmlformats-officedocument.model+data"],
    /* from test files */
    ["bmp", "image/bmp"],
    ["png", "image/png"],
    ["gif", "image/gif"],
    ["emf", "image/x-emf"],
    ["wmf", "image/x-wmf"],
    ["jpg", "image/jpeg"],
    ["jpeg", "image/jpeg"],
    ["tif", "image/tiff"],
    ["tiff", "image/tiff"],
    ["pdf", "application/pdf"],
    ["rels", "application/vnd.openxmlformats-package.relationships+xml"]
  ].map(function(x2) {
    return writextag("Default", null, { "Extension": x2[0], "ContentType": x2[1] });
  }));
  var f1 = /* @__PURE__ */ __name(function(w2) {
    if (ct2[w2] && ct2[w2].length > 0) {
      v2 = ct2[w2][0];
      o2[o2.length] = writextag("Override", null, {
        "PartName": (v2[0] == "/" ? "" : "/") + v2,
        "ContentType": CT_LIST[w2][opts.bookType] || CT_LIST[w2]["xlsx"]
      });
    }
  }, "f1");
  var f2 = /* @__PURE__ */ __name(function(w2) {
    (ct2[w2] || []).forEach(function(v3) {
      o2[o2.length] = writextag("Override", null, {
        "PartName": (v3[0] == "/" ? "" : "/") + v3,
        "ContentType": CT_LIST[w2][opts.bookType] || CT_LIST[w2]["xlsx"]
      });
    });
  }, "f2");
  var f3 = /* @__PURE__ */ __name(function(t2) {
    (ct2[t2] || []).forEach(function(v3) {
      o2[o2.length] = writextag("Override", null, {
        "PartName": (v3[0] == "/" ? "" : "/") + v3,
        "ContentType": type2ct[t2][0]
      });
    });
  }, "f3");
  f1("workbooks");
  f2("sheets");
  f2("charts");
  f3("themes");
  ["strs", "styles"].forEach(f1);
  ["coreprops", "extprops", "custprops"].forEach(f3);
  f3("vba");
  f3("comments");
  f3("threadedcomments");
  f3("drawings");
  f2("metadata");
  f3("people");
  if (o2.length > 2) {
    o2[o2.length] = "</Types>";
    o2[1] = o2[1].replace("/>", ">");
  }
  return o2.join("");
}
__name(write_ct, "write_ct");
var RELS = {
  WB: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/officeDocument",
  SHEET: "http://sheetjs.openxmlformats.org/officeDocument/2006/relationships/officeDocument",
  HLINK: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/hyperlink",
  VML: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/vmlDrawing",
  XPATH: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/externalLinkPath",
  XMISS: "http://schemas.microsoft.com/office/2006/relationships/xlExternalLinkPath/xlPathMissing",
  XLINK: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/externalLink",
  CXML: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/customXml",
  CXMLP: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/customXmlProps",
  CMNT: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/comments",
  CORE_PROPS: "http://schemas.openxmlformats.org/package/2006/relationships/metadata/core-properties",
  EXT_PROPS: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/extended-properties",
  CUST_PROPS: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/custom-properties",
  SST: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/sharedStrings",
  STY: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/styles",
  THEME: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/theme",
  CHART: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/chart",
  CHARTEX: "http://schemas.microsoft.com/office/2014/relationships/chartEx",
  CS: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/chartsheet",
  WS: [
    "http://schemas.openxmlformats.org/officeDocument/2006/relationships/worksheet",
    "http://purl.oclc.org/ooxml/officeDocument/relationships/worksheet"
  ],
  DS: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/dialogsheet",
  MS: "http://schemas.microsoft.com/office/2006/relationships/xlMacrosheet",
  IMG: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/image",
  DRAW: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/drawing",
  XLMETA: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/sheetMetadata",
  TCMNT: "http://schemas.microsoft.com/office/2017/10/relationships/threadedComment",
  PEOPLE: "http://schemas.microsoft.com/office/2017/10/relationships/person",
  VBA: "http://schemas.microsoft.com/office/2006/relationships/vbaProject"
};
function get_rels_path(file) {
  var n2 = file.lastIndexOf("/");
  return file.slice(0, n2 + 1) + "_rels/" + file.slice(n2 + 1) + ".rels";
}
__name(get_rels_path, "get_rels_path");
function write_rels(rels) {
  var o2 = [XML_HEADER, writextag("Relationships", null, {
    //'xmlns:ns0': XMLNS.RELS,
    "xmlns": XMLNS.RELS
  })];
  keys(rels["!id"]).forEach(function(rid) {
    o2[o2.length] = writextag("Relationship", null, rels["!id"][rid]);
  });
  if (o2.length > 2) {
    o2[o2.length] = "</Relationships>";
    o2[1] = o2[1].replace("/>", ">");
  }
  return o2.join("");
}
__name(write_rels, "write_rels");
function add_rels(rels, rId, f2, type, relobj, targetmode) {
  if (!relobj)
    relobj = {};
  if (!rels["!id"])
    rels["!id"] = {};
  if (!rels["!idx"])
    rels["!idx"] = 1;
  if (rId < 0)
    for (rId = rels["!idx"]; rels["!id"]["rId" + rId]; ++rId) {
    }
  rels["!idx"] = rId + 1;
  relobj.Id = "rId" + rId;
  relobj.Type = type;
  relobj.Target = f2;
  if (targetmode)
    relobj.TargetMode = targetmode;
  else if ([RELS.HLINK, RELS.XPATH, RELS.XMISS].indexOf(relobj.Type) > -1)
    relobj.TargetMode = "External";
  if (rels["!id"][relobj.Id])
    throw new Error("Cannot rewrite rId " + rId);
  rels["!id"][relobj.Id] = relobj;
  rels[("/" + relobj.Target).replace("//", "/")] = relobj;
  return rId;
}
__name(add_rels, "add_rels");
function write_manifest(manifest) {
  var o2 = [XML_HEADER];
  o2.push('<manifest:manifest xmlns:manifest="urn:oasis:names:tc:opendocument:xmlns:manifest:1.0" manifest:version="1.2">\n');
  o2.push('  <manifest:file-entry manifest:full-path="/" manifest:version="1.2" manifest:media-type="application/vnd.oasis.opendocument.spreadsheet"/>\n');
  for (var i2 = 0; i2 < manifest.length; ++i2)
    o2.push('  <manifest:file-entry manifest:full-path="' + manifest[i2][0] + '" manifest:media-type="' + manifest[i2][1] + '"/>\n');
  o2.push("</manifest:manifest>");
  return o2.join("");
}
__name(write_manifest, "write_manifest");
function write_rdf_type(file, res, tag) {
  return [
    '  <rdf:Description rdf:about="' + file + '">\n',
    '    <rdf:type rdf:resource="http://docs.oasis-open.org/ns/office/1.2/meta/' + (tag || "odf") + "#" + res + '"/>\n',
    "  </rdf:Description>\n"
  ].join("");
}
__name(write_rdf_type, "write_rdf_type");
function write_rdf_has(base, file) {
  return [
    '  <rdf:Description rdf:about="' + base + '">\n',
    '    <ns0:hasPart xmlns:ns0="http://docs.oasis-open.org/ns/office/1.2/meta/pkg#" rdf:resource="' + file + '"/>\n',
    "  </rdf:Description>\n"
  ].join("");
}
__name(write_rdf_has, "write_rdf_has");
function write_rdf(rdf) {
  var o2 = [XML_HEADER];
  o2.push('<rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#">\n');
  for (var i2 = 0; i2 != rdf.length; ++i2) {
    o2.push(write_rdf_type(rdf[i2][0], rdf[i2][1]));
    o2.push(write_rdf_has("", rdf[i2][0]));
  }
  o2.push(write_rdf_type("", "Document", "pkg"));
  o2.push("</rdf:RDF>");
  return o2.join("");
}
__name(write_rdf, "write_rdf");
function write_meta_ods() {
  return '<office:document-meta xmlns:office="urn:oasis:names:tc:opendocument:xmlns:office:1.0" xmlns:meta="urn:oasis:names:tc:opendocument:xmlns:meta:1.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:xlink="http://www.w3.org/1999/xlink" office:version="1.2"><office:meta><meta:generator>SheetJS ' + XLSX.version + "</meta:generator></office:meta></office:document-meta>";
}
__name(write_meta_ods, "write_meta_ods");
var CORE_PROPS = [
  ["cp:category", "Category"],
  ["cp:contentStatus", "ContentStatus"],
  ["cp:keywords", "Keywords"],
  ["cp:lastModifiedBy", "LastAuthor"],
  ["cp:lastPrinted", "LastPrinted"],
  ["cp:revision", "RevNumber"],
  ["cp:version", "Version"],
  ["dc:creator", "Author"],
  ["dc:description", "Comments"],
  ["dc:identifier", "Identifier"],
  ["dc:language", "Language"],
  ["dc:subject", "Subject"],
  ["dc:title", "Title"],
  ["dcterms:created", "CreatedDate", "date"],
  ["dcterms:modified", "ModifiedDate", "date"]
];
function cp_doit(f2, g2, h3, o2, p2) {
  if (p2[f2] != null || g2 == null || g2 === "")
    return;
  p2[f2] = g2;
  g2 = escapexml(g2);
  o2[o2.length] = h3 ? writextag(f2, g2, h3) : writetag(f2, g2);
}
__name(cp_doit, "cp_doit");
function write_core_props(cp, _opts) {
  var opts = _opts || {};
  var o2 = [XML_HEADER, writextag("cp:coreProperties", null, {
    //'xmlns': XMLNS.CORE_PROPS,
    "xmlns:cp": XMLNS.CORE_PROPS,
    "xmlns:dc": XMLNS.dc,
    "xmlns:dcterms": XMLNS.dcterms,
    "xmlns:dcmitype": XMLNS.dcmitype,
    "xmlns:xsi": XMLNS.xsi
  })], p2 = {};
  if (!cp && !opts.Props)
    return o2.join("");
  if (cp) {
    if (cp.CreatedDate != null)
      cp_doit("dcterms:created", typeof cp.CreatedDate === "string" ? cp.CreatedDate : write_w3cdtf(cp.CreatedDate, opts.WTF), { "xsi:type": "dcterms:W3CDTF" }, o2, p2);
    if (cp.ModifiedDate != null)
      cp_doit("dcterms:modified", typeof cp.ModifiedDate === "string" ? cp.ModifiedDate : write_w3cdtf(cp.ModifiedDate, opts.WTF), { "xsi:type": "dcterms:W3CDTF" }, o2, p2);
  }
  for (var i2 = 0; i2 != CORE_PROPS.length; ++i2) {
    var f2 = CORE_PROPS[i2];
    var v2 = opts.Props && opts.Props[f2[1]] != null ? opts.Props[f2[1]] : cp ? cp[f2[1]] : null;
    if (v2 === true)
      v2 = "1";
    else if (v2 === false)
      v2 = "0";
    else if (typeof v2 == "number")
      v2 = String(v2);
    if (v2 != null)
      cp_doit(f2[0], v2, null, o2, p2);
  }
  if (o2.length > 2) {
    o2[o2.length] = "</cp:coreProperties>";
    o2[1] = o2[1].replace("/>", ">");
  }
  return o2.join("");
}
__name(write_core_props, "write_core_props");
var EXT_PROPS = [
  ["Application", "Application", "string"],
  ["AppVersion", "AppVersion", "string"],
  ["Company", "Company", "string"],
  ["DocSecurity", "DocSecurity", "string"],
  ["Manager", "Manager", "string"],
  ["HyperlinksChanged", "HyperlinksChanged", "bool"],
  ["SharedDoc", "SharedDoc", "bool"],
  ["LinksUpToDate", "LinksUpToDate", "bool"],
  ["ScaleCrop", "ScaleCrop", "bool"],
  ["HeadingPairs", "HeadingPairs", "raw"],
  ["TitlesOfParts", "TitlesOfParts", "raw"]
];
var PseudoPropsPairs = [
  "Worksheets",
  "SheetNames",
  "NamedRanges",
  "DefinedNames",
  "Chartsheets",
  "ChartNames"
];
function write_ext_props(cp) {
  var o2 = [], W2 = writextag;
  if (!cp)
    cp = {};
  cp.Application = "SheetJS";
  o2[o2.length] = XML_HEADER;
  o2[o2.length] = writextag("Properties", null, {
    "xmlns": XMLNS.EXT_PROPS,
    "xmlns:vt": XMLNS.vt
  });
  EXT_PROPS.forEach(function(f2) {
    if (cp[f2[1]] === void 0)
      return;
    var v2;
    switch (f2[2]) {
      case "string":
        v2 = escapexml(String(cp[f2[1]]));
        break;
      case "bool":
        v2 = cp[f2[1]] ? "true" : "false";
        break;
    }
    if (v2 !== void 0)
      o2[o2.length] = W2(f2[0], v2);
  });
  o2[o2.length] = W2("HeadingPairs", W2("vt:vector", W2("vt:variant", "<vt:lpstr>Worksheets</vt:lpstr>") + W2("vt:variant", W2("vt:i4", String(cp.Worksheets))), { size: 2, baseType: "variant" }));
  o2[o2.length] = W2("TitlesOfParts", W2("vt:vector", cp.SheetNames.map(function(s2) {
    return "<vt:lpstr>" + escapexml(s2) + "</vt:lpstr>";
  }).join(""), { size: cp.Worksheets, baseType: "lpstr" }));
  if (o2.length > 2) {
    o2[o2.length] = "</Properties>";
    o2[1] = o2[1].replace("/>", ">");
  }
  return o2.join("");
}
__name(write_ext_props, "write_ext_props");
function write_cust_props(cp) {
  var o2 = [XML_HEADER, writextag("Properties", null, {
    "xmlns": XMLNS.CUST_PROPS,
    "xmlns:vt": XMLNS.vt
  })];
  if (!cp)
    return o2.join("");
  var pid = 1;
  keys(cp).forEach(/* @__PURE__ */ __name(function custprop(k2) {
    ++pid;
    o2[o2.length] = writextag("property", write_vt(cp[k2], true), {
      "fmtid": "{D5CDD505-2E9C-101B-9397-08002B2CF9AE}",
      "pid": pid,
      "name": escapexml(k2)
    });
  }, "custprop"));
  if (o2.length > 2) {
    o2[o2.length] = "</Properties>";
    o2[1] = o2[1].replace("/>", ">");
  }
  return o2.join("");
}
__name(write_cust_props, "write_cust_props");
var XLMLDocPropsMap = {
  Title: "Title",
  Subject: "Subject",
  Author: "Author",
  Keywords: "Keywords",
  Comments: "Description",
  LastAuthor: "LastAuthor",
  RevNumber: "Revision",
  Application: "AppName",
  /* TotalTime: 'TotalTime', */
  LastPrinted: "LastPrinted",
  CreatedDate: "Created",
  ModifiedDate: "LastSaved",
  /* Pages */
  /* Words */
  /* Characters */
  Category: "Category",
  /* PresentationFormat */
  Manager: "Manager",
  Company: "Company",
  /* Guid */
  /* HyperlinkBase */
  /* Bytes */
  /* Lines */
  /* Paragraphs */
  /* CharactersWithSpaces */
  AppVersion: "Version",
  ContentStatus: "ContentStatus",
  /* NOTE: missing from schema */
  Identifier: "Identifier",
  /* NOTE: missing from schema */
  Language: "Language"
  /* NOTE: missing from schema */
};
function xlml_write_docprops(Props, opts) {
  var o2 = [];
  keys(XLMLDocPropsMap).map(function(m2) {
    for (var i2 = 0; i2 < CORE_PROPS.length; ++i2)
      if (CORE_PROPS[i2][1] == m2)
        return CORE_PROPS[i2];
    for (i2 = 0; i2 < EXT_PROPS.length; ++i2)
      if (EXT_PROPS[i2][1] == m2)
        return EXT_PROPS[i2];
    throw m2;
  }).forEach(function(p2) {
    if (Props[p2[1]] == null)
      return;
    var m2 = opts && opts.Props && opts.Props[p2[1]] != null ? opts.Props[p2[1]] : Props[p2[1]];
    switch (p2[2]) {
      case "date":
        m2 = new Date(m2).toISOString().replace(/\.\d*Z/, "Z");
        break;
    }
    if (typeof m2 == "number")
      m2 = String(m2);
    else if (m2 === true || m2 === false) {
      m2 = m2 ? "1" : "0";
    } else if (m2 instanceof Date)
      m2 = new Date(m2).toISOString().replace(/\.\d*Z/, "");
    o2.push(writetag(XLMLDocPropsMap[p2[1]] || p2[1], m2));
  });
  return writextag("DocumentProperties", o2.join(""), { xmlns: XLMLNS.o });
}
__name(xlml_write_docprops, "xlml_write_docprops");
function xlml_write_custprops(Props, Custprops) {
  var BLACKLIST = ["Worksheets", "SheetNames"];
  var T2 = "CustomDocumentProperties";
  var o2 = [];
  if (Props)
    keys(Props).forEach(function(k2) {
      if (!Object.prototype.hasOwnProperty.call(Props, k2))
        return;
      for (var i2 = 0; i2 < CORE_PROPS.length; ++i2)
        if (k2 == CORE_PROPS[i2][1])
          return;
      for (i2 = 0; i2 < EXT_PROPS.length; ++i2)
        if (k2 == EXT_PROPS[i2][1])
          return;
      for (i2 = 0; i2 < BLACKLIST.length; ++i2)
        if (k2 == BLACKLIST[i2])
          return;
      var m2 = Props[k2];
      var t2 = "string";
      if (typeof m2 == "number") {
        t2 = "float";
        m2 = String(m2);
      } else if (m2 === true || m2 === false) {
        t2 = "boolean";
        m2 = m2 ? "1" : "0";
      } else
        m2 = String(m2);
      o2.push(writextag(escapexmltag(k2), m2, { "dt:dt": t2 }));
    });
  if (Custprops)
    keys(Custprops).forEach(function(k2) {
      if (!Object.prototype.hasOwnProperty.call(Custprops, k2))
        return;
      if (Props && Object.prototype.hasOwnProperty.call(Props, k2))
        return;
      var m2 = Custprops[k2];
      var t2 = "string";
      if (typeof m2 == "number") {
        t2 = "float";
        m2 = String(m2);
      } else if (m2 === true || m2 === false) {
        t2 = "boolean";
        m2 = m2 ? "1" : "0";
      } else if (m2 instanceof Date) {
        t2 = "dateTime.tz";
        m2 = m2.toISOString();
      } else
        m2 = String(m2);
      o2.push(writextag(escapexmltag(k2), m2, { "dt:dt": t2 }));
    });
  return "<" + T2 + ' xmlns="' + XLMLNS.o + '">' + o2.join("") + "</" + T2 + ">";
}
__name(xlml_write_custprops, "xlml_write_custprops");
function write_FILETIME(time) {
  var date = typeof time == "string" ? new Date(Date.parse(time)) : time;
  var t2 = date.getTime() / 1e3 + 11644473600;
  var l2 = t2 % Math.pow(2, 32), h3 = (t2 - l2) / Math.pow(2, 32);
  l2 *= 1e7;
  h3 *= 1e7;
  var w2 = l2 / Math.pow(2, 32) | 0;
  if (w2 > 0) {
    l2 = l2 % Math.pow(2, 32);
    h3 += w2;
  }
  var o2 = new_buf(8);
  o2.write_shift(4, l2);
  o2.write_shift(4, h3);
  return o2;
}
__name(write_FILETIME, "write_FILETIME");
function write_TypedPropertyValue(type, value) {
  var o2 = new_buf(4), p2 = new_buf(4);
  o2.write_shift(4, type == 80 ? 31 : type);
  switch (type) {
    case 3:
      p2.write_shift(-4, value);
      break;
    case 5:
      p2 = new_buf(8);
      p2.write_shift(8, value, "f");
      break;
    case 11:
      p2.write_shift(4, value ? 1 : 0);
      break;
    case 64:
      p2 = write_FILETIME(value);
      break;
    case 31:
    case 80:
      p2 = new_buf(4 + 2 * (value.length + 1) + (value.length % 2 ? 0 : 2));
      p2.write_shift(4, value.length + 1);
      p2.write_shift(0, value, "dbcs");
      while (p2.l != p2.length)
        p2.write_shift(1, 0);
      break;
    default:
      throw new Error("TypedPropertyValue unrecognized type " + type + " " + value);
  }
  return bconcat([o2, p2]);
}
__name(write_TypedPropertyValue, "write_TypedPropertyValue");
var XLSPSSkip = ["CodePage", "Thumbnail", "_PID_LINKBASE", "_PID_HLINKS", "SystemIdentifier", "FMTID"];
function guess_property_type(val) {
  switch (typeof val) {
    case "boolean":
      return 11;
    case "number":
      return (val | 0) == val ? 3 : 5;
    case "string":
      return 31;
    case "object":
      if (val instanceof Date)
        return 64;
      break;
  }
  return -1;
}
__name(guess_property_type, "guess_property_type");
function write_PropertySet(entries, RE, PIDSI) {
  var hdr = new_buf(8), piao = [], prop = [];
  var sz = 8, i2 = 0;
  var pr = new_buf(8), pio = new_buf(8);
  pr.write_shift(4, 2);
  pr.write_shift(4, 1200);
  pio.write_shift(4, 1);
  prop.push(pr);
  piao.push(pio);
  sz += 8 + pr.length;
  if (!RE) {
    pio = new_buf(8);
    pio.write_shift(4, 0);
    piao.unshift(pio);
    var bufs = [new_buf(4)];
    bufs[0].write_shift(4, entries.length);
    for (i2 = 0; i2 < entries.length; ++i2) {
      var value = entries[i2][0];
      pr = new_buf(4 + 4 + 2 * (value.length + 1) + (value.length % 2 ? 0 : 2));
      pr.write_shift(4, i2 + 2);
      pr.write_shift(4, value.length + 1);
      pr.write_shift(0, value, "dbcs");
      while (pr.l != pr.length)
        pr.write_shift(1, 0);
      bufs.push(pr);
    }
    pr = bconcat(bufs);
    prop.unshift(pr);
    sz += 8 + pr.length;
  }
  for (i2 = 0; i2 < entries.length; ++i2) {
    if (RE && !RE[entries[i2][0]])
      continue;
    if (XLSPSSkip.indexOf(entries[i2][0]) > -1 || PseudoPropsPairs.indexOf(entries[i2][0]) > -1)
      continue;
    if (entries[i2][1] == null)
      continue;
    var val = entries[i2][1], idx = 0;
    if (RE) {
      idx = +RE[entries[i2][0]];
      var pinfo = PIDSI[idx];
      if (pinfo.p == "version" && typeof val == "string") {
        var arr = val.split(".");
        val = (+arr[0] << 16) + (+arr[1] || 0);
      }
      pr = write_TypedPropertyValue(pinfo.t, val);
    } else {
      var T2 = guess_property_type(val);
      if (T2 == -1) {
        T2 = 31;
        val = String(val);
      }
      pr = write_TypedPropertyValue(T2, val);
    }
    prop.push(pr);
    pio = new_buf(8);
    pio.write_shift(4, !RE ? 2 + i2 : idx);
    piao.push(pio);
    sz += 8 + pr.length;
  }
  var w2 = 8 * (prop.length + 1);
  for (i2 = 0; i2 < prop.length; ++i2) {
    piao[i2].write_shift(4, w2);
    w2 += prop[i2].length;
  }
  hdr.write_shift(4, sz);
  hdr.write_shift(4, prop.length);
  return bconcat([hdr].concat(piao).concat(prop));
}
__name(write_PropertySet, "write_PropertySet");
function write_PropertySetStream(entries, clsid, RE, PIDSI, entries2, clsid2) {
  var hdr = new_buf(entries2 ? 68 : 48);
  var bufs = [hdr];
  hdr.write_shift(2, 65534);
  hdr.write_shift(2, 0);
  hdr.write_shift(4, 842412599);
  hdr.write_shift(16, CFB.utils.consts.HEADER_CLSID, "hex");
  hdr.write_shift(4, entries2 ? 2 : 1);
  hdr.write_shift(16, clsid, "hex");
  hdr.write_shift(4, entries2 ? 68 : 48);
  var ps0 = write_PropertySet(entries, RE, PIDSI);
  bufs.push(ps0);
  if (entries2) {
    var ps1 = write_PropertySet(entries2, null, null);
    hdr.write_shift(16, clsid2, "hex");
    hdr.write_shift(4, 68 + ps0.length);
    bufs.push(ps1);
  }
  return bconcat(bufs);
}
__name(write_PropertySetStream, "write_PropertySetStream");
function writezeroes(n2, o2) {
  if (!o2)
    o2 = new_buf(n2);
  for (var j2 = 0; j2 < n2; ++j2)
    o2.write_shift(1, 0);
  return o2;
}
__name(writezeroes, "writezeroes");
function parsebool(blob, length) {
  return blob.read_shift(length) === 1;
}
__name(parsebool, "parsebool");
function writebool(v2, o2) {
  if (!o2)
    o2 = new_buf(2);
  o2.write_shift(2, +!!v2);
  return o2;
}
__name(writebool, "writebool");
function parseuint16(blob) {
  return blob.read_shift(2, "u");
}
__name(parseuint16, "parseuint16");
function writeuint16(v2, o2) {
  if (!o2)
    o2 = new_buf(2);
  o2.write_shift(2, v2);
  return o2;
}
__name(writeuint16, "writeuint16");
function write_Bes(v2, t2, o2) {
  if (!o2)
    o2 = new_buf(2);
  o2.write_shift(1, t2 == "e" ? +v2 : +!!v2);
  o2.write_shift(1, t2 == "e" ? 1 : 0);
  return o2;
}
__name(write_Bes, "write_Bes");
function parse_ShortXLUnicodeString(blob, length, opts) {
  var cch = blob.read_shift(opts && opts.biff >= 12 ? 2 : 1);
  var encoding = "sbcs-cont";
  if (opts && opts.biff >= 8)
    ;
  if (!opts || opts.biff == 8) {
    var fHighByte = blob.read_shift(1);
    if (fHighByte) {
      encoding = "dbcs-cont";
    }
  } else if (opts.biff == 12) {
    encoding = "wstr";
  }
  if (opts.biff >= 2 && opts.biff <= 5)
    encoding = "cpstr";
  var o2 = cch ? blob.read_shift(cch, encoding) : "";
  return o2;
}
__name(parse_ShortXLUnicodeString, "parse_ShortXLUnicodeString");
function write_XLUnicodeRichExtendedString(xlstr) {
  var str = xlstr.t || "";
  var hdr = new_buf(3 + 0);
  hdr.write_shift(2, str.length);
  hdr.write_shift(1, 0 | 1);
  var otext = new_buf(2 * str.length);
  otext.write_shift(2 * str.length, str, "utf16le");
  var out = [hdr, otext];
  return bconcat(out);
}
__name(write_XLUnicodeRichExtendedString, "write_XLUnicodeRichExtendedString");
function parse_XLUnicodeStringNoCch(blob, cch, opts) {
  var retval;
  if (opts) {
    if (opts.biff >= 2 && opts.biff <= 5)
      return blob.read_shift(cch, "cpstr");
    if (opts.biff >= 12)
      return blob.read_shift(cch, "dbcs-cont");
  }
  var fHighByte = blob.read_shift(1);
  if (fHighByte === 0) {
    retval = blob.read_shift(cch, "sbcs-cont");
  } else {
    retval = blob.read_shift(cch, "dbcs-cont");
  }
  return retval;
}
__name(parse_XLUnicodeStringNoCch, "parse_XLUnicodeStringNoCch");
function parse_XLUnicodeString(blob, length, opts) {
  var cch = blob.read_shift(opts && opts.biff == 2 ? 1 : 2);
  if (cch === 0) {
    blob.l++;
    return "";
  }
  return parse_XLUnicodeStringNoCch(blob, cch, opts);
}
__name(parse_XLUnicodeString, "parse_XLUnicodeString");
function parse_XLUnicodeString2(blob, length, opts) {
  if (opts.biff > 5)
    return parse_XLUnicodeString(blob, length, opts);
  var cch = blob.read_shift(1);
  if (cch === 0) {
    blob.l++;
    return "";
  }
  return blob.read_shift(cch, opts.biff <= 4 || !blob.lens ? "cpstr" : "sbcs-cont");
}
__name(parse_XLUnicodeString2, "parse_XLUnicodeString2");
function write_XLUnicodeString(str, opts, o2) {
  if (!o2)
    o2 = new_buf(3 + 2 * str.length);
  o2.write_shift(2, str.length);
  o2.write_shift(1, 1);
  o2.write_shift(31, str, "utf16le");
  return o2;
}
__name(write_XLUnicodeString, "write_XLUnicodeString");
function write_HyperlinkString(str, o2) {
  if (!o2)
    o2 = new_buf(6 + str.length * 2);
  o2.write_shift(4, 1 + str.length);
  for (var i2 = 0; i2 < str.length; ++i2)
    o2.write_shift(2, str.charCodeAt(i2));
  o2.write_shift(2, 0);
  return o2;
}
__name(write_HyperlinkString, "write_HyperlinkString");
function write_Hyperlink(hl) {
  var out = new_buf(512), i2 = 0;
  var Target = hl.Target;
  if (Target.slice(0, 7) == "file://")
    Target = Target.slice(7);
  var hashidx = Target.indexOf("#");
  var F2 = hashidx > -1 ? 31 : 23;
  switch (Target.charAt(0)) {
    case "#":
      F2 = 28;
      break;
    case ".":
      F2 &= ~2;
      break;
  }
  out.write_shift(4, 2);
  out.write_shift(4, F2);
  var data = [8, 6815827, 6619237, 4849780, 83];
  for (i2 = 0; i2 < data.length; ++i2)
    out.write_shift(4, data[i2]);
  if (F2 == 28) {
    Target = Target.slice(1);
    write_HyperlinkString(Target, out);
  } else if (F2 & 2) {
    data = "e0 c9 ea 79 f9 ba ce 11 8c 82 00 aa 00 4b a9 0b".split(" ");
    for (i2 = 0; i2 < data.length; ++i2)
      out.write_shift(1, parseInt(data[i2], 16));
    var Pretarget = hashidx > -1 ? Target.slice(0, hashidx) : Target;
    out.write_shift(4, 2 * (Pretarget.length + 1));
    for (i2 = 0; i2 < Pretarget.length; ++i2)
      out.write_shift(2, Pretarget.charCodeAt(i2));
    out.write_shift(2, 0);
    if (F2 & 8)
      write_HyperlinkString(hashidx > -1 ? Target.slice(hashidx + 1) : "", out);
  } else {
    data = "03 03 00 00 00 00 00 00 c0 00 00 00 00 00 00 46".split(" ");
    for (i2 = 0; i2 < data.length; ++i2)
      out.write_shift(1, parseInt(data[i2], 16));
    var P2 = 0;
    while (Target.slice(P2 * 3, P2 * 3 + 3) == "../" || Target.slice(P2 * 3, P2 * 3 + 3) == "..\\")
      ++P2;
    out.write_shift(2, P2);
    out.write_shift(4, Target.length - 3 * P2 + 1);
    for (i2 = 0; i2 < Target.length - 3 * P2; ++i2)
      out.write_shift(1, Target.charCodeAt(i2 + 3 * P2) & 255);
    out.write_shift(1, 0);
    out.write_shift(2, 65535);
    out.write_shift(2, 57005);
    for (i2 = 0; i2 < 6; ++i2)
      out.write_shift(4, 0);
  }
  return out.slice(0, out.l);
}
__name(write_Hyperlink, "write_Hyperlink");
function write_XLSCell(R2, C2, ixfe, o2) {
  if (!o2)
    o2 = new_buf(6);
  o2.write_shift(2, R2);
  o2.write_shift(2, C2);
  o2.write_shift(2, ixfe || 0);
  return o2;
}
__name(write_XLSCell, "write_XLSCell");
function parse_XTI(blob, length, opts) {
  var w2 = opts.biff > 8 ? 4 : 2;
  var iSupBook = blob.read_shift(w2), itabFirst = blob.read_shift(w2, "i"), itabLast = blob.read_shift(w2, "i");
  return [iSupBook, itabFirst, itabLast];
}
__name(parse_XTI, "parse_XTI");
function parse_Ref8U(blob) {
  var rwFirst = blob.read_shift(2);
  var rwLast = blob.read_shift(2);
  var colFirst = blob.read_shift(2);
  var colLast = blob.read_shift(2);
  return { s: { c: colFirst, r: rwFirst }, e: { c: colLast, r: rwLast } };
}
__name(parse_Ref8U, "parse_Ref8U");
function write_Ref8U(r, o2) {
  if (!o2)
    o2 = new_buf(8);
  o2.write_shift(2, r.s.r);
  o2.write_shift(2, r.e.r);
  o2.write_shift(2, r.s.c);
  o2.write_shift(2, r.e.c);
  return o2;
}
__name(write_Ref8U, "write_Ref8U");
function write_BOF(wb, t2, o2) {
  var h3 = 1536, w2 = 16;
  switch (o2.bookType) {
    case "biff8":
      break;
    case "biff5":
      h3 = 1280;
      w2 = 8;
      break;
    case "biff4":
      h3 = 4;
      w2 = 6;
      break;
    case "biff3":
      h3 = 3;
      w2 = 6;
      break;
    case "biff2":
      h3 = 2;
      w2 = 4;
      break;
    case "xla":
      break;
    default:
      throw new Error("unsupported BIFF version");
  }
  var out = new_buf(w2);
  out.write_shift(2, h3);
  out.write_shift(2, t2);
  if (w2 > 4)
    out.write_shift(2, 29282);
  if (w2 > 6)
    out.write_shift(2, 1997);
  if (w2 > 8) {
    out.write_shift(2, 49161);
    out.write_shift(2, 1);
    out.write_shift(2, 1798);
    out.write_shift(2, 0);
  }
  return out;
}
__name(write_BOF, "write_BOF");
function write_WriteAccess(s2, opts) {
  var b8 = !opts || opts.biff == 8;
  var o2 = new_buf(b8 ? 112 : 54);
  o2.write_shift(opts.biff == 8 ? 2 : 1, 7);
  if (b8)
    o2.write_shift(1, 0);
  o2.write_shift(4, 859007059);
  o2.write_shift(4, 5458548 | (b8 ? 0 : 536870912));
  while (o2.l < o2.length)
    o2.write_shift(1, b8 ? 0 : 32);
  return o2;
}
__name(write_WriteAccess, "write_WriteAccess");
function write_BoundSheet8(data, opts) {
  var w2 = !opts || opts.biff >= 8 ? 2 : 1;
  var o2 = new_buf(8 + w2 * data.name.length);
  o2.write_shift(4, data.pos);
  o2.write_shift(1, data.hs || 0);
  o2.write_shift(1, data.dt);
  o2.write_shift(1, data.name.length);
  if (opts.biff >= 8)
    o2.write_shift(1, 1);
  o2.write_shift(w2 * data.name.length, data.name, opts.biff < 8 ? "sbcs" : "utf16le");
  var out = o2.slice(0, o2.l);
  out.l = o2.l;
  return out;
}
__name(write_BoundSheet8, "write_BoundSheet8");
function write_SST(sst, opts) {
  var header = new_buf(8);
  header.write_shift(4, sst.Count);
  header.write_shift(4, sst.Unique);
  var strs = [];
  for (var j2 = 0; j2 < sst.length; ++j2)
    strs[j2] = write_XLUnicodeRichExtendedString(sst[j2]);
  var o2 = bconcat([header].concat(strs));
  o2.parts = [header.length].concat(strs.map(function(str) {
    return str.length;
  }));
  return o2;
}
__name(write_SST, "write_SST");
function write_Window1() {
  var o2 = new_buf(18);
  o2.write_shift(2, 0);
  o2.write_shift(2, 0);
  o2.write_shift(2, 29280);
  o2.write_shift(2, 17600);
  o2.write_shift(2, 56);
  o2.write_shift(2, 0);
  o2.write_shift(2, 0);
  o2.write_shift(2, 1);
  o2.write_shift(2, 500);
  return o2;
}
__name(write_Window1, "write_Window1");
function write_Window2(view) {
  var o2 = new_buf(18), f2 = 1718;
  if (view && view.RTL)
    f2 |= 64;
  o2.write_shift(2, f2);
  o2.write_shift(4, 0);
  o2.write_shift(4, 64);
  o2.write_shift(4, 0);
  o2.write_shift(4, 0);
  return o2;
}
__name(write_Window2, "write_Window2");
function write_Font(data, opts) {
  var name = data.name || "Arial";
  var b5 = opts && opts.biff == 5, w2 = b5 ? 15 + name.length : 16 + 2 * name.length;
  var o2 = new_buf(w2);
  o2.write_shift(2, (data.sz || 12) * 20);
  o2.write_shift(4, 0);
  o2.write_shift(2, 400);
  o2.write_shift(4, 0);
  o2.write_shift(2, 0);
  o2.write_shift(1, name.length);
  if (!b5)
    o2.write_shift(1, 1);
  o2.write_shift((b5 ? 1 : 2) * name.length, name, b5 ? "sbcs" : "utf16le");
  return o2;
}
__name(write_Font, "write_Font");
function write_LabelSst(R2, C2, v2, os) {
  var o2 = new_buf(10);
  write_XLSCell(R2, C2, os, o2);
  o2.write_shift(4, v2);
  return o2;
}
__name(write_LabelSst, "write_LabelSst");
function write_Label(R2, C2, v2, os, opts) {
  var b8 = !opts || opts.biff == 8;
  var o2 = new_buf(6 + 2 + +b8 + (1 + b8) * v2.length);
  write_XLSCell(R2, C2, os, o2);
  o2.write_shift(2, v2.length);
  if (b8)
    o2.write_shift(1, 1);
  o2.write_shift((1 + b8) * v2.length, v2, b8 ? "utf16le" : "sbcs");
  return o2;
}
__name(write_Label, "write_Label");
function write_Format(i2, f2, opts, o2) {
  var b5 = opts && opts.biff == 5;
  if (!o2)
    o2 = new_buf(b5 ? 3 + f2.length : 5 + 2 * f2.length);
  o2.write_shift(2, i2);
  o2.write_shift(b5 ? 1 : 2, f2.length);
  if (!b5)
    o2.write_shift(1, 1);
  o2.write_shift((b5 ? 1 : 2) * f2.length, f2, b5 ? "sbcs" : "utf16le");
  var out = o2.length > o2.l ? o2.slice(0, o2.l) : o2;
  if (out.l == null)
    out.l = out.length;
  return out;
}
__name(write_Format, "write_Format");
function write_Dimensions(range, opts) {
  var w2 = opts.biff == 8 || !opts.biff ? 4 : 2;
  var o2 = new_buf(2 * w2 + 6);
  o2.write_shift(w2, range.s.r);
  o2.write_shift(w2, range.e.r + 1);
  o2.write_shift(2, range.s.c);
  o2.write_shift(2, range.e.c + 1);
  o2.write_shift(2, 0);
  return o2;
}
__name(write_Dimensions, "write_Dimensions");
function write_XF(data, ixfeP, opts, o2) {
  var b5 = opts && opts.biff == 5;
  if (!o2)
    o2 = new_buf(b5 ? 16 : 20);
  o2.write_shift(2, 0);
  if (data.style) {
    o2.write_shift(2, data.numFmtId || 0);
    o2.write_shift(2, 65524);
  } else {
    o2.write_shift(2, data.numFmtId || 0);
    o2.write_shift(2, ixfeP << 4);
  }
  var f2 = 0;
  if (data.numFmtId > 0 && b5)
    f2 |= 1024;
  o2.write_shift(4, f2);
  o2.write_shift(4, 0);
  if (!b5)
    o2.write_shift(4, 0);
  o2.write_shift(2, 0);
  return o2;
}
__name(write_XF, "write_XF");
function write_Guts(guts) {
  var o2 = new_buf(8);
  o2.write_shift(4, 0);
  o2.write_shift(2, guts[0] ? guts[0] + 1 : 0);
  o2.write_shift(2, guts[1] ? guts[1] + 1 : 0);
  return o2;
}
__name(write_Guts, "write_Guts");
function write_BoolErr(R2, C2, v2, os, opts, t2) {
  var o2 = new_buf(8);
  write_XLSCell(R2, C2, os, o2);
  write_Bes(v2, t2, o2);
  return o2;
}
__name(write_BoolErr, "write_BoolErr");
function write_Number(R2, C2, v2, os) {
  var o2 = new_buf(14);
  write_XLSCell(R2, C2, os, o2);
  write_Xnum(v2, o2);
  return o2;
}
__name(write_Number, "write_Number");
function parse_ExternSheet(blob, length, opts) {
  if (opts.biff < 8)
    return parse_BIFF5ExternSheet(blob, length, opts);
  var o2 = [], target = blob.l + length, len = blob.read_shift(opts.biff > 8 ? 4 : 2);
  while (len-- !== 0)
    o2.push(parse_XTI(blob, opts.biff > 8 ? 12 : 6, opts));
  if (blob.l != target)
    throw new Error("Bad ExternSheet: " + blob.l + " != " + target);
  return o2;
}
__name(parse_ExternSheet, "parse_ExternSheet");
function parse_BIFF5ExternSheet(blob, length, opts) {
  if (blob[blob.l + 1] == 3)
    blob[blob.l]++;
  var o2 = parse_ShortXLUnicodeString(blob, length, opts);
  return o2.charCodeAt(0) == 3 ? o2.slice(1) : o2;
}
__name(parse_BIFF5ExternSheet, "parse_BIFF5ExternSheet");
function write_MergeCells(merges) {
  var o2 = new_buf(2 + merges.length * 8);
  o2.write_shift(2, merges.length);
  for (var i2 = 0; i2 < merges.length; ++i2)
    write_Ref8U(merges[i2], o2);
  return o2;
}
__name(write_MergeCells, "write_MergeCells");
function write_HLink(hl) {
  var O2 = new_buf(24);
  var ref = decode_cell(hl[0]);
  O2.write_shift(2, ref.r);
  O2.write_shift(2, ref.r);
  O2.write_shift(2, ref.c);
  O2.write_shift(2, ref.c);
  var clsid = "d0 c9 ea 79 f9 ba ce 11 8c 82 00 aa 00 4b a9 0b".split(" ");
  for (var i2 = 0; i2 < 16; ++i2)
    O2.write_shift(1, parseInt(clsid[i2], 16));
  return bconcat([O2, write_Hyperlink(hl[1])]);
}
__name(write_HLink, "write_HLink");
function write_HLinkTooltip(hl) {
  var TT = hl[1].Tooltip;
  var O2 = new_buf(10 + 2 * (TT.length + 1));
  O2.write_shift(2, 2048);
  var ref = decode_cell(hl[0]);
  O2.write_shift(2, ref.r);
  O2.write_shift(2, ref.r);
  O2.write_shift(2, ref.c);
  O2.write_shift(2, ref.c);
  for (var i2 = 0; i2 < TT.length; ++i2)
    O2.write_shift(2, TT.charCodeAt(i2));
  O2.write_shift(2, 0);
  return O2;
}
__name(write_HLinkTooltip, "write_HLinkTooltip");
function write_Country(o2) {
  if (!o2)
    o2 = new_buf(4);
  o2.write_shift(2, 1);
  o2.write_shift(2, 1);
  return o2;
}
__name(write_Country, "write_Country");
function parse_ColInfo(blob, length, opts) {
  if (!opts.cellStyles)
    return parsenoop(blob, length);
  var w2 = opts && opts.biff >= 12 ? 4 : 2;
  var colFirst = blob.read_shift(w2);
  var colLast = blob.read_shift(w2);
  var coldx = blob.read_shift(w2);
  var ixfe = blob.read_shift(w2);
  var flags = blob.read_shift(2);
  if (w2 == 2)
    blob.l += 2;
  var o2 = { s: colFirst, e: colLast, w: coldx, ixfe, flags };
  if (opts.biff >= 5 || !opts.biff)
    o2.level = flags >> 8 & 7;
  return o2;
}
__name(parse_ColInfo, "parse_ColInfo");
function write_ColInfo(col, idx) {
  var o2 = new_buf(12);
  o2.write_shift(2, idx);
  o2.write_shift(2, idx);
  o2.write_shift(2, col.width * 256);
  o2.write_shift(2, 0);
  var f2 = 0;
  if (col.hidden)
    f2 |= 1;
  o2.write_shift(1, f2);
  f2 = col.level || 0;
  o2.write_shift(1, f2);
  o2.write_shift(2, 0);
  return o2;
}
__name(write_ColInfo, "write_ColInfo");
function write_RRTabId(n2) {
  var out = new_buf(2 * n2);
  for (var i2 = 0; i2 < n2; ++i2)
    out.write_shift(2, i2 + 1);
  return out;
}
__name(write_RRTabId, "write_RRTabId");
function write_BIFF2NUM(r, c2, val) {
  var out = new_buf(15);
  write_BIFF2Cell(out, r, c2);
  out.write_shift(8, val, "f");
  return out;
}
__name(write_BIFF2NUM, "write_BIFF2NUM");
function write_BIFF2INT(r, c2, val) {
  var out = new_buf(9);
  write_BIFF2Cell(out, r, c2);
  out.write_shift(2, val);
  return out;
}
__name(write_BIFF2INT, "write_BIFF2INT");
var DBF = /* @__PURE__ */ function() {
  var dbf_codepage_map = {
    /* Code Pages Supported by Visual FoxPro */
    /*::[*/
    1: 437,
    /*::[*/
    2: 850,
    /*::[*/
    3: 1252,
    /*::[*/
    4: 1e4,
    /*::[*/
    100: 852,
    /*::[*/
    101: 866,
    /*::[*/
    102: 865,
    /*::[*/
    103: 861,
    /*::[*/
    104: 895,
    /*::[*/
    105: 620,
    /*::[*/
    106: 737,
    /*::[*/
    107: 857,
    /*::[*/
    120: 950,
    /*::[*/
    121: 949,
    /*::[*/
    122: 936,
    /*::[*/
    123: 932,
    /*::[*/
    124: 874,
    /*::[*/
    125: 1255,
    /*::[*/
    126: 1256,
    /*::[*/
    150: 10007,
    /*::[*/
    151: 10029,
    /*::[*/
    152: 10006,
    /*::[*/
    200: 1250,
    /*::[*/
    201: 1251,
    /*::[*/
    202: 1254,
    /*::[*/
    203: 1253,
    /* shapefile DBF extension */
    /*::[*/
    0: 20127,
    /*::[*/
    8: 865,
    /*::[*/
    9: 437,
    /*::[*/
    10: 850,
    /*::[*/
    11: 437,
    /*::[*/
    13: 437,
    /*::[*/
    14: 850,
    /*::[*/
    15: 437,
    /*::[*/
    16: 850,
    /*::[*/
    17: 437,
    /*::[*/
    18: 850,
    /*::[*/
    19: 932,
    /*::[*/
    20: 850,
    /*::[*/
    21: 437,
    /*::[*/
    22: 850,
    /*::[*/
    23: 865,
    /*::[*/
    24: 437,
    /*::[*/
    25: 437,
    /*::[*/
    26: 850,
    /*::[*/
    27: 437,
    /*::[*/
    28: 863,
    /*::[*/
    29: 850,
    /*::[*/
    31: 852,
    /*::[*/
    34: 852,
    /*::[*/
    35: 852,
    /*::[*/
    36: 860,
    /*::[*/
    37: 850,
    /*::[*/
    38: 866,
    /*::[*/
    55: 850,
    /*::[*/
    64: 852,
    /*::[*/
    77: 936,
    /*::[*/
    78: 949,
    /*::[*/
    79: 950,
    /*::[*/
    80: 874,
    /*::[*/
    87: 1252,
    /*::[*/
    88: 1252,
    /*::[*/
    89: 1252,
    /*::[*/
    108: 863,
    /*::[*/
    134: 737,
    /*::[*/
    135: 852,
    /*::[*/
    136: 857,
    /*::[*/
    204: 1257,
    /*::[*/
    255: 16969
  };
  var dbf_reverse_map = evert({
    /*::[*/
    1: 437,
    /*::[*/
    2: 850,
    /*::[*/
    3: 1252,
    /*::[*/
    4: 1e4,
    /*::[*/
    100: 852,
    /*::[*/
    101: 866,
    /*::[*/
    102: 865,
    /*::[*/
    103: 861,
    /*::[*/
    104: 895,
    /*::[*/
    105: 620,
    /*::[*/
    106: 737,
    /*::[*/
    107: 857,
    /*::[*/
    120: 950,
    /*::[*/
    121: 949,
    /*::[*/
    122: 936,
    /*::[*/
    123: 932,
    /*::[*/
    124: 874,
    /*::[*/
    125: 1255,
    /*::[*/
    126: 1256,
    /*::[*/
    150: 10007,
    /*::[*/
    151: 10029,
    /*::[*/
    152: 10006,
    /*::[*/
    200: 1250,
    /*::[*/
    201: 1251,
    /*::[*/
    202: 1254,
    /*::[*/
    203: 1253,
    /*::[*/
    0: 20127
  });
  function dbf_to_aoa(buf, opts) {
    var out = [];
    var d2 = new_raw_buf(1);
    switch (opts.type) {
      case "base64":
        d2 = s2a(Base64_decode(buf));
        break;
      case "binary":
        d2 = s2a(buf);
        break;
      case "buffer":
      case "array":
        d2 = buf;
        break;
    }
    prep_blob(d2, 0);
    var ft2 = d2.read_shift(1);
    var memo = !!(ft2 & 136);
    var vfp = false, l7 = false;
    switch (ft2) {
      case 2:
        break;
      case 3:
        break;
      case 48:
        vfp = true;
        memo = true;
        break;
      case 49:
        vfp = true;
        memo = true;
        break;
      case 131:
        break;
      case 139:
        break;
      case 140:
        l7 = true;
        break;
      case 245:
        break;
      default:
        throw new Error("DBF Unsupported Version: " + ft2.toString(16));
    }
    var nrow = 0, fpos = 521;
    if (ft2 == 2)
      nrow = d2.read_shift(2);
    d2.l += 3;
    if (ft2 != 2)
      nrow = d2.read_shift(4);
    if (nrow > 1048576)
      nrow = 1e6;
    if (ft2 != 2)
      fpos = d2.read_shift(2);
    var rlen = d2.read_shift(2);
    var current_cp = opts.codepage || 1252;
    if (ft2 != 2) {
      d2.l += 16;
      d2.read_shift(1);
      if (d2[d2.l] !== 0)
        current_cp = dbf_codepage_map[d2[d2.l]];
      d2.l += 1;
      d2.l += 2;
    }
    if (l7)
      d2.l += 36;
    var fields = [], field = {};
    var hend = Math.min(d2.length, ft2 == 2 ? 521 : fpos - 10 - (vfp ? 264 : 0));
    var ww = l7 ? 32 : 11;
    while (d2.l < hend && d2[d2.l] != 13) {
      field = {};
      field.name = $cptable.utils.decode(current_cp, d2.slice(d2.l, d2.l + ww)).replace(/[\u0000\r\n].*$/g, "");
      d2.l += ww;
      field.type = String.fromCharCode(d2.read_shift(1));
      if (ft2 != 2 && !l7)
        field.offset = d2.read_shift(4);
      field.len = d2.read_shift(1);
      if (ft2 == 2)
        field.offset = d2.read_shift(2);
      field.dec = d2.read_shift(1);
      if (field.name.length)
        fields.push(field);
      if (ft2 != 2)
        d2.l += l7 ? 13 : 14;
      switch (field.type) {
        case "B":
          if ((!vfp || field.len != 8) && opts.WTF)
            console.log("Skipping " + field.name + ":" + field.type);
          break;
        case "G":
        case "P":
          if (opts.WTF)
            console.log("Skipping " + field.name + ":" + field.type);
          break;
        case "+":
        case "0":
        case "@":
        case "C":
        case "D":
        case "F":
        case "I":
        case "L":
        case "M":
        case "N":
        case "O":
        case "T":
        case "Y":
          break;
        default:
          throw new Error("Unknown Field Type: " + field.type);
      }
    }
    if (d2[d2.l] !== 13)
      d2.l = fpos - 1;
    if (d2.read_shift(1) !== 13)
      throw new Error("DBF Terminator not found " + d2.l + " " + d2[d2.l]);
    d2.l = fpos;
    var R2 = 0, C2 = 0;
    out[0] = [];
    for (C2 = 0; C2 != fields.length; ++C2)
      out[0][C2] = fields[C2].name;
    while (nrow-- > 0) {
      if (d2[d2.l] === 42) {
        d2.l += rlen;
        continue;
      }
      ++d2.l;
      out[++R2] = [];
      C2 = 0;
      for (C2 = 0; C2 != fields.length; ++C2) {
        var dd = d2.slice(d2.l, d2.l + fields[C2].len);
        d2.l += fields[C2].len;
        prep_blob(dd, 0);
        var s2 = $cptable.utils.decode(current_cp, dd);
        switch (fields[C2].type) {
          case "C":
            if (s2.trim().length)
              out[R2][C2] = s2.replace(/\s+$/, "");
            break;
          case "D":
            if (s2.length === 8)
              out[R2][C2] = new Date(+s2.slice(0, 4), +s2.slice(4, 6) - 1, +s2.slice(6, 8));
            else
              out[R2][C2] = s2;
            break;
          case "F":
            out[R2][C2] = parseFloat(s2.trim());
            break;
          case "+":
          case "I":
            out[R2][C2] = l7 ? dd.read_shift(-4, "i") ^ 2147483648 : dd.read_shift(4, "i");
            break;
          case "L":
            switch (s2.trim().toUpperCase()) {
              case "Y":
              case "T":
                out[R2][C2] = true;
                break;
              case "N":
              case "F":
                out[R2][C2] = false;
                break;
              case "":
              case "?":
                break;
              default:
                throw new Error("DBF Unrecognized L:|" + s2 + "|");
            }
            break;
          case "M":
            if (!memo)
              throw new Error("DBF Unexpected MEMO for type " + ft2.toString(16));
            out[R2][C2] = "##MEMO##" + (l7 ? parseInt(s2.trim(), 10) : dd.read_shift(4));
            break;
          case "N":
            s2 = s2.replace(/\u0000/g, "").trim();
            if (s2 && s2 != ".")
              out[R2][C2] = +s2 || 0;
            break;
          case "@":
            out[R2][C2] = new Date(dd.read_shift(-8, "f") - 621356832e5);
            break;
          case "T":
            out[R2][C2] = new Date((dd.read_shift(4) - 2440588) * 864e5 + dd.read_shift(4));
            break;
          case "Y":
            out[R2][C2] = dd.read_shift(4, "i") / 1e4 + dd.read_shift(4, "i") / 1e4 * Math.pow(2, 32);
            break;
          case "O":
            out[R2][C2] = -dd.read_shift(-8, "f");
            break;
          case "B":
            if (vfp && fields[C2].len == 8) {
              out[R2][C2] = dd.read_shift(8, "f");
              break;
            }
          case "G":
          case "P":
            dd.l += fields[C2].len;
            break;
          case "0":
            if (fields[C2].name === "_NullFlags")
              break;
          default:
            throw new Error("DBF Unsupported data type " + fields[C2].type);
        }
      }
    }
    if (ft2 != 2) {
      if (d2.l < d2.length && d2[d2.l++] != 26)
        throw new Error("DBF EOF Marker missing " + (d2.l - 1) + " of " + d2.length + " " + d2[d2.l - 1].toString(16));
    }
    if (opts && opts.sheetRows)
      out = out.slice(0, opts.sheetRows);
    opts.DBF = fields;
    return out;
  }
  __name(dbf_to_aoa, "dbf_to_aoa");
  function dbf_to_sheet(buf, opts) {
    var o2 = opts || {};
    if (!o2.dateNF)
      o2.dateNF = "yyyymmdd";
    var ws = aoa_to_sheet(dbf_to_aoa(buf, o2), o2);
    ws["!cols"] = o2.DBF.map(function(field) {
      return {
        wch: field.len,
        DBF: field
      };
    });
    delete o2.DBF;
    return ws;
  }
  __name(dbf_to_sheet, "dbf_to_sheet");
  function dbf_to_workbook(buf, opts) {
    try {
      return sheet_to_workbook(dbf_to_sheet(buf, opts), opts);
    } catch (e) {
      if (opts && opts.WTF)
        throw e;
    }
    return { SheetNames: [], Sheets: {} };
  }
  __name(dbf_to_workbook, "dbf_to_workbook");
  var _RLEN = { "B": 8, "C": 250, "L": 1, "D": 8, "?": 0, "": 0 };
  function sheet_to_dbf(ws, opts) {
    var o2 = opts || {};
    if (+o2.codepage >= 0)
      set_cp(+o2.codepage);
    if (o2.type == "string")
      throw new Error("Cannot write DBF to JS string");
    var ba = buf_array();
    var aoa = sheet_to_json(ws, { header: 1, raw: true, cellDates: true });
    var headers = aoa[0], data = aoa.slice(1), cols = ws["!cols"] || [];
    var i2 = 0, j2 = 0, hcnt = 0, rlen = 1;
    for (i2 = 0; i2 < headers.length; ++i2) {
      if (((cols[i2] || {}).DBF || {}).name) {
        headers[i2] = cols[i2].DBF.name;
        ++hcnt;
        continue;
      }
      if (headers[i2] == null)
        continue;
      ++hcnt;
      if (typeof headers[i2] === "number")
        headers[i2] = headers[i2].toString(10);
      if (typeof headers[i2] !== "string")
        throw new Error("DBF Invalid column name " + headers[i2] + " |" + typeof headers[i2] + "|");
      if (headers.indexOf(headers[i2]) !== i2) {
        for (j2 = 0; j2 < 1024; ++j2)
          if (headers.indexOf(headers[i2] + "_" + j2) == -1) {
            headers[i2] += "_" + j2;
            break;
          }
      }
    }
    var range = safe_decode_range(ws["!ref"]);
    var coltypes = [];
    var colwidths = [];
    var coldecimals = [];
    for (i2 = 0; i2 <= range.e.c - range.s.c; ++i2) {
      var guess = "", _guess = "", maxlen = 0;
      var col = [];
      for (j2 = 0; j2 < data.length; ++j2) {
        if (data[j2][i2] != null)
          col.push(data[j2][i2]);
      }
      if (col.length == 0 || headers[i2] == null) {
        coltypes[i2] = "?";
        continue;
      }
      for (j2 = 0; j2 < col.length; ++j2) {
        switch (typeof col[j2]) {
          case "number":
            _guess = "B";
            break;
          case "string":
            _guess = "C";
            break;
          case "boolean":
            _guess = "L";
            break;
          case "object":
            _guess = col[j2] instanceof Date ? "D" : "C";
            break;
          default:
            _guess = "C";
        }
        maxlen = Math.max(maxlen, String(col[j2]).length);
        guess = guess && guess != _guess ? "C" : _guess;
      }
      if (maxlen > 250)
        maxlen = 250;
      _guess = ((cols[i2] || {}).DBF || {}).type;
      if (_guess == "C") {
        if (cols[i2].DBF.len > maxlen)
          maxlen = cols[i2].DBF.len;
      }
      if (guess == "B" && _guess == "N") {
        guess = "N";
        coldecimals[i2] = cols[i2].DBF.dec;
        maxlen = cols[i2].DBF.len;
      }
      colwidths[i2] = guess == "C" || _guess == "N" ? maxlen : _RLEN[guess] || 0;
      rlen += colwidths[i2];
      coltypes[i2] = guess;
    }
    var h3 = ba.next(32);
    h3.write_shift(4, 318902576);
    h3.write_shift(4, data.length);
    h3.write_shift(2, 296 + 32 * hcnt);
    h3.write_shift(2, rlen);
    for (i2 = 0; i2 < 4; ++i2)
      h3.write_shift(4, 0);
    h3.write_shift(4, 0 | (+dbf_reverse_map[
      /*::String(*/
      current_ansi
      /*::)*/
    ] || 3) << 8);
    for (i2 = 0, j2 = 0; i2 < headers.length; ++i2) {
      if (headers[i2] == null)
        continue;
      var hf = ba.next(32);
      var _f = (headers[i2].slice(-10) + "\0\0\0\0\0\0\0\0\0\0\0").slice(0, 11);
      hf.write_shift(1, _f, "sbcs");
      hf.write_shift(1, coltypes[i2] == "?" ? "C" : coltypes[i2], "sbcs");
      hf.write_shift(4, j2);
      hf.write_shift(1, colwidths[i2] || _RLEN[coltypes[i2]] || 0);
      hf.write_shift(1, coldecimals[i2] || 0);
      hf.write_shift(1, 2);
      hf.write_shift(4, 0);
      hf.write_shift(1, 0);
      hf.write_shift(4, 0);
      hf.write_shift(4, 0);
      j2 += colwidths[i2] || _RLEN[coltypes[i2]] || 0;
    }
    var hb = ba.next(264);
    hb.write_shift(4, 13);
    for (i2 = 0; i2 < 65; ++i2)
      hb.write_shift(4, 0);
    for (i2 = 0; i2 < data.length; ++i2) {
      var rout = ba.next(rlen);
      rout.write_shift(1, 0);
      for (j2 = 0; j2 < headers.length; ++j2) {
        if (headers[j2] == null)
          continue;
        switch (coltypes[j2]) {
          case "L":
            rout.write_shift(1, data[i2][j2] == null ? 63 : data[i2][j2] ? 84 : 70);
            break;
          case "B":
            rout.write_shift(8, data[i2][j2] || 0, "f");
            break;
          case "N":
            var _n = "0";
            if (typeof data[i2][j2] == "number")
              _n = data[i2][j2].toFixed(coldecimals[j2] || 0);
            for (hcnt = 0; hcnt < colwidths[j2] - _n.length; ++hcnt)
              rout.write_shift(1, 32);
            rout.write_shift(1, _n, "sbcs");
            break;
          case "D":
            if (!data[i2][j2])
              rout.write_shift(8, "00000000", "sbcs");
            else {
              rout.write_shift(4, ("0000" + data[i2][j2].getFullYear()).slice(-4), "sbcs");
              rout.write_shift(2, ("00" + (data[i2][j2].getMonth() + 1)).slice(-2), "sbcs");
              rout.write_shift(2, ("00" + data[i2][j2].getDate()).slice(-2), "sbcs");
            }
            break;
          case "C":
            var _s = String(data[i2][j2] != null ? data[i2][j2] : "").slice(0, colwidths[j2]);
            rout.write_shift(1, _s, "sbcs");
            for (hcnt = 0; hcnt < colwidths[j2] - _s.length; ++hcnt)
              rout.write_shift(1, 32);
            break;
        }
      }
    }
    ba.next(1).write_shift(1, 26);
    return ba.end();
  }
  __name(sheet_to_dbf, "sheet_to_dbf");
  return {
    to_workbook: dbf_to_workbook,
    to_sheet: dbf_to_sheet,
    from_sheet: sheet_to_dbf
  };
}();
var SYLK = /* @__PURE__ */ function() {
  var sylk_escapes = {
    AA: "",
    BA: "",
    CA: "",
    DA: 195,
    HA: "",
    JA: 197,
    AE: "",
    BE: "",
    CE: "",
    HE: "",
    AI: "",
    BI: "",
    CI: "",
    HI: "",
    AO: "",
    BO: "",
    CO: "",
    DO: 213,
    HO: "",
    AU: "",
    BU: "",
    CU: "",
    HU: "",
    Aa: "",
    Ba: "",
    Ca: "",
    Da: 227,
    Ha: "",
    Ja: 229,
    Ae: "",
    Be: "",
    Ce: "",
    He: "",
    Ai: "",
    Bi: "",
    Ci: "",
    Hi: "",
    Ao: "",
    Bo: "",
    Co: "",
    Do: 245,
    Ho: "",
    Au: "",
    Bu: "",
    Cu: "",
    Hu: "",
    KC: "",
    Kc: "",
    q: "",
    z: "",
    a: "",
    j: "",
    DN: 209,
    Dn: 241,
    Hy: 255,
    S: 169,
    c: 170,
    R: 174,
    "B ": 180,
    /*::[*/
    0: 176,
    /*::[*/
    1: 177,
    /*::[*/
    2: 178,
    /*::[*/
    3: 179,
    /*::[*/
    5: 181,
    /*::[*/
    6: 182,
    /*::[*/
    7: 183,
    Q: 185,
    k: 186,
    b: 208,
    i: 216,
    l: 222,
    s: 240,
    y: 248,
    "!": 161,
    '"': 162,
    "#": 163,
    "(": 164,
    "%": 165,
    "'": 167,
    "H ": 168,
    "+": 171,
    ";": 187,
    "<": 188,
    "=": 189,
    ">": 190,
    "?": 191,
    "{": 223
  };
  var sylk_char_regex = new RegExp("\x1BN(" + keys(sylk_escapes).join("|").replace(/\|\|\|/, "|\\||").replace(/([?()+])/g, "\\$1") + "|\\|)", "gm");
  var sylk_char_fn = /* @__PURE__ */ __name(function(_2, $1) {
    var o2 = sylk_escapes[$1];
    return typeof o2 == "number" ? _getansi(o2) : o2;
  }, "sylk_char_fn");
  var decode_sylk_char = /* @__PURE__ */ __name(function($$, $1, $2) {
    var newcc = $1.charCodeAt(0) - 32 << 4 | $2.charCodeAt(0) - 48;
    return newcc == 59 ? $$ : _getansi(newcc);
  }, "decode_sylk_char");
  sylk_escapes["|"] = 254;
  function sylk_to_aoa(d2, opts) {
    switch (opts.type) {
      case "base64":
        return sylk_to_aoa_str(Base64_decode(d2), opts);
      case "binary":
        return sylk_to_aoa_str(d2, opts);
      case "buffer":
        return sylk_to_aoa_str(has_buf && Buffer.isBuffer(d2) ? d2.toString("binary") : a2s(d2), opts);
      case "array":
        return sylk_to_aoa_str(cc2str(d2), opts);
    }
    throw new Error("Unrecognized type " + opts.type);
  }
  __name(sylk_to_aoa, "sylk_to_aoa");
  function sylk_to_aoa_str(str, opts) {
    var records = str.split(/[\n\r]+/), R2 = -1, C2 = -1, ri = 0, rj = 0, arr = [];
    var formats = [];
    var next_cell_format = null;
    var sht = {}, rowinfo = [], colinfo = [], cw = [];
    var Mval = 0, j2;
    if (+opts.codepage >= 0)
      set_cp(+opts.codepage);
    for (; ri !== records.length; ++ri) {
      Mval = 0;
      var rstr = records[ri].trim().replace(/\x1B([\x20-\x2F])([\x30-\x3F])/g, decode_sylk_char).replace(sylk_char_regex, sylk_char_fn);
      var record = rstr.replace(/;;/g, "\0").split(";").map(function(x2) {
        return x2.replace(/\u0000/g, ";");
      });
      var RT = record[0], val;
      if (rstr.length > 0)
        switch (RT) {
          case "ID":
            break;
          case "E":
            break;
          case "B":
            break;
          case "O":
            break;
          case "W":
            break;
          case "P":
            if (record[1].charAt(0) == "P")
              formats.push(rstr.slice(3).replace(/;;/g, ";"));
            break;
          case "C":
            var C_seen_K = false, C_seen_X = false, C_seen_S = false, C_seen_E = false, _R = -1, _C = -1;
            for (rj = 1; rj < record.length; ++rj)
              switch (record[rj].charAt(0)) {
                case "A":
                  break;
                case "X":
                  C2 = parseInt(record[rj].slice(1)) - 1;
                  C_seen_X = true;
                  break;
                case "Y":
                  R2 = parseInt(record[rj].slice(1)) - 1;
                  if (!C_seen_X)
                    C2 = 0;
                  for (j2 = arr.length; j2 <= R2; ++j2)
                    arr[j2] = [];
                  break;
                case "K":
                  val = record[rj].slice(1);
                  if (val.charAt(0) === '"')
                    val = val.slice(1, val.length - 1);
                  else if (val === "TRUE")
                    val = true;
                  else if (val === "FALSE")
                    val = false;
                  else if (!isNaN(fuzzynum(val))) {
                    val = fuzzynum(val);
                    if (next_cell_format !== null && fmt_is_date(next_cell_format))
                      val = numdate(val);
                  } else if (!isNaN(fuzzydate(val).getDate())) {
                    val = parseDate(val);
                  }
                  C_seen_K = true;
                  break;
                case "E":
                  C_seen_E = true;
                  var formula = rc_to_a1(record[rj].slice(1), { r: R2, c: C2 });
                  arr[R2][C2] = [arr[R2][C2], formula];
                  break;
                case "S":
                  C_seen_S = true;
                  arr[R2][C2] = [arr[R2][C2], "S5S"];
                  break;
                case "G":
                  break;
                case "R":
                  _R = parseInt(record[rj].slice(1)) - 1;
                  break;
                case "C":
                  _C = parseInt(record[rj].slice(1)) - 1;
                  break;
                default:
                  if (opts && opts.WTF)
                    throw new Error("SYLK bad record " + rstr);
              }
            if (C_seen_K) {
              if (arr[R2][C2] && arr[R2][C2].length == 2)
                arr[R2][C2][0] = val;
              else
                arr[R2][C2] = val;
              next_cell_format = null;
            }
            if (C_seen_S) {
              if (C_seen_E)
                throw new Error("SYLK shared formula cannot have own formula");
              var shrbase = _R > -1 && arr[_R][_C];
              if (!shrbase || !shrbase[1])
                throw new Error("SYLK shared formula cannot find base");
              arr[R2][C2][1] = shift_formula_str(shrbase[1], { r: R2 - _R, c: C2 - _C });
            }
            break;
          case "F":
            var F_seen = 0;
            for (rj = 1; rj < record.length; ++rj)
              switch (record[rj].charAt(0)) {
                case "X":
                  C2 = parseInt(record[rj].slice(1)) - 1;
                  ++F_seen;
                  break;
                case "Y":
                  R2 = parseInt(record[rj].slice(1)) - 1;
                  for (j2 = arr.length; j2 <= R2; ++j2)
                    arr[j2] = [];
                  break;
                case "M":
                  Mval = parseInt(record[rj].slice(1)) / 20;
                  break;
                case "F":
                  break;
                case "G":
                  break;
                case "P":
                  next_cell_format = formats[parseInt(record[rj].slice(1))];
                  break;
                case "S":
                  break;
                case "D":
                  break;
                case "N":
                  break;
                case "W":
                  cw = record[rj].slice(1).split(" ");
                  for (j2 = parseInt(cw[0], 10); j2 <= parseInt(cw[1], 10); ++j2) {
                    Mval = parseInt(cw[2], 10);
                    colinfo[j2 - 1] = Mval === 0 ? { hidden: true } : { wch: Mval };
                    process_col(colinfo[j2 - 1]);
                  }
                  break;
                case "C":
                  C2 = parseInt(record[rj].slice(1)) - 1;
                  if (!colinfo[C2])
                    colinfo[C2] = {};
                  break;
                case "R":
                  R2 = parseInt(record[rj].slice(1)) - 1;
                  if (!rowinfo[R2])
                    rowinfo[R2] = {};
                  if (Mval > 0) {
                    rowinfo[R2].hpt = Mval;
                    rowinfo[R2].hpx = pt2px(Mval);
                  } else if (Mval === 0)
                    rowinfo[R2].hidden = true;
                  break;
                default:
                  if (opts && opts.WTF)
                    throw new Error("SYLK bad record " + rstr);
              }
            if (F_seen < 1)
              next_cell_format = null;
            break;
          default:
            if (opts && opts.WTF)
              throw new Error("SYLK bad record " + rstr);
        }
    }
    if (rowinfo.length > 0)
      sht["!rows"] = rowinfo;
    if (colinfo.length > 0)
      sht["!cols"] = colinfo;
    if (opts && opts.sheetRows)
      arr = arr.slice(0, opts.sheetRows);
    return [arr, sht];
  }
  __name(sylk_to_aoa_str, "sylk_to_aoa_str");
  function sylk_to_sheet(d2, opts) {
    var aoasht = sylk_to_aoa(d2, opts);
    var aoa = aoasht[0], ws = aoasht[1];
    var o2 = aoa_to_sheet(aoa, opts);
    keys(ws).forEach(function(k2) {
      o2[k2] = ws[k2];
    });
    return o2;
  }
  __name(sylk_to_sheet, "sylk_to_sheet");
  function sylk_to_workbook(d2, opts) {
    return sheet_to_workbook(sylk_to_sheet(d2, opts), opts);
  }
  __name(sylk_to_workbook, "sylk_to_workbook");
  function write_ws_cell_sylk(cell, ws, R2, C2) {
    var o2 = "C;Y" + (R2 + 1) + ";X" + (C2 + 1) + ";K";
    switch (cell.t) {
      case "n":
        o2 += cell.v || 0;
        if (cell.f && !cell.F)
          o2 += ";E" + a1_to_rc(cell.f, { r: R2, c: C2 });
        break;
      case "b":
        o2 += cell.v ? "TRUE" : "FALSE";
        break;
      case "e":
        o2 += cell.w || cell.v;
        break;
      case "d":
        o2 += '"' + (cell.w || cell.v) + '"';
        break;
      case "s":
        o2 += '"' + cell.v.replace(/"/g, "").replace(/;/g, ";;") + '"';
        break;
    }
    return o2;
  }
  __name(write_ws_cell_sylk, "write_ws_cell_sylk");
  function write_ws_cols_sylk(out, cols) {
    cols.forEach(function(col, i2) {
      var rec = "F;W" + (i2 + 1) + " " + (i2 + 1) + " ";
      if (col.hidden)
        rec += "0";
      else {
        if (typeof col.width == "number" && !col.wpx)
          col.wpx = width2px(col.width);
        if (typeof col.wpx == "number" && !col.wch)
          col.wch = px2char(col.wpx);
        if (typeof col.wch == "number")
          rec += Math.round(col.wch);
      }
      if (rec.charAt(rec.length - 1) != " ")
        out.push(rec);
    });
  }
  __name(write_ws_cols_sylk, "write_ws_cols_sylk");
  function write_ws_rows_sylk(out, rows) {
    rows.forEach(function(row, i2) {
      var rec = "F;";
      if (row.hidden)
        rec += "M0;";
      else if (row.hpt)
        rec += "M" + 20 * row.hpt + ";";
      else if (row.hpx)
        rec += "M" + 20 * px2pt(row.hpx) + ";";
      if (rec.length > 2)
        out.push(rec + "R" + (i2 + 1));
    });
  }
  __name(write_ws_rows_sylk, "write_ws_rows_sylk");
  function sheet_to_sylk(ws, opts) {
    var preamble = ["ID;PWXL;N;E"], o2 = [];
    var r = safe_decode_range(ws["!ref"]), cell;
    var dense = Array.isArray(ws);
    var RS = "\r\n";
    preamble.push("P;PGeneral");
    preamble.push("F;P0;DG0G8;M255");
    if (ws["!cols"])
      write_ws_cols_sylk(preamble, ws["!cols"]);
    if (ws["!rows"])
      write_ws_rows_sylk(preamble, ws["!rows"]);
    preamble.push("B;Y" + (r.e.r - r.s.r + 1) + ";X" + (r.e.c - r.s.c + 1) + ";D" + [r.s.c, r.s.r, r.e.c, r.e.r].join(" "));
    for (var R2 = r.s.r; R2 <= r.e.r; ++R2) {
      for (var C2 = r.s.c; C2 <= r.e.c; ++C2) {
        var coord = encode_cell({ r: R2, c: C2 });
        cell = dense ? (ws[R2] || [])[C2] : ws[coord];
        if (!cell || cell.v == null && (!cell.f || cell.F))
          continue;
        o2.push(write_ws_cell_sylk(cell, ws, R2, C2));
      }
    }
    return preamble.join(RS) + RS + o2.join(RS) + RS + "E" + RS;
  }
  __name(sheet_to_sylk, "sheet_to_sylk");
  return {
    to_workbook: sylk_to_workbook,
    to_sheet: sylk_to_sheet,
    from_sheet: sheet_to_sylk
  };
}();
var DIF = /* @__PURE__ */ function() {
  function dif_to_aoa(d2, opts) {
    switch (opts.type) {
      case "base64":
        return dif_to_aoa_str(Base64_decode(d2), opts);
      case "binary":
        return dif_to_aoa_str(d2, opts);
      case "buffer":
        return dif_to_aoa_str(has_buf && Buffer.isBuffer(d2) ? d2.toString("binary") : a2s(d2), opts);
      case "array":
        return dif_to_aoa_str(cc2str(d2), opts);
    }
    throw new Error("Unrecognized type " + opts.type);
  }
  __name(dif_to_aoa, "dif_to_aoa");
  function dif_to_aoa_str(str, opts) {
    var records = str.split("\n"), R2 = -1, C2 = -1, ri = 0, arr = [];
    for (; ri !== records.length; ++ri) {
      if (records[ri].trim() === "BOT") {
        arr[++R2] = [];
        C2 = 0;
        continue;
      }
      if (R2 < 0)
        continue;
      var metadata = records[ri].trim().split(",");
      var type = metadata[0], value = metadata[1];
      ++ri;
      var data = records[ri] || "";
      while ((data.match(/["]/g) || []).length & 1 && ri < records.length - 1)
        data += "\n" + records[++ri];
      data = data.trim();
      switch (+type) {
        case -1:
          if (data === "BOT") {
            arr[++R2] = [];
            C2 = 0;
            continue;
          } else if (data !== "EOD")
            throw new Error("Unrecognized DIF special command " + data);
          break;
        case 0:
          if (data === "TRUE")
            arr[R2][C2] = true;
          else if (data === "FALSE")
            arr[R2][C2] = false;
          else if (!isNaN(fuzzynum(value)))
            arr[R2][C2] = fuzzynum(value);
          else if (!isNaN(fuzzydate(value).getDate()))
            arr[R2][C2] = parseDate(value);
          else
            arr[R2][C2] = value;
          ++C2;
          break;
        case 1:
          data = data.slice(1, data.length - 1);
          data = data.replace(/""/g, '"');
          if (data && data.match(/^=".*"$/))
            data = data.slice(2, -1);
          arr[R2][C2++] = data !== "" ? data : null;
          break;
      }
      if (data === "EOD")
        break;
    }
    if (opts && opts.sheetRows)
      arr = arr.slice(0, opts.sheetRows);
    return arr;
  }
  __name(dif_to_aoa_str, "dif_to_aoa_str");
  function dif_to_sheet(str, opts) {
    return aoa_to_sheet(dif_to_aoa(str, opts), opts);
  }
  __name(dif_to_sheet, "dif_to_sheet");
  function dif_to_workbook(str, opts) {
    return sheet_to_workbook(dif_to_sheet(str, opts), opts);
  }
  __name(dif_to_workbook, "dif_to_workbook");
  var sheet_to_dif = /* @__PURE__ */ function() {
    var push_field = /* @__PURE__ */ __name(function pf(o2, topic, v2, n2, s2) {
      o2.push(topic);
      o2.push(v2 + "," + n2);
      o2.push('"' + s2.replace(/"/g, '""') + '"');
    }, "pf");
    var push_value = /* @__PURE__ */ __name(function po(o2, type, v2, s2) {
      o2.push(type + "," + v2);
      o2.push(type == 1 ? '"' + s2.replace(/"/g, '""') + '"' : s2);
    }, "po");
    return /* @__PURE__ */ __name(function sheet_to_dif2(ws) {
      var o2 = [];
      var r = safe_decode_range(ws["!ref"]), cell;
      var dense = Array.isArray(ws);
      push_field(o2, "TABLE", 0, 1, "sheetjs");
      push_field(o2, "VECTORS", 0, r.e.r - r.s.r + 1, "");
      push_field(o2, "TUPLES", 0, r.e.c - r.s.c + 1, "");
      push_field(o2, "DATA", 0, 0, "");
      for (var R2 = r.s.r; R2 <= r.e.r; ++R2) {
        push_value(o2, -1, 0, "BOT");
        for (var C2 = r.s.c; C2 <= r.e.c; ++C2) {
          var coord = encode_cell({ r: R2, c: C2 });
          cell = dense ? (ws[R2] || [])[C2] : ws[coord];
          if (!cell) {
            push_value(o2, 1, 0, "");
            continue;
          }
          switch (cell.t) {
            case "n":
              var val = cell.w;
              if (!val && cell.v != null)
                val = cell.v;
              if (val == null) {
                if (cell.f && !cell.F)
                  push_value(o2, 1, 0, "=" + cell.f);
                else
                  push_value(o2, 1, 0, "");
              } else
                push_value(o2, 0, val, "V");
              break;
            case "b":
              push_value(o2, 0, cell.v ? 1 : 0, cell.v ? "TRUE" : "FALSE");
              break;
            case "s":
              push_value(o2, 1, 0, isNaN(cell.v) ? cell.v : '="' + cell.v + '"');
              break;
            case "d":
              if (!cell.w)
                cell.w = SSF_format(cell.z || table_fmt[14], datenum(parseDate(cell.v)));
              push_value(o2, 0, cell.w, "V");
              break;
            default:
              push_value(o2, 1, 0, "");
          }
        }
      }
      push_value(o2, -1, 0, "EOD");
      var RS = "\r\n";
      var oo = o2.join(RS);
      return oo;
    }, "sheet_to_dif");
  }();
  return {
    to_workbook: dif_to_workbook,
    to_sheet: dif_to_sheet,
    from_sheet: sheet_to_dif
  };
}();
var ETH = /* @__PURE__ */ function() {
  function decode(s2) {
    return s2.replace(/\\b/g, "\\").replace(/\\c/g, ":").replace(/\\n/g, "\n");
  }
  __name(decode, "decode");
  function encode(s2) {
    return s2.replace(/\\/g, "\\b").replace(/:/g, "\\c").replace(/\n/g, "\\n");
  }
  __name(encode, "encode");
  function eth_to_aoa(str, opts) {
    var records = str.split("\n"), R2 = -1, C2 = -1, ri = 0, arr = [];
    for (; ri !== records.length; ++ri) {
      var record = records[ri].trim().split(":");
      if (record[0] !== "cell")
        continue;
      var addr = decode_cell(record[1]);
      if (arr.length <= addr.r) {
        for (R2 = arr.length; R2 <= addr.r; ++R2)
          if (!arr[R2])
            arr[R2] = [];
      }
      R2 = addr.r;
      C2 = addr.c;
      switch (record[2]) {
        case "t":
          arr[R2][C2] = decode(record[3]);
          break;
        case "v":
          arr[R2][C2] = +record[3];
          break;
        case "vtf":
          var _f = record[record.length - 1];
        case "vtc":
          switch (record[3]) {
            case "nl":
              arr[R2][C2] = +record[4] ? true : false;
              break;
            default:
              arr[R2][C2] = +record[4];
              break;
          }
          if (record[2] == "vtf")
            arr[R2][C2] = [arr[R2][C2], _f];
      }
    }
    if (opts && opts.sheetRows)
      arr = arr.slice(0, opts.sheetRows);
    return arr;
  }
  __name(eth_to_aoa, "eth_to_aoa");
  function eth_to_sheet(d2, opts) {
    return aoa_to_sheet(eth_to_aoa(d2, opts), opts);
  }
  __name(eth_to_sheet, "eth_to_sheet");
  function eth_to_workbook(d2, opts) {
    return sheet_to_workbook(eth_to_sheet(d2, opts), opts);
  }
  __name(eth_to_workbook, "eth_to_workbook");
  var header = [
    "socialcalc:version:1.5",
    "MIME-Version: 1.0",
    "Content-Type: multipart/mixed; boundary=SocialCalcSpreadsheetControlSave"
  ].join("\n");
  var sep = [
    "--SocialCalcSpreadsheetControlSave",
    "Content-type: text/plain; charset=UTF-8"
  ].join("\n") + "\n";
  var meta = [
    "# SocialCalc Spreadsheet Control Save",
    "part:sheet"
  ].join("\n");
  var end = "--SocialCalcSpreadsheetControlSave--";
  function sheet_to_eth_data(ws) {
    if (!ws || !ws["!ref"])
      return "";
    var o2 = [], oo = [], cell, coord = "";
    var r = decode_range(ws["!ref"]);
    var dense = Array.isArray(ws);
    for (var R2 = r.s.r; R2 <= r.e.r; ++R2) {
      for (var C2 = r.s.c; C2 <= r.e.c; ++C2) {
        coord = encode_cell({ r: R2, c: C2 });
        cell = dense ? (ws[R2] || [])[C2] : ws[coord];
        if (!cell || cell.v == null || cell.t === "z")
          continue;
        oo = ["cell", coord, "t"];
        switch (cell.t) {
          case "s":
          case "str":
            oo.push(encode(cell.v));
            break;
          case "n":
            if (!cell.f) {
              oo[2] = "v";
              oo[3] = cell.v;
            } else {
              oo[2] = "vtf";
              oo[3] = "n";
              oo[4] = cell.v;
              oo[5] = encode(cell.f);
            }
            break;
          case "b":
            oo[2] = "vt" + (cell.f ? "f" : "c");
            oo[3] = "nl";
            oo[4] = cell.v ? "1" : "0";
            oo[5] = encode(cell.f || (cell.v ? "TRUE" : "FALSE"));
            break;
          case "d":
            var t2 = datenum(parseDate(cell.v));
            oo[2] = "vtc";
            oo[3] = "nd";
            oo[4] = "" + t2;
            oo[5] = cell.w || SSF_format(cell.z || table_fmt[14], t2);
            break;
          case "e":
            continue;
        }
        o2.push(oo.join(":"));
      }
    }
    o2.push("sheet:c:" + (r.e.c - r.s.c + 1) + ":r:" + (r.e.r - r.s.r + 1) + ":tvf:1");
    o2.push("valueformat:1:text-wiki");
    return o2.join("\n");
  }
  __name(sheet_to_eth_data, "sheet_to_eth_data");
  function sheet_to_eth(ws) {
    return [header, sep, meta, sep, sheet_to_eth_data(ws), end].join("\n");
  }
  __name(sheet_to_eth, "sheet_to_eth");
  return {
    to_workbook: eth_to_workbook,
    to_sheet: eth_to_sheet,
    from_sheet: sheet_to_eth
  };
}();
var PRN = /* @__PURE__ */ function() {
  function set_text_arr(data, arr, R2, C2, o2) {
    if (o2.raw)
      arr[R2][C2] = data;
    else if (data === "")
      ;
    else if (data === "TRUE")
      arr[R2][C2] = true;
    else if (data === "FALSE")
      arr[R2][C2] = false;
    else if (!isNaN(fuzzynum(data)))
      arr[R2][C2] = fuzzynum(data);
    else if (!isNaN(fuzzydate(data).getDate()))
      arr[R2][C2] = parseDate(data);
    else
      arr[R2][C2] = data;
  }
  __name(set_text_arr, "set_text_arr");
  function prn_to_aoa_str(f2, opts) {
    var o2 = opts || {};
    var arr = [];
    if (!f2 || f2.length === 0)
      return arr;
    var lines = f2.split(/[\r\n]/);
    var L2 = lines.length - 1;
    while (L2 >= 0 && lines[L2].length === 0)
      --L2;
    var start = 10, idx = 0;
    var R2 = 0;
    for (; R2 <= L2; ++R2) {
      idx = lines[R2].indexOf(" ");
      if (idx == -1)
        idx = lines[R2].length;
      else
        idx++;
      start = Math.max(start, idx);
    }
    for (R2 = 0; R2 <= L2; ++R2) {
      arr[R2] = [];
      var C2 = 0;
      set_text_arr(lines[R2].slice(0, start).trim(), arr, R2, C2, o2);
      for (C2 = 1; C2 <= (lines[R2].length - start) / 10 + 1; ++C2)
        set_text_arr(lines[R2].slice(start + (C2 - 1) * 10, start + C2 * 10).trim(), arr, R2, C2, o2);
    }
    if (o2.sheetRows)
      arr = arr.slice(0, o2.sheetRows);
    return arr;
  }
  __name(prn_to_aoa_str, "prn_to_aoa_str");
  var guess_seps = {
    /*::[*/
    44: ",",
    /*::[*/
    9: "	",
    /*::[*/
    59: ";",
    /*::[*/
    124: "|"
  };
  var guess_sep_weights = {
    /*::[*/
    44: 3,
    /*::[*/
    9: 2,
    /*::[*/
    59: 1,
    /*::[*/
    124: 0
  };
  function guess_sep(str) {
    var cnt = {}, instr = false, end = 0, cc = 0;
    for (; end < str.length; ++end) {
      if ((cc = str.charCodeAt(end)) == 34)
        instr = !instr;
      else if (!instr && cc in guess_seps)
        cnt[cc] = (cnt[cc] || 0) + 1;
    }
    cc = [];
    for (end in cnt)
      if (Object.prototype.hasOwnProperty.call(cnt, end)) {
        cc.push([cnt[end], end]);
      }
    if (!cc.length) {
      cnt = guess_sep_weights;
      for (end in cnt)
        if (Object.prototype.hasOwnProperty.call(cnt, end)) {
          cc.push([cnt[end], end]);
        }
    }
    cc.sort(function(a2, b2) {
      return a2[0] - b2[0] || guess_sep_weights[a2[1]] - guess_sep_weights[b2[1]];
    });
    return guess_seps[cc.pop()[1]] || 44;
  }
  __name(guess_sep, "guess_sep");
  function dsv_to_sheet_str(str, opts) {
    var o2 = opts || {};
    var sep = "";
    var ws = o2.dense ? [] : {};
    var range = { s: { c: 0, r: 0 }, e: { c: 0, r: 0 } };
    if (str.slice(0, 4) == "sep=") {
      if (str.charCodeAt(5) == 13 && str.charCodeAt(6) == 10) {
        sep = str.charAt(4);
        str = str.slice(7);
      } else if (str.charCodeAt(5) == 13 || str.charCodeAt(5) == 10) {
        sep = str.charAt(4);
        str = str.slice(6);
      } else
        sep = guess_sep(str.slice(0, 1024));
    } else if (o2 && o2.FS)
      sep = o2.FS;
    else
      sep = guess_sep(str.slice(0, 1024));
    var R2 = 0, C2 = 0, v2 = 0;
    var start = 0, end = 0, sepcc = sep.charCodeAt(0), instr = false, cc = 0, startcc = str.charCodeAt(0);
    str = str.replace(/\r\n/mg, "\n");
    var _re = o2.dateNF != null ? dateNF_regex(o2.dateNF) : null;
    function finish_cell() {
      var s2 = str.slice(start, end);
      var cell = {};
      if (s2.charAt(0) == '"' && s2.charAt(s2.length - 1) == '"')
        s2 = s2.slice(1, -1).replace(/""/g, '"');
      if (s2.length === 0)
        cell.t = "z";
      else if (o2.raw) {
        cell.t = "s";
        cell.v = s2;
      } else if (s2.trim().length === 0) {
        cell.t = "s";
        cell.v = s2;
      } else if (s2.charCodeAt(0) == 61) {
        if (s2.charCodeAt(1) == 34 && s2.charCodeAt(s2.length - 1) == 34) {
          cell.t = "s";
          cell.v = s2.slice(2, -1).replace(/""/g, '"');
        } else if (fuzzyfmla(s2)) {
          cell.t = "n";
          cell.f = s2.slice(1);
        } else {
          cell.t = "s";
          cell.v = s2;
        }
      } else if (s2 == "TRUE") {
        cell.t = "b";
        cell.v = true;
      } else if (s2 == "FALSE") {
        cell.t = "b";
        cell.v = false;
      } else if (!isNaN(v2 = fuzzynum(s2))) {
        cell.t = "n";
        if (o2.cellText !== false)
          cell.w = s2;
        cell.v = v2;
      } else if (!isNaN(fuzzydate(s2).getDate()) || _re && s2.match(_re)) {
        cell.z = o2.dateNF || table_fmt[14];
        var k2 = 0;
        if (_re && s2.match(_re)) {
          s2 = dateNF_fix(s2, o2.dateNF, s2.match(_re) || []);
          k2 = 1;
        }
        if (o2.cellDates) {
          cell.t = "d";
          cell.v = parseDate(s2, k2);
        } else {
          cell.t = "n";
          cell.v = datenum(parseDate(s2, k2));
        }
        if (o2.cellText !== false)
          cell.w = SSF_format(cell.z, cell.v instanceof Date ? datenum(cell.v) : cell.v);
        if (!o2.cellNF)
          delete cell.z;
      } else {
        cell.t = "s";
        cell.v = s2;
      }
      if (cell.t == "z")
        ;
      else if (o2.dense) {
        if (!ws[R2])
          ws[R2] = [];
        ws[R2][C2] = cell;
      } else
        ws[encode_cell({ c: C2, r: R2 })] = cell;
      start = end + 1;
      startcc = str.charCodeAt(start);
      if (range.e.c < C2)
        range.e.c = C2;
      if (range.e.r < R2)
        range.e.r = R2;
      if (cc == sepcc)
        ++C2;
      else {
        C2 = 0;
        ++R2;
        if (o2.sheetRows && o2.sheetRows <= R2)
          return true;
      }
    }
    __name(finish_cell, "finish_cell");
    outer:
      for (; end < str.length; ++end)
        switch (cc = str.charCodeAt(end)) {
          case 34:
            if (startcc === 34)
              instr = !instr;
            break;
          case sepcc:
          case 10:
          case 13:
            if (!instr && finish_cell())
              break outer;
            break;
        }
    if (end - start > 0)
      finish_cell();
    ws["!ref"] = encode_range(range);
    return ws;
  }
  __name(dsv_to_sheet_str, "dsv_to_sheet_str");
  function prn_to_sheet_str(str, opts) {
    if (!(opts && opts.PRN))
      return dsv_to_sheet_str(str, opts);
    if (opts.FS)
      return dsv_to_sheet_str(str, opts);
    if (str.slice(0, 4) == "sep=")
      return dsv_to_sheet_str(str, opts);
    if (str.indexOf("	") >= 0 || str.indexOf(",") >= 0 || str.indexOf(";") >= 0)
      return dsv_to_sheet_str(str, opts);
    return aoa_to_sheet(prn_to_aoa_str(str, opts), opts);
  }
  __name(prn_to_sheet_str, "prn_to_sheet_str");
  function prn_to_sheet(d2, opts) {
    var str = "", bytes = opts.type == "string" ? [0, 0, 0, 0] : firstbyte(d2, opts);
    switch (opts.type) {
      case "base64":
        str = Base64_decode(d2);
        break;
      case "binary":
        str = d2;
        break;
      case "buffer":
        if (opts.codepage == 65001)
          str = d2.toString("utf8");
        else if (opts.codepage && typeof $cptable !== "undefined")
          str = $cptable.utils.decode(opts.codepage, d2);
        else
          str = has_buf && Buffer.isBuffer(d2) ? d2.toString("binary") : a2s(d2);
        break;
      case "array":
        str = cc2str(d2);
        break;
      case "string":
        str = d2;
        break;
      default:
        throw new Error("Unrecognized type " + opts.type);
    }
    if (bytes[0] == 239 && bytes[1] == 187 && bytes[2] == 191)
      str = utf8read(str.slice(3));
    else if (opts.type != "string" && opts.type != "buffer" && opts.codepage == 65001)
      str = utf8read(str);
    else if (opts.type == "binary" && typeof $cptable !== "undefined" && opts.codepage)
      str = $cptable.utils.decode(opts.codepage, $cptable.utils.encode(28591, str));
    if (str.slice(0, 19) == "socialcalc:version:")
      return ETH.to_sheet(opts.type == "string" ? str : utf8read(str), opts);
    return prn_to_sheet_str(str, opts);
  }
  __name(prn_to_sheet, "prn_to_sheet");
  function prn_to_workbook(d2, opts) {
    return sheet_to_workbook(prn_to_sheet(d2, opts), opts);
  }
  __name(prn_to_workbook, "prn_to_workbook");
  function sheet_to_prn(ws) {
    var o2 = [];
    var r = safe_decode_range(ws["!ref"]), cell;
    var dense = Array.isArray(ws);
    for (var R2 = r.s.r; R2 <= r.e.r; ++R2) {
      var oo = [];
      for (var C2 = r.s.c; C2 <= r.e.c; ++C2) {
        var coord = encode_cell({ r: R2, c: C2 });
        cell = dense ? (ws[R2] || [])[C2] : ws[coord];
        if (!cell || cell.v == null) {
          oo.push("          ");
          continue;
        }
        var w2 = (cell.w || (format_cell(cell), cell.w) || "").slice(0, 10);
        while (w2.length < 10)
          w2 += " ";
        oo.push(w2 + (C2 === 0 ? " " : ""));
      }
      o2.push(oo.join(""));
    }
    return o2.join("\n");
  }
  __name(sheet_to_prn, "sheet_to_prn");
  return {
    to_workbook: prn_to_workbook,
    to_sheet: prn_to_sheet,
    from_sheet: sheet_to_prn
  };
}();
var WK_ = /* @__PURE__ */ function() {
  function lotushopper(data, cb, opts) {
    if (!data)
      return;
    prep_blob(data, data.l || 0);
    var Enum = opts.Enum || WK1Enum;
    while (data.l < data.length) {
      var RT = data.read_shift(2);
      var R2 = Enum[RT] || Enum[65535];
      var length = data.read_shift(2);
      var tgt = data.l + length;
      var d2 = R2.f && R2.f(data, length, opts);
      data.l = tgt;
      if (cb(d2, R2, RT))
        return;
    }
  }
  __name(lotushopper, "lotushopper");
  function lotus_to_workbook(d2, opts) {
    switch (opts.type) {
      case "base64":
        return lotus_to_workbook_buf(s2a(Base64_decode(d2)), opts);
      case "binary":
        return lotus_to_workbook_buf(s2a(d2), opts);
      case "buffer":
      case "array":
        return lotus_to_workbook_buf(d2, opts);
    }
    throw "Unsupported type " + opts.type;
  }
  __name(lotus_to_workbook, "lotus_to_workbook");
  function lotus_to_workbook_buf(d2, opts) {
    if (!d2)
      return d2;
    var o2 = opts || {};
    var s2 = o2.dense ? [] : {}, n2 = "Sheet1", next_n = "", sidx = 0;
    var sheets = {}, snames = [], realnames = [];
    var refguess = { s: { r: 0, c: 0 }, e: { r: 0, c: 0 } };
    var sheetRows = o2.sheetRows || 0;
    if (d2[2] == 0) {
      if (d2[3] == 8 || d2[3] == 9) {
        if (d2.length >= 16 && d2[14] == 5 && d2[15] === 108)
          throw new Error("Unsupported Works 3 for Mac file");
      }
    }
    if (d2[2] == 2) {
      o2.Enum = WK1Enum;
      lotushopper(d2, function(val, R2, RT) {
        switch (RT) {
          case 0:
            o2.vers = val;
            if (val >= 4096)
              o2.qpro = true;
            break;
          case 6:
            refguess = val;
            break;
          case 204:
            if (val)
              next_n = val;
            break;
          case 222:
            next_n = val;
            break;
          case 15:
          case 51:
            if (!o2.qpro)
              val[1].v = val[1].v.slice(1);
          case 13:
          case 14:
          case 16:
            if (RT == 14 && (val[2] & 112) == 112 && (val[2] & 15) > 1 && (val[2] & 15) < 15) {
              val[1].z = o2.dateNF || table_fmt[14];
              if (o2.cellDates) {
                val[1].t = "d";
                val[1].v = numdate(val[1].v);
              }
            }
            if (o2.qpro) {
              if (val[3] > sidx) {
                s2["!ref"] = encode_range(refguess);
                sheets[n2] = s2;
                snames.push(n2);
                s2 = o2.dense ? [] : {};
                refguess = { s: { r: 0, c: 0 }, e: { r: 0, c: 0 } };
                sidx = val[3];
                n2 = next_n || "Sheet" + (sidx + 1);
                next_n = "";
              }
            }
            var tmpcell = o2.dense ? (s2[val[0].r] || [])[val[0].c] : s2[encode_cell(val[0])];
            if (tmpcell) {
              tmpcell.t = val[1].t;
              tmpcell.v = val[1].v;
              if (val[1].z != null)
                tmpcell.z = val[1].z;
              if (val[1].f != null)
                tmpcell.f = val[1].f;
              break;
            }
            if (o2.dense) {
              if (!s2[val[0].r])
                s2[val[0].r] = [];
              s2[val[0].r][val[0].c] = val[1];
            } else
              s2[encode_cell(val[0])] = val[1];
            break;
        }
      }, o2);
    } else if (d2[2] == 26 || d2[2] == 14) {
      o2.Enum = WK3Enum;
      if (d2[2] == 14) {
        o2.qpro = true;
        d2.l = 0;
      }
      lotushopper(d2, function(val, R2, RT) {
        switch (RT) {
          case 204:
            n2 = val;
            break;
          case 22:
            val[1].v = val[1].v.slice(1);
          case 23:
          case 24:
          case 25:
          case 37:
          case 39:
          case 40:
            if (val[3] > sidx) {
              s2["!ref"] = encode_range(refguess);
              sheets[n2] = s2;
              snames.push(n2);
              s2 = o2.dense ? [] : {};
              refguess = { s: { r: 0, c: 0 }, e: { r: 0, c: 0 } };
              sidx = val[3];
              n2 = "Sheet" + (sidx + 1);
            }
            if (sheetRows > 0 && val[0].r >= sheetRows)
              break;
            if (o2.dense) {
              if (!s2[val[0].r])
                s2[val[0].r] = [];
              s2[val[0].r][val[0].c] = val[1];
            } else
              s2[encode_cell(val[0])] = val[1];
            if (refguess.e.c < val[0].c)
              refguess.e.c = val[0].c;
            if (refguess.e.r < val[0].r)
              refguess.e.r = val[0].r;
            break;
          case 27:
            if (val[14e3])
              realnames[val[14e3][0]] = val[14e3][1];
            break;
          case 1537:
            realnames[val[0]] = val[1];
            if (val[0] == sidx)
              n2 = val[1];
            break;
        }
      }, o2);
    } else
      throw new Error("Unrecognized LOTUS BOF " + d2[2]);
    s2["!ref"] = encode_range(refguess);
    sheets[next_n || n2] = s2;
    snames.push(next_n || n2);
    if (!realnames.length)
      return { SheetNames: snames, Sheets: sheets };
    var osheets = {}, rnames = [];
    for (var i2 = 0; i2 < realnames.length; ++i2)
      if (sheets[snames[i2]]) {
        rnames.push(realnames[i2] || snames[i2]);
        osheets[realnames[i2]] = sheets[realnames[i2]] || sheets[snames[i2]];
      } else {
        rnames.push(realnames[i2]);
        osheets[realnames[i2]] = { "!ref": "A1" };
      }
    return { SheetNames: rnames, Sheets: osheets };
  }
  __name(lotus_to_workbook_buf, "lotus_to_workbook_buf");
  function sheet_to_wk1(ws, opts) {
    var o2 = opts || {};
    if (+o2.codepage >= 0)
      set_cp(+o2.codepage);
    if (o2.type == "string")
      throw new Error("Cannot write WK1 to JS string");
    var ba = buf_array();
    var range = safe_decode_range(ws["!ref"]);
    var dense = Array.isArray(ws);
    var cols = [];
    write_biff_rec(ba, 0, write_BOF_WK1(1030));
    write_biff_rec(ba, 6, write_RANGE(range));
    var max_R = Math.min(range.e.r, 8191);
    for (var R2 = range.s.r; R2 <= max_R; ++R2) {
      var rr = encode_row(R2);
      for (var C2 = range.s.c; C2 <= range.e.c; ++C2) {
        if (R2 === range.s.r)
          cols[C2] = encode_col(C2);
        var ref = cols[C2] + rr;
        var cell = dense ? (ws[R2] || [])[C2] : ws[ref];
        if (!cell || cell.t == "z")
          continue;
        if (cell.t == "n") {
          if ((cell.v | 0) == cell.v && cell.v >= -32768 && cell.v <= 32767)
            write_biff_rec(ba, 13, write_INTEGER(R2, C2, cell.v));
          else
            write_biff_rec(ba, 14, write_NUMBER(R2, C2, cell.v));
        } else {
          var str = format_cell(cell);
          write_biff_rec(ba, 15, write_LABEL(R2, C2, str.slice(0, 239)));
        }
      }
    }
    write_biff_rec(ba, 1);
    return ba.end();
  }
  __name(sheet_to_wk1, "sheet_to_wk1");
  function book_to_wk3(wb, opts) {
    var o2 = opts || {};
    if (+o2.codepage >= 0)
      set_cp(+o2.codepage);
    if (o2.type == "string")
      throw new Error("Cannot write WK3 to JS string");
    var ba = buf_array();
    write_biff_rec(ba, 0, write_BOF_WK3(wb));
    for (var i2 = 0, cnt = 0; i2 < wb.SheetNames.length; ++i2)
      if ((wb.Sheets[wb.SheetNames[i2]] || {})["!ref"])
        write_biff_rec(ba, 27, write_XFORMAT_SHEETNAME(wb.SheetNames[i2], cnt++));
    var wsidx = 0;
    for (i2 = 0; i2 < wb.SheetNames.length; ++i2) {
      var ws = wb.Sheets[wb.SheetNames[i2]];
      if (!ws || !ws["!ref"])
        continue;
      var range = safe_decode_range(ws["!ref"]);
      var dense = Array.isArray(ws);
      var cols = [];
      var max_R = Math.min(range.e.r, 8191);
      for (var R2 = range.s.r; R2 <= max_R; ++R2) {
        var rr = encode_row(R2);
        for (var C2 = range.s.c; C2 <= range.e.c; ++C2) {
          if (R2 === range.s.r)
            cols[C2] = encode_col(C2);
          var ref = cols[C2] + rr;
          var cell = dense ? (ws[R2] || [])[C2] : ws[ref];
          if (!cell || cell.t == "z")
            continue;
          if (cell.t == "n") {
            write_biff_rec(ba, 23, write_NUMBER_17(R2, C2, wsidx, cell.v));
          } else {
            var str = format_cell(cell);
            write_biff_rec(ba, 22, write_LABEL_16(R2, C2, wsidx, str.slice(0, 239)));
          }
        }
      }
      ++wsidx;
    }
    write_biff_rec(ba, 1);
    return ba.end();
  }
  __name(book_to_wk3, "book_to_wk3");
  function write_BOF_WK1(v2) {
    var out = new_buf(2);
    out.write_shift(2, v2);
    return out;
  }
  __name(write_BOF_WK1, "write_BOF_WK1");
  function write_BOF_WK3(wb) {
    var out = new_buf(26);
    out.write_shift(2, 4096);
    out.write_shift(2, 4);
    out.write_shift(4, 0);
    var rows = 0, cols = 0, wscnt = 0;
    for (var i2 = 0; i2 < wb.SheetNames.length; ++i2) {
      var name = wb.SheetNames[i2];
      var ws = wb.Sheets[name];
      if (!ws || !ws["!ref"])
        continue;
      ++wscnt;
      var range = decode_range(ws["!ref"]);
      if (rows < range.e.r)
        rows = range.e.r;
      if (cols < range.e.c)
        cols = range.e.c;
    }
    if (rows > 8191)
      rows = 8191;
    out.write_shift(2, rows);
    out.write_shift(1, wscnt);
    out.write_shift(1, cols);
    out.write_shift(2, 0);
    out.write_shift(2, 0);
    out.write_shift(1, 1);
    out.write_shift(1, 2);
    out.write_shift(4, 0);
    out.write_shift(4, 0);
    return out;
  }
  __name(write_BOF_WK3, "write_BOF_WK3");
  function parse_RANGE(blob, length, opts) {
    var o2 = { s: { c: 0, r: 0 }, e: { c: 0, r: 0 } };
    if (length == 8 && opts.qpro) {
      o2.s.c = blob.read_shift(1);
      blob.l++;
      o2.s.r = blob.read_shift(2);
      o2.e.c = blob.read_shift(1);
      blob.l++;
      o2.e.r = blob.read_shift(2);
      return o2;
    }
    o2.s.c = blob.read_shift(2);
    o2.s.r = blob.read_shift(2);
    if (length == 12 && opts.qpro)
      blob.l += 2;
    o2.e.c = blob.read_shift(2);
    o2.e.r = blob.read_shift(2);
    if (length == 12 && opts.qpro)
      blob.l += 2;
    if (o2.s.c == 65535)
      o2.s.c = o2.e.c = o2.s.r = o2.e.r = 0;
    return o2;
  }
  __name(parse_RANGE, "parse_RANGE");
  function write_RANGE(range) {
    var out = new_buf(8);
    out.write_shift(2, range.s.c);
    out.write_shift(2, range.s.r);
    out.write_shift(2, range.e.c);
    out.write_shift(2, range.e.r);
    return out;
  }
  __name(write_RANGE, "write_RANGE");
  function parse_cell(blob, length, opts) {
    var o2 = [{ c: 0, r: 0 }, { t: "n", v: 0 }, 0, 0];
    if (opts.qpro && opts.vers != 20768) {
      o2[0].c = blob.read_shift(1);
      o2[3] = blob.read_shift(1);
      o2[0].r = blob.read_shift(2);
      blob.l += 2;
    } else {
      o2[2] = blob.read_shift(1);
      o2[0].c = blob.read_shift(2);
      o2[0].r = blob.read_shift(2);
    }
    return o2;
  }
  __name(parse_cell, "parse_cell");
  function parse_LABEL(blob, length, opts) {
    var tgt = blob.l + length;
    var o2 = parse_cell(blob, length, opts);
    o2[1].t = "s";
    if (opts.vers == 20768) {
      blob.l++;
      var len = blob.read_shift(1);
      o2[1].v = blob.read_shift(len, "utf8");
      return o2;
    }
    if (opts.qpro)
      blob.l++;
    o2[1].v = blob.read_shift(tgt - blob.l, "cstr");
    return o2;
  }
  __name(parse_LABEL, "parse_LABEL");
  function write_LABEL(R2, C2, s2) {
    var o2 = new_buf(7 + s2.length);
    o2.write_shift(1, 255);
    o2.write_shift(2, C2);
    o2.write_shift(2, R2);
    o2.write_shift(1, 39);
    for (var i2 = 0; i2 < o2.length; ++i2) {
      var cc = s2.charCodeAt(i2);
      o2.write_shift(1, cc >= 128 ? 95 : cc);
    }
    o2.write_shift(1, 0);
    return o2;
  }
  __name(write_LABEL, "write_LABEL");
  function parse_INTEGER(blob, length, opts) {
    var o2 = parse_cell(blob, length, opts);
    o2[1].v = blob.read_shift(2, "i");
    return o2;
  }
  __name(parse_INTEGER, "parse_INTEGER");
  function write_INTEGER(R2, C2, v2) {
    var o2 = new_buf(7);
    o2.write_shift(1, 255);
    o2.write_shift(2, C2);
    o2.write_shift(2, R2);
    o2.write_shift(2, v2, "i");
    return o2;
  }
  __name(write_INTEGER, "write_INTEGER");
  function parse_NUMBER(blob, length, opts) {
    var o2 = parse_cell(blob, length, opts);
    o2[1].v = blob.read_shift(8, "f");
    return o2;
  }
  __name(parse_NUMBER, "parse_NUMBER");
  function write_NUMBER(R2, C2, v2) {
    var o2 = new_buf(13);
    o2.write_shift(1, 255);
    o2.write_shift(2, C2);
    o2.write_shift(2, R2);
    o2.write_shift(8, v2, "f");
    return o2;
  }
  __name(write_NUMBER, "write_NUMBER");
  function parse_FORMULA(blob, length, opts) {
    var tgt = blob.l + length;
    var o2 = parse_cell(blob, length, opts);
    o2[1].v = blob.read_shift(8, "f");
    if (opts.qpro)
      blob.l = tgt;
    else {
      var flen = blob.read_shift(2);
      wk1_fmla_to_csf(blob.slice(blob.l, blob.l + flen), o2);
      blob.l += flen;
    }
    return o2;
  }
  __name(parse_FORMULA, "parse_FORMULA");
  function wk1_parse_rc(B2, V2, col) {
    var rel = V2 & 32768;
    V2 &= ~32768;
    V2 = (rel ? B2 : 0) + (V2 >= 8192 ? V2 - 16384 : V2);
    return (rel ? "" : "$") + (col ? encode_col(V2) : encode_row(V2));
  }
  __name(wk1_parse_rc, "wk1_parse_rc");
  var FuncTab = {
    51: ["FALSE", 0],
    52: ["TRUE", 0],
    70: ["LEN", 1],
    80: ["SUM", 69],
    81: ["AVERAGEA", 69],
    82: ["COUNTA", 69],
    83: ["MINA", 69],
    84: ["MAXA", 69],
    111: ["T", 1]
  };
  var BinOpTab = [
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    // eslint-disable-line no-mixed-spaces-and-tabs
    "",
    "+",
    "-",
    "*",
    "/",
    "^",
    "=",
    "<>",
    // eslint-disable-line no-mixed-spaces-and-tabs
    "<=",
    ">=",
    "<",
    ">",
    "",
    "",
    "",
    "",
    // eslint-disable-line no-mixed-spaces-and-tabs
    "&",
    "",
    "",
    "",
    "",
    "",
    "",
    ""
    // eslint-disable-line no-mixed-spaces-and-tabs
  ];
  function wk1_fmla_to_csf(blob, o2) {
    prep_blob(blob, 0);
    var out = [], argc = 0, R2 = "", C2 = "", argL = "", argR = "";
    while (blob.l < blob.length) {
      var cc = blob[blob.l++];
      switch (cc) {
        case 0:
          out.push(blob.read_shift(8, "f"));
          break;
        case 1:
          {
            C2 = wk1_parse_rc(o2[0].c, blob.read_shift(2), true);
            R2 = wk1_parse_rc(o2[0].r, blob.read_shift(2), false);
            out.push(C2 + R2);
          }
          break;
        case 2:
          {
            var c2 = wk1_parse_rc(o2[0].c, blob.read_shift(2), true);
            var r = wk1_parse_rc(o2[0].r, blob.read_shift(2), false);
            C2 = wk1_parse_rc(o2[0].c, blob.read_shift(2), true);
            R2 = wk1_parse_rc(o2[0].r, blob.read_shift(2), false);
            out.push(c2 + r + ":" + C2 + R2);
          }
          break;
        case 3:
          if (blob.l < blob.length) {
            console.error("WK1 premature formula end");
            return;
          }
          break;
        case 4:
          out.push("(" + out.pop() + ")");
          break;
        case 5:
          out.push(blob.read_shift(2));
          break;
        case 6:
          {
            var Z2 = "";
            while (cc = blob[blob.l++])
              Z2 += String.fromCharCode(cc);
            out.push('"' + Z2.replace(/"/g, '""') + '"');
          }
          break;
        case 8:
          out.push("-" + out.pop());
          break;
        case 23:
          out.push("+" + out.pop());
          break;
        case 22:
          out.push("NOT(" + out.pop() + ")");
          break;
        case 20:
        case 21:
          {
            argR = out.pop();
            argL = out.pop();
            out.push(["AND", "OR"][cc - 20] + "(" + argL + "," + argR + ")");
          }
          break;
        default:
          if (cc < 32 && BinOpTab[cc]) {
            argR = out.pop();
            argL = out.pop();
            out.push(argL + BinOpTab[cc] + argR);
          } else if (FuncTab[cc]) {
            argc = FuncTab[cc][1];
            if (argc == 69)
              argc = blob[blob.l++];
            if (argc > out.length) {
              console.error("WK1 bad formula parse 0x" + cc.toString(16) + ":|" + out.join("|") + "|");
              return;
            }
            var args = out.slice(-argc);
            out.length -= argc;
            out.push(FuncTab[cc][0] + "(" + args.join(",") + ")");
          } else if (cc <= 7)
            return console.error("WK1 invalid opcode " + cc.toString(16));
          else if (cc <= 24)
            return console.error("WK1 unsupported op " + cc.toString(16));
          else if (cc <= 30)
            return console.error("WK1 invalid opcode " + cc.toString(16));
          else if (cc <= 115)
            return console.error("WK1 unsupported function opcode " + cc.toString(16));
          else
            return console.error("WK1 unrecognized opcode " + cc.toString(16));
      }
    }
    if (out.length == 1)
      o2[1].f = "" + out[0];
    else
      console.error("WK1 bad formula parse |" + out.join("|") + "|");
  }
  __name(wk1_fmla_to_csf, "wk1_fmla_to_csf");
  function parse_cell_3(blob) {
    var o2 = [{ c: 0, r: 0 }, { t: "n", v: 0 }, 0];
    o2[0].r = blob.read_shift(2);
    o2[3] = blob[blob.l++];
    o2[0].c = blob[blob.l++];
    return o2;
  }
  __name(parse_cell_3, "parse_cell_3");
  function parse_LABEL_16(blob, length) {
    var o2 = parse_cell_3(blob);
    o2[1].t = "s";
    o2[1].v = blob.read_shift(length - 4, "cstr");
    return o2;
  }
  __name(parse_LABEL_16, "parse_LABEL_16");
  function write_LABEL_16(R2, C2, wsidx, s2) {
    var o2 = new_buf(6 + s2.length);
    o2.write_shift(2, R2);
    o2.write_shift(1, wsidx);
    o2.write_shift(1, C2);
    o2.write_shift(1, 39);
    for (var i2 = 0; i2 < s2.length; ++i2) {
      var cc = s2.charCodeAt(i2);
      o2.write_shift(1, cc >= 128 ? 95 : cc);
    }
    o2.write_shift(1, 0);
    return o2;
  }
  __name(write_LABEL_16, "write_LABEL_16");
  function parse_NUMBER_18(blob, length) {
    var o2 = parse_cell_3(blob);
    o2[1].v = blob.read_shift(2);
    var v2 = o2[1].v >> 1;
    if (o2[1].v & 1) {
      switch (v2 & 7) {
        case 0:
          v2 = (v2 >> 3) * 5e3;
          break;
        case 1:
          v2 = (v2 >> 3) * 500;
          break;
        case 2:
          v2 = (v2 >> 3) / 20;
          break;
        case 3:
          v2 = (v2 >> 3) / 200;
          break;
        case 4:
          v2 = (v2 >> 3) / 2e3;
          break;
        case 5:
          v2 = (v2 >> 3) / 2e4;
          break;
        case 6:
          v2 = (v2 >> 3) / 16;
          break;
        case 7:
          v2 = (v2 >> 3) / 64;
          break;
      }
    }
    o2[1].v = v2;
    return o2;
  }
  __name(parse_NUMBER_18, "parse_NUMBER_18");
  function parse_NUMBER_17(blob, length) {
    var o2 = parse_cell_3(blob);
    var v1 = blob.read_shift(4);
    var v2 = blob.read_shift(4);
    var e = blob.read_shift(2);
    if (e == 65535) {
      if (v1 === 0 && v2 === 3221225472) {
        o2[1].t = "e";
        o2[1].v = 15;
      } else if (v1 === 0 && v2 === 3489660928) {
        o2[1].t = "e";
        o2[1].v = 42;
      } else
        o2[1].v = 0;
      return o2;
    }
    var s2 = e & 32768;
    e = (e & 32767) - 16446;
    o2[1].v = (1 - s2 * 2) * (v2 * Math.pow(2, e + 32) + v1 * Math.pow(2, e));
    return o2;
  }
  __name(parse_NUMBER_17, "parse_NUMBER_17");
  function write_NUMBER_17(R2, C2, wsidx, v2) {
    var o2 = new_buf(14);
    o2.write_shift(2, R2);
    o2.write_shift(1, wsidx);
    o2.write_shift(1, C2);
    if (v2 == 0) {
      o2.write_shift(4, 0);
      o2.write_shift(4, 0);
      o2.write_shift(2, 65535);
      return o2;
    }
    var s2 = 0, e = 0, v1 = 0, v22 = 0;
    if (v2 < 0) {
      s2 = 1;
      v2 = -v2;
    }
    e = Math.log2(v2) | 0;
    v2 /= Math.pow(2, e - 31);
    v22 = v2 >>> 0;
    if ((v22 & 2147483648) == 0) {
      v2 /= 2;
      ++e;
      v22 = v2 >>> 0;
    }
    v2 -= v22;
    v22 |= 2147483648;
    v22 >>>= 0;
    v2 *= Math.pow(2, 32);
    v1 = v2 >>> 0;
    o2.write_shift(4, v1);
    o2.write_shift(4, v22);
    e += 16383 + (s2 ? 32768 : 0);
    o2.write_shift(2, e);
    return o2;
  }
  __name(write_NUMBER_17, "write_NUMBER_17");
  function parse_FORMULA_19(blob, length) {
    var o2 = parse_NUMBER_17(blob);
    blob.l += length - 14;
    return o2;
  }
  __name(parse_FORMULA_19, "parse_FORMULA_19");
  function parse_NUMBER_25(blob, length) {
    var o2 = parse_cell_3(blob);
    var v1 = blob.read_shift(4);
    o2[1].v = v1 >> 6;
    return o2;
  }
  __name(parse_NUMBER_25, "parse_NUMBER_25");
  function parse_NUMBER_27(blob, length) {
    var o2 = parse_cell_3(blob);
    var v1 = blob.read_shift(8, "f");
    o2[1].v = v1;
    return o2;
  }
  __name(parse_NUMBER_27, "parse_NUMBER_27");
  function parse_FORMULA_28(blob, length) {
    var o2 = parse_NUMBER_27(blob);
    blob.l += length - 10;
    return o2;
  }
  __name(parse_FORMULA_28, "parse_FORMULA_28");
  function parse_SHEETNAMECS(blob, length) {
    return blob[blob.l + length - 1] == 0 ? blob.read_shift(length, "cstr") : "";
  }
  __name(parse_SHEETNAMECS, "parse_SHEETNAMECS");
  function parse_SHEETNAMELP(blob, length) {
    var len = blob[blob.l++];
    if (len > length - 1)
      len = length - 1;
    var o2 = "";
    while (o2.length < len)
      o2 += String.fromCharCode(blob[blob.l++]);
    return o2;
  }
  __name(parse_SHEETNAMELP, "parse_SHEETNAMELP");
  function parse_SHEETINFOQP(blob, length, opts) {
    if (!opts.qpro || length < 21)
      return;
    var id = blob.read_shift(1);
    blob.l += 17;
    blob.l += 1;
    blob.l += 2;
    var nm = blob.read_shift(length - 21, "cstr");
    return [id, nm];
  }
  __name(parse_SHEETINFOQP, "parse_SHEETINFOQP");
  function parse_XFORMAT(blob, length) {
    var o2 = {}, tgt = blob.l + length;
    while (blob.l < tgt) {
      var dt2 = blob.read_shift(2);
      if (dt2 == 14e3) {
        o2[dt2] = [0, ""];
        o2[dt2][0] = blob.read_shift(2);
        while (blob[blob.l]) {
          o2[dt2][1] += String.fromCharCode(blob[blob.l]);
          blob.l++;
        }
        blob.l++;
      }
    }
    return o2;
  }
  __name(parse_XFORMAT, "parse_XFORMAT");
  function write_XFORMAT_SHEETNAME(name, wsidx) {
    var out = new_buf(5 + name.length);
    out.write_shift(2, 14e3);
    out.write_shift(2, wsidx);
    for (var i2 = 0; i2 < name.length; ++i2) {
      var cc = name.charCodeAt(i2);
      out[out.l++] = cc > 127 ? 95 : cc;
    }
    out[out.l++] = 0;
    return out;
  }
  __name(write_XFORMAT_SHEETNAME, "write_XFORMAT_SHEETNAME");
  var WK1Enum = {
    /*::[*/
    0: { n: "BOF", f: parseuint16 },
    /*::[*/
    1: { n: "EOF" },
    /*::[*/
    2: { n: "CALCMODE" },
    /*::[*/
    3: { n: "CALCORDER" },
    /*::[*/
    4: { n: "SPLIT" },
    /*::[*/
    5: { n: "SYNC" },
    /*::[*/
    6: { n: "RANGE", f: parse_RANGE },
    /*::[*/
    7: { n: "WINDOW1" },
    /*::[*/
    8: { n: "COLW1" },
    /*::[*/
    9: { n: "WINTWO" },
    /*::[*/
    10: { n: "COLW2" },
    /*::[*/
    11: { n: "NAME" },
    /*::[*/
    12: { n: "BLANK" },
    /*::[*/
    13: { n: "INTEGER", f: parse_INTEGER },
    /*::[*/
    14: { n: "NUMBER", f: parse_NUMBER },
    /*::[*/
    15: { n: "LABEL", f: parse_LABEL },
    /*::[*/
    16: { n: "FORMULA", f: parse_FORMULA },
    /*::[*/
    24: { n: "TABLE" },
    /*::[*/
    25: { n: "ORANGE" },
    /*::[*/
    26: { n: "PRANGE" },
    /*::[*/
    27: { n: "SRANGE" },
    /*::[*/
    28: { n: "FRANGE" },
    /*::[*/
    29: { n: "KRANGE1" },
    /*::[*/
    32: { n: "HRANGE" },
    /*::[*/
    35: { n: "KRANGE2" },
    /*::[*/
    36: { n: "PROTEC" },
    /*::[*/
    37: { n: "FOOTER" },
    /*::[*/
    38: { n: "HEADER" },
    /*::[*/
    39: { n: "SETUP" },
    /*::[*/
    40: { n: "MARGINS" },
    /*::[*/
    41: { n: "LABELFMT" },
    /*::[*/
    42: { n: "TITLES" },
    /*::[*/
    43: { n: "SHEETJS" },
    /*::[*/
    45: { n: "GRAPH" },
    /*::[*/
    46: { n: "NGRAPH" },
    /*::[*/
    47: { n: "CALCCOUNT" },
    /*::[*/
    48: { n: "UNFORMATTED" },
    /*::[*/
    49: { n: "CURSORW12" },
    /*::[*/
    50: { n: "WINDOW" },
    /*::[*/
    51: { n: "STRING", f: parse_LABEL },
    /*::[*/
    55: { n: "PASSWORD" },
    /*::[*/
    56: { n: "LOCKED" },
    /*::[*/
    60: { n: "QUERY" },
    /*::[*/
    61: { n: "QUERYNAME" },
    /*::[*/
    62: { n: "PRINT" },
    /*::[*/
    63: { n: "PRINTNAME" },
    /*::[*/
    64: { n: "GRAPH2" },
    /*::[*/
    65: { n: "GRAPHNAME" },
    /*::[*/
    66: { n: "ZOOM" },
    /*::[*/
    67: { n: "SYMSPLIT" },
    /*::[*/
    68: { n: "NSROWS" },
    /*::[*/
    69: { n: "NSCOLS" },
    /*::[*/
    70: { n: "RULER" },
    /*::[*/
    71: { n: "NNAME" },
    /*::[*/
    72: { n: "ACOMM" },
    /*::[*/
    73: { n: "AMACRO" },
    /*::[*/
    74: { n: "PARSE" },
    /*::[*/
    102: { n: "PRANGES??" },
    /*::[*/
    103: { n: "RRANGES??" },
    /*::[*/
    104: { n: "FNAME??" },
    /*::[*/
    105: { n: "MRANGES??" },
    /*::[*/
    204: { n: "SHEETNAMECS", f: parse_SHEETNAMECS },
    /*::[*/
    222: { n: "SHEETNAMELP", f: parse_SHEETNAMELP },
    /*::[*/
    65535: { n: "" }
  };
  var WK3Enum = {
    /*::[*/
    0: { n: "BOF" },
    /*::[*/
    1: { n: "EOF" },
    /*::[*/
    2: { n: "PASSWORD" },
    /*::[*/
    3: { n: "CALCSET" },
    /*::[*/
    4: { n: "WINDOWSET" },
    /*::[*/
    5: { n: "SHEETCELLPTR" },
    /*::[*/
    6: { n: "SHEETLAYOUT" },
    /*::[*/
    7: { n: "COLUMNWIDTH" },
    /*::[*/
    8: { n: "HIDDENCOLUMN" },
    /*::[*/
    9: { n: "USERRANGE" },
    /*::[*/
    10: { n: "SYSTEMRANGE" },
    /*::[*/
    11: { n: "ZEROFORCE" },
    /*::[*/
    12: { n: "SORTKEYDIR" },
    /*::[*/
    13: { n: "FILESEAL" },
    /*::[*/
    14: { n: "DATAFILLNUMS" },
    /*::[*/
    15: { n: "PRINTMAIN" },
    /*::[*/
    16: { n: "PRINTSTRING" },
    /*::[*/
    17: { n: "GRAPHMAIN" },
    /*::[*/
    18: { n: "GRAPHSTRING" },
    /*::[*/
    19: { n: "??" },
    /*::[*/
    20: { n: "ERRCELL" },
    /*::[*/
    21: { n: "NACELL" },
    /*::[*/
    22: { n: "LABEL16", f: parse_LABEL_16 },
    /*::[*/
    23: { n: "NUMBER17", f: parse_NUMBER_17 },
    /*::[*/
    24: { n: "NUMBER18", f: parse_NUMBER_18 },
    /*::[*/
    25: { n: "FORMULA19", f: parse_FORMULA_19 },
    /*::[*/
    26: { n: "FORMULA1A" },
    /*::[*/
    27: { n: "XFORMAT", f: parse_XFORMAT },
    /*::[*/
    28: { n: "DTLABELMISC" },
    /*::[*/
    29: { n: "DTLABELCELL" },
    /*::[*/
    30: { n: "GRAPHWINDOW" },
    /*::[*/
    31: { n: "CPA" },
    /*::[*/
    32: { n: "LPLAUTO" },
    /*::[*/
    33: { n: "QUERY" },
    /*::[*/
    34: { n: "HIDDENSHEET" },
    /*::[*/
    35: { n: "??" },
    /*::[*/
    37: { n: "NUMBER25", f: parse_NUMBER_25 },
    /*::[*/
    38: { n: "??" },
    /*::[*/
    39: { n: "NUMBER27", f: parse_NUMBER_27 },
    /*::[*/
    40: { n: "FORMULA28", f: parse_FORMULA_28 },
    /*::[*/
    142: { n: "??" },
    /*::[*/
    147: { n: "??" },
    /*::[*/
    150: { n: "??" },
    /*::[*/
    151: { n: "??" },
    /*::[*/
    152: { n: "??" },
    /*::[*/
    153: { n: "??" },
    /*::[*/
    154: { n: "??" },
    /*::[*/
    155: { n: "??" },
    /*::[*/
    156: { n: "??" },
    /*::[*/
    163: { n: "??" },
    /*::[*/
    174: { n: "??" },
    /*::[*/
    175: { n: "??" },
    /*::[*/
    176: { n: "??" },
    /*::[*/
    177: { n: "??" },
    /*::[*/
    184: { n: "??" },
    /*::[*/
    185: { n: "??" },
    /*::[*/
    186: { n: "??" },
    /*::[*/
    187: { n: "??" },
    /*::[*/
    188: { n: "??" },
    /*::[*/
    195: { n: "??" },
    /*::[*/
    201: { n: "??" },
    /*::[*/
    204: { n: "SHEETNAMECS", f: parse_SHEETNAMECS },
    /*::[*/
    205: { n: "??" },
    /*::[*/
    206: { n: "??" },
    /*::[*/
    207: { n: "??" },
    /*::[*/
    208: { n: "??" },
    /*::[*/
    256: { n: "??" },
    /*::[*/
    259: { n: "??" },
    /*::[*/
    260: { n: "??" },
    /*::[*/
    261: { n: "??" },
    /*::[*/
    262: { n: "??" },
    /*::[*/
    263: { n: "??" },
    /*::[*/
    265: { n: "??" },
    /*::[*/
    266: { n: "??" },
    /*::[*/
    267: { n: "??" },
    /*::[*/
    268: { n: "??" },
    /*::[*/
    270: { n: "??" },
    /*::[*/
    271: { n: "??" },
    /*::[*/
    384: { n: "??" },
    /*::[*/
    389: { n: "??" },
    /*::[*/
    390: { n: "??" },
    /*::[*/
    393: { n: "??" },
    /*::[*/
    396: { n: "??" },
    /*::[*/
    512: { n: "??" },
    /*::[*/
    514: { n: "??" },
    /*::[*/
    513: { n: "??" },
    /*::[*/
    516: { n: "??" },
    /*::[*/
    517: { n: "??" },
    /*::[*/
    640: { n: "??" },
    /*::[*/
    641: { n: "??" },
    /*::[*/
    642: { n: "??" },
    /*::[*/
    643: { n: "??" },
    /*::[*/
    644: { n: "??" },
    /*::[*/
    645: { n: "??" },
    /*::[*/
    646: { n: "??" },
    /*::[*/
    647: { n: "??" },
    /*::[*/
    648: { n: "??" },
    /*::[*/
    658: { n: "??" },
    /*::[*/
    659: { n: "??" },
    /*::[*/
    660: { n: "??" },
    /*::[*/
    661: { n: "??" },
    /*::[*/
    662: { n: "??" },
    /*::[*/
    665: { n: "??" },
    /*::[*/
    666: { n: "??" },
    /*::[*/
    768: { n: "??" },
    /*::[*/
    772: { n: "??" },
    /*::[*/
    1537: { n: "SHEETINFOQP", f: parse_SHEETINFOQP },
    /*::[*/
    1600: { n: "??" },
    /*::[*/
    1602: { n: "??" },
    /*::[*/
    1793: { n: "??" },
    /*::[*/
    1794: { n: "??" },
    /*::[*/
    1795: { n: "??" },
    /*::[*/
    1796: { n: "??" },
    /*::[*/
    1920: { n: "??" },
    /*::[*/
    2048: { n: "??" },
    /*::[*/
    2049: { n: "??" },
    /*::[*/
    2052: { n: "??" },
    /*::[*/
    2688: { n: "??" },
    /*::[*/
    10998: { n: "??" },
    /*::[*/
    12849: { n: "??" },
    /*::[*/
    28233: { n: "??" },
    /*::[*/
    28484: { n: "??" },
    /*::[*/
    65535: { n: "" }
  };
  return {
    sheet_to_wk1,
    book_to_wk3,
    to_workbook: lotus_to_workbook
  };
}();
var straywsregex = /^\s|\s$|[\t\n\r]/;
function write_sst_xml(sst, opts) {
  if (!opts.bookSST)
    return "";
  var o2 = [XML_HEADER];
  o2[o2.length] = writextag("sst", null, {
    xmlns: XMLNS_main[0],
    count: sst.Count,
    uniqueCount: sst.Unique
  });
  for (var i2 = 0; i2 != sst.length; ++i2) {
    if (sst[i2] == null)
      continue;
    var s2 = sst[i2];
    var sitag = "<si>";
    if (s2.r)
      sitag += s2.r;
    else {
      sitag += "<t";
      if (!s2.t)
        s2.t = "";
      if (s2.t.match(straywsregex))
        sitag += ' xml:space="preserve"';
      sitag += ">" + escapexml(s2.t) + "</t>";
    }
    sitag += "</si>";
    o2[o2.length] = sitag;
  }
  if (o2.length > 2) {
    o2[o2.length] = "</sst>";
    o2[1] = o2[1].replace("/>", ">");
  }
  return o2.join("");
}
__name(write_sst_xml, "write_sst_xml");
function parse_BrtBeginSst(data) {
  return [data.read_shift(4), data.read_shift(4)];
}
__name(parse_BrtBeginSst, "parse_BrtBeginSst");
function write_BrtBeginSst(sst, o2) {
  if (!o2)
    o2 = new_buf(8);
  o2.write_shift(4, sst.Count);
  o2.write_shift(4, sst.Unique);
  return o2;
}
__name(write_BrtBeginSst, "write_BrtBeginSst");
var write_BrtSSTItem = write_RichStr;
function write_sst_bin(sst) {
  var ba = buf_array();
  write_record(ba, 159, write_BrtBeginSst(sst));
  for (var i2 = 0; i2 < sst.length; ++i2)
    write_record(ba, 19, write_BrtSSTItem(sst[i2]));
  write_record(
    ba,
    160
    /* BrtEndSst */
  );
  return ba.end();
}
__name(write_sst_bin, "write_sst_bin");
function _JS2ANSI(str) {
  var o2 = [], oo = str.split("");
  for (var i2 = 0; i2 < oo.length; ++i2)
    o2[i2] = oo[i2].charCodeAt(0);
  return o2;
}
__name(_JS2ANSI, "_JS2ANSI");
function crypto_CreatePasswordVerifier_Method1(Password) {
  var Verifier = 0, PasswordArray;
  var PasswordDecoded = _JS2ANSI(Password);
  var len = PasswordDecoded.length + 1, i2, PasswordByte;
  var Intermediate1, Intermediate2, Intermediate3;
  PasswordArray = new_raw_buf(len);
  PasswordArray[0] = PasswordDecoded.length;
  for (i2 = 1; i2 != len; ++i2)
    PasswordArray[i2] = PasswordDecoded[i2 - 1];
  for (i2 = len - 1; i2 >= 0; --i2) {
    PasswordByte = PasswordArray[i2];
    Intermediate1 = (Verifier & 16384) === 0 ? 0 : 1;
    Intermediate2 = Verifier << 1 & 32767;
    Intermediate3 = Intermediate1 | Intermediate2;
    Verifier = Intermediate3 ^ PasswordByte;
  }
  return Verifier ^ 52811;
}
__name(crypto_CreatePasswordVerifier_Method1, "crypto_CreatePasswordVerifier_Method1");
var RTF = /* @__PURE__ */ function() {
  function rtf_to_sheet(d2, opts) {
    switch (opts.type) {
      case "base64":
        return rtf_to_sheet_str(Base64_decode(d2), opts);
      case "binary":
        return rtf_to_sheet_str(d2, opts);
      case "buffer":
        return rtf_to_sheet_str(has_buf && Buffer.isBuffer(d2) ? d2.toString("binary") : a2s(d2), opts);
      case "array":
        return rtf_to_sheet_str(cc2str(d2), opts);
    }
    throw new Error("Unrecognized type " + opts.type);
  }
  __name(rtf_to_sheet, "rtf_to_sheet");
  function rtf_to_sheet_str(str, opts) {
    var o2 = opts || {};
    var ws = o2.dense ? [] : {};
    var rows = str.match(/\\trowd.*?\\row\b/g);
    if (!rows.length)
      throw new Error("RTF missing table");
    var range = { s: { c: 0, r: 0 }, e: { c: 0, r: rows.length - 1 } };
    rows.forEach(function(rowtf, R2) {
      if (Array.isArray(ws))
        ws[R2] = [];
      var rtfre = /\\\w+\b/g;
      var last_index = 0;
      var res;
      var C2 = -1;
      while (res = rtfre.exec(rowtf)) {
        switch (res[0]) {
          case "\\cell":
            var data = rowtf.slice(last_index, rtfre.lastIndex - res[0].length);
            if (data[0] == " ")
              data = data.slice(1);
            ++C2;
            if (data.length) {
              var cell = { v: data, t: "s" };
              if (Array.isArray(ws))
                ws[R2][C2] = cell;
              else
                ws[encode_cell({ r: R2, c: C2 })] = cell;
            }
            break;
        }
        last_index = rtfre.lastIndex;
      }
      if (C2 > range.e.c)
        range.e.c = C2;
    });
    ws["!ref"] = encode_range(range);
    return ws;
  }
  __name(rtf_to_sheet_str, "rtf_to_sheet_str");
  function rtf_to_workbook(d2, opts) {
    return sheet_to_workbook(rtf_to_sheet(d2, opts), opts);
  }
  __name(rtf_to_workbook, "rtf_to_workbook");
  function sheet_to_rtf(ws) {
    var o2 = ["{\\rtf1\\ansi"];
    var r = safe_decode_range(ws["!ref"]), cell;
    var dense = Array.isArray(ws);
    for (var R2 = r.s.r; R2 <= r.e.r; ++R2) {
      o2.push("\\trowd\\trautofit1");
      for (var C2 = r.s.c; C2 <= r.e.c; ++C2)
        o2.push("\\cellx" + (C2 + 1));
      o2.push("\\pard\\intbl");
      for (C2 = r.s.c; C2 <= r.e.c; ++C2) {
        var coord = encode_cell({ r: R2, c: C2 });
        cell = dense ? (ws[R2] || [])[C2] : ws[coord];
        if (!cell || cell.v == null && (!cell.f || cell.F))
          continue;
        o2.push(" " + (cell.w || (format_cell(cell), cell.w)));
        o2.push("\\cell");
      }
      o2.push("\\pard\\intbl\\row");
    }
    return o2.join("") + "}";
  }
  __name(sheet_to_rtf, "sheet_to_rtf");
  return {
    to_workbook: rtf_to_workbook,
    to_sheet: rtf_to_sheet,
    from_sheet: sheet_to_rtf
  };
}();
function rgb2Hex(rgb) {
  for (var i2 = 0, o2 = 1; i2 != 3; ++i2)
    o2 = o2 * 256 + (rgb[i2] > 255 ? 255 : rgb[i2] < 0 ? 0 : rgb[i2]);
  return o2.toString(16).toUpperCase().slice(1);
}
__name(rgb2Hex, "rgb2Hex");
var DEF_MDW = 6, MDW = DEF_MDW;
function width2px(width) {
  return Math.floor((width + Math.round(128 / MDW) / 256) * MDW);
}
__name(width2px, "width2px");
function px2char(px) {
  return Math.floor((px - 5) / MDW * 100 + 0.5) / 100;
}
__name(px2char, "px2char");
function char2width(chr) {
  return Math.round((chr * MDW + 5) / MDW * 256) / 256;
}
__name(char2width, "char2width");
function process_col(coll) {
  if (coll.width) {
    coll.wpx = width2px(coll.width);
    coll.wch = px2char(coll.wpx);
    coll.MDW = MDW;
  } else if (coll.wpx) {
    coll.wch = px2char(coll.wpx);
    coll.width = char2width(coll.wch);
    coll.MDW = MDW;
  } else if (typeof coll.wch == "number") {
    coll.width = char2width(coll.wch);
    coll.wpx = width2px(coll.width);
    coll.MDW = MDW;
  }
  if (coll.customWidth)
    delete coll.customWidth;
}
__name(process_col, "process_col");
var DEF_PPI = 96, PPI = DEF_PPI;
function px2pt(px) {
  return px * 96 / PPI;
}
__name(px2pt, "px2pt");
function pt2px(pt2) {
  return pt2 * PPI / 96;
}
__name(pt2px, "pt2px");
function write_numFmts(NF) {
  var o2 = ["<numFmts>"];
  [[5, 8], [23, 26], [41, 44], [
    /*63*/
    50,
    /*66],[164,*/
    392
  ]].forEach(function(r) {
    for (var i2 = r[0]; i2 <= r[1]; ++i2)
      if (NF[i2] != null)
        o2[o2.length] = writextag("numFmt", null, { numFmtId: i2, formatCode: escapexml(NF[i2]) });
  });
  if (o2.length === 1)
    return "";
  o2[o2.length] = "</numFmts>";
  o2[0] = writextag("numFmts", null, { count: o2.length - 2 }).replace("/>", ">");
  return o2.join("");
}
__name(write_numFmts, "write_numFmts");
function write_cellXfs(cellXfs) {
  var o2 = [];
  o2[o2.length] = writextag("cellXfs", null);
  cellXfs.forEach(function(c2) {
    o2[o2.length] = writextag("xf", null, c2);
  });
  o2[o2.length] = "</cellXfs>";
  if (o2.length === 2)
    return "";
  o2[0] = writextag("cellXfs", null, { count: o2.length - 2 }).replace("/>", ">");
  return o2.join("");
}
__name(write_cellXfs, "write_cellXfs");
function write_sty_xml(wb, opts) {
  var o2 = [XML_HEADER, writextag("styleSheet", null, {
    "xmlns": XMLNS_main[0],
    "xmlns:vt": XMLNS.vt
  })], w2;
  if (wb.SSF && (w2 = write_numFmts(wb.SSF)) != null)
    o2[o2.length] = w2;
  o2[o2.length] = '<fonts count="1"><font><sz val="12"/><color theme="1"/><name val="Calibri"/><family val="2"/><scheme val="minor"/></font></fonts>';
  o2[o2.length] = '<fills count="2"><fill><patternFill patternType="none"/></fill><fill><patternFill patternType="gray125"/></fill></fills>';
  o2[o2.length] = '<borders count="1"><border><left/><right/><top/><bottom/><diagonal/></border></borders>';
  o2[o2.length] = '<cellStyleXfs count="1"><xf numFmtId="0" fontId="0" fillId="0" borderId="0"/></cellStyleXfs>';
  if (w2 = write_cellXfs(opts.cellXfs))
    o2[o2.length] = w2;
  o2[o2.length] = '<cellStyles count="1"><cellStyle name="Normal" xfId="0" builtinId="0"/></cellStyles>';
  o2[o2.length] = '<dxfs count="0"/>';
  o2[o2.length] = '<tableStyles count="0" defaultTableStyle="TableStyleMedium9" defaultPivotStyle="PivotStyleMedium4"/>';
  if (o2.length > 2) {
    o2[o2.length] = "</styleSheet>";
    o2[1] = o2[1].replace("/>", ">");
  }
  return o2.join("");
}
__name(write_sty_xml, "write_sty_xml");
function parse_BrtFmt(data, length) {
  var numFmtId = data.read_shift(2);
  var stFmtCode = parse_XLWideString(data);
  return [numFmtId, stFmtCode];
}
__name(parse_BrtFmt, "parse_BrtFmt");
function write_BrtFmt(i2, f2, o2) {
  if (!o2)
    o2 = new_buf(6 + 4 * f2.length);
  o2.write_shift(2, i2);
  write_XLWideString(f2, o2);
  var out = o2.length > o2.l ? o2.slice(0, o2.l) : o2;
  if (o2.l == null)
    o2.l = o2.length;
  return out;
}
__name(write_BrtFmt, "write_BrtFmt");
function parse_BrtFont(data, length, opts) {
  var out = {};
  out.sz = data.read_shift(2) / 20;
  var grbit = parse_FontFlags(data);
  if (grbit.fItalic)
    out.italic = 1;
  if (grbit.fCondense)
    out.condense = 1;
  if (grbit.fExtend)
    out.extend = 1;
  if (grbit.fShadow)
    out.shadow = 1;
  if (grbit.fOutline)
    out.outline = 1;
  if (grbit.fStrikeout)
    out.strike = 1;
  var bls = data.read_shift(2);
  if (bls === 700)
    out.bold = 1;
  switch (data.read_shift(2)) {
    case 1:
      out.vertAlign = "superscript";
      break;
    case 2:
      out.vertAlign = "subscript";
      break;
  }
  var underline = data.read_shift(1);
  if (underline != 0)
    out.underline = underline;
  var family = data.read_shift(1);
  if (family > 0)
    out.family = family;
  var bCharSet = data.read_shift(1);
  if (bCharSet > 0)
    out.charset = bCharSet;
  data.l++;
  out.color = parse_BrtColor(data);
  switch (data.read_shift(1)) {
    case 1:
      out.scheme = "major";
      break;
    case 2:
      out.scheme = "minor";
      break;
  }
  out.name = parse_XLWideString(data);
  return out;
}
__name(parse_BrtFont, "parse_BrtFont");
function write_BrtFont(font, o2) {
  if (!o2)
    o2 = new_buf(25 + 4 * 32);
  o2.write_shift(2, font.sz * 20);
  write_FontFlags(font, o2);
  o2.write_shift(2, font.bold ? 700 : 400);
  var sss = 0;
  if (font.vertAlign == "superscript")
    sss = 1;
  else if (font.vertAlign == "subscript")
    sss = 2;
  o2.write_shift(2, sss);
  o2.write_shift(1, font.underline || 0);
  o2.write_shift(1, font.family || 0);
  o2.write_shift(1, font.charset || 0);
  o2.write_shift(1, 0);
  write_BrtColor(font.color, o2);
  var scheme = 0;
  if (font.scheme == "major")
    scheme = 1;
  if (font.scheme == "minor")
    scheme = 2;
  o2.write_shift(1, scheme);
  write_XLWideString(font.name, o2);
  return o2.length > o2.l ? o2.slice(0, o2.l) : o2;
}
__name(write_BrtFont, "write_BrtFont");
var XLSBFillPTNames = [
  "none",
  "solid",
  "mediumGray",
  "darkGray",
  "lightGray",
  "darkHorizontal",
  "darkVertical",
  "darkDown",
  "darkUp",
  "darkGrid",
  "darkTrellis",
  "lightHorizontal",
  "lightVertical",
  "lightDown",
  "lightUp",
  "lightGrid",
  "lightTrellis",
  "gray125",
  "gray0625"
];
var rev_XLSBFillPTNames;
var parse_BrtFill = parsenoop;
function write_BrtFill(fill2, o2) {
  if (!o2)
    o2 = new_buf(4 * 3 + 8 * 7 + 16 * 1);
  if (!rev_XLSBFillPTNames)
    rev_XLSBFillPTNames = evert(XLSBFillPTNames);
  var fls = rev_XLSBFillPTNames[fill2.patternType];
  if (fls == null)
    fls = 40;
  o2.write_shift(4, fls);
  var j2 = 0;
  if (fls != 40) {
    write_BrtColor({ auto: 1 }, o2);
    write_BrtColor({ auto: 1 }, o2);
    for (; j2 < 12; ++j2)
      o2.write_shift(4, 0);
  } else {
    for (; j2 < 4; ++j2)
      o2.write_shift(4, 0);
    for (; j2 < 12; ++j2)
      o2.write_shift(4, 0);
  }
  return o2.length > o2.l ? o2.slice(0, o2.l) : o2;
}
__name(write_BrtFill, "write_BrtFill");
function parse_BrtXF(data, length) {
  var tgt = data.l + length;
  var ixfeParent = data.read_shift(2);
  var ifmt = data.read_shift(2);
  data.l = tgt;
  return { ixfe: ixfeParent, numFmtId: ifmt };
}
__name(parse_BrtXF, "parse_BrtXF");
function write_BrtXF(data, ixfeP, o2) {
  if (!o2)
    o2 = new_buf(16);
  o2.write_shift(2, ixfeP || 0);
  o2.write_shift(2, data.numFmtId || 0);
  o2.write_shift(2, 0);
  o2.write_shift(2, 0);
  o2.write_shift(2, 0);
  o2.write_shift(1, 0);
  o2.write_shift(1, 0);
  var flow = 0;
  o2.write_shift(1, flow);
  o2.write_shift(1, 0);
  o2.write_shift(1, 0);
  o2.write_shift(1, 0);
  return o2;
}
__name(write_BrtXF, "write_BrtXF");
function write_Blxf(data, o2) {
  if (!o2)
    o2 = new_buf(10);
  o2.write_shift(1, 0);
  o2.write_shift(1, 0);
  o2.write_shift(4, 0);
  o2.write_shift(4, 0);
  return o2;
}
__name(write_Blxf, "write_Blxf");
var parse_BrtBorder = parsenoop;
function write_BrtBorder(border, o2) {
  if (!o2)
    o2 = new_buf(51);
  o2.write_shift(1, 0);
  write_Blxf(null, o2);
  write_Blxf(null, o2);
  write_Blxf(null, o2);
  write_Blxf(null, o2);
  write_Blxf(null, o2);
  return o2.length > o2.l ? o2.slice(0, o2.l) : o2;
}
__name(write_BrtBorder, "write_BrtBorder");
function write_BrtStyle(style, o2) {
  if (!o2)
    o2 = new_buf(12 + 4 * 10);
  o2.write_shift(4, style.xfId);
  o2.write_shift(2, 1);
  o2.write_shift(1, +style.builtinId);
  o2.write_shift(1, 0);
  write_XLNullableWideString(style.name || "", o2);
  return o2.length > o2.l ? o2.slice(0, o2.l) : o2;
}
__name(write_BrtStyle, "write_BrtStyle");
function write_BrtBeginTableStyles(cnt, defTableStyle, defPivotStyle) {
  var o2 = new_buf(4 + 256 * 2 * 4);
  o2.write_shift(4, cnt);
  write_XLNullableWideString(defTableStyle, o2);
  write_XLNullableWideString(defPivotStyle, o2);
  return o2.length > o2.l ? o2.slice(0, o2.l) : o2;
}
__name(write_BrtBeginTableStyles, "write_BrtBeginTableStyles");
function write_FMTS_bin(ba, NF) {
  if (!NF)
    return;
  var cnt = 0;
  [[5, 8], [23, 26], [41, 44], [
    /*63*/
    50,
    /*66],[164,*/
    392
  ]].forEach(function(r) {
    for (var i2 = r[0]; i2 <= r[1]; ++i2)
      if (NF[i2] != null)
        ++cnt;
  });
  if (cnt == 0)
    return;
  write_record(ba, 615, write_UInt32LE(cnt));
  [[5, 8], [23, 26], [41, 44], [
    /*63*/
    50,
    /*66],[164,*/
    392
  ]].forEach(function(r) {
    for (var i2 = r[0]; i2 <= r[1]; ++i2)
      if (NF[i2] != null)
        write_record(ba, 44, write_BrtFmt(i2, NF[i2]));
  });
  write_record(
    ba,
    616
    /* BrtEndFmts */
  );
}
__name(write_FMTS_bin, "write_FMTS_bin");
function write_FONTS_bin(ba) {
  var cnt = 1;
  write_record(ba, 611, write_UInt32LE(cnt));
  write_record(ba, 43, write_BrtFont({
    sz: 12,
    color: { theme: 1 },
    name: "Calibri",
    family: 2,
    scheme: "minor"
  }));
  write_record(
    ba,
    612
    /* BrtEndFonts */
  );
}
__name(write_FONTS_bin, "write_FONTS_bin");
function write_FILLS_bin(ba) {
  var cnt = 2;
  write_record(ba, 603, write_UInt32LE(cnt));
  write_record(ba, 45, write_BrtFill({ patternType: "none" }));
  write_record(ba, 45, write_BrtFill({ patternType: "gray125" }));
  write_record(
    ba,
    604
    /* BrtEndFills */
  );
}
__name(write_FILLS_bin, "write_FILLS_bin");
function write_BORDERS_bin(ba) {
  var cnt = 1;
  write_record(ba, 613, write_UInt32LE(cnt));
  write_record(ba, 46, write_BrtBorder());
  write_record(
    ba,
    614
    /* BrtEndBorders */
  );
}
__name(write_BORDERS_bin, "write_BORDERS_bin");
function write_CELLSTYLEXFS_bin(ba) {
  var cnt = 1;
  write_record(ba, 626, write_UInt32LE(cnt));
  write_record(ba, 47, write_BrtXF({
    numFmtId: 0,
    fontId: 0,
    fillId: 0,
    borderId: 0
  }, 65535));
  write_record(
    ba,
    627
    /* BrtEndCellStyleXFs */
  );
}
__name(write_CELLSTYLEXFS_bin, "write_CELLSTYLEXFS_bin");
function write_CELLXFS_bin(ba, data) {
  write_record(ba, 617, write_UInt32LE(data.length));
  data.forEach(function(c2) {
    write_record(ba, 47, write_BrtXF(c2, 0));
  });
  write_record(
    ba,
    618
    /* BrtEndCellXFs */
  );
}
__name(write_CELLXFS_bin, "write_CELLXFS_bin");
function write_STYLES_bin(ba) {
  var cnt = 1;
  write_record(ba, 619, write_UInt32LE(cnt));
  write_record(ba, 48, write_BrtStyle({
    xfId: 0,
    builtinId: 0,
    name: "Normal"
  }));
  write_record(
    ba,
    620
    /* BrtEndStyles */
  );
}
__name(write_STYLES_bin, "write_STYLES_bin");
function write_DXFS_bin(ba) {
  var cnt = 0;
  write_record(ba, 505, write_UInt32LE(cnt));
  write_record(
    ba,
    506
    /* BrtEndDXFs */
  );
}
__name(write_DXFS_bin, "write_DXFS_bin");
function write_TABLESTYLES_bin(ba) {
  var cnt = 0;
  write_record(ba, 508, write_BrtBeginTableStyles(cnt, "TableStyleMedium9", "PivotStyleMedium4"));
  write_record(
    ba,
    509
    /* BrtEndTableStyles */
  );
}
__name(write_TABLESTYLES_bin, "write_TABLESTYLES_bin");
function write_sty_bin(wb, opts) {
  var ba = buf_array();
  write_record(
    ba,
    278
    /* BrtBeginStyleSheet */
  );
  write_FMTS_bin(ba, wb.SSF);
  write_FONTS_bin(ba);
  write_FILLS_bin(ba);
  write_BORDERS_bin(ba);
  write_CELLSTYLEXFS_bin(ba);
  write_CELLXFS_bin(ba, opts.cellXfs);
  write_STYLES_bin(ba);
  write_DXFS_bin(ba);
  write_TABLESTYLES_bin(ba);
  write_record(
    ba,
    279
    /* BrtEndStyleSheet */
  );
  return ba.end();
}
__name(write_sty_bin, "write_sty_bin");
function write_theme(Themes, opts) {
  if (opts && opts.themeXLSX)
    return opts.themeXLSX;
  if (Themes && typeof Themes.raw == "string")
    return Themes.raw;
  var o2 = [XML_HEADER];
  o2[o2.length] = '<a:theme xmlns:a="http://schemas.openxmlformats.org/drawingml/2006/main" name="Office Theme">';
  o2[o2.length] = "<a:themeElements>";
  o2[o2.length] = '<a:clrScheme name="Office">';
  o2[o2.length] = '<a:dk1><a:sysClr val="windowText" lastClr="000000"/></a:dk1>';
  o2[o2.length] = '<a:lt1><a:sysClr val="window" lastClr="FFFFFF"/></a:lt1>';
  o2[o2.length] = '<a:dk2><a:srgbClr val="1F497D"/></a:dk2>';
  o2[o2.length] = '<a:lt2><a:srgbClr val="EEECE1"/></a:lt2>';
  o2[o2.length] = '<a:accent1><a:srgbClr val="4F81BD"/></a:accent1>';
  o2[o2.length] = '<a:accent2><a:srgbClr val="C0504D"/></a:accent2>';
  o2[o2.length] = '<a:accent3><a:srgbClr val="9BBB59"/></a:accent3>';
  o2[o2.length] = '<a:accent4><a:srgbClr val="8064A2"/></a:accent4>';
  o2[o2.length] = '<a:accent5><a:srgbClr val="4BACC6"/></a:accent5>';
  o2[o2.length] = '<a:accent6><a:srgbClr val="F79646"/></a:accent6>';
  o2[o2.length] = '<a:hlink><a:srgbClr val="0000FF"/></a:hlink>';
  o2[o2.length] = '<a:folHlink><a:srgbClr val="800080"/></a:folHlink>';
  o2[o2.length] = "</a:clrScheme>";
  o2[o2.length] = '<a:fontScheme name="Office">';
  o2[o2.length] = "<a:majorFont>";
  o2[o2.length] = '<a:latin typeface="Cambria"/>';
  o2[o2.length] = '<a:ea typeface=""/>';
  o2[o2.length] = '<a:cs typeface=""/>';
  o2[o2.length] = '<a:font script="Jpan" typeface=" "/>';
  o2[o2.length] = '<a:font script="Hang" typeface=" "/>';
  o2[o2.length] = '<a:font script="Hans" typeface=""/>';
  o2[o2.length] = '<a:font script="Hant" typeface=""/>';
  o2[o2.length] = '<a:font script="Arab" typeface="Times New Roman"/>';
  o2[o2.length] = '<a:font script="Hebr" typeface="Times New Roman"/>';
  o2[o2.length] = '<a:font script="Thai" typeface="Tahoma"/>';
  o2[o2.length] = '<a:font script="Ethi" typeface="Nyala"/>';
  o2[o2.length] = '<a:font script="Beng" typeface="Vrinda"/>';
  o2[o2.length] = '<a:font script="Gujr" typeface="Shruti"/>';
  o2[o2.length] = '<a:font script="Khmr" typeface="MoolBoran"/>';
  o2[o2.length] = '<a:font script="Knda" typeface="Tunga"/>';
  o2[o2.length] = '<a:font script="Guru" typeface="Raavi"/>';
  o2[o2.length] = '<a:font script="Cans" typeface="Euphemia"/>';
  o2[o2.length] = '<a:font script="Cher" typeface="Plantagenet Cherokee"/>';
  o2[o2.length] = '<a:font script="Yiii" typeface="Microsoft Yi Baiti"/>';
  o2[o2.length] = '<a:font script="Tibt" typeface="Microsoft Himalaya"/>';
  o2[o2.length] = '<a:font script="Thaa" typeface="MV Boli"/>';
  o2[o2.length] = '<a:font script="Deva" typeface="Mangal"/>';
  o2[o2.length] = '<a:font script="Telu" typeface="Gautami"/>';
  o2[o2.length] = '<a:font script="Taml" typeface="Latha"/>';
  o2[o2.length] = '<a:font script="Syrc" typeface="Estrangelo Edessa"/>';
  o2[o2.length] = '<a:font script="Orya" typeface="Kalinga"/>';
  o2[o2.length] = '<a:font script="Mlym" typeface="Kartika"/>';
  o2[o2.length] = '<a:font script="Laoo" typeface="DokChampa"/>';
  o2[o2.length] = '<a:font script="Sinh" typeface="Iskoola Pota"/>';
  o2[o2.length] = '<a:font script="Mong" typeface="Mongolian Baiti"/>';
  o2[o2.length] = '<a:font script="Viet" typeface="Times New Roman"/>';
  o2[o2.length] = '<a:font script="Uigh" typeface="Microsoft Uighur"/>';
  o2[o2.length] = '<a:font script="Geor" typeface="Sylfaen"/>';
  o2[o2.length] = "</a:majorFont>";
  o2[o2.length] = "<a:minorFont>";
  o2[o2.length] = '<a:latin typeface="Calibri"/>';
  o2[o2.length] = '<a:ea typeface=""/>';
  o2[o2.length] = '<a:cs typeface=""/>';
  o2[o2.length] = '<a:font script="Jpan" typeface=" "/>';
  o2[o2.length] = '<a:font script="Hang" typeface=" "/>';
  o2[o2.length] = '<a:font script="Hans" typeface=""/>';
  o2[o2.length] = '<a:font script="Hant" typeface=""/>';
  o2[o2.length] = '<a:font script="Arab" typeface="Arial"/>';
  o2[o2.length] = '<a:font script="Hebr" typeface="Arial"/>';
  o2[o2.length] = '<a:font script="Thai" typeface="Tahoma"/>';
  o2[o2.length] = '<a:font script="Ethi" typeface="Nyala"/>';
  o2[o2.length] = '<a:font script="Beng" typeface="Vrinda"/>';
  o2[o2.length] = '<a:font script="Gujr" typeface="Shruti"/>';
  o2[o2.length] = '<a:font script="Khmr" typeface="DaunPenh"/>';
  o2[o2.length] = '<a:font script="Knda" typeface="Tunga"/>';
  o2[o2.length] = '<a:font script="Guru" typeface="Raavi"/>';
  o2[o2.length] = '<a:font script="Cans" typeface="Euphemia"/>';
  o2[o2.length] = '<a:font script="Cher" typeface="Plantagenet Cherokee"/>';
  o2[o2.length] = '<a:font script="Yiii" typeface="Microsoft Yi Baiti"/>';
  o2[o2.length] = '<a:font script="Tibt" typeface="Microsoft Himalaya"/>';
  o2[o2.length] = '<a:font script="Thaa" typeface="MV Boli"/>';
  o2[o2.length] = '<a:font script="Deva" typeface="Mangal"/>';
  o2[o2.length] = '<a:font script="Telu" typeface="Gautami"/>';
  o2[o2.length] = '<a:font script="Taml" typeface="Latha"/>';
  o2[o2.length] = '<a:font script="Syrc" typeface="Estrangelo Edessa"/>';
  o2[o2.length] = '<a:font script="Orya" typeface="Kalinga"/>';
  o2[o2.length] = '<a:font script="Mlym" typeface="Kartika"/>';
  o2[o2.length] = '<a:font script="Laoo" typeface="DokChampa"/>';
  o2[o2.length] = '<a:font script="Sinh" typeface="Iskoola Pota"/>';
  o2[o2.length] = '<a:font script="Mong" typeface="Mongolian Baiti"/>';
  o2[o2.length] = '<a:font script="Viet" typeface="Arial"/>';
  o2[o2.length] = '<a:font script="Uigh" typeface="Microsoft Uighur"/>';
  o2[o2.length] = '<a:font script="Geor" typeface="Sylfaen"/>';
  o2[o2.length] = "</a:minorFont>";
  o2[o2.length] = "</a:fontScheme>";
  o2[o2.length] = '<a:fmtScheme name="Office">';
  o2[o2.length] = "<a:fillStyleLst>";
  o2[o2.length] = '<a:solidFill><a:schemeClr val="phClr"/></a:solidFill>';
  o2[o2.length] = '<a:gradFill rotWithShape="1">';
  o2[o2.length] = "<a:gsLst>";
  o2[o2.length] = '<a:gs pos="0"><a:schemeClr val="phClr"><a:tint val="50000"/><a:satMod val="300000"/></a:schemeClr></a:gs>';
  o2[o2.length] = '<a:gs pos="35000"><a:schemeClr val="phClr"><a:tint val="37000"/><a:satMod val="300000"/></a:schemeClr></a:gs>';
  o2[o2.length] = '<a:gs pos="100000"><a:schemeClr val="phClr"><a:tint val="15000"/><a:satMod val="350000"/></a:schemeClr></a:gs>';
  o2[o2.length] = "</a:gsLst>";
  o2[o2.length] = '<a:lin ang="16200000" scaled="1"/>';
  o2[o2.length] = "</a:gradFill>";
  o2[o2.length] = '<a:gradFill rotWithShape="1">';
  o2[o2.length] = "<a:gsLst>";
  o2[o2.length] = '<a:gs pos="0"><a:schemeClr val="phClr"><a:tint val="100000"/><a:shade val="100000"/><a:satMod val="130000"/></a:schemeClr></a:gs>';
  o2[o2.length] = '<a:gs pos="100000"><a:schemeClr val="phClr"><a:tint val="50000"/><a:shade val="100000"/><a:satMod val="350000"/></a:schemeClr></a:gs>';
  o2[o2.length] = "</a:gsLst>";
  o2[o2.length] = '<a:lin ang="16200000" scaled="0"/>';
  o2[o2.length] = "</a:gradFill>";
  o2[o2.length] = "</a:fillStyleLst>";
  o2[o2.length] = "<a:lnStyleLst>";
  o2[o2.length] = '<a:ln w="9525" cap="flat" cmpd="sng" algn="ctr"><a:solidFill><a:schemeClr val="phClr"><a:shade val="95000"/><a:satMod val="105000"/></a:schemeClr></a:solidFill><a:prstDash val="solid"/></a:ln>';
  o2[o2.length] = '<a:ln w="25400" cap="flat" cmpd="sng" algn="ctr"><a:solidFill><a:schemeClr val="phClr"/></a:solidFill><a:prstDash val="solid"/></a:ln>';
  o2[o2.length] = '<a:ln w="38100" cap="flat" cmpd="sng" algn="ctr"><a:solidFill><a:schemeClr val="phClr"/></a:solidFill><a:prstDash val="solid"/></a:ln>';
  o2[o2.length] = "</a:lnStyleLst>";
  o2[o2.length] = "<a:effectStyleLst>";
  o2[o2.length] = "<a:effectStyle>";
  o2[o2.length] = "<a:effectLst>";
  o2[o2.length] = '<a:outerShdw blurRad="40000" dist="20000" dir="5400000" rotWithShape="0"><a:srgbClr val="000000"><a:alpha val="38000"/></a:srgbClr></a:outerShdw>';
  o2[o2.length] = "</a:effectLst>";
  o2[o2.length] = "</a:effectStyle>";
  o2[o2.length] = "<a:effectStyle>";
  o2[o2.length] = "<a:effectLst>";
  o2[o2.length] = '<a:outerShdw blurRad="40000" dist="23000" dir="5400000" rotWithShape="0"><a:srgbClr val="000000"><a:alpha val="35000"/></a:srgbClr></a:outerShdw>';
  o2[o2.length] = "</a:effectLst>";
  o2[o2.length] = "</a:effectStyle>";
  o2[o2.length] = "<a:effectStyle>";
  o2[o2.length] = "<a:effectLst>";
  o2[o2.length] = '<a:outerShdw blurRad="40000" dist="23000" dir="5400000" rotWithShape="0"><a:srgbClr val="000000"><a:alpha val="35000"/></a:srgbClr></a:outerShdw>';
  o2[o2.length] = "</a:effectLst>";
  o2[o2.length] = '<a:scene3d><a:camera prst="orthographicFront"><a:rot lat="0" lon="0" rev="0"/></a:camera><a:lightRig rig="threePt" dir="t"><a:rot lat="0" lon="0" rev="1200000"/></a:lightRig></a:scene3d>';
  o2[o2.length] = '<a:sp3d><a:bevelT w="63500" h="25400"/></a:sp3d>';
  o2[o2.length] = "</a:effectStyle>";
  o2[o2.length] = "</a:effectStyleLst>";
  o2[o2.length] = "<a:bgFillStyleLst>";
  o2[o2.length] = '<a:solidFill><a:schemeClr val="phClr"/></a:solidFill>';
  o2[o2.length] = '<a:gradFill rotWithShape="1">';
  o2[o2.length] = "<a:gsLst>";
  o2[o2.length] = '<a:gs pos="0"><a:schemeClr val="phClr"><a:tint val="40000"/><a:satMod val="350000"/></a:schemeClr></a:gs>';
  o2[o2.length] = '<a:gs pos="40000"><a:schemeClr val="phClr"><a:tint val="45000"/><a:shade val="99000"/><a:satMod val="350000"/></a:schemeClr></a:gs>';
  o2[o2.length] = '<a:gs pos="100000"><a:schemeClr val="phClr"><a:shade val="20000"/><a:satMod val="255000"/></a:schemeClr></a:gs>';
  o2[o2.length] = "</a:gsLst>";
  o2[o2.length] = '<a:path path="circle"><a:fillToRect l="50000" t="-80000" r="50000" b="180000"/></a:path>';
  o2[o2.length] = "</a:gradFill>";
  o2[o2.length] = '<a:gradFill rotWithShape="1">';
  o2[o2.length] = "<a:gsLst>";
  o2[o2.length] = '<a:gs pos="0"><a:schemeClr val="phClr"><a:tint val="80000"/><a:satMod val="300000"/></a:schemeClr></a:gs>';
  o2[o2.length] = '<a:gs pos="100000"><a:schemeClr val="phClr"><a:shade val="30000"/><a:satMod val="200000"/></a:schemeClr></a:gs>';
  o2[o2.length] = "</a:gsLst>";
  o2[o2.length] = '<a:path path="circle"><a:fillToRect l="50000" t="50000" r="50000" b="50000"/></a:path>';
  o2[o2.length] = "</a:gradFill>";
  o2[o2.length] = "</a:bgFillStyleLst>";
  o2[o2.length] = "</a:fmtScheme>";
  o2[o2.length] = "</a:themeElements>";
  o2[o2.length] = "<a:objectDefaults>";
  o2[o2.length] = "<a:spDef>";
  o2[o2.length] = '<a:spPr/><a:bodyPr/><a:lstStyle/><a:style><a:lnRef idx="1"><a:schemeClr val="accent1"/></a:lnRef><a:fillRef idx="3"><a:schemeClr val="accent1"/></a:fillRef><a:effectRef idx="2"><a:schemeClr val="accent1"/></a:effectRef><a:fontRef idx="minor"><a:schemeClr val="lt1"/></a:fontRef></a:style>';
  o2[o2.length] = "</a:spDef>";
  o2[o2.length] = "<a:lnDef>";
  o2[o2.length] = '<a:spPr/><a:bodyPr/><a:lstStyle/><a:style><a:lnRef idx="2"><a:schemeClr val="accent1"/></a:lnRef><a:fillRef idx="0"><a:schemeClr val="accent1"/></a:fillRef><a:effectRef idx="1"><a:schemeClr val="accent1"/></a:effectRef><a:fontRef idx="minor"><a:schemeClr val="tx1"/></a:fontRef></a:style>';
  o2[o2.length] = "</a:lnDef>";
  o2[o2.length] = "</a:objectDefaults>";
  o2[o2.length] = "<a:extraClrSchemeLst/>";
  o2[o2.length] = "</a:theme>";
  return o2.join("");
}
__name(write_theme, "write_theme");
function parse_BrtMdtinfo(data, length) {
  return {
    flags: data.read_shift(4),
    version: data.read_shift(4),
    name: parse_XLWideString(data)
  };
}
__name(parse_BrtMdtinfo, "parse_BrtMdtinfo");
function write_BrtMdtinfo(data) {
  var o2 = new_buf(12 + 2 * data.name.length);
  o2.write_shift(4, data.flags);
  o2.write_shift(4, data.version);
  write_XLWideString(data.name, o2);
  return o2.slice(0, o2.l);
}
__name(write_BrtMdtinfo, "write_BrtMdtinfo");
function parse_BrtMdb(data) {
  var out = [];
  var cnt = data.read_shift(4);
  while (cnt-- > 0)
    out.push([data.read_shift(4), data.read_shift(4)]);
  return out;
}
__name(parse_BrtMdb, "parse_BrtMdb");
function write_BrtMdb(mdb) {
  var o2 = new_buf(4 + 8 * mdb.length);
  o2.write_shift(4, mdb.length);
  for (var i2 = 0; i2 < mdb.length; ++i2) {
    o2.write_shift(4, mdb[i2][0]);
    o2.write_shift(4, mdb[i2][1]);
  }
  return o2;
}
__name(write_BrtMdb, "write_BrtMdb");
function write_BrtBeginEsfmd(cnt, name) {
  var o2 = new_buf(8 + 2 * name.length);
  o2.write_shift(4, cnt);
  write_XLWideString(name, o2);
  return o2.slice(0, o2.l);
}
__name(write_BrtBeginEsfmd, "write_BrtBeginEsfmd");
function parse_BrtBeginEsmdb(data) {
  data.l += 4;
  return data.read_shift(4) != 0;
}
__name(parse_BrtBeginEsmdb, "parse_BrtBeginEsmdb");
function write_BrtBeginEsmdb(cnt, cm) {
  var o2 = new_buf(8);
  o2.write_shift(4, cnt);
  o2.write_shift(4, cm ? 1 : 0);
  return o2;
}
__name(write_BrtBeginEsmdb, "write_BrtBeginEsmdb");
function write_xlmeta_bin() {
  var ba = buf_array();
  write_record(ba, 332);
  write_record(ba, 334, write_UInt32LE(1));
  write_record(ba, 335, write_BrtMdtinfo({
    name: "XLDAPR",
    version: 12e4,
    flags: 3496657072
  }));
  write_record(ba, 336);
  write_record(ba, 339, write_BrtBeginEsfmd(1, "XLDAPR"));
  write_record(ba, 52);
  write_record(ba, 35, write_UInt32LE(514));
  write_record(ba, 4096, write_UInt32LE(0));
  write_record(ba, 4097, writeuint16(1));
  write_record(ba, 36);
  write_record(ba, 53);
  write_record(ba, 340);
  write_record(ba, 337, write_BrtBeginEsmdb(1, true));
  write_record(ba, 51, write_BrtMdb([[1, 0]]));
  write_record(ba, 338);
  write_record(ba, 333);
  return ba.end();
}
__name(write_xlmeta_bin, "write_xlmeta_bin");
function write_xlmeta_xml() {
  var o2 = [XML_HEADER];
  o2.push('<metadata xmlns="http://schemas.openxmlformats.org/spreadsheetml/2006/main" xmlns:xlrd="http://schemas.microsoft.com/office/spreadsheetml/2017/richdata" xmlns:xda="http://schemas.microsoft.com/office/spreadsheetml/2017/dynamicarray">\n  <metadataTypes count="1">\n    <metadataType name="XLDAPR" minSupportedVersion="120000" copy="1" pasteAll="1" pasteValues="1" merge="1" splitFirst="1" rowColShift="1" clearFormats="1" clearComments="1" assign="1" coerce="1" cellMeta="1"/>\n  </metadataTypes>\n  <futureMetadata name="XLDAPR" count="1">\n    <bk>\n      <extLst>\n        <ext uri="{bdbb8cdc-fa1e-496e-a857-3c3f30c029c3}">\n          <xda:dynamicArrayProperties fDynamic="1" fCollapsed="0"/>\n        </ext>\n      </extLst>\n    </bk>\n  </futureMetadata>\n  <cellMetadata count="1">\n    <bk>\n      <rc t="1" v="0"/>\n    </bk>\n  </cellMetadata>\n</metadata>');
  return o2.join("");
}
__name(write_xlmeta_xml, "write_xlmeta_xml");
function parse_BrtCalcChainItem$(data) {
  var out = {};
  out.i = data.read_shift(4);
  var cell = {};
  cell.r = data.read_shift(4);
  cell.c = data.read_shift(4);
  out.r = encode_cell(cell);
  var flags = data.read_shift(1);
  if (flags & 2)
    out.l = "1";
  if (flags & 8)
    out.a = "1";
  return out;
}
__name(parse_BrtCalcChainItem$, "parse_BrtCalcChainItem$");
var _shapeid = 1024;
function write_comments_vml(rId, comments) {
  var csize = [21600, 21600];
  var bbox = ["m0,0l0", csize[1], csize[0], csize[1], csize[0], "0xe"].join(",");
  var o2 = [
    writextag("xml", null, { "xmlns:v": XLMLNS.v, "xmlns:o": XLMLNS.o, "xmlns:x": XLMLNS.x, "xmlns:mv": XLMLNS.mv }).replace(/\/>/, ">"),
    writextag("o:shapelayout", writextag("o:idmap", null, { "v:ext": "edit", "data": rId }), { "v:ext": "edit" }),
    writextag("v:shapetype", [
      writextag("v:stroke", null, { joinstyle: "miter" }),
      writextag("v:path", null, { gradientshapeok: "t", "o:connecttype": "rect" })
    ].join(""), { id: "_x0000_t202", "o:spt": 202, coordsize: csize.join(","), path: bbox })
  ];
  while (_shapeid < rId * 1e3)
    _shapeid += 1e3;
  comments.forEach(function(x2) {
    var c2 = decode_cell(x2[0]);
    var fillopts = (
      /*::(*/
      { "color2": "#BEFF82", "type": "gradient" }
    );
    if (fillopts.type == "gradient")
      fillopts.angle = "-180";
    var fillparm = fillopts.type == "gradient" ? writextag("o:fill", null, { type: "gradientUnscaled", "v:ext": "view" }) : null;
    var fillxml = writextag("v:fill", fillparm, fillopts);
    var shadata = { on: "t", "obscured": "t" };
    ++_shapeid;
    o2 = o2.concat([
      "<v:shape" + wxt_helper({
        id: "_x0000_s" + _shapeid,
        type: "#_x0000_t202",
        style: "position:absolute; margin-left:80pt;margin-top:5pt;width:104pt;height:64pt;z-index:10" + (x2[1].hidden ? ";visibility:hidden" : ""),
        fillcolor: "#ECFAD4",
        strokecolor: "#edeaa1"
      }) + ">",
      fillxml,
      writextag("v:shadow", null, shadata),
      writextag("v:path", null, { "o:connecttype": "none" }),
      '<v:textbox><div style="text-align:left"></div></v:textbox>',
      '<x:ClientData ObjectType="Note">',
      "<x:MoveWithCells/>",
      "<x:SizeWithCells/>",
      /* Part 4 19.4.2.3 Anchor (Anchor) */
      writetag("x:Anchor", [c2.c + 1, 0, c2.r + 1, 0, c2.c + 3, 20, c2.r + 5, 20].join(",")),
      writetag("x:AutoFill", "False"),
      writetag("x:Row", String(c2.r)),
      writetag("x:Column", String(c2.c)),
      x2[1].hidden ? "" : "<x:Visible/>",
      "</x:ClientData>",
      "</v:shape>"
    ]);
  });
  o2.push("</xml>");
  return o2.join("");
}
__name(write_comments_vml, "write_comments_vml");
function write_comments_xml(data) {
  var o2 = [XML_HEADER, writextag("comments", null, { "xmlns": XMLNS_main[0] })];
  var iauthor = [];
  o2.push("<authors>");
  data.forEach(function(x2) {
    x2[1].forEach(function(w2) {
      var a2 = escapexml(w2.a);
      if (iauthor.indexOf(a2) == -1) {
        iauthor.push(a2);
        o2.push("<author>" + a2 + "</author>");
      }
      if (w2.T && w2.ID && iauthor.indexOf("tc=" + w2.ID) == -1) {
        iauthor.push("tc=" + w2.ID);
        o2.push("<author>tc=" + w2.ID + "</author>");
      }
    });
  });
  if (iauthor.length == 0) {
    iauthor.push("SheetJ5");
    o2.push("<author>SheetJ5</author>");
  }
  o2.push("</authors>");
  o2.push("<commentList>");
  data.forEach(function(d2) {
    var lastauthor = 0, ts = [];
    if (d2[1][0] && d2[1][0].T && d2[1][0].ID)
      lastauthor = iauthor.indexOf("tc=" + d2[1][0].ID);
    else
      d2[1].forEach(function(c2) {
        if (c2.a)
          lastauthor = iauthor.indexOf(escapexml(c2.a));
        ts.push(c2.t || "");
      });
    o2.push('<comment ref="' + d2[0] + '" authorId="' + lastauthor + '"><text>');
    if (ts.length <= 1)
      o2.push(writetag("t", escapexml(ts[0] || "")));
    else {
      var t2 = "Comment:\n    " + ts[0] + "\n";
      for (var i2 = 1; i2 < ts.length; ++i2)
        t2 += "Reply:\n    " + ts[i2] + "\n";
      o2.push(writetag("t", escapexml(t2)));
    }
    o2.push("</text></comment>");
  });
  o2.push("</commentList>");
  if (o2.length > 2) {
    o2[o2.length] = "</comments>";
    o2[1] = o2[1].replace("/>", ">");
  }
  return o2.join("");
}
__name(write_comments_xml, "write_comments_xml");
function write_tcmnt_xml(comments, people, opts) {
  var o2 = [XML_HEADER, writextag("ThreadedComments", null, { "xmlns": XMLNS.TCMNT }).replace(/[\/]>/, ">")];
  comments.forEach(function(carr) {
    var rootid = "";
    (carr[1] || []).forEach(function(c2, idx) {
      if (!c2.T) {
        delete c2.ID;
        return;
      }
      if (c2.a && people.indexOf(c2.a) == -1)
        people.push(c2.a);
      var tcopts = {
        ref: carr[0],
        id: "{54EE7951-7262-4200-6969-" + ("000000000000" + opts.tcid++).slice(-12) + "}"
      };
      if (idx == 0)
        rootid = tcopts.id;
      else
        tcopts.parentId = rootid;
      c2.ID = tcopts.id;
      if (c2.a)
        tcopts.personId = "{54EE7950-7262-4200-6969-" + ("000000000000" + people.indexOf(c2.a)).slice(-12) + "}";
      o2.push(writextag("threadedComment", writetag("text", c2.t || ""), tcopts));
    });
  });
  o2.push("</ThreadedComments>");
  return o2.join("");
}
__name(write_tcmnt_xml, "write_tcmnt_xml");
function write_people_xml(people) {
  var o2 = [XML_HEADER, writextag("personList", null, {
    "xmlns": XMLNS.TCMNT,
    "xmlns:x": XMLNS_main[0]
  }).replace(/[\/]>/, ">")];
  people.forEach(function(person, idx) {
    o2.push(writextag("person", null, {
      displayName: person,
      id: "{54EE7950-7262-4200-6969-" + ("000000000000" + idx).slice(-12) + "}",
      userId: person,
      providerId: "None"
    }));
  });
  o2.push("</personList>");
  return o2.join("");
}
__name(write_people_xml, "write_people_xml");
function parse_BrtBeginComment(data) {
  var out = {};
  out.iauthor = data.read_shift(4);
  var rfx = parse_UncheckedRfX(data);
  out.rfx = rfx.s;
  out.ref = encode_cell(rfx.s);
  data.l += 16;
  return out;
}
__name(parse_BrtBeginComment, "parse_BrtBeginComment");
function write_BrtBeginComment(data, o2) {
  if (o2 == null)
    o2 = new_buf(36);
  o2.write_shift(4, data[1].iauthor);
  write_UncheckedRfX(data[0], o2);
  o2.write_shift(4, 0);
  o2.write_shift(4, 0);
  o2.write_shift(4, 0);
  o2.write_shift(4, 0);
  return o2;
}
__name(write_BrtBeginComment, "write_BrtBeginComment");
var parse_BrtCommentAuthor = parse_XLWideString;
function write_BrtCommentAuthor(data) {
  return write_XLWideString(data.slice(0, 54));
}
__name(write_BrtCommentAuthor, "write_BrtCommentAuthor");
function write_comments_bin(data) {
  var ba = buf_array();
  var iauthor = [];
  write_record(
    ba,
    628
    /* BrtBeginComments */
  );
  write_record(
    ba,
    630
    /* BrtBeginCommentAuthors */
  );
  data.forEach(function(comment) {
    comment[1].forEach(function(c2) {
      if (iauthor.indexOf(c2.a) > -1)
        return;
      iauthor.push(c2.a.slice(0, 54));
      write_record(ba, 632, write_BrtCommentAuthor(c2.a));
    });
  });
  write_record(
    ba,
    631
    /* BrtEndCommentAuthors */
  );
  write_record(
    ba,
    633
    /* BrtBeginCommentList */
  );
  data.forEach(function(comment) {
    comment[1].forEach(function(c2) {
      c2.iauthor = iauthor.indexOf(c2.a);
      var range = { s: decode_cell(comment[0]), e: decode_cell(comment[0]) };
      write_record(ba, 635, write_BrtBeginComment([range, c2]));
      if (c2.t && c2.t.length > 0)
        write_record(ba, 637, write_BrtCommentText(c2));
      write_record(
        ba,
        636
        /* BrtEndComment */
      );
      delete c2.iauthor;
    });
  });
  write_record(
    ba,
    634
    /* BrtEndCommentList */
  );
  write_record(
    ba,
    629
    /* BrtEndComments */
  );
  return ba.end();
}
__name(write_comments_bin, "write_comments_bin");
function fill_vba_xls(cfb, vba) {
  vba.FullPaths.forEach(function(p2, i2) {
    if (i2 == 0)
      return;
    var newpath = p2.replace(/[^\/]*[\/]/, "/_VBA_PROJECT_CUR/");
    if (newpath.slice(-1) !== "/")
      CFB.utils.cfb_add(cfb, newpath, vba.FileIndex[i2].content);
  });
}
__name(fill_vba_xls, "fill_vba_xls");
var VBAFMTS = ["xlsb", "xlsm", "xlam", "biff8", "xla"];
var rc_to_a1 = /* @__PURE__ */ function() {
  var rcregex = /(^|[^A-Za-z_])R(\[?-?\d+\]|[1-9]\d*|)C(\[?-?\d+\]|[1-9]\d*|)(?![A-Za-z0-9_])/g;
  var rcbase = { r: 0, c: 0 };
  function rcfunc($$, $1, $2, $3) {
    var cRel = false, rRel = false;
    if ($2.length == 0)
      rRel = true;
    else if ($2.charAt(0) == "[") {
      rRel = true;
      $2 = $2.slice(1, -1);
    }
    if ($3.length == 0)
      cRel = true;
    else if ($3.charAt(0) == "[") {
      cRel = true;
      $3 = $3.slice(1, -1);
    }
    var R2 = $2.length > 0 ? parseInt($2, 10) | 0 : 0, C2 = $3.length > 0 ? parseInt($3, 10) | 0 : 0;
    if (cRel)
      C2 += rcbase.c;
    else
      --C2;
    if (rRel)
      R2 += rcbase.r;
    else
      --R2;
    return $1 + (cRel ? "" : "$") + encode_col(C2) + (rRel ? "" : "$") + encode_row(R2);
  }
  __name(rcfunc, "rcfunc");
  return /* @__PURE__ */ __name(function rc_to_a12(fstr, base) {
    rcbase = base;
    return fstr.replace(rcregex, rcfunc);
  }, "rc_to_a1");
}();
var crefregex = /(^|[^._A-Z0-9])([$]?)([A-Z]{1,2}|[A-W][A-Z]{2}|X[A-E][A-Z]|XF[A-D])([$]?)(10[0-3]\d{4}|104[0-7]\d{3}|1048[0-4]\d{2}|10485[0-6]\d|104857[0-6]|[1-9]\d{0,5})(?![_.\(A-Za-z0-9])/g;
var a1_to_rc = /* @__PURE__ */ function() {
  return /* @__PURE__ */ __name(function a1_to_rc2(fstr, base) {
    return fstr.replace(crefregex, function($0, $1, $2, $3, $4, $5) {
      var c2 = decode_col($3) - ($2 ? 0 : base.c);
      var r = decode_row($5) - ($4 ? 0 : base.r);
      var R2 = r == 0 ? "" : !$4 ? "[" + r + "]" : r + 1;
      var C2 = c2 == 0 ? "" : !$2 ? "[" + c2 + "]" : c2 + 1;
      return $1 + "R" + R2 + "C" + C2;
    });
  }, "a1_to_rc");
}();
function shift_formula_str(f2, delta) {
  return f2.replace(crefregex, function($0, $1, $2, $3, $4, $5) {
    return $1 + ($2 == "$" ? $2 + $3 : encode_col(decode_col($3) + delta.c)) + ($4 == "$" ? $4 + $5 : encode_row(decode_row($5) + delta.r));
  });
}
__name(shift_formula_str, "shift_formula_str");
function fuzzyfmla(f2) {
  if (f2.length == 1)
    return false;
  return true;
}
__name(fuzzyfmla, "fuzzyfmla");
function parseread1(blob) {
  blob.l += 1;
  return;
}
__name(parseread1, "parseread1");
function parse_ColRelU(blob, length) {
  var c2 = blob.read_shift(length == 1 ? 1 : 2);
  return [c2 & 16383, c2 >> 14 & 1, c2 >> 15 & 1];
}
__name(parse_ColRelU, "parse_ColRelU");
function parse_RgceArea(blob, length, opts) {
  var w2 = 2;
  if (opts) {
    if (opts.biff >= 2 && opts.biff <= 5)
      return parse_RgceArea_BIFF2(blob);
    else if (opts.biff == 12)
      w2 = 4;
  }
  var r = blob.read_shift(w2), R2 = blob.read_shift(w2);
  var c2 = parse_ColRelU(blob, 2);
  var C2 = parse_ColRelU(blob, 2);
  return { s: { r, c: c2[0], cRel: c2[1], rRel: c2[2] }, e: { r: R2, c: C2[0], cRel: C2[1], rRel: C2[2] } };
}
__name(parse_RgceArea, "parse_RgceArea");
function parse_RgceArea_BIFF2(blob) {
  var r = parse_ColRelU(blob, 2), R2 = parse_ColRelU(blob, 2);
  var c2 = blob.read_shift(1);
  var C2 = blob.read_shift(1);
  return { s: { r: r[0], c: c2, cRel: r[1], rRel: r[2] }, e: { r: R2[0], c: C2, cRel: R2[1], rRel: R2[2] } };
}
__name(parse_RgceArea_BIFF2, "parse_RgceArea_BIFF2");
function parse_RgceAreaRel(blob, length, opts) {
  if (opts.biff < 8)
    return parse_RgceArea_BIFF2(blob);
  var r = blob.read_shift(opts.biff == 12 ? 4 : 2), R2 = blob.read_shift(opts.biff == 12 ? 4 : 2);
  var c2 = parse_ColRelU(blob, 2);
  var C2 = parse_ColRelU(blob, 2);
  return { s: { r, c: c2[0], cRel: c2[1], rRel: c2[2] }, e: { r: R2, c: C2[0], cRel: C2[1], rRel: C2[2] } };
}
__name(parse_RgceAreaRel, "parse_RgceAreaRel");
function parse_RgceLoc(blob, length, opts) {
  if (opts && opts.biff >= 2 && opts.biff <= 5)
    return parse_RgceLoc_BIFF2(blob);
  var r = blob.read_shift(opts && opts.biff == 12 ? 4 : 2);
  var c2 = parse_ColRelU(blob, 2);
  return { r, c: c2[0], cRel: c2[1], rRel: c2[2] };
}
__name(parse_RgceLoc, "parse_RgceLoc");
function parse_RgceLoc_BIFF2(blob) {
  var r = parse_ColRelU(blob, 2);
  var c2 = blob.read_shift(1);
  return { r: r[0], c: c2, cRel: r[1], rRel: r[2] };
}
__name(parse_RgceLoc_BIFF2, "parse_RgceLoc_BIFF2");
function parse_RgceElfLoc(blob) {
  var r = blob.read_shift(2);
  var c2 = blob.read_shift(2);
  return { r, c: c2 & 255, fQuoted: !!(c2 & 16384), cRel: c2 >> 15, rRel: c2 >> 15 };
}
__name(parse_RgceElfLoc, "parse_RgceElfLoc");
function parse_RgceLocRel(blob, length, opts) {
  var biff = opts && opts.biff ? opts.biff : 8;
  if (biff >= 2 && biff <= 5)
    return parse_RgceLocRel_BIFF2(blob);
  var r = blob.read_shift(biff >= 12 ? 4 : 2);
  var cl = blob.read_shift(2);
  var cRel = (cl & 16384) >> 14, rRel = (cl & 32768) >> 15;
  cl &= 16383;
  if (rRel == 1)
    while (r > 524287)
      r -= 1048576;
  if (cRel == 1)
    while (cl > 8191)
      cl = cl - 16384;
  return { r, c: cl, cRel, rRel };
}
__name(parse_RgceLocRel, "parse_RgceLocRel");
function parse_RgceLocRel_BIFF2(blob) {
  var rl = blob.read_shift(2);
  var c2 = blob.read_shift(1);
  var rRel = (rl & 32768) >> 15, cRel = (rl & 16384) >> 14;
  rl &= 16383;
  if (rRel == 1 && rl >= 8192)
    rl = rl - 16384;
  if (cRel == 1 && c2 >= 128)
    c2 = c2 - 256;
  return { r: rl, c: c2, cRel, rRel };
}
__name(parse_RgceLocRel_BIFF2, "parse_RgceLocRel_BIFF2");
function parse_PtgArea(blob, length, opts) {
  var type = (blob[blob.l++] & 96) >> 5;
  var area = parse_RgceArea(blob, opts.biff >= 2 && opts.biff <= 5 ? 6 : 8, opts);
  return [type, area];
}
__name(parse_PtgArea, "parse_PtgArea");
function parse_PtgArea3d(blob, length, opts) {
  var type = (blob[blob.l++] & 96) >> 5;
  var ixti = blob.read_shift(2, "i");
  var w2 = 8;
  if (opts)
    switch (opts.biff) {
      case 5:
        blob.l += 12;
        w2 = 6;
        break;
      case 12:
        w2 = 12;
        break;
    }
  var area = parse_RgceArea(blob, w2, opts);
  return [type, ixti, area];
}
__name(parse_PtgArea3d, "parse_PtgArea3d");
function parse_PtgAreaErr(blob, length, opts) {
  var type = (blob[blob.l++] & 96) >> 5;
  blob.l += opts && opts.biff > 8 ? 12 : opts.biff < 8 ? 6 : 8;
  return [type];
}
__name(parse_PtgAreaErr, "parse_PtgAreaErr");
function parse_PtgAreaErr3d(blob, length, opts) {
  var type = (blob[blob.l++] & 96) >> 5;
  var ixti = blob.read_shift(2);
  var w2 = 8;
  if (opts)
    switch (opts.biff) {
      case 5:
        blob.l += 12;
        w2 = 6;
        break;
      case 12:
        w2 = 12;
        break;
    }
  blob.l += w2;
  return [type, ixti];
}
__name(parse_PtgAreaErr3d, "parse_PtgAreaErr3d");
function parse_PtgAreaN(blob, length, opts) {
  var type = (blob[blob.l++] & 96) >> 5;
  var area = parse_RgceAreaRel(blob, length - 1, opts);
  return [type, area];
}
__name(parse_PtgAreaN, "parse_PtgAreaN");
function parse_PtgArray(blob, length, opts) {
  var type = (blob[blob.l++] & 96) >> 5;
  blob.l += opts.biff == 2 ? 6 : opts.biff == 12 ? 14 : 7;
  return [type];
}
__name(parse_PtgArray, "parse_PtgArray");
function parse_PtgAttrBaxcel(blob) {
  var bitSemi = blob[blob.l + 1] & 1;
  var bitBaxcel = 1;
  blob.l += 4;
  return [bitSemi, bitBaxcel];
}
__name(parse_PtgAttrBaxcel, "parse_PtgAttrBaxcel");
function parse_PtgAttrChoose(blob, length, opts) {
  blob.l += 2;
  var offset = blob.read_shift(opts && opts.biff == 2 ? 1 : 2);
  var o2 = [];
  for (var i2 = 0; i2 <= offset; ++i2)
    o2.push(blob.read_shift(opts && opts.biff == 2 ? 1 : 2));
  return o2;
}
__name(parse_PtgAttrChoose, "parse_PtgAttrChoose");
function parse_PtgAttrGoto(blob, length, opts) {
  var bitGoto = blob[blob.l + 1] & 255 ? 1 : 0;
  blob.l += 2;
  return [bitGoto, blob.read_shift(opts && opts.biff == 2 ? 1 : 2)];
}
__name(parse_PtgAttrGoto, "parse_PtgAttrGoto");
function parse_PtgAttrIf(blob, length, opts) {
  var bitIf = blob[blob.l + 1] & 255 ? 1 : 0;
  blob.l += 2;
  return [bitIf, blob.read_shift(opts && opts.biff == 2 ? 1 : 2)];
}
__name(parse_PtgAttrIf, "parse_PtgAttrIf");
function parse_PtgAttrIfError(blob) {
  var bitIf = blob[blob.l + 1] & 255 ? 1 : 0;
  blob.l += 2;
  return [bitIf, blob.read_shift(2)];
}
__name(parse_PtgAttrIfError, "parse_PtgAttrIfError");
function parse_PtgAttrSemi(blob, length, opts) {
  var bitSemi = blob[blob.l + 1] & 255 ? 1 : 0;
  blob.l += opts && opts.biff == 2 ? 3 : 4;
  return [bitSemi];
}
__name(parse_PtgAttrSemi, "parse_PtgAttrSemi");
function parse_PtgAttrSpaceType(blob) {
  var type = blob.read_shift(1), cch = blob.read_shift(1);
  return [type, cch];
}
__name(parse_PtgAttrSpaceType, "parse_PtgAttrSpaceType");
function parse_PtgAttrSpace(blob) {
  blob.read_shift(2);
  return parse_PtgAttrSpaceType(blob);
}
__name(parse_PtgAttrSpace, "parse_PtgAttrSpace");
function parse_PtgAttrSpaceSemi(blob) {
  blob.read_shift(2);
  return parse_PtgAttrSpaceType(blob);
}
__name(parse_PtgAttrSpaceSemi, "parse_PtgAttrSpaceSemi");
function parse_PtgRef(blob, length, opts) {
  var type = (blob[blob.l] & 96) >> 5;
  blob.l += 1;
  var loc = parse_RgceLoc(blob, 0, opts);
  return [type, loc];
}
__name(parse_PtgRef, "parse_PtgRef");
function parse_PtgRefN(blob, length, opts) {
  var type = (blob[blob.l] & 96) >> 5;
  blob.l += 1;
  var loc = parse_RgceLocRel(blob, 0, opts);
  return [type, loc];
}
__name(parse_PtgRefN, "parse_PtgRefN");
function parse_PtgRef3d(blob, length, opts) {
  var type = (blob[blob.l] & 96) >> 5;
  blob.l += 1;
  var ixti = blob.read_shift(2);
  if (opts && opts.biff == 5)
    blob.l += 12;
  var loc = parse_RgceLoc(blob, 0, opts);
  return [type, ixti, loc];
}
__name(parse_PtgRef3d, "parse_PtgRef3d");
function parse_PtgFunc(blob, length, opts) {
  var type = (blob[blob.l] & 96) >> 5;
  blob.l += 1;
  var iftab = blob.read_shift(opts && opts.biff <= 3 ? 1 : 2);
  return [FtabArgc[iftab], Ftab[iftab], type];
}
__name(parse_PtgFunc, "parse_PtgFunc");
function parse_PtgFuncVar(blob, length, opts) {
  var type = blob[blob.l++];
  var cparams = blob.read_shift(1), tab = opts && opts.biff <= 3 ? [type == 88 ? -1 : 0, blob.read_shift(1)] : parsetab(blob);
  return [cparams, (tab[0] === 0 ? Ftab : Cetab)[tab[1]]];
}
__name(parse_PtgFuncVar, "parse_PtgFuncVar");
function parsetab(blob) {
  return [blob[blob.l + 1] >> 7, blob.read_shift(2) & 32767];
}
__name(parsetab, "parsetab");
function parse_PtgAttrSum(blob, length, opts) {
  blob.l += opts && opts.biff == 2 ? 3 : 4;
  return;
}
__name(parse_PtgAttrSum, "parse_PtgAttrSum");
function parse_PtgExp(blob, length, opts) {
  blob.l++;
  if (opts && opts.biff == 12)
    return [blob.read_shift(4, "i"), 0];
  var row = blob.read_shift(2);
  var col = blob.read_shift(opts && opts.biff == 2 ? 1 : 2);
  return [row, col];
}
__name(parse_PtgExp, "parse_PtgExp");
function parse_PtgErr(blob) {
  blob.l++;
  return BErr[blob.read_shift(1)];
}
__name(parse_PtgErr, "parse_PtgErr");
function parse_PtgInt(blob) {
  blob.l++;
  return blob.read_shift(2);
}
__name(parse_PtgInt, "parse_PtgInt");
function parse_PtgBool(blob) {
  blob.l++;
  return blob.read_shift(1) !== 0;
}
__name(parse_PtgBool, "parse_PtgBool");
function parse_PtgNum(blob) {
  blob.l++;
  return parse_Xnum(blob);
}
__name(parse_PtgNum, "parse_PtgNum");
function parse_PtgStr(blob, length, opts) {
  blob.l++;
  return parse_ShortXLUnicodeString(blob, length - 1, opts);
}
__name(parse_PtgStr, "parse_PtgStr");
function parse_SerAr(blob, biff) {
  var val = [blob.read_shift(1)];
  if (biff == 12)
    switch (val[0]) {
      case 2:
        val[0] = 4;
        break;
      case 4:
        val[0] = 16;
        break;
      case 0:
        val[0] = 1;
        break;
      case 1:
        val[0] = 2;
        break;
    }
  switch (val[0]) {
    case 4:
      val[1] = parsebool(blob, 1) ? "TRUE" : "FALSE";
      if (biff != 12)
        blob.l += 7;
      break;
    case 37:
    case 16:
      val[1] = BErr[blob[blob.l]];
      blob.l += biff == 12 ? 4 : 8;
      break;
    case 0:
      blob.l += 8;
      break;
    case 1:
      val[1] = parse_Xnum(blob);
      break;
    case 2:
      val[1] = parse_XLUnicodeString2(blob, 0, { biff: biff > 0 && biff < 8 ? 2 : biff });
      break;
    default:
      throw new Error("Bad SerAr: " + val[0]);
  }
  return val;
}
__name(parse_SerAr, "parse_SerAr");
function parse_PtgExtraMem(blob, cce, opts) {
  var count = blob.read_shift(opts.biff == 12 ? 4 : 2);
  var out = [];
  for (var i2 = 0; i2 != count; ++i2)
    out.push((opts.biff == 12 ? parse_UncheckedRfX : parse_Ref8U)(blob));
  return out;
}
__name(parse_PtgExtraMem, "parse_PtgExtraMem");
function parse_PtgExtraArray(blob, length, opts) {
  var rows = 0, cols = 0;
  if (opts.biff == 12) {
    rows = blob.read_shift(4);
    cols = blob.read_shift(4);
  } else {
    cols = 1 + blob.read_shift(1);
    rows = 1 + blob.read_shift(2);
  }
  if (opts.biff >= 2 && opts.biff < 8) {
    --rows;
    if (--cols == 0)
      cols = 256;
  }
  for (var i2 = 0, o2 = []; i2 != rows && (o2[i2] = []); ++i2)
    for (var j2 = 0; j2 != cols; ++j2)
      o2[i2][j2] = parse_SerAr(blob, opts.biff);
  return o2;
}
__name(parse_PtgExtraArray, "parse_PtgExtraArray");
function parse_PtgName(blob, length, opts) {
  var type = blob.read_shift(1) >>> 5 & 3;
  var w2 = !opts || opts.biff >= 8 ? 4 : 2;
  var nameindex = blob.read_shift(w2);
  switch (opts.biff) {
    case 2:
      blob.l += 5;
      break;
    case 3:
    case 4:
      blob.l += 8;
      break;
    case 5:
      blob.l += 12;
      break;
  }
  return [type, 0, nameindex];
}
__name(parse_PtgName, "parse_PtgName");
function parse_PtgNameX(blob, length, opts) {
  if (opts.biff == 5)
    return parse_PtgNameX_BIFF5(blob);
  var type = blob.read_shift(1) >>> 5 & 3;
  var ixti = blob.read_shift(2);
  var nameindex = blob.read_shift(4);
  return [type, ixti, nameindex];
}
__name(parse_PtgNameX, "parse_PtgNameX");
function parse_PtgNameX_BIFF5(blob) {
  var type = blob.read_shift(1) >>> 5 & 3;
  var ixti = blob.read_shift(2, "i");
  blob.l += 8;
  var nameindex = blob.read_shift(2);
  blob.l += 12;
  return [type, ixti, nameindex];
}
__name(parse_PtgNameX_BIFF5, "parse_PtgNameX_BIFF5");
function parse_PtgMemArea(blob, length, opts) {
  var type = blob.read_shift(1) >>> 5 & 3;
  blob.l += opts && opts.biff == 2 ? 3 : 4;
  var cce = blob.read_shift(opts && opts.biff == 2 ? 1 : 2);
  return [type, cce];
}
__name(parse_PtgMemArea, "parse_PtgMemArea");
function parse_PtgMemFunc(blob, length, opts) {
  var type = blob.read_shift(1) >>> 5 & 3;
  var cce = blob.read_shift(opts && opts.biff == 2 ? 1 : 2);
  return [type, cce];
}
__name(parse_PtgMemFunc, "parse_PtgMemFunc");
function parse_PtgRefErr(blob, length, opts) {
  var type = blob.read_shift(1) >>> 5 & 3;
  blob.l += 4;
  if (opts.biff < 8)
    blob.l--;
  if (opts.biff == 12)
    blob.l += 2;
  return [type];
}
__name(parse_PtgRefErr, "parse_PtgRefErr");
function parse_PtgRefErr3d(blob, length, opts) {
  var type = (blob[blob.l++] & 96) >> 5;
  var ixti = blob.read_shift(2);
  var w2 = 4;
  if (opts)
    switch (opts.biff) {
      case 5:
        w2 = 15;
        break;
      case 12:
        w2 = 6;
        break;
    }
  blob.l += w2;
  return [type, ixti];
}
__name(parse_PtgRefErr3d, "parse_PtgRefErr3d");
var parse_PtgMemErr = parsenoop;
var parse_PtgMemNoMem = parsenoop;
var parse_PtgTbl = parsenoop;
function parse_PtgElfLoc(blob, length, opts) {
  blob.l += 2;
  return [parse_RgceElfLoc(blob)];
}
__name(parse_PtgElfLoc, "parse_PtgElfLoc");
function parse_PtgElfNoop(blob) {
  blob.l += 6;
  return [];
}
__name(parse_PtgElfNoop, "parse_PtgElfNoop");
var parse_PtgElfCol = parse_PtgElfLoc;
var parse_PtgElfColS = parse_PtgElfNoop;
var parse_PtgElfColSV = parse_PtgElfNoop;
var parse_PtgElfColV = parse_PtgElfLoc;
function parse_PtgElfLel(blob) {
  blob.l += 2;
  return [parseuint16(blob), blob.read_shift(2) & 1];
}
__name(parse_PtgElfLel, "parse_PtgElfLel");
var parse_PtgElfRadical = parse_PtgElfLoc;
var parse_PtgElfRadicalLel = parse_PtgElfLel;
var parse_PtgElfRadicalS = parse_PtgElfNoop;
var parse_PtgElfRw = parse_PtgElfLoc;
var parse_PtgElfRwV = parse_PtgElfLoc;
var PtgListRT = [
  "Data",
  "All",
  "Headers",
  "??",
  "?Data2",
  "??",
  "?DataHeaders",
  "??",
  "Totals",
  "??",
  "??",
  "??",
  "?DataTotals",
  "??",
  "??",
  "??",
  "?Current"
];
function parse_PtgList(blob) {
  blob.l += 2;
  var ixti = blob.read_shift(2);
  var flags = blob.read_shift(2);
  var idx = blob.read_shift(4);
  var c2 = blob.read_shift(2);
  var C2 = blob.read_shift(2);
  var rt2 = PtgListRT[flags >> 2 & 31];
  return { ixti, coltype: flags & 3, rt: rt2, idx, c: c2, C: C2 };
}
__name(parse_PtgList, "parse_PtgList");
function parse_PtgSxName(blob) {
  blob.l += 2;
  return [blob.read_shift(4)];
}
__name(parse_PtgSxName, "parse_PtgSxName");
function parse_PtgSheet(blob, length, opts) {
  blob.l += 5;
  blob.l += 2;
  blob.l += opts.biff == 2 ? 1 : 4;
  return ["PTGSHEET"];
}
__name(parse_PtgSheet, "parse_PtgSheet");
function parse_PtgEndSheet(blob, length, opts) {
  blob.l += opts.biff == 2 ? 4 : 5;
  return ["PTGENDSHEET"];
}
__name(parse_PtgEndSheet, "parse_PtgEndSheet");
function parse_PtgMemAreaN(blob) {
  var type = blob.read_shift(1) >>> 5 & 3;
  var cce = blob.read_shift(2);
  return [type, cce];
}
__name(parse_PtgMemAreaN, "parse_PtgMemAreaN");
function parse_PtgMemNoMemN(blob) {
  var type = blob.read_shift(1) >>> 5 & 3;
  var cce = blob.read_shift(2);
  return [type, cce];
}
__name(parse_PtgMemNoMemN, "parse_PtgMemNoMemN");
function parse_PtgAttrNoop(blob) {
  blob.l += 4;
  return [0, 0];
}
__name(parse_PtgAttrNoop, "parse_PtgAttrNoop");
var PtgTypes = {
  /*::[*/
  1: { n: "PtgExp", f: parse_PtgExp },
  /*::[*/
  2: { n: "PtgTbl", f: parse_PtgTbl },
  /*::[*/
  3: { n: "PtgAdd", f: parseread1 },
  /*::[*/
  4: { n: "PtgSub", f: parseread1 },
  /*::[*/
  5: { n: "PtgMul", f: parseread1 },
  /*::[*/
  6: { n: "PtgDiv", f: parseread1 },
  /*::[*/
  7: { n: "PtgPower", f: parseread1 },
  /*::[*/
  8: { n: "PtgConcat", f: parseread1 },
  /*::[*/
  9: { n: "PtgLt", f: parseread1 },
  /*::[*/
  10: { n: "PtgLe", f: parseread1 },
  /*::[*/
  11: { n: "PtgEq", f: parseread1 },
  /*::[*/
  12: { n: "PtgGe", f: parseread1 },
  /*::[*/
  13: { n: "PtgGt", f: parseread1 },
  /*::[*/
  14: { n: "PtgNe", f: parseread1 },
  /*::[*/
  15: { n: "PtgIsect", f: parseread1 },
  /*::[*/
  16: { n: "PtgUnion", f: parseread1 },
  /*::[*/
  17: { n: "PtgRange", f: parseread1 },
  /*::[*/
  18: { n: "PtgUplus", f: parseread1 },
  /*::[*/
  19: { n: "PtgUminus", f: parseread1 },
  /*::[*/
  20: { n: "PtgPercent", f: parseread1 },
  /*::[*/
  21: { n: "PtgParen", f: parseread1 },
  /*::[*/
  22: { n: "PtgMissArg", f: parseread1 },
  /*::[*/
  23: { n: "PtgStr", f: parse_PtgStr },
  /*::[*/
  26: { n: "PtgSheet", f: parse_PtgSheet },
  /*::[*/
  27: { n: "PtgEndSheet", f: parse_PtgEndSheet },
  /*::[*/
  28: { n: "PtgErr", f: parse_PtgErr },
  /*::[*/
  29: { n: "PtgBool", f: parse_PtgBool },
  /*::[*/
  30: { n: "PtgInt", f: parse_PtgInt },
  /*::[*/
  31: { n: "PtgNum", f: parse_PtgNum },
  /*::[*/
  32: { n: "PtgArray", f: parse_PtgArray },
  /*::[*/
  33: { n: "PtgFunc", f: parse_PtgFunc },
  /*::[*/
  34: { n: "PtgFuncVar", f: parse_PtgFuncVar },
  /*::[*/
  35: { n: "PtgName", f: parse_PtgName },
  /*::[*/
  36: { n: "PtgRef", f: parse_PtgRef },
  /*::[*/
  37: { n: "PtgArea", f: parse_PtgArea },
  /*::[*/
  38: { n: "PtgMemArea", f: parse_PtgMemArea },
  /*::[*/
  39: { n: "PtgMemErr", f: parse_PtgMemErr },
  /*::[*/
  40: { n: "PtgMemNoMem", f: parse_PtgMemNoMem },
  /*::[*/
  41: { n: "PtgMemFunc", f: parse_PtgMemFunc },
  /*::[*/
  42: { n: "PtgRefErr", f: parse_PtgRefErr },
  /*::[*/
  43: { n: "PtgAreaErr", f: parse_PtgAreaErr },
  /*::[*/
  44: { n: "PtgRefN", f: parse_PtgRefN },
  /*::[*/
  45: { n: "PtgAreaN", f: parse_PtgAreaN },
  /*::[*/
  46: { n: "PtgMemAreaN", f: parse_PtgMemAreaN },
  /*::[*/
  47: { n: "PtgMemNoMemN", f: parse_PtgMemNoMemN },
  /*::[*/
  57: { n: "PtgNameX", f: parse_PtgNameX },
  /*::[*/
  58: { n: "PtgRef3d", f: parse_PtgRef3d },
  /*::[*/
  59: { n: "PtgArea3d", f: parse_PtgArea3d },
  /*::[*/
  60: { n: "PtgRefErr3d", f: parse_PtgRefErr3d },
  /*::[*/
  61: { n: "PtgAreaErr3d", f: parse_PtgAreaErr3d },
  /*::[*/
  255: {}
};
var PtgDupes = {
  /*::[*/
  64: 32,
  /*::[*/
  96: 32,
  /*::[*/
  65: 33,
  /*::[*/
  97: 33,
  /*::[*/
  66: 34,
  /*::[*/
  98: 34,
  /*::[*/
  67: 35,
  /*::[*/
  99: 35,
  /*::[*/
  68: 36,
  /*::[*/
  100: 36,
  /*::[*/
  69: 37,
  /*::[*/
  101: 37,
  /*::[*/
  70: 38,
  /*::[*/
  102: 38,
  /*::[*/
  71: 39,
  /*::[*/
  103: 39,
  /*::[*/
  72: 40,
  /*::[*/
  104: 40,
  /*::[*/
  73: 41,
  /*::[*/
  105: 41,
  /*::[*/
  74: 42,
  /*::[*/
  106: 42,
  /*::[*/
  75: 43,
  /*::[*/
  107: 43,
  /*::[*/
  76: 44,
  /*::[*/
  108: 44,
  /*::[*/
  77: 45,
  /*::[*/
  109: 45,
  /*::[*/
  78: 46,
  /*::[*/
  110: 46,
  /*::[*/
  79: 47,
  /*::[*/
  111: 47,
  /*::[*/
  88: 34,
  /*::[*/
  120: 34,
  /*::[*/
  89: 57,
  /*::[*/
  121: 57,
  /*::[*/
  90: 58,
  /*::[*/
  122: 58,
  /*::[*/
  91: 59,
  /*::[*/
  123: 59,
  /*::[*/
  92: 60,
  /*::[*/
  124: 60,
  /*::[*/
  93: 61,
  /*::[*/
  125: 61
};
var Ptg18 = {
  /*::[*/
  1: { n: "PtgElfLel", f: parse_PtgElfLel },
  /*::[*/
  2: { n: "PtgElfRw", f: parse_PtgElfRw },
  /*::[*/
  3: { n: "PtgElfCol", f: parse_PtgElfCol },
  /*::[*/
  6: { n: "PtgElfRwV", f: parse_PtgElfRwV },
  /*::[*/
  7: { n: "PtgElfColV", f: parse_PtgElfColV },
  /*::[*/
  10: { n: "PtgElfRadical", f: parse_PtgElfRadical },
  /*::[*/
  11: { n: "PtgElfRadicalS", f: parse_PtgElfRadicalS },
  /*::[*/
  13: { n: "PtgElfColS", f: parse_PtgElfColS },
  /*::[*/
  15: { n: "PtgElfColSV", f: parse_PtgElfColSV },
  /*::[*/
  16: { n: "PtgElfRadicalLel", f: parse_PtgElfRadicalLel },
  /*::[*/
  25: { n: "PtgList", f: parse_PtgList },
  /*::[*/
  29: { n: "PtgSxName", f: parse_PtgSxName },
  /*::[*/
  255: {}
};
var Ptg19 = {
  /*::[*/
  0: { n: "PtgAttrNoop", f: parse_PtgAttrNoop },
  /*::[*/
  1: { n: "PtgAttrSemi", f: parse_PtgAttrSemi },
  /*::[*/
  2: { n: "PtgAttrIf", f: parse_PtgAttrIf },
  /*::[*/
  4: { n: "PtgAttrChoose", f: parse_PtgAttrChoose },
  /*::[*/
  8: { n: "PtgAttrGoto", f: parse_PtgAttrGoto },
  /*::[*/
  16: { n: "PtgAttrSum", f: parse_PtgAttrSum },
  /*::[*/
  32: { n: "PtgAttrBaxcel", f: parse_PtgAttrBaxcel },
  /*::[*/
  33: { n: "PtgAttrBaxcel", f: parse_PtgAttrBaxcel },
  /*::[*/
  64: { n: "PtgAttrSpace", f: parse_PtgAttrSpace },
  /*::[*/
  65: { n: "PtgAttrSpaceSemi", f: parse_PtgAttrSpaceSemi },
  /*::[*/
  128: { n: "PtgAttrIfError", f: parse_PtgAttrIfError },
  /*::[*/
  255: {}
};
function parse_RgbExtra(blob, length, rgce, opts) {
  if (opts.biff < 8)
    return parsenoop(blob, length);
  var target = blob.l + length;
  var o2 = [];
  for (var i2 = 0; i2 !== rgce.length; ++i2) {
    switch (rgce[i2][0]) {
      case "PtgArray":
        rgce[i2][1] = parse_PtgExtraArray(blob, 0, opts);
        o2.push(rgce[i2][1]);
        break;
      case "PtgMemArea":
        rgce[i2][2] = parse_PtgExtraMem(blob, rgce[i2][1], opts);
        o2.push(rgce[i2][2]);
        break;
      case "PtgExp":
        if (opts && opts.biff == 12) {
          rgce[i2][1][1] = blob.read_shift(4);
          o2.push(rgce[i2][1]);
        }
        break;
      case "PtgList":
      case "PtgElfRadicalS":
      case "PtgElfColS":
      case "PtgElfColSV":
        throw "Unsupported " + rgce[i2][0];
    }
  }
  length = target - blob.l;
  if (length !== 0)
    o2.push(parsenoop(blob, length));
  return o2;
}
__name(parse_RgbExtra, "parse_RgbExtra");
function parse_Rgce(blob, length, opts) {
  var target = blob.l + length;
  var R2, id, ptgs = [];
  while (target != blob.l) {
    length = target - blob.l;
    id = blob[blob.l];
    R2 = PtgTypes[id] || PtgTypes[PtgDupes[id]];
    if (id === 24 || id === 25)
      R2 = (id === 24 ? Ptg18 : Ptg19)[blob[blob.l + 1]];
    if (!R2 || !R2.f) {
      parsenoop(blob, length);
    } else {
      ptgs.push([R2.n, R2.f(blob, length, opts)]);
    }
  }
  return ptgs;
}
__name(parse_Rgce, "parse_Rgce");
function stringify_array(f2) {
  var o2 = [];
  for (var i2 = 0; i2 < f2.length; ++i2) {
    var x2 = f2[i2], r = [];
    for (var j2 = 0; j2 < x2.length; ++j2) {
      var y2 = x2[j2];
      if (y2)
        switch (y2[0]) {
          case 2:
            r.push('"' + y2[1].replace(/"/g, '""') + '"');
            break;
          default:
            r.push(y2[1]);
        }
      else
        r.push("");
    }
    o2.push(r.join(","));
  }
  return o2.join(";");
}
__name(stringify_array, "stringify_array");
var PtgBinOp = {
  PtgAdd: "+",
  PtgConcat: "&",
  PtgDiv: "/",
  PtgEq: "=",
  PtgGe: ">=",
  PtgGt: ">",
  PtgLe: "<=",
  PtgLt: "<",
  PtgMul: "*",
  PtgNe: "<>",
  PtgPower: "^",
  PtgSub: "-"
};
function formula_quote_sheet_name(sname, opts) {
  if (!sname && !(opts && opts.biff <= 5 && opts.biff >= 2))
    throw new Error("empty sheet name");
  if (/[^\w\u4E00-\u9FFF\u3040-\u30FF]/.test(sname))
    return "'" + sname + "'";
  return sname;
}
__name(formula_quote_sheet_name, "formula_quote_sheet_name");
function get_ixti_raw(supbooks, ixti, opts) {
  if (!supbooks)
    return "SH33TJSERR0";
  if (opts.biff > 8 && (!supbooks.XTI || !supbooks.XTI[ixti]))
    return supbooks.SheetNames[ixti];
  if (!supbooks.XTI)
    return "SH33TJSERR6";
  var XTI = supbooks.XTI[ixti];
  if (opts.biff < 8) {
    if (ixti > 1e4)
      ixti -= 65536;
    if (ixti < 0)
      ixti = -ixti;
    return ixti == 0 ? "" : supbooks.XTI[ixti - 1];
  }
  if (!XTI)
    return "SH33TJSERR1";
  var o2 = "";
  if (opts.biff > 8)
    switch (supbooks[XTI[0]][0]) {
      case 357:
        o2 = XTI[1] == -1 ? "#REF" : supbooks.SheetNames[XTI[1]];
        return XTI[1] == XTI[2] ? o2 : o2 + ":" + supbooks.SheetNames[XTI[2]];
      case 358:
        if (opts.SID != null)
          return supbooks.SheetNames[opts.SID];
        return "SH33TJSSAME" + supbooks[XTI[0]][0];
      case 355:
      default:
        return "SH33TJSSRC" + supbooks[XTI[0]][0];
    }
  switch (supbooks[XTI[0]][0][0]) {
    case 1025:
      o2 = XTI[1] == -1 ? "#REF" : supbooks.SheetNames[XTI[1]] || "SH33TJSERR3";
      return XTI[1] == XTI[2] ? o2 : o2 + ":" + supbooks.SheetNames[XTI[2]];
    case 14849:
      return supbooks[XTI[0]].slice(1).map(function(name) {
        return name.Name;
      }).join(";;");
    default:
      if (!supbooks[XTI[0]][0][3])
        return "SH33TJSERR2";
      o2 = XTI[1] == -1 ? "#REF" : supbooks[XTI[0]][0][3][XTI[1]] || "SH33TJSERR4";
      return XTI[1] == XTI[2] ? o2 : o2 + ":" + supbooks[XTI[0]][0][3][XTI[2]];
  }
}
__name(get_ixti_raw, "get_ixti_raw");
function get_ixti(supbooks, ixti, opts) {
  var ixtiraw = get_ixti_raw(supbooks, ixti, opts);
  return ixtiraw == "#REF" ? ixtiraw : formula_quote_sheet_name(ixtiraw, opts);
}
__name(get_ixti, "get_ixti");
function stringify_formula(formula, range, cell, supbooks, opts) {
  var biff = opts && opts.biff || 8;
  var _range = (
    /*range != null ? range :*/
    { s: { c: 0, r: 0 }, e: { c: 0, r: 0 } }
  );
  var stack = [], e1, e2, c2, ixti = 0, nameidx = 0, r, sname = "";
  if (!formula[0] || !formula[0][0])
    return "";
  var last_sp = -1, sp = "";
  for (var ff = 0, fflen = formula[0].length; ff < fflen; ++ff) {
    var f2 = formula[0][ff];
    switch (f2[0]) {
      case "PtgUminus":
        stack.push("-" + stack.pop());
        break;
      case "PtgUplus":
        stack.push("+" + stack.pop());
        break;
      case "PtgPercent":
        stack.push(stack.pop() + "%");
        break;
      case "PtgAdd":
      case "PtgConcat":
      case "PtgDiv":
      case "PtgEq":
      case "PtgGe":
      case "PtgGt":
      case "PtgLe":
      case "PtgLt":
      case "PtgMul":
      case "PtgNe":
      case "PtgPower":
      case "PtgSub":
        e1 = stack.pop();
        e2 = stack.pop();
        if (last_sp >= 0) {
          switch (formula[0][last_sp][1][0]) {
            case 0:
              sp = fill(" ", formula[0][last_sp][1][1]);
              break;
            case 1:
              sp = fill("\r", formula[0][last_sp][1][1]);
              break;
            default:
              sp = "";
              if (opts.WTF)
                throw new Error("Unexpected PtgAttrSpaceType " + formula[0][last_sp][1][0]);
          }
          e2 = e2 + sp;
          last_sp = -1;
        }
        stack.push(e2 + PtgBinOp[f2[0]] + e1);
        break;
      case "PtgIsect":
        e1 = stack.pop();
        e2 = stack.pop();
        stack.push(e2 + " " + e1);
        break;
      case "PtgUnion":
        e1 = stack.pop();
        e2 = stack.pop();
        stack.push(e2 + "," + e1);
        break;
      case "PtgRange":
        e1 = stack.pop();
        e2 = stack.pop();
        stack.push(e2 + ":" + e1);
        break;
      case "PtgAttrChoose":
        break;
      case "PtgAttrGoto":
        break;
      case "PtgAttrIf":
        break;
      case "PtgAttrIfError":
        break;
      case "PtgRef":
        c2 = shift_cell_xls(f2[1][1], _range, opts);
        stack.push(encode_cell_xls(c2, biff));
        break;
      case "PtgRefN":
        c2 = cell ? shift_cell_xls(f2[1][1], cell, opts) : f2[1][1];
        stack.push(encode_cell_xls(c2, biff));
        break;
      case "PtgRef3d":
        ixti = /*::Number(*/
        f2[1][1];
        c2 = shift_cell_xls(f2[1][2], _range, opts);
        sname = get_ixti(supbooks, ixti, opts);
        stack.push(sname + "!" + encode_cell_xls(c2, biff));
        break;
      case "PtgFunc":
      case "PtgFuncVar":
        var argc = f2[1][0], func = f2[1][1];
        if (!argc)
          argc = 0;
        argc &= 127;
        var args = argc == 0 ? [] : stack.slice(-argc);
        stack.length -= argc;
        if (func === "User")
          func = args.shift();
        stack.push(func + "(" + args.join(",") + ")");
        break;
      case "PtgBool":
        stack.push(f2[1] ? "TRUE" : "FALSE");
        break;
      case "PtgInt":
        stack.push(
          /*::String(*/
          f2[1]
          /*::)*/
        );
        break;
      case "PtgNum":
        stack.push(String(f2[1]));
        break;
      case "PtgStr":
        stack.push('"' + f2[1].replace(/"/g, '""') + '"');
        break;
      case "PtgErr":
        stack.push(
          /*::String(*/
          f2[1]
          /*::)*/
        );
        break;
      case "PtgAreaN":
        r = shift_range_xls(f2[1][1], cell ? { s: cell } : _range, opts);
        stack.push(encode_range_xls(r, opts));
        break;
      case "PtgArea":
        r = shift_range_xls(f2[1][1], _range, opts);
        stack.push(encode_range_xls(r, opts));
        break;
      case "PtgArea3d":
        ixti = /*::Number(*/
        f2[1][1];
        r = f2[1][2];
        sname = get_ixti(supbooks, ixti, opts);
        stack.push(sname + "!" + encode_range_xls(r, opts));
        break;
      case "PtgAttrSum":
        stack.push("SUM(" + stack.pop() + ")");
        break;
      case "PtgAttrBaxcel":
      case "PtgAttrSemi":
        break;
      case "PtgName":
        nameidx = f2[1][2];
        var lbl = (supbooks.names || [])[nameidx - 1] || (supbooks[0] || [])[nameidx];
        var name = lbl ? lbl.Name : "SH33TJSNAME" + String(nameidx);
        if (name && name.slice(0, 6) == "_xlfn." && !opts.xlfn)
          name = name.slice(6);
        stack.push(name);
        break;
      case "PtgNameX":
        var bookidx = f2[1][1];
        nameidx = f2[1][2];
        var externbook;
        if (opts.biff <= 5) {
          if (bookidx < 0)
            bookidx = -bookidx;
          if (supbooks[bookidx])
            externbook = supbooks[bookidx][nameidx];
        } else {
          var o2 = "";
          if (((supbooks[bookidx] || [])[0] || [])[0] == 14849)
            ;
          else if (((supbooks[bookidx] || [])[0] || [])[0] == 1025) {
            if (supbooks[bookidx][nameidx] && supbooks[bookidx][nameidx].itab > 0) {
              o2 = supbooks.SheetNames[supbooks[bookidx][nameidx].itab - 1] + "!";
            }
          } else
            o2 = supbooks.SheetNames[nameidx - 1] + "!";
          if (supbooks[bookidx] && supbooks[bookidx][nameidx])
            o2 += supbooks[bookidx][nameidx].Name;
          else if (supbooks[0] && supbooks[0][nameidx])
            o2 += supbooks[0][nameidx].Name;
          else {
            var ixtidata = (get_ixti_raw(supbooks, bookidx, opts) || "").split(";;");
            if (ixtidata[nameidx - 1])
              o2 = ixtidata[nameidx - 1];
            else
              o2 += "SH33TJSERRX";
          }
          stack.push(o2);
          break;
        }
        if (!externbook)
          externbook = { Name: "SH33TJSERRY" };
        stack.push(externbook.Name);
        break;
      case "PtgParen":
        var lp = "(", rp = ")";
        if (last_sp >= 0) {
          sp = "";
          switch (formula[0][last_sp][1][0]) {
            case 2:
              lp = fill(" ", formula[0][last_sp][1][1]) + lp;
              break;
            case 3:
              lp = fill("\r", formula[0][last_sp][1][1]) + lp;
              break;
            case 4:
              rp = fill(" ", formula[0][last_sp][1][1]) + rp;
              break;
            case 5:
              rp = fill("\r", formula[0][last_sp][1][1]) + rp;
              break;
            default:
              if (opts.WTF)
                throw new Error("Unexpected PtgAttrSpaceType " + formula[0][last_sp][1][0]);
          }
          last_sp = -1;
        }
        stack.push(lp + stack.pop() + rp);
        break;
      case "PtgRefErr":
        stack.push("#REF!");
        break;
      case "PtgRefErr3d":
        stack.push("#REF!");
        break;
      case "PtgExp":
        c2 = { c: f2[1][1], r: f2[1][0] };
        var q2 = { c: cell.c, r: cell.r };
        if (supbooks.sharedf[encode_cell(c2)]) {
          var parsedf = supbooks.sharedf[encode_cell(c2)];
          stack.push(stringify_formula(parsedf, _range, q2, supbooks, opts));
        } else {
          var fnd = false;
          for (e1 = 0; e1 != supbooks.arrayf.length; ++e1) {
            e2 = supbooks.arrayf[e1];
            if (c2.c < e2[0].s.c || c2.c > e2[0].e.c)
              continue;
            if (c2.r < e2[0].s.r || c2.r > e2[0].e.r)
              continue;
            stack.push(stringify_formula(e2[1], _range, q2, supbooks, opts));
            fnd = true;
            break;
          }
          if (!fnd)
            stack.push(
              /*::String(*/
              f2[1]
              /*::)*/
            );
        }
        break;
      case "PtgArray":
        stack.push("{" + stringify_array(
          /*::(*/
          f2[1]
          /*:: :any)*/
        ) + "}");
        break;
      case "PtgMemArea":
        break;
      case "PtgAttrSpace":
      case "PtgAttrSpaceSemi":
        last_sp = ff;
        break;
      case "PtgTbl":
        break;
      case "PtgMemErr":
        break;
      case "PtgMissArg":
        stack.push("");
        break;
      case "PtgAreaErr":
        stack.push("#REF!");
        break;
      case "PtgAreaErr3d":
        stack.push("#REF!");
        break;
      case "PtgList":
        stack.push("Table" + f2[1].idx + "[#" + f2[1].rt + "]");
        break;
      case "PtgMemAreaN":
      case "PtgMemNoMemN":
      case "PtgAttrNoop":
      case "PtgSheet":
      case "PtgEndSheet":
        break;
      case "PtgMemFunc":
        break;
      case "PtgMemNoMem":
        break;
      case "PtgElfCol":
      case "PtgElfColS":
      case "PtgElfColSV":
      case "PtgElfColV":
      case "PtgElfLel":
      case "PtgElfRadical":
      case "PtgElfRadicalLel":
      case "PtgElfRadicalS":
      case "PtgElfRw":
      case "PtgElfRwV":
        throw new Error("Unsupported ELFs");
      case "PtgSxName":
        throw new Error("Unrecognized Formula Token: " + String(f2));
      default:
        throw new Error("Unrecognized Formula Token: " + String(f2));
    }
    var PtgNonDisp = ["PtgAttrSpace", "PtgAttrSpaceSemi", "PtgAttrGoto"];
    if (opts.biff != 3) {
      if (last_sp >= 0 && PtgNonDisp.indexOf(formula[0][ff][0]) == -1) {
        f2 = formula[0][last_sp];
        var _left = true;
        switch (f2[1][0]) {
          case 4:
            _left = false;
          case 0:
            sp = fill(" ", f2[1][1]);
            break;
          case 5:
            _left = false;
          case 1:
            sp = fill("\r", f2[1][1]);
            break;
          default:
            sp = "";
            if (opts.WTF)
              throw new Error("Unexpected PtgAttrSpaceType " + f2[1][0]);
        }
        stack.push((_left ? sp : "") + stack.pop() + (_left ? "" : sp));
        last_sp = -1;
      }
    }
  }
  if (stack.length > 1 && opts.WTF)
    throw new Error("bad formula stack");
  return stack[0];
}
__name(stringify_formula, "stringify_formula");
function write_FormulaValue(value) {
  if (value == null) {
    var o2 = new_buf(8);
    o2.write_shift(1, 3);
    o2.write_shift(1, 0);
    o2.write_shift(2, 0);
    o2.write_shift(2, 0);
    o2.write_shift(2, 65535);
    return o2;
  } else if (typeof value == "number")
    return write_Xnum(value);
  return write_Xnum(0);
}
__name(write_FormulaValue, "write_FormulaValue");
function write_Formula(cell, R2, C2, opts, os) {
  var o1 = write_XLSCell(R2, C2, os);
  var o2 = write_FormulaValue(cell.v);
  var o3 = new_buf(6);
  var flags = 1 | 32;
  o3.write_shift(2, flags);
  o3.write_shift(4, 0);
  var bf = new_buf(cell.bf.length);
  for (var i2 = 0; i2 < cell.bf.length; ++i2)
    bf[i2] = cell.bf[i2];
  var out = bconcat([o1, o2, o3, bf]);
  return out;
}
__name(write_Formula, "write_Formula");
function parse_XLSBParsedFormula(data, length, opts) {
  var cce = data.read_shift(4);
  var rgce = parse_Rgce(data, cce, opts);
  var cb = data.read_shift(4);
  var rgcb = cb > 0 ? parse_RgbExtra(data, cb, rgce, opts) : null;
  return [rgce, rgcb];
}
__name(parse_XLSBParsedFormula, "parse_XLSBParsedFormula");
var parse_XLSBArrayParsedFormula = parse_XLSBParsedFormula;
var parse_XLSBCellParsedFormula = parse_XLSBParsedFormula;
var parse_XLSBNameParsedFormula = parse_XLSBParsedFormula;
var parse_XLSBSharedParsedFormula = parse_XLSBParsedFormula;
var Cetab = {
  0: "BEEP",
  1: "OPEN",
  2: "OPEN.LINKS",
  3: "CLOSE.ALL",
  4: "SAVE",
  5: "SAVE.AS",
  6: "FILE.DELETE",
  7: "PAGE.SETUP",
  8: "PRINT",
  9: "PRINTER.SETUP",
  10: "QUIT",
  11: "NEW.WINDOW",
  12: "ARRANGE.ALL",
  13: "WINDOW.SIZE",
  14: "WINDOW.MOVE",
  15: "FULL",
  16: "CLOSE",
  17: "RUN",
  22: "SET.PRINT.AREA",
  23: "SET.PRINT.TITLES",
  24: "SET.PAGE.BREAK",
  25: "REMOVE.PAGE.BREAK",
  26: "FONT",
  27: "DISPLAY",
  28: "PROTECT.DOCUMENT",
  29: "PRECISION",
  30: "A1.R1C1",
  31: "CALCULATE.NOW",
  32: "CALCULATION",
  34: "DATA.FIND",
  35: "EXTRACT",
  36: "DATA.DELETE",
  37: "SET.DATABASE",
  38: "SET.CRITERIA",
  39: "SORT",
  40: "DATA.SERIES",
  41: "TABLE",
  42: "FORMAT.NUMBER",
  43: "ALIGNMENT",
  44: "STYLE",
  45: "BORDER",
  46: "CELL.PROTECTION",
  47: "COLUMN.WIDTH",
  48: "UNDO",
  49: "CUT",
  50: "COPY",
  51: "PASTE",
  52: "CLEAR",
  53: "PASTE.SPECIAL",
  54: "EDIT.DELETE",
  55: "INSERT",
  56: "FILL.RIGHT",
  57: "FILL.DOWN",
  61: "DEFINE.NAME",
  62: "CREATE.NAMES",
  63: "FORMULA.GOTO",
  64: "FORMULA.FIND",
  65: "SELECT.LAST.CELL",
  66: "SHOW.ACTIVE.CELL",
  67: "GALLERY.AREA",
  68: "GALLERY.BAR",
  69: "GALLERY.COLUMN",
  70: "GALLERY.LINE",
  71: "GALLERY.PIE",
  72: "GALLERY.SCATTER",
  73: "COMBINATION",
  74: "PREFERRED",
  75: "ADD.OVERLAY",
  76: "GRIDLINES",
  77: "SET.PREFERRED",
  78: "AXES",
  79: "LEGEND",
  80: "ATTACH.TEXT",
  81: "ADD.ARROW",
  82: "SELECT.CHART",
  83: "SELECT.PLOT.AREA",
  84: "PATTERNS",
  85: "MAIN.CHART",
  86: "OVERLAY",
  87: "SCALE",
  88: "FORMAT.LEGEND",
  89: "FORMAT.TEXT",
  90: "EDIT.REPEAT",
  91: "PARSE",
  92: "JUSTIFY",
  93: "HIDE",
  94: "UNHIDE",
  95: "WORKSPACE",
  96: "FORMULA",
  97: "FORMULA.FILL",
  98: "FORMULA.ARRAY",
  99: "DATA.FIND.NEXT",
  100: "DATA.FIND.PREV",
  101: "FORMULA.FIND.NEXT",
  102: "FORMULA.FIND.PREV",
  103: "ACTIVATE",
  104: "ACTIVATE.NEXT",
  105: "ACTIVATE.PREV",
  106: "UNLOCKED.NEXT",
  107: "UNLOCKED.PREV",
  108: "COPY.PICTURE",
  109: "SELECT",
  110: "DELETE.NAME",
  111: "DELETE.FORMAT",
  112: "VLINE",
  113: "HLINE",
  114: "VPAGE",
  115: "HPAGE",
  116: "VSCROLL",
  117: "HSCROLL",
  118: "ALERT",
  119: "NEW",
  120: "CANCEL.COPY",
  121: "SHOW.CLIPBOARD",
  122: "MESSAGE",
  124: "PASTE.LINK",
  125: "APP.ACTIVATE",
  126: "DELETE.ARROW",
  127: "ROW.HEIGHT",
  128: "FORMAT.MOVE",
  129: "FORMAT.SIZE",
  130: "FORMULA.REPLACE",
  131: "SEND.KEYS",
  132: "SELECT.SPECIAL",
  133: "APPLY.NAMES",
  134: "REPLACE.FONT",
  135: "FREEZE.PANES",
  136: "SHOW.INFO",
  137: "SPLIT",
  138: "ON.WINDOW",
  139: "ON.DATA",
  140: "DISABLE.INPUT",
  142: "OUTLINE",
  143: "LIST.NAMES",
  144: "FILE.CLOSE",
  145: "SAVE.WORKBOOK",
  146: "DATA.FORM",
  147: "COPY.CHART",
  148: "ON.TIME",
  149: "WAIT",
  150: "FORMAT.FONT",
  151: "FILL.UP",
  152: "FILL.LEFT",
  153: "DELETE.OVERLAY",
  155: "SHORT.MENUS",
  159: "SET.UPDATE.STATUS",
  161: "COLOR.PALETTE",
  162: "DELETE.STYLE",
  163: "WINDOW.RESTORE",
  164: "WINDOW.MAXIMIZE",
  166: "CHANGE.LINK",
  167: "CALCULATE.DOCUMENT",
  168: "ON.KEY",
  169: "APP.RESTORE",
  170: "APP.MOVE",
  171: "APP.SIZE",
  172: "APP.MINIMIZE",
  173: "APP.MAXIMIZE",
  174: "BRING.TO.FRONT",
  175: "SEND.TO.BACK",
  185: "MAIN.CHART.TYPE",
  186: "OVERLAY.CHART.TYPE",
  187: "SELECT.END",
  188: "OPEN.MAIL",
  189: "SEND.MAIL",
  190: "STANDARD.FONT",
  191: "CONSOLIDATE",
  192: "SORT.SPECIAL",
  193: "GALLERY.3D.AREA",
  194: "GALLERY.3D.COLUMN",
  195: "GALLERY.3D.LINE",
  196: "GALLERY.3D.PIE",
  197: "VIEW.3D",
  198: "GOAL.SEEK",
  199: "WORKGROUP",
  200: "FILL.GROUP",
  201: "UPDATE.LINK",
  202: "PROMOTE",
  203: "DEMOTE",
  204: "SHOW.DETAIL",
  206: "UNGROUP",
  207: "OBJECT.PROPERTIES",
  208: "SAVE.NEW.OBJECT",
  209: "SHARE",
  210: "SHARE.NAME",
  211: "DUPLICATE",
  212: "APPLY.STYLE",
  213: "ASSIGN.TO.OBJECT",
  214: "OBJECT.PROTECTION",
  215: "HIDE.OBJECT",
  216: "SET.EXTRACT",
  217: "CREATE.PUBLISHER",
  218: "SUBSCRIBE.TO",
  219: "ATTRIBUTES",
  220: "SHOW.TOOLBAR",
  222: "PRINT.PREVIEW",
  223: "EDIT.COLOR",
  224: "SHOW.LEVELS",
  225: "FORMAT.MAIN",
  226: "FORMAT.OVERLAY",
  227: "ON.RECALC",
  228: "EDIT.SERIES",
  229: "DEFINE.STYLE",
  240: "LINE.PRINT",
  243: "ENTER.DATA",
  249: "GALLERY.RADAR",
  250: "MERGE.STYLES",
  251: "EDITION.OPTIONS",
  252: "PASTE.PICTURE",
  253: "PASTE.PICTURE.LINK",
  254: "SPELLING",
  256: "ZOOM",
  259: "INSERT.OBJECT",
  260: "WINDOW.MINIMIZE",
  265: "SOUND.NOTE",
  266: "SOUND.PLAY",
  267: "FORMAT.SHAPE",
  268: "EXTEND.POLYGON",
  269: "FORMAT.AUTO",
  272: "GALLERY.3D.BAR",
  273: "GALLERY.3D.SURFACE",
  274: "FILL.AUTO",
  276: "CUSTOMIZE.TOOLBAR",
  277: "ADD.TOOL",
  278: "EDIT.OBJECT",
  279: "ON.DOUBLECLICK",
  280: "ON.ENTRY",
  281: "WORKBOOK.ADD",
  282: "WORKBOOK.MOVE",
  283: "WORKBOOK.COPY",
  284: "WORKBOOK.OPTIONS",
  285: "SAVE.WORKSPACE",
  288: "CHART.WIZARD",
  289: "DELETE.TOOL",
  290: "MOVE.TOOL",
  291: "WORKBOOK.SELECT",
  292: "WORKBOOK.ACTIVATE",
  293: "ASSIGN.TO.TOOL",
  295: "COPY.TOOL",
  296: "RESET.TOOL",
  297: "CONSTRAIN.NUMERIC",
  298: "PASTE.TOOL",
  302: "WORKBOOK.NEW",
  305: "SCENARIO.CELLS",
  306: "SCENARIO.DELETE",
  307: "SCENARIO.ADD",
  308: "SCENARIO.EDIT",
  309: "SCENARIO.SHOW",
  310: "SCENARIO.SHOW.NEXT",
  311: "SCENARIO.SUMMARY",
  312: "PIVOT.TABLE.WIZARD",
  313: "PIVOT.FIELD.PROPERTIES",
  314: "PIVOT.FIELD",
  315: "PIVOT.ITEM",
  316: "PIVOT.ADD.FIELDS",
  318: "OPTIONS.CALCULATION",
  319: "OPTIONS.EDIT",
  320: "OPTIONS.VIEW",
  321: "ADDIN.MANAGER",
  322: "MENU.EDITOR",
  323: "ATTACH.TOOLBARS",
  324: "VBAActivate",
  325: "OPTIONS.CHART",
  328: "VBA.INSERT.FILE",
  330: "VBA.PROCEDURE.DEFINITION",
  336: "ROUTING.SLIP",
  338: "ROUTE.DOCUMENT",
  339: "MAIL.LOGON",
  342: "INSERT.PICTURE",
  343: "EDIT.TOOL",
  344: "GALLERY.DOUGHNUT",
  350: "CHART.TREND",
  352: "PIVOT.ITEM.PROPERTIES",
  354: "WORKBOOK.INSERT",
  355: "OPTIONS.TRANSITION",
  356: "OPTIONS.GENERAL",
  370: "FILTER.ADVANCED",
  373: "MAIL.ADD.MAILER",
  374: "MAIL.DELETE.MAILER",
  375: "MAIL.REPLY",
  376: "MAIL.REPLY.ALL",
  377: "MAIL.FORWARD",
  378: "MAIL.NEXT.LETTER",
  379: "DATA.LABEL",
  380: "INSERT.TITLE",
  381: "FONT.PROPERTIES",
  382: "MACRO.OPTIONS",
  383: "WORKBOOK.HIDE",
  384: "WORKBOOK.UNHIDE",
  385: "WORKBOOK.DELETE",
  386: "WORKBOOK.NAME",
  388: "GALLERY.CUSTOM",
  390: "ADD.CHART.AUTOFORMAT",
  391: "DELETE.CHART.AUTOFORMAT",
  392: "CHART.ADD.DATA",
  393: "AUTO.OUTLINE",
  394: "TAB.ORDER",
  395: "SHOW.DIALOG",
  396: "SELECT.ALL",
  397: "UNGROUP.SHEETS",
  398: "SUBTOTAL.CREATE",
  399: "SUBTOTAL.REMOVE",
  400: "RENAME.OBJECT",
  412: "WORKBOOK.SCROLL",
  413: "WORKBOOK.NEXT",
  414: "WORKBOOK.PREV",
  415: "WORKBOOK.TAB.SPLIT",
  416: "FULL.SCREEN",
  417: "WORKBOOK.PROTECT",
  420: "SCROLLBAR.PROPERTIES",
  421: "PIVOT.SHOW.PAGES",
  422: "TEXT.TO.COLUMNS",
  423: "FORMAT.CHARTTYPE",
  424: "LINK.FORMAT",
  425: "TRACER.DISPLAY",
  430: "TRACER.NAVIGATE",
  431: "TRACER.CLEAR",
  432: "TRACER.ERROR",
  433: "PIVOT.FIELD.GROUP",
  434: "PIVOT.FIELD.UNGROUP",
  435: "CHECKBOX.PROPERTIES",
  436: "LABEL.PROPERTIES",
  437: "LISTBOX.PROPERTIES",
  438: "EDITBOX.PROPERTIES",
  439: "PIVOT.REFRESH",
  440: "LINK.COMBO",
  441: "OPEN.TEXT",
  442: "HIDE.DIALOG",
  443: "SET.DIALOG.FOCUS",
  444: "ENABLE.OBJECT",
  445: "PUSHBUTTON.PROPERTIES",
  446: "SET.DIALOG.DEFAULT",
  447: "FILTER",
  448: "FILTER.SHOW.ALL",
  449: "CLEAR.OUTLINE",
  450: "FUNCTION.WIZARD",
  451: "ADD.LIST.ITEM",
  452: "SET.LIST.ITEM",
  453: "REMOVE.LIST.ITEM",
  454: "SELECT.LIST.ITEM",
  455: "SET.CONTROL.VALUE",
  456: "SAVE.COPY.AS",
  458: "OPTIONS.LISTS.ADD",
  459: "OPTIONS.LISTS.DELETE",
  460: "SERIES.AXES",
  461: "SERIES.X",
  462: "SERIES.Y",
  463: "ERRORBAR.X",
  464: "ERRORBAR.Y",
  465: "FORMAT.CHART",
  466: "SERIES.ORDER",
  467: "MAIL.LOGOFF",
  468: "CLEAR.ROUTING.SLIP",
  469: "APP.ACTIVATE.MICROSOFT",
  470: "MAIL.EDIT.MAILER",
  471: "ON.SHEET",
  472: "STANDARD.WIDTH",
  473: "SCENARIO.MERGE",
  474: "SUMMARY.INFO",
  475: "FIND.FILE",
  476: "ACTIVE.CELL.FONT",
  477: "ENABLE.TIPWIZARD",
  478: "VBA.MAKE.ADDIN",
  480: "INSERTDATATABLE",
  481: "WORKGROUP.OPTIONS",
  482: "MAIL.SEND.MAILER",
  485: "AUTOCORRECT",
  489: "POST.DOCUMENT",
  491: "PICKLIST",
  493: "VIEW.SHOW",
  494: "VIEW.DEFINE",
  495: "VIEW.DELETE",
  509: "SHEET.BACKGROUND",
  510: "INSERT.MAP.OBJECT",
  511: "OPTIONS.MENONO",
  517: "MSOCHECKS",
  518: "NORMAL",
  519: "LAYOUT",
  520: "RM.PRINT.AREA",
  521: "CLEAR.PRINT.AREA",
  522: "ADD.PRINT.AREA",
  523: "MOVE.BRK",
  545: "HIDECURR.NOTE",
  546: "HIDEALL.NOTES",
  547: "DELETE.NOTE",
  548: "TRAVERSE.NOTES",
  549: "ACTIVATE.NOTES",
  620: "PROTECT.REVISIONS",
  621: "UNPROTECT.REVISIONS",
  647: "OPTIONS.ME",
  653: "WEB.PUBLISH",
  667: "NEWWEBQUERY",
  673: "PIVOT.TABLE.CHART",
  753: "OPTIONS.SAVE",
  755: "OPTIONS.SPELL",
  808: "HIDEALL.INKANNOTS"
};
var Ftab = {
  0: "COUNT",
  1: "IF",
  2: "ISNA",
  3: "ISERROR",
  4: "SUM",
  5: "AVERAGE",
  6: "MIN",
  7: "MAX",
  8: "ROW",
  9: "COLUMN",
  10: "NA",
  11: "NPV",
  12: "STDEV",
  13: "DOLLAR",
  14: "FIXED",
  15: "SIN",
  16: "COS",
  17: "TAN",
  18: "ATAN",
  19: "PI",
  20: "SQRT",
  21: "EXP",
  22: "LN",
  23: "LOG10",
  24: "ABS",
  25: "INT",
  26: "SIGN",
  27: "ROUND",
  28: "LOOKUP",
  29: "INDEX",
  30: "REPT",
  31: "MID",
  32: "LEN",
  33: "VALUE",
  34: "TRUE",
  35: "FALSE",
  36: "AND",
  37: "OR",
  38: "NOT",
  39: "MOD",
  40: "DCOUNT",
  41: "DSUM",
  42: "DAVERAGE",
  43: "DMIN",
  44: "DMAX",
  45: "DSTDEV",
  46: "VAR",
  47: "DVAR",
  48: "TEXT",
  49: "LINEST",
  50: "TREND",
  51: "LOGEST",
  52: "GROWTH",
  53: "GOTO",
  54: "HALT",
  55: "RETURN",
  56: "PV",
  57: "FV",
  58: "NPER",
  59: "PMT",
  60: "RATE",
  61: "MIRR",
  62: "IRR",
  63: "RAND",
  64: "MATCH",
  65: "DATE",
  66: "TIME",
  67: "DAY",
  68: "MONTH",
  69: "YEAR",
  70: "WEEKDAY",
  71: "HOUR",
  72: "MINUTE",
  73: "SECOND",
  74: "NOW",
  75: "AREAS",
  76: "ROWS",
  77: "COLUMNS",
  78: "OFFSET",
  79: "ABSREF",
  80: "RELREF",
  81: "ARGUMENT",
  82: "SEARCH",
  83: "TRANSPOSE",
  84: "ERROR",
  85: "STEP",
  86: "TYPE",
  87: "ECHO",
  88: "SET.NAME",
  89: "CALLER",
  90: "DEREF",
  91: "WINDOWS",
  92: "SERIES",
  93: "DOCUMENTS",
  94: "ACTIVE.CELL",
  95: "SELECTION",
  96: "RESULT",
  97: "ATAN2",
  98: "ASIN",
  99: "ACOS",
  100: "CHOOSE",
  101: "HLOOKUP",
  102: "VLOOKUP",
  103: "LINKS",
  104: "INPUT",
  105: "ISREF",
  106: "GET.FORMULA",
  107: "GET.NAME",
  108: "SET.VALUE",
  109: "LOG",
  110: "EXEC",
  111: "CHAR",
  112: "LOWER",
  113: "UPPER",
  114: "PROPER",
  115: "LEFT",
  116: "RIGHT",
  117: "EXACT",
  118: "TRIM",
  119: "REPLACE",
  120: "SUBSTITUTE",
  121: "CODE",
  122: "NAMES",
  123: "DIRECTORY",
  124: "FIND",
  125: "CELL",
  126: "ISERR",
  127: "ISTEXT",
  128: "ISNUMBER",
  129: "ISBLANK",
  130: "T",
  131: "N",
  132: "FOPEN",
  133: "FCLOSE",
  134: "FSIZE",
  135: "FREADLN",
  136: "FREAD",
  137: "FWRITELN",
  138: "FWRITE",
  139: "FPOS",
  140: "DATEVALUE",
  141: "TIMEVALUE",
  142: "SLN",
  143: "SYD",
  144: "DDB",
  145: "GET.DEF",
  146: "REFTEXT",
  147: "TEXTREF",
  148: "INDIRECT",
  149: "REGISTER",
  150: "CALL",
  151: "ADD.BAR",
  152: "ADD.MENU",
  153: "ADD.COMMAND",
  154: "ENABLE.COMMAND",
  155: "CHECK.COMMAND",
  156: "RENAME.COMMAND",
  157: "SHOW.BAR",
  158: "DELETE.MENU",
  159: "DELETE.COMMAND",
  160: "GET.CHART.ITEM",
  161: "DIALOG.BOX",
  162: "CLEAN",
  163: "MDETERM",
  164: "MINVERSE",
  165: "MMULT",
  166: "FILES",
  167: "IPMT",
  168: "PPMT",
  169: "COUNTA",
  170: "CANCEL.KEY",
  171: "FOR",
  172: "WHILE",
  173: "BREAK",
  174: "NEXT",
  175: "INITIATE",
  176: "REQUEST",
  177: "POKE",
  178: "EXECUTE",
  179: "TERMINATE",
  180: "RESTART",
  181: "HELP",
  182: "GET.BAR",
  183: "PRODUCT",
  184: "FACT",
  185: "GET.CELL",
  186: "GET.WORKSPACE",
  187: "GET.WINDOW",
  188: "GET.DOCUMENT",
  189: "DPRODUCT",
  190: "ISNONTEXT",
  191: "GET.NOTE",
  192: "NOTE",
  193: "STDEVP",
  194: "VARP",
  195: "DSTDEVP",
  196: "DVARP",
  197: "TRUNC",
  198: "ISLOGICAL",
  199: "DCOUNTA",
  200: "DELETE.BAR",
  201: "UNREGISTER",
  204: "USDOLLAR",
  205: "FINDB",
  206: "SEARCHB",
  207: "REPLACEB",
  208: "LEFTB",
  209: "RIGHTB",
  210: "MIDB",
  211: "LENB",
  212: "ROUNDUP",
  213: "ROUNDDOWN",
  214: "ASC",
  215: "DBCS",
  216: "RANK",
  219: "ADDRESS",
  220: "DAYS360",
  221: "TODAY",
  222: "VDB",
  223: "ELSE",
  224: "ELSE.IF",
  225: "END.IF",
  226: "FOR.CELL",
  227: "MEDIAN",
  228: "SUMPRODUCT",
  229: "SINH",
  230: "COSH",
  231: "TANH",
  232: "ASINH",
  233: "ACOSH",
  234: "ATANH",
  235: "DGET",
  236: "CREATE.OBJECT",
  237: "VOLATILE",
  238: "LAST.ERROR",
  239: "CUSTOM.UNDO",
  240: "CUSTOM.REPEAT",
  241: "FORMULA.CONVERT",
  242: "GET.LINK.INFO",
  243: "TEXT.BOX",
  244: "INFO",
  245: "GROUP",
  246: "GET.OBJECT",
  247: "DB",
  248: "PAUSE",
  251: "RESUME",
  252: "FREQUENCY",
  253: "ADD.TOOLBAR",
  254: "DELETE.TOOLBAR",
  255: "User",
  256: "RESET.TOOLBAR",
  257: "EVALUATE",
  258: "GET.TOOLBAR",
  259: "GET.TOOL",
  260: "SPELLING.CHECK",
  261: "ERROR.TYPE",
  262: "APP.TITLE",
  263: "WINDOW.TITLE",
  264: "SAVE.TOOLBAR",
  265: "ENABLE.TOOL",
  266: "PRESS.TOOL",
  267: "REGISTER.ID",
  268: "GET.WORKBOOK",
  269: "AVEDEV",
  270: "BETADIST",
  271: "GAMMALN",
  272: "BETAINV",
  273: "BINOMDIST",
  274: "CHIDIST",
  275: "CHIINV",
  276: "COMBIN",
  277: "CONFIDENCE",
  278: "CRITBINOM",
  279: "EVEN",
  280: "EXPONDIST",
  281: "FDIST",
  282: "FINV",
  283: "FISHER",
  284: "FISHERINV",
  285: "FLOOR",
  286: "GAMMADIST",
  287: "GAMMAINV",
  288: "CEILING",
  289: "HYPGEOMDIST",
  290: "LOGNORMDIST",
  291: "LOGINV",
  292: "NEGBINOMDIST",
  293: "NORMDIST",
  294: "NORMSDIST",
  295: "NORMINV",
  296: "NORMSINV",
  297: "STANDARDIZE",
  298: "ODD",
  299: "PERMUT",
  300: "POISSON",
  301: "TDIST",
  302: "WEIBULL",
  303: "SUMXMY2",
  304: "SUMX2MY2",
  305: "SUMX2PY2",
  306: "CHITEST",
  307: "CORREL",
  308: "COVAR",
  309: "FORECAST",
  310: "FTEST",
  311: "INTERCEPT",
  312: "PEARSON",
  313: "RSQ",
  314: "STEYX",
  315: "SLOPE",
  316: "TTEST",
  317: "PROB",
  318: "DEVSQ",
  319: "GEOMEAN",
  320: "HARMEAN",
  321: "SUMSQ",
  322: "KURT",
  323: "SKEW",
  324: "ZTEST",
  325: "LARGE",
  326: "SMALL",
  327: "QUARTILE",
  328: "PERCENTILE",
  329: "PERCENTRANK",
  330: "MODE",
  331: "TRIMMEAN",
  332: "TINV",
  334: "MOVIE.COMMAND",
  335: "GET.MOVIE",
  336: "CONCATENATE",
  337: "POWER",
  338: "PIVOT.ADD.DATA",
  339: "GET.PIVOT.TABLE",
  340: "GET.PIVOT.FIELD",
  341: "GET.PIVOT.ITEM",
  342: "RADIANS",
  343: "DEGREES",
  344: "SUBTOTAL",
  345: "SUMIF",
  346: "COUNTIF",
  347: "COUNTBLANK",
  348: "SCENARIO.GET",
  349: "OPTIONS.LISTS.GET",
  350: "ISPMT",
  351: "DATEDIF",
  352: "DATESTRING",
  353: "NUMBERSTRING",
  354: "ROMAN",
  355: "OPEN.DIALOG",
  356: "SAVE.DIALOG",
  357: "VIEW.GET",
  358: "GETPIVOTDATA",
  359: "HYPERLINK",
  360: "PHONETIC",
  361: "AVERAGEA",
  362: "MAXA",
  363: "MINA",
  364: "STDEVPA",
  365: "VARPA",
  366: "STDEVA",
  367: "VARA",
  368: "BAHTTEXT",
  369: "THAIDAYOFWEEK",
  370: "THAIDIGIT",
  371: "THAIMONTHOFYEAR",
  372: "THAINUMSOUND",
  373: "THAINUMSTRING",
  374: "THAISTRINGLENGTH",
  375: "ISTHAIDIGIT",
  376: "ROUNDBAHTDOWN",
  377: "ROUNDBAHTUP",
  378: "THAIYEAR",
  379: "RTD",
  380: "CUBEVALUE",
  381: "CUBEMEMBER",
  382: "CUBEMEMBERPROPERTY",
  383: "CUBERANKEDMEMBER",
  384: "HEX2BIN",
  385: "HEX2DEC",
  386: "HEX2OCT",
  387: "DEC2BIN",
  388: "DEC2HEX",
  389: "DEC2OCT",
  390: "OCT2BIN",
  391: "OCT2HEX",
  392: "OCT2DEC",
  393: "BIN2DEC",
  394: "BIN2OCT",
  395: "BIN2HEX",
  396: "IMSUB",
  397: "IMDIV",
  398: "IMPOWER",
  399: "IMABS",
  400: "IMSQRT",
  401: "IMLN",
  402: "IMLOG2",
  403: "IMLOG10",
  404: "IMSIN",
  405: "IMCOS",
  406: "IMEXP",
  407: "IMARGUMENT",
  408: "IMCONJUGATE",
  409: "IMAGINARY",
  410: "IMREAL",
  411: "COMPLEX",
  412: "IMSUM",
  413: "IMPRODUCT",
  414: "SERIESSUM",
  415: "FACTDOUBLE",
  416: "SQRTPI",
  417: "QUOTIENT",
  418: "DELTA",
  419: "GESTEP",
  420: "ISEVEN",
  421: "ISODD",
  422: "MROUND",
  423: "ERF",
  424: "ERFC",
  425: "BESSELJ",
  426: "BESSELK",
  427: "BESSELY",
  428: "BESSELI",
  429: "XIRR",
  430: "XNPV",
  431: "PRICEMAT",
  432: "YIELDMAT",
  433: "INTRATE",
  434: "RECEIVED",
  435: "DISC",
  436: "PRICEDISC",
  437: "YIELDDISC",
  438: "TBILLEQ",
  439: "TBILLPRICE",
  440: "TBILLYIELD",
  441: "PRICE",
  442: "YIELD",
  443: "DOLLARDE",
  444: "DOLLARFR",
  445: "NOMINAL",
  446: "EFFECT",
  447: "CUMPRINC",
  448: "CUMIPMT",
  449: "EDATE",
  450: "EOMONTH",
  451: "YEARFRAC",
  452: "COUPDAYBS",
  453: "COUPDAYS",
  454: "COUPDAYSNC",
  455: "COUPNCD",
  456: "COUPNUM",
  457: "COUPPCD",
  458: "DURATION",
  459: "MDURATION",
  460: "ODDLPRICE",
  461: "ODDLYIELD",
  462: "ODDFPRICE",
  463: "ODDFYIELD",
  464: "RANDBETWEEN",
  465: "WEEKNUM",
  466: "AMORDEGRC",
  467: "AMORLINC",
  468: "CONVERT",
  724: "SHEETJS",
  469: "ACCRINT",
  470: "ACCRINTM",
  471: "WORKDAY",
  472: "NETWORKDAYS",
  473: "GCD",
  474: "MULTINOMIAL",
  475: "LCM",
  476: "FVSCHEDULE",
  477: "CUBEKPIMEMBER",
  478: "CUBESET",
  479: "CUBESETCOUNT",
  480: "IFERROR",
  481: "COUNTIFS",
  482: "SUMIFS",
  483: "AVERAGEIF",
  484: "AVERAGEIFS"
};
var FtabArgc = {
  2: 1,
  3: 1,
  10: 0,
  15: 1,
  16: 1,
  17: 1,
  18: 1,
  19: 0,
  20: 1,
  21: 1,
  22: 1,
  23: 1,
  24: 1,
  25: 1,
  26: 1,
  27: 2,
  30: 2,
  31: 3,
  32: 1,
  33: 1,
  34: 0,
  35: 0,
  38: 1,
  39: 2,
  40: 3,
  41: 3,
  42: 3,
  43: 3,
  44: 3,
  45: 3,
  47: 3,
  48: 2,
  53: 1,
  61: 3,
  63: 0,
  65: 3,
  66: 3,
  67: 1,
  68: 1,
  69: 1,
  70: 1,
  71: 1,
  72: 1,
  73: 1,
  74: 0,
  75: 1,
  76: 1,
  77: 1,
  79: 2,
  80: 2,
  83: 1,
  85: 0,
  86: 1,
  89: 0,
  90: 1,
  94: 0,
  95: 0,
  97: 2,
  98: 1,
  99: 1,
  101: 3,
  102: 3,
  105: 1,
  106: 1,
  108: 2,
  111: 1,
  112: 1,
  113: 1,
  114: 1,
  117: 2,
  118: 1,
  119: 4,
  121: 1,
  126: 1,
  127: 1,
  128: 1,
  129: 1,
  130: 1,
  131: 1,
  133: 1,
  134: 1,
  135: 1,
  136: 2,
  137: 2,
  138: 2,
  140: 1,
  141: 1,
  142: 3,
  143: 4,
  144: 4,
  161: 1,
  162: 1,
  163: 1,
  164: 1,
  165: 2,
  172: 1,
  175: 2,
  176: 2,
  177: 3,
  178: 2,
  179: 1,
  184: 1,
  186: 1,
  189: 3,
  190: 1,
  195: 3,
  196: 3,
  197: 1,
  198: 1,
  199: 3,
  201: 1,
  207: 4,
  210: 3,
  211: 1,
  212: 2,
  213: 2,
  214: 1,
  215: 1,
  225: 0,
  229: 1,
  230: 1,
  231: 1,
  232: 1,
  233: 1,
  234: 1,
  235: 3,
  244: 1,
  247: 4,
  252: 2,
  257: 1,
  261: 1,
  271: 1,
  273: 4,
  274: 2,
  275: 2,
  276: 2,
  277: 3,
  278: 3,
  279: 1,
  280: 3,
  281: 3,
  282: 3,
  283: 1,
  284: 1,
  285: 2,
  286: 4,
  287: 3,
  288: 2,
  289: 4,
  290: 3,
  291: 3,
  292: 3,
  293: 4,
  294: 1,
  295: 3,
  296: 1,
  297: 3,
  298: 1,
  299: 2,
  300: 3,
  301: 3,
  302: 4,
  303: 2,
  304: 2,
  305: 2,
  306: 2,
  307: 2,
  308: 2,
  309: 3,
  310: 2,
  311: 2,
  312: 2,
  313: 2,
  314: 2,
  315: 2,
  316: 4,
  325: 2,
  326: 2,
  327: 2,
  328: 2,
  331: 2,
  332: 2,
  337: 2,
  342: 1,
  343: 1,
  346: 2,
  347: 1,
  350: 4,
  351: 3,
  352: 1,
  353: 2,
  360: 1,
  368: 1,
  369: 1,
  370: 1,
  371: 1,
  372: 1,
  373: 1,
  374: 1,
  375: 1,
  376: 1,
  377: 1,
  378: 1,
  382: 3,
  385: 1,
  392: 1,
  393: 1,
  396: 2,
  397: 2,
  398: 2,
  399: 1,
  400: 1,
  401: 1,
  402: 1,
  403: 1,
  404: 1,
  405: 1,
  406: 1,
  407: 1,
  408: 1,
  409: 1,
  410: 1,
  414: 4,
  415: 1,
  416: 1,
  417: 2,
  420: 1,
  421: 1,
  422: 2,
  424: 1,
  425: 2,
  426: 2,
  427: 2,
  428: 2,
  430: 3,
  438: 3,
  439: 3,
  440: 3,
  443: 2,
  444: 2,
  445: 2,
  446: 2,
  447: 6,
  448: 6,
  449: 2,
  450: 2,
  464: 2,
  468: 3,
  476: 2,
  479: 1,
  480: 2,
  65535: 0
};
function csf_to_ods_formula(f2) {
  var o2 = "of:=" + f2.replace(crefregex, "$1[.$2$3$4$5]").replace(/\]:\[/g, ":");
  return o2.replace(/;/g, "|").replace(/,/g, ";");
}
__name(csf_to_ods_formula, "csf_to_ods_formula");
function csf_to_ods_3D(r) {
  return r.replace(/\./, "!");
}
__name(csf_to_ods_3D, "csf_to_ods_3D");
var browser_has_Map = typeof Map !== "undefined";
function get_sst_id(sst, str, rev2) {
  var i2 = 0, len = sst.length;
  if (rev2) {
    if (browser_has_Map ? rev2.has(str) : Object.prototype.hasOwnProperty.call(rev2, str)) {
      var revarr = browser_has_Map ? rev2.get(str) : rev2[str];
      for (; i2 < revarr.length; ++i2) {
        if (sst[revarr[i2]].t === str) {
          sst.Count++;
          return revarr[i2];
        }
      }
    }
  } else
    for (; i2 < len; ++i2) {
      if (sst[i2].t === str) {
        sst.Count++;
        return i2;
      }
    }
  sst[len] = { t: str };
  sst.Count++;
  sst.Unique++;
  if (rev2) {
    if (browser_has_Map) {
      if (!rev2.has(str))
        rev2.set(str, []);
      rev2.get(str).push(len);
    } else {
      if (!Object.prototype.hasOwnProperty.call(rev2, str))
        rev2[str] = [];
      rev2[str].push(len);
    }
  }
  return len;
}
__name(get_sst_id, "get_sst_id");
function col_obj_w(C2, col) {
  var p2 = { min: C2 + 1, max: C2 + 1 };
  var wch = -1;
  if (col.MDW)
    MDW = col.MDW;
  if (col.width != null)
    p2.customWidth = 1;
  else if (col.wpx != null)
    wch = px2char(col.wpx);
  else if (col.wch != null)
    wch = col.wch;
  if (wch > -1) {
    p2.width = char2width(wch);
    p2.customWidth = 1;
  } else if (col.width != null)
    p2.width = col.width;
  if (col.hidden)
    p2.hidden = true;
  if (col.level != null) {
    p2.outlineLevel = p2.level = col.level;
  }
  return p2;
}
__name(col_obj_w, "col_obj_w");
function default_margins(margins, mode) {
  if (!margins)
    return;
  var defs = [0.7, 0.7, 0.75, 0.75, 0.3, 0.3];
  if (mode == "xlml")
    defs = [1, 1, 1, 1, 0.5, 0.5];
  if (margins.left == null)
    margins.left = defs[0];
  if (margins.right == null)
    margins.right = defs[1];
  if (margins.top == null)
    margins.top = defs[2];
  if (margins.bottom == null)
    margins.bottom = defs[3];
  if (margins.header == null)
    margins.header = defs[4];
  if (margins.footer == null)
    margins.footer = defs[5];
}
__name(default_margins, "default_margins");
function get_cell_style(styles, cell, opts) {
  var z2 = opts.revssf[cell.z != null ? cell.z : "General"];
  var i2 = 60, len = styles.length;
  if (z2 == null && opts.ssf) {
    for (; i2 < 392; ++i2)
      if (opts.ssf[i2] == null) {
        SSF_load(cell.z, i2);
        opts.ssf[i2] = cell.z;
        opts.revssf[cell.z] = z2 = i2;
        break;
      }
  }
  for (i2 = 0; i2 != len; ++i2)
    if (styles[i2].numFmtId === z2)
      return i2;
  styles[len] = {
    numFmtId: z2,
    fontId: 0,
    fillId: 0,
    borderId: 0,
    xfId: 0,
    applyNumberFormat: 1
  };
  return len;
}
__name(get_cell_style, "get_cell_style");
function check_ws(ws, sname, i2) {
  if (ws && ws["!ref"]) {
    var range = safe_decode_range(ws["!ref"]);
    if (range.e.c < range.s.c || range.e.r < range.s.r)
      throw new Error("Bad range (" + i2 + "): " + ws["!ref"]);
  }
}
__name(check_ws, "check_ws");
function write_ws_xml_merges(merges) {
  if (merges.length === 0)
    return "";
  var o2 = '<mergeCells count="' + merges.length + '">';
  for (var i2 = 0; i2 != merges.length; ++i2)
    o2 += '<mergeCell ref="' + encode_range(merges[i2]) + '"/>';
  return o2 + "</mergeCells>";
}
__name(write_ws_xml_merges, "write_ws_xml_merges");
function write_ws_xml_sheetpr(ws, wb, idx, opts, o2) {
  var needed = false;
  var props = {}, payload = null;
  if (opts.bookType !== "xlsx" && wb.vbaraw) {
    var cname = wb.SheetNames[idx];
    try {
      if (wb.Workbook)
        cname = wb.Workbook.Sheets[idx].CodeName || cname;
    } catch (e) {
    }
    needed = true;
    props.codeName = utf8write(escapexml(cname));
  }
  if (ws && ws["!outline"]) {
    var outlineprops = { summaryBelow: 1, summaryRight: 1 };
    if (ws["!outline"].above)
      outlineprops.summaryBelow = 0;
    if (ws["!outline"].left)
      outlineprops.summaryRight = 0;
    payload = (payload || "") + writextag("outlinePr", null, outlineprops);
  }
  if (!needed && !payload)
    return;
  o2[o2.length] = writextag("sheetPr", payload, props);
}
__name(write_ws_xml_sheetpr, "write_ws_xml_sheetpr");
var sheetprot_deffalse = ["objects", "scenarios", "selectLockedCells", "selectUnlockedCells"];
var sheetprot_deftrue = [
  "formatColumns",
  "formatRows",
  "formatCells",
  "insertColumns",
  "insertRows",
  "insertHyperlinks",
  "deleteColumns",
  "deleteRows",
  "sort",
  "autoFilter",
  "pivotTables"
];
function write_ws_xml_protection(sp) {
  var o2 = { sheet: 1 };
  sheetprot_deffalse.forEach(function(n2) {
    if (sp[n2] != null && sp[n2])
      o2[n2] = "1";
  });
  sheetprot_deftrue.forEach(function(n2) {
    if (sp[n2] != null && !sp[n2])
      o2[n2] = "0";
  });
  if (sp.password)
    o2.password = crypto_CreatePasswordVerifier_Method1(sp.password).toString(16).toUpperCase();
  return writextag("sheetProtection", null, o2);
}
__name(write_ws_xml_protection, "write_ws_xml_protection");
function write_ws_xml_margins(margin) {
  default_margins(margin);
  return writextag("pageMargins", null, margin);
}
__name(write_ws_xml_margins, "write_ws_xml_margins");
function write_ws_xml_cols(ws, cols) {
  var o2 = ["<cols>"], col;
  for (var i2 = 0; i2 != cols.length; ++i2) {
    if (!(col = cols[i2]))
      continue;
    o2[o2.length] = writextag("col", null, col_obj_w(i2, col));
  }
  o2[o2.length] = "</cols>";
  return o2.join("");
}
__name(write_ws_xml_cols, "write_ws_xml_cols");
function write_ws_xml_autofilter(data, ws, wb, idx) {
  var ref = typeof data.ref == "string" ? data.ref : encode_range(data.ref);
  if (!wb.Workbook)
    wb.Workbook = { Sheets: [] };
  if (!wb.Workbook.Names)
    wb.Workbook.Names = [];
  var names2 = wb.Workbook.Names;
  var range = decode_range(ref);
  if (range.s.r == range.e.r) {
    range.e.r = decode_range(ws["!ref"]).e.r;
    ref = encode_range(range);
  }
  for (var i2 = 0; i2 < names2.length; ++i2) {
    var name = names2[i2];
    if (name.Name != "_xlnm._FilterDatabase")
      continue;
    if (name.Sheet != idx)
      continue;
    name.Ref = "'" + wb.SheetNames[idx] + "'!" + ref;
    break;
  }
  if (i2 == names2.length)
    names2.push({ Name: "_xlnm._FilterDatabase", Sheet: idx, Ref: "'" + wb.SheetNames[idx] + "'!" + ref });
  return writextag("autoFilter", null, { ref });
}
__name(write_ws_xml_autofilter, "write_ws_xml_autofilter");
function write_ws_xml_sheetviews(ws, opts, idx, wb) {
  var sview = { workbookViewId: "0" };
  if ((((wb || {}).Workbook || {}).Views || [])[0])
    sview.rightToLeft = wb.Workbook.Views[0].RTL ? "1" : "0";
  return writextag("sheetViews", writextag("sheetView", null, sview), {});
}
__name(write_ws_xml_sheetviews, "write_ws_xml_sheetviews");
function write_ws_xml_cell(cell, ref, ws, opts) {
  if (cell.c)
    ws["!comments"].push([ref, cell.c]);
  if (cell.v === void 0 && typeof cell.f !== "string" || cell.t === "z" && !cell.f)
    return "";
  var vv = "";
  var oldt = cell.t, oldv = cell.v;
  if (cell.t !== "z")
    switch (cell.t) {
      case "b":
        vv = cell.v ? "1" : "0";
        break;
      case "n":
        vv = "" + cell.v;
        break;
      case "e":
        vv = BErr[cell.v];
        break;
      case "d":
        if (opts && opts.cellDates)
          vv = parseDate(cell.v, -1).toISOString();
        else {
          cell = dup(cell);
          cell.t = "n";
          vv = "" + (cell.v = datenum(parseDate(cell.v)));
        }
        if (typeof cell.z === "undefined")
          cell.z = table_fmt[14];
        break;
      default:
        vv = cell.v;
        break;
    }
  var v2 = writetag("v", escapexml(vv)), o2 = { r: ref };
  var os = get_cell_style(opts.cellXfs, cell, opts);
  if (os !== 0)
    o2.s = os;
  switch (cell.t) {
    case "n":
      break;
    case "d":
      o2.t = "d";
      break;
    case "b":
      o2.t = "b";
      break;
    case "e":
      o2.t = "e";
      break;
    case "z":
      break;
    default:
      if (cell.v == null) {
        delete cell.t;
        break;
      }
      if (cell.v.length > 32767)
        throw new Error("Text length must not exceed 32767 characters");
      if (opts && opts.bookSST) {
        v2 = writetag("v", "" + get_sst_id(opts.Strings, cell.v, opts.revStrings));
        o2.t = "s";
        break;
      }
      o2.t = "str";
      break;
  }
  if (cell.t != oldt) {
    cell.t = oldt;
    cell.v = oldv;
  }
  if (typeof cell.f == "string" && cell.f) {
    var ff = cell.F && cell.F.slice(0, ref.length) == ref ? { t: "array", ref: cell.F } : null;
    v2 = writextag("f", escapexml(cell.f), ff) + (cell.v != null ? v2 : "");
  }
  if (cell.l)
    ws["!links"].push([ref, cell.l]);
  if (cell.D)
    o2.cm = 1;
  return writextag("c", v2, o2);
}
__name(write_ws_xml_cell, "write_ws_xml_cell");
function write_ws_xml_data(ws, opts, idx, wb) {
  var o2 = [], r = [], range = safe_decode_range(ws["!ref"]), cell = "", ref, rr = "", cols = [], R2 = 0, C2 = 0, rows = ws["!rows"];
  var dense = Array.isArray(ws);
  var params = { r: rr }, row, height = -1;
  for (C2 = range.s.c; C2 <= range.e.c; ++C2)
    cols[C2] = encode_col(C2);
  for (R2 = range.s.r; R2 <= range.e.r; ++R2) {
    r = [];
    rr = encode_row(R2);
    for (C2 = range.s.c; C2 <= range.e.c; ++C2) {
      ref = cols[C2] + rr;
      var _cell = dense ? (ws[R2] || [])[C2] : ws[ref];
      if (_cell === void 0)
        continue;
      if ((cell = write_ws_xml_cell(_cell, ref, ws, opts)) != null)
        r.push(cell);
    }
    if (r.length > 0 || rows && rows[R2]) {
      params = { r: rr };
      if (rows && rows[R2]) {
        row = rows[R2];
        if (row.hidden)
          params.hidden = 1;
        height = -1;
        if (row.hpx)
          height = px2pt(row.hpx);
        else if (row.hpt)
          height = row.hpt;
        if (height > -1) {
          params.ht = height;
          params.customHeight = 1;
        }
        if (row.level) {
          params.outlineLevel = row.level;
        }
      }
      o2[o2.length] = writextag("row", r.join(""), params);
    }
  }
  if (rows)
    for (; R2 < rows.length; ++R2) {
      if (rows && rows[R2]) {
        params = { r: R2 + 1 };
        row = rows[R2];
        if (row.hidden)
          params.hidden = 1;
        height = -1;
        if (row.hpx)
          height = px2pt(row.hpx);
        else if (row.hpt)
          height = row.hpt;
        if (height > -1) {
          params.ht = height;
          params.customHeight = 1;
        }
        if (row.level) {
          params.outlineLevel = row.level;
        }
        o2[o2.length] = writextag("row", "", params);
      }
    }
  return o2.join("");
}
__name(write_ws_xml_data, "write_ws_xml_data");
function write_ws_xml(idx, opts, wb, rels) {
  var o2 = [XML_HEADER, writextag("worksheet", null, {
    "xmlns": XMLNS_main[0],
    "xmlns:r": XMLNS.r
  })];
  var s2 = wb.SheetNames[idx], sidx = 0, rdata = "";
  var ws = wb.Sheets[s2];
  if (ws == null)
    ws = {};
  var ref = ws["!ref"] || "A1";
  var range = safe_decode_range(ref);
  if (range.e.c > 16383 || range.e.r > 1048575) {
    if (opts.WTF)
      throw new Error("Range " + ref + " exceeds format limit A1:XFD1048576");
    range.e.c = Math.min(range.e.c, 16383);
    range.e.r = Math.min(range.e.c, 1048575);
    ref = encode_range(range);
  }
  if (!rels)
    rels = {};
  ws["!comments"] = [];
  var _drawing = [];
  write_ws_xml_sheetpr(ws, wb, idx, opts, o2);
  o2[o2.length] = writextag("dimension", null, { "ref": ref });
  o2[o2.length] = write_ws_xml_sheetviews(ws, opts, idx, wb);
  if (opts.sheetFormat)
    o2[o2.length] = writextag("sheetFormatPr", null, {
      defaultRowHeight: opts.sheetFormat.defaultRowHeight || "16",
      baseColWidth: opts.sheetFormat.baseColWidth || "10",
      outlineLevelRow: opts.sheetFormat.outlineLevelRow || "7"
    });
  if (ws["!cols"] != null && ws["!cols"].length > 0)
    o2[o2.length] = write_ws_xml_cols(ws, ws["!cols"]);
  o2[sidx = o2.length] = "<sheetData/>";
  ws["!links"] = [];
  if (ws["!ref"] != null) {
    rdata = write_ws_xml_data(ws, opts);
    if (rdata.length > 0)
      o2[o2.length] = rdata;
  }
  if (o2.length > sidx + 1) {
    o2[o2.length] = "</sheetData>";
    o2[sidx] = o2[sidx].replace("/>", ">");
  }
  if (ws["!protect"])
    o2[o2.length] = write_ws_xml_protection(ws["!protect"]);
  if (ws["!autofilter"] != null)
    o2[o2.length] = write_ws_xml_autofilter(ws["!autofilter"], ws, wb, idx);
  if (ws["!merges"] != null && ws["!merges"].length > 0)
    o2[o2.length] = write_ws_xml_merges(ws["!merges"]);
  var relc = -1, rel, rId = -1;
  if (
    /*::(*/
    ws["!links"].length > 0
  ) {
    o2[o2.length] = "<hyperlinks>";
    ws["!links"].forEach(function(l2) {
      if (!l2[1].Target)
        return;
      rel = { "ref": l2[0] };
      if (l2[1].Target.charAt(0) != "#") {
        rId = add_rels(rels, -1, escapexml(l2[1].Target).replace(/#.*$/, ""), RELS.HLINK);
        rel["r:id"] = "rId" + rId;
      }
      if ((relc = l2[1].Target.indexOf("#")) > -1)
        rel.location = escapexml(l2[1].Target.slice(relc + 1));
      if (l2[1].Tooltip)
        rel.tooltip = escapexml(l2[1].Tooltip);
      o2[o2.length] = writextag("hyperlink", null, rel);
    });
    o2[o2.length] = "</hyperlinks>";
  }
  delete ws["!links"];
  if (ws["!margins"] != null)
    o2[o2.length] = write_ws_xml_margins(ws["!margins"]);
  if (!opts || opts.ignoreEC || opts.ignoreEC == void 0)
    o2[o2.length] = writetag("ignoredErrors", writextag("ignoredError", null, { numberStoredAsText: 1, sqref: ref }));
  if (_drawing.length > 0) {
    rId = add_rels(rels, -1, "../drawings/drawing" + (idx + 1) + ".xml", RELS.DRAW);
    o2[o2.length] = writextag("drawing", null, { "r:id": "rId" + rId });
    ws["!drawing"] = _drawing;
  }
  if (ws["!comments"].length > 0) {
    rId = add_rels(rels, -1, "../drawings/vmlDrawing" + (idx + 1) + ".vml", RELS.VML);
    o2[o2.length] = writextag("legacyDrawing", null, { "r:id": "rId" + rId });
    ws["!legacy"] = rId;
  }
  if (o2.length > 1) {
    o2[o2.length] = "</worksheet>";
    o2[1] = o2[1].replace("/>", ">");
  }
  return o2.join("");
}
__name(write_ws_xml, "write_ws_xml");
function parse_BrtRowHdr(data, length) {
  var z2 = {};
  var tgt = data.l + length;
  z2.r = data.read_shift(4);
  data.l += 4;
  var miyRw = data.read_shift(2);
  data.l += 1;
  var flags = data.read_shift(1);
  data.l = tgt;
  if (flags & 7)
    z2.level = flags & 7;
  if (flags & 16)
    z2.hidden = true;
  if (flags & 32)
    z2.hpt = miyRw / 20;
  return z2;
}
__name(parse_BrtRowHdr, "parse_BrtRowHdr");
function write_BrtRowHdr(R2, range, ws) {
  var o2 = new_buf(17 + 8 * 16);
  var row = (ws["!rows"] || [])[R2] || {};
  o2.write_shift(4, R2);
  o2.write_shift(4, 0);
  var miyRw = 320;
  if (row.hpx)
    miyRw = px2pt(row.hpx) * 20;
  else if (row.hpt)
    miyRw = row.hpt * 20;
  o2.write_shift(2, miyRw);
  o2.write_shift(1, 0);
  var flags = 0;
  if (row.level)
    flags |= row.level;
  if (row.hidden)
    flags |= 16;
  if (row.hpx || row.hpt)
    flags |= 32;
  o2.write_shift(1, flags);
  o2.write_shift(1, 0);
  var ncolspan = 0, lcs = o2.l;
  o2.l += 4;
  var caddr = { r: R2, c: 0 };
  for (var i2 = 0; i2 < 16; ++i2) {
    if (range.s.c > i2 + 1 << 10 || range.e.c < i2 << 10)
      continue;
    var first = -1, last = -1;
    for (var j2 = i2 << 10; j2 < i2 + 1 << 10; ++j2) {
      caddr.c = j2;
      var cell = Array.isArray(ws) ? (ws[caddr.r] || [])[caddr.c] : ws[encode_cell(caddr)];
      if (cell) {
        if (first < 0)
          first = j2;
        last = j2;
      }
    }
    if (first < 0)
      continue;
    ++ncolspan;
    o2.write_shift(4, first);
    o2.write_shift(4, last);
  }
  var l2 = o2.l;
  o2.l = lcs;
  o2.write_shift(4, ncolspan);
  o2.l = l2;
  return o2.length > o2.l ? o2.slice(0, o2.l) : o2;
}
__name(write_BrtRowHdr, "write_BrtRowHdr");
function write_row_header(ba, ws, range, R2) {
  var o2 = write_BrtRowHdr(R2, range, ws);
  if (o2.length > 17 || (ws["!rows"] || [])[R2])
    write_record(ba, 0, o2);
}
__name(write_row_header, "write_row_header");
var parse_BrtWsDim = parse_UncheckedRfX;
var write_BrtWsDim = write_UncheckedRfX;
function parse_BrtWsFmtInfo() {
}
__name(parse_BrtWsFmtInfo, "parse_BrtWsFmtInfo");
function parse_BrtWsProp(data, length) {
  var z2 = {};
  var f2 = data[data.l];
  ++data.l;
  z2.above = !(f2 & 64);
  z2.left = !(f2 & 128);
  data.l += 18;
  z2.name = parse_XLSBCodeName(data);
  return z2;
}
__name(parse_BrtWsProp, "parse_BrtWsProp");
function write_BrtWsProp(str, outl, o2) {
  if (o2 == null)
    o2 = new_buf(84 + 4 * str.length);
  var f2 = 192;
  if (outl) {
    if (outl.above)
      f2 &= ~64;
    if (outl.left)
      f2 &= ~128;
  }
  o2.write_shift(1, f2);
  for (var i2 = 1; i2 < 3; ++i2)
    o2.write_shift(1, 0);
  write_BrtColor({ auto: 1 }, o2);
  o2.write_shift(-4, -1);
  o2.write_shift(-4, -1);
  write_XLSBCodeName(str, o2);
  return o2.slice(0, o2.l);
}
__name(write_BrtWsProp, "write_BrtWsProp");
function parse_BrtCellBlank(data) {
  var cell = parse_XLSBCell(data);
  return [cell];
}
__name(parse_BrtCellBlank, "parse_BrtCellBlank");
function write_BrtCellBlank(cell, ncell, o2) {
  if (o2 == null)
    o2 = new_buf(8);
  return write_XLSBCell(ncell, o2);
}
__name(write_BrtCellBlank, "write_BrtCellBlank");
function parse_BrtShortBlank(data) {
  var cell = parse_XLSBShortCell(data);
  return [cell];
}
__name(parse_BrtShortBlank, "parse_BrtShortBlank");
function write_BrtShortBlank(cell, ncell, o2) {
  if (o2 == null)
    o2 = new_buf(4);
  return write_XLSBShortCell(ncell, o2);
}
__name(write_BrtShortBlank, "write_BrtShortBlank");
function parse_BrtCellBool(data) {
  var cell = parse_XLSBCell(data);
  var fBool = data.read_shift(1);
  return [cell, fBool, "b"];
}
__name(parse_BrtCellBool, "parse_BrtCellBool");
function write_BrtCellBool(cell, ncell, o2) {
  if (o2 == null)
    o2 = new_buf(9);
  write_XLSBCell(ncell, o2);
  o2.write_shift(1, cell.v ? 1 : 0);
  return o2;
}
__name(write_BrtCellBool, "write_BrtCellBool");
function parse_BrtShortBool(data) {
  var cell = parse_XLSBShortCell(data);
  var fBool = data.read_shift(1);
  return [cell, fBool, "b"];
}
__name(parse_BrtShortBool, "parse_BrtShortBool");
function write_BrtShortBool(cell, ncell, o2) {
  if (o2 == null)
    o2 = new_buf(5);
  write_XLSBShortCell(ncell, o2);
  o2.write_shift(1, cell.v ? 1 : 0);
  return o2;
}
__name(write_BrtShortBool, "write_BrtShortBool");
function parse_BrtCellError(data) {
  var cell = parse_XLSBCell(data);
  var bError = data.read_shift(1);
  return [cell, bError, "e"];
}
__name(parse_BrtCellError, "parse_BrtCellError");
function write_BrtCellError(cell, ncell, o2) {
  if (o2 == null)
    o2 = new_buf(9);
  write_XLSBCell(ncell, o2);
  o2.write_shift(1, cell.v);
  return o2;
}
__name(write_BrtCellError, "write_BrtCellError");
function parse_BrtShortError(data) {
  var cell = parse_XLSBShortCell(data);
  var bError = data.read_shift(1);
  return [cell, bError, "e"];
}
__name(parse_BrtShortError, "parse_BrtShortError");
function write_BrtShortError(cell, ncell, o2) {
  if (o2 == null)
    o2 = new_buf(8);
  write_XLSBShortCell(ncell, o2);
  o2.write_shift(1, cell.v);
  o2.write_shift(2, 0);
  o2.write_shift(1, 0);
  return o2;
}
__name(write_BrtShortError, "write_BrtShortError");
function parse_BrtCellIsst(data) {
  var cell = parse_XLSBCell(data);
  var isst = data.read_shift(4);
  return [cell, isst, "s"];
}
__name(parse_BrtCellIsst, "parse_BrtCellIsst");
function write_BrtCellIsst(cell, ncell, o2) {
  if (o2 == null)
    o2 = new_buf(12);
  write_XLSBCell(ncell, o2);
  o2.write_shift(4, ncell.v);
  return o2;
}
__name(write_BrtCellIsst, "write_BrtCellIsst");
function parse_BrtShortIsst(data) {
  var cell = parse_XLSBShortCell(data);
  var isst = data.read_shift(4);
  return [cell, isst, "s"];
}
__name(parse_BrtShortIsst, "parse_BrtShortIsst");
function write_BrtShortIsst(cell, ncell, o2) {
  if (o2 == null)
    o2 = new_buf(8);
  write_XLSBShortCell(ncell, o2);
  o2.write_shift(4, ncell.v);
  return o2;
}
__name(write_BrtShortIsst, "write_BrtShortIsst");
function parse_BrtCellReal(data) {
  var cell = parse_XLSBCell(data);
  var value = parse_Xnum(data);
  return [cell, value, "n"];
}
__name(parse_BrtCellReal, "parse_BrtCellReal");
function write_BrtCellReal(cell, ncell, o2) {
  if (o2 == null)
    o2 = new_buf(16);
  write_XLSBCell(ncell, o2);
  write_Xnum(cell.v, o2);
  return o2;
}
__name(write_BrtCellReal, "write_BrtCellReal");
function parse_BrtShortReal(data) {
  var cell = parse_XLSBShortCell(data);
  var value = parse_Xnum(data);
  return [cell, value, "n"];
}
__name(parse_BrtShortReal, "parse_BrtShortReal");
function write_BrtShortReal(cell, ncell, o2) {
  if (o2 == null)
    o2 = new_buf(12);
  write_XLSBShortCell(ncell, o2);
  write_Xnum(cell.v, o2);
  return o2;
}
__name(write_BrtShortReal, "write_BrtShortReal");
function parse_BrtCellRk(data) {
  var cell = parse_XLSBCell(data);
  var value = parse_RkNumber(data);
  return [cell, value, "n"];
}
__name(parse_BrtCellRk, "parse_BrtCellRk");
function write_BrtCellRk(cell, ncell, o2) {
  if (o2 == null)
    o2 = new_buf(12);
  write_XLSBCell(ncell, o2);
  write_RkNumber(cell.v, o2);
  return o2;
}
__name(write_BrtCellRk, "write_BrtCellRk");
function parse_BrtShortRk(data) {
  var cell = parse_XLSBShortCell(data);
  var value = parse_RkNumber(data);
  return [cell, value, "n"];
}
__name(parse_BrtShortRk, "parse_BrtShortRk");
function write_BrtShortRk(cell, ncell, o2) {
  if (o2 == null)
    o2 = new_buf(8);
  write_XLSBShortCell(ncell, o2);
  write_RkNumber(cell.v, o2);
  return o2;
}
__name(write_BrtShortRk, "write_BrtShortRk");
function parse_BrtCellRString(data) {
  var cell = parse_XLSBCell(data);
  var value = parse_RichStr(data);
  return [cell, value, "is"];
}
__name(parse_BrtCellRString, "parse_BrtCellRString");
function parse_BrtCellSt(data) {
  var cell = parse_XLSBCell(data);
  var value = parse_XLWideString(data);
  return [cell, value, "str"];
}
__name(parse_BrtCellSt, "parse_BrtCellSt");
function write_BrtCellSt(cell, ncell, o2) {
  if (o2 == null)
    o2 = new_buf(12 + 4 * cell.v.length);
  write_XLSBCell(ncell, o2);
  write_XLWideString(cell.v, o2);
  return o2.length > o2.l ? o2.slice(0, o2.l) : o2;
}
__name(write_BrtCellSt, "write_BrtCellSt");
function parse_BrtShortSt(data) {
  var cell = parse_XLSBShortCell(data);
  var value = parse_XLWideString(data);
  return [cell, value, "str"];
}
__name(parse_BrtShortSt, "parse_BrtShortSt");
function write_BrtShortSt(cell, ncell, o2) {
  if (o2 == null)
    o2 = new_buf(8 + 4 * cell.v.length);
  write_XLSBShortCell(ncell, o2);
  write_XLWideString(cell.v, o2);
  return o2.length > o2.l ? o2.slice(0, o2.l) : o2;
}
__name(write_BrtShortSt, "write_BrtShortSt");
function parse_BrtFmlaBool(data, length, opts) {
  var end = data.l + length;
  var cell = parse_XLSBCell(data);
  cell.r = opts["!row"];
  var value = data.read_shift(1);
  var o2 = [cell, value, "b"];
  if (opts.cellFormula) {
    data.l += 2;
    var formula = parse_XLSBCellParsedFormula(data, end - data.l, opts);
    o2[3] = stringify_formula(formula, null, cell, opts.supbooks, opts);
  } else
    data.l = end;
  return o2;
}
__name(parse_BrtFmlaBool, "parse_BrtFmlaBool");
function parse_BrtFmlaError(data, length, opts) {
  var end = data.l + length;
  var cell = parse_XLSBCell(data);
  cell.r = opts["!row"];
  var value = data.read_shift(1);
  var o2 = [cell, value, "e"];
  if (opts.cellFormula) {
    data.l += 2;
    var formula = parse_XLSBCellParsedFormula(data, end - data.l, opts);
    o2[3] = stringify_formula(formula, null, cell, opts.supbooks, opts);
  } else
    data.l = end;
  return o2;
}
__name(parse_BrtFmlaError, "parse_BrtFmlaError");
function parse_BrtFmlaNum(data, length, opts) {
  var end = data.l + length;
  var cell = parse_XLSBCell(data);
  cell.r = opts["!row"];
  var value = parse_Xnum(data);
  var o2 = [cell, value, "n"];
  if (opts.cellFormula) {
    data.l += 2;
    var formula = parse_XLSBCellParsedFormula(data, end - data.l, opts);
    o2[3] = stringify_formula(formula, null, cell, opts.supbooks, opts);
  } else
    data.l = end;
  return o2;
}
__name(parse_BrtFmlaNum, "parse_BrtFmlaNum");
function parse_BrtFmlaString(data, length, opts) {
  var end = data.l + length;
  var cell = parse_XLSBCell(data);
  cell.r = opts["!row"];
  var value = parse_XLWideString(data);
  var o2 = [cell, value, "str"];
  if (opts.cellFormula) {
    data.l += 2;
    var formula = parse_XLSBCellParsedFormula(data, end - data.l, opts);
    o2[3] = stringify_formula(formula, null, cell, opts.supbooks, opts);
  } else
    data.l = end;
  return o2;
}
__name(parse_BrtFmlaString, "parse_BrtFmlaString");
var parse_BrtMergeCell = parse_UncheckedRfX;
var write_BrtMergeCell = write_UncheckedRfX;
function write_BrtBeginMergeCells(cnt, o2) {
  if (o2 == null)
    o2 = new_buf(4);
  o2.write_shift(4, cnt);
  return o2;
}
__name(write_BrtBeginMergeCells, "write_BrtBeginMergeCells");
function parse_BrtHLink(data, length) {
  var end = data.l + length;
  var rfx = parse_UncheckedRfX(data);
  var relId = parse_XLNullableWideString(data);
  var loc = parse_XLWideString(data);
  var tooltip = parse_XLWideString(data);
  var display = parse_XLWideString(data);
  data.l = end;
  var o2 = { rfx, relId, loc, display };
  if (tooltip)
    o2.Tooltip = tooltip;
  return o2;
}
__name(parse_BrtHLink, "parse_BrtHLink");
function write_BrtHLink(l2, rId) {
  var o2 = new_buf(50 + 4 * (l2[1].Target.length + (l2[1].Tooltip || "").length));
  write_UncheckedRfX({ s: decode_cell(l2[0]), e: decode_cell(l2[0]) }, o2);
  write_RelID("rId" + rId, o2);
  var locidx = l2[1].Target.indexOf("#");
  var loc = locidx == -1 ? "" : l2[1].Target.slice(locidx + 1);
  write_XLWideString(loc || "", o2);
  write_XLWideString(l2[1].Tooltip || "", o2);
  write_XLWideString("", o2);
  return o2.slice(0, o2.l);
}
__name(write_BrtHLink, "write_BrtHLink");
function parse_BrtPane() {
}
__name(parse_BrtPane, "parse_BrtPane");
function parse_BrtArrFmla(data, length, opts) {
  var end = data.l + length;
  var rfx = parse_RfX(data);
  var fAlwaysCalc = data.read_shift(1);
  var o2 = [rfx];
  o2[2] = fAlwaysCalc;
  if (opts.cellFormula) {
    var formula = parse_XLSBArrayParsedFormula(data, end - data.l, opts);
    o2[1] = formula;
  } else
    data.l = end;
  return o2;
}
__name(parse_BrtArrFmla, "parse_BrtArrFmla");
function parse_BrtShrFmla(data, length, opts) {
  var end = data.l + length;
  var rfx = parse_UncheckedRfX(data);
  var o2 = [rfx];
  if (opts.cellFormula) {
    var formula = parse_XLSBSharedParsedFormula(data, end - data.l, opts);
    o2[1] = formula;
    data.l = end;
  } else
    data.l = end;
  return o2;
}
__name(parse_BrtShrFmla, "parse_BrtShrFmla");
function write_BrtColInfo(C2, col, o2) {
  if (o2 == null)
    o2 = new_buf(18);
  var p2 = col_obj_w(C2, col);
  o2.write_shift(-4, C2);
  o2.write_shift(-4, C2);
  o2.write_shift(4, (p2.width || 10) * 256);
  o2.write_shift(
    4,
    0
    /*ixfe*/
  );
  var flags = 0;
  if (col.hidden)
    flags |= 1;
  if (typeof p2.width == "number")
    flags |= 2;
  if (col.level)
    flags |= col.level << 8;
  o2.write_shift(2, flags);
  return o2;
}
__name(write_BrtColInfo, "write_BrtColInfo");
var BrtMarginKeys = ["left", "right", "top", "bottom", "header", "footer"];
function parse_BrtMargins(data) {
  var margins = {};
  BrtMarginKeys.forEach(function(k2) {
    margins[k2] = parse_Xnum(data);
  });
  return margins;
}
__name(parse_BrtMargins, "parse_BrtMargins");
function write_BrtMargins(margins, o2) {
  if (o2 == null)
    o2 = new_buf(6 * 8);
  default_margins(margins);
  BrtMarginKeys.forEach(function(k2) {
    write_Xnum(margins[k2], o2);
  });
  return o2;
}
__name(write_BrtMargins, "write_BrtMargins");
function parse_BrtBeginWsView(data) {
  var f2 = data.read_shift(2);
  data.l += 28;
  return { RTL: f2 & 32 };
}
__name(parse_BrtBeginWsView, "parse_BrtBeginWsView");
function write_BrtBeginWsView(ws, Workbook, o2) {
  if (o2 == null)
    o2 = new_buf(30);
  var f2 = 924;
  if ((((Workbook || {}).Views || [])[0] || {}).RTL)
    f2 |= 32;
  o2.write_shift(2, f2);
  o2.write_shift(4, 0);
  o2.write_shift(4, 0);
  o2.write_shift(4, 0);
  o2.write_shift(1, 0);
  o2.write_shift(1, 0);
  o2.write_shift(2, 0);
  o2.write_shift(2, 100);
  o2.write_shift(2, 0);
  o2.write_shift(2, 0);
  o2.write_shift(2, 0);
  o2.write_shift(4, 0);
  return o2;
}
__name(write_BrtBeginWsView, "write_BrtBeginWsView");
function write_BrtCellIgnoreEC(ref) {
  var o2 = new_buf(24);
  o2.write_shift(4, 4);
  o2.write_shift(4, 1);
  write_UncheckedRfX(ref, o2);
  return o2;
}
__name(write_BrtCellIgnoreEC, "write_BrtCellIgnoreEC");
function write_BrtSheetProtection(sp, o2) {
  if (o2 == null)
    o2 = new_buf(16 * 4 + 2);
  o2.write_shift(2, sp.password ? crypto_CreatePasswordVerifier_Method1(sp.password) : 0);
  o2.write_shift(4, 1);
  [
    ["objects", false],
    // fObjects
    ["scenarios", false],
    // fScenarios
    ["formatCells", true],
    // fFormatCells
    ["formatColumns", true],
    // fFormatColumns
    ["formatRows", true],
    // fFormatRows
    ["insertColumns", true],
    // fInsertColumns
    ["insertRows", true],
    // fInsertRows
    ["insertHyperlinks", true],
    // fInsertHyperlinks
    ["deleteColumns", true],
    // fDeleteColumns
    ["deleteRows", true],
    // fDeleteRows
    ["selectLockedCells", false],
    // fSelLockedCells
    ["sort", true],
    // fSort
    ["autoFilter", true],
    // fAutoFilter
    ["pivotTables", true],
    // fPivotTables
    ["selectUnlockedCells", false]
    // fSelUnlockedCells
  ].forEach(function(n2) {
    if (n2[1])
      o2.write_shift(4, sp[n2[0]] != null && !sp[n2[0]] ? 1 : 0);
    else
      o2.write_shift(4, sp[n2[0]] != null && sp[n2[0]] ? 0 : 1);
  });
  return o2;
}
__name(write_BrtSheetProtection, "write_BrtSheetProtection");
function parse_BrtDVal() {
}
__name(parse_BrtDVal, "parse_BrtDVal");
function parse_BrtDVal14() {
}
__name(parse_BrtDVal14, "parse_BrtDVal14");
function write_ws_bin_cell(ba, cell, R2, C2, opts, ws, last_seen) {
  if (cell.v === void 0)
    return false;
  var vv = "";
  switch (cell.t) {
    case "b":
      vv = cell.v ? "1" : "0";
      break;
    case "d":
      cell = dup(cell);
      cell.z = cell.z || table_fmt[14];
      cell.v = datenum(parseDate(cell.v));
      cell.t = "n";
      break;
    case "n":
    case "e":
      vv = "" + cell.v;
      break;
    default:
      vv = cell.v;
      break;
  }
  var o2 = { r: R2, c: C2 };
  o2.s = get_cell_style(opts.cellXfs, cell, opts);
  if (cell.l)
    ws["!links"].push([encode_cell(o2), cell.l]);
  if (cell.c)
    ws["!comments"].push([encode_cell(o2), cell.c]);
  switch (cell.t) {
    case "s":
    case "str":
      if (opts.bookSST) {
        vv = get_sst_id(opts.Strings, cell.v, opts.revStrings);
        o2.t = "s";
        o2.v = vv;
        if (last_seen)
          write_record(ba, 18, write_BrtShortIsst(cell, o2));
        else
          write_record(ba, 7, write_BrtCellIsst(cell, o2));
      } else {
        o2.t = "str";
        if (last_seen)
          write_record(ba, 17, write_BrtShortSt(cell, o2));
        else
          write_record(ba, 6, write_BrtCellSt(cell, o2));
      }
      return true;
    case "n":
      if (cell.v == (cell.v | 0) && cell.v > -1e3 && cell.v < 1e3) {
        if (last_seen)
          write_record(ba, 13, write_BrtShortRk(cell, o2));
        else
          write_record(ba, 2, write_BrtCellRk(cell, o2));
      } else {
        if (last_seen)
          write_record(ba, 16, write_BrtShortReal(cell, o2));
        else
          write_record(ba, 5, write_BrtCellReal(cell, o2));
      }
      return true;
    case "b":
      o2.t = "b";
      if (last_seen)
        write_record(ba, 15, write_BrtShortBool(cell, o2));
      else
        write_record(ba, 4, write_BrtCellBool(cell, o2));
      return true;
    case "e":
      o2.t = "e";
      if (last_seen)
        write_record(ba, 14, write_BrtShortError(cell, o2));
      else
        write_record(ba, 3, write_BrtCellError(cell, o2));
      return true;
  }
  if (last_seen)
    write_record(ba, 12, write_BrtShortBlank(cell, o2));
  else
    write_record(ba, 1, write_BrtCellBlank(cell, o2));
  return true;
}
__name(write_ws_bin_cell, "write_ws_bin_cell");
function write_CELLTABLE(ba, ws, idx, opts) {
  var range = safe_decode_range(ws["!ref"] || "A1"), ref, rr = "", cols = [];
  write_record(
    ba,
    145
    /* BrtBeginSheetData */
  );
  var dense = Array.isArray(ws);
  var cap = range.e.r;
  if (ws["!rows"])
    cap = Math.max(range.e.r, ws["!rows"].length - 1);
  for (var R2 = range.s.r; R2 <= cap; ++R2) {
    rr = encode_row(R2);
    write_row_header(ba, ws, range, R2);
    var last_seen = false;
    if (R2 <= range.e.r)
      for (var C2 = range.s.c; C2 <= range.e.c; ++C2) {
        if (R2 === range.s.r)
          cols[C2] = encode_col(C2);
        ref = cols[C2] + rr;
        var cell = dense ? (ws[R2] || [])[C2] : ws[ref];
        if (!cell) {
          last_seen = false;
          continue;
        }
        last_seen = write_ws_bin_cell(ba, cell, R2, C2, opts, ws, last_seen);
      }
  }
  write_record(
    ba,
    146
    /* BrtEndSheetData */
  );
}
__name(write_CELLTABLE, "write_CELLTABLE");
function write_MERGECELLS(ba, ws) {
  if (!ws || !ws["!merges"])
    return;
  write_record(ba, 177, write_BrtBeginMergeCells(ws["!merges"].length));
  ws["!merges"].forEach(function(m2) {
    write_record(ba, 176, write_BrtMergeCell(m2));
  });
  write_record(
    ba,
    178
    /* BrtEndMergeCells */
  );
}
__name(write_MERGECELLS, "write_MERGECELLS");
function write_COLINFOS(ba, ws) {
  if (!ws || !ws["!cols"])
    return;
  write_record(
    ba,
    390
    /* BrtBeginColInfos */
  );
  ws["!cols"].forEach(function(m2, i2) {
    if (m2)
      write_record(ba, 60, write_BrtColInfo(i2, m2));
  });
  write_record(
    ba,
    391
    /* BrtEndColInfos */
  );
}
__name(write_COLINFOS, "write_COLINFOS");
function write_IGNOREECS(ba, ws) {
  if (!ws || !ws["!ref"])
    return;
  write_record(
    ba,
    648
    /* BrtBeginCellIgnoreECs */
  );
  write_record(ba, 649, write_BrtCellIgnoreEC(safe_decode_range(ws["!ref"])));
  write_record(
    ba,
    650
    /* BrtEndCellIgnoreECs */
  );
}
__name(write_IGNOREECS, "write_IGNOREECS");
function write_HLINKS(ba, ws, rels) {
  ws["!links"].forEach(function(l2) {
    if (!l2[1].Target)
      return;
    var rId = add_rels(rels, -1, l2[1].Target.replace(/#.*$/, ""), RELS.HLINK);
    write_record(ba, 494, write_BrtHLink(l2, rId));
  });
  delete ws["!links"];
}
__name(write_HLINKS, "write_HLINKS");
function write_LEGACYDRAWING(ba, ws, idx, rels) {
  if (ws["!comments"].length > 0) {
    var rId = add_rels(rels, -1, "../drawings/vmlDrawing" + (idx + 1) + ".vml", RELS.VML);
    write_record(ba, 551, write_RelID("rId" + rId));
    ws["!legacy"] = rId;
  }
}
__name(write_LEGACYDRAWING, "write_LEGACYDRAWING");
function write_AUTOFILTER(ba, ws, wb, idx) {
  if (!ws["!autofilter"])
    return;
  var data = ws["!autofilter"];
  var ref = typeof data.ref === "string" ? data.ref : encode_range(data.ref);
  if (!wb.Workbook)
    wb.Workbook = { Sheets: [] };
  if (!wb.Workbook.Names)
    wb.Workbook.Names = [];
  var names2 = wb.Workbook.Names;
  var range = decode_range(ref);
  if (range.s.r == range.e.r) {
    range.e.r = decode_range(ws["!ref"]).e.r;
    ref = encode_range(range);
  }
  for (var i2 = 0; i2 < names2.length; ++i2) {
    var name = names2[i2];
    if (name.Name != "_xlnm._FilterDatabase")
      continue;
    if (name.Sheet != idx)
      continue;
    name.Ref = "'" + wb.SheetNames[idx] + "'!" + ref;
    break;
  }
  if (i2 == names2.length)
    names2.push({ Name: "_xlnm._FilterDatabase", Sheet: idx, Ref: "'" + wb.SheetNames[idx] + "'!" + ref });
  write_record(ba, 161, write_UncheckedRfX(safe_decode_range(ref)));
  write_record(
    ba,
    162
    /* BrtEndAFilter */
  );
}
__name(write_AUTOFILTER, "write_AUTOFILTER");
function write_WSVIEWS2(ba, ws, Workbook) {
  write_record(
    ba,
    133
    /* BrtBeginWsViews */
  );
  {
    write_record(ba, 137, write_BrtBeginWsView(ws, Workbook));
    write_record(
      ba,
      138
      /* BrtEndWsView */
    );
  }
  write_record(
    ba,
    134
    /* BrtEndWsViews */
  );
}
__name(write_WSVIEWS2, "write_WSVIEWS2");
function write_SHEETPROTECT(ba, ws) {
  if (!ws["!protect"])
    return;
  write_record(ba, 535, write_BrtSheetProtection(ws["!protect"]));
}
__name(write_SHEETPROTECT, "write_SHEETPROTECT");
function write_ws_bin(idx, opts, wb, rels) {
  var ba = buf_array();
  var s2 = wb.SheetNames[idx], ws = wb.Sheets[s2] || {};
  var c2 = s2;
  try {
    if (wb && wb.Workbook)
      c2 = wb.Workbook.Sheets[idx].CodeName || c2;
  } catch (e) {
  }
  var r = safe_decode_range(ws["!ref"] || "A1");
  if (r.e.c > 16383 || r.e.r > 1048575) {
    if (opts.WTF)
      throw new Error("Range " + (ws["!ref"] || "A1") + " exceeds format limit A1:XFD1048576");
    r.e.c = Math.min(r.e.c, 16383);
    r.e.r = Math.min(r.e.c, 1048575);
  }
  ws["!links"] = [];
  ws["!comments"] = [];
  write_record(
    ba,
    129
    /* BrtBeginSheet */
  );
  if (wb.vbaraw || ws["!outline"])
    write_record(ba, 147, write_BrtWsProp(c2, ws["!outline"]));
  write_record(ba, 148, write_BrtWsDim(r));
  write_WSVIEWS2(ba, ws, wb.Workbook);
  write_COLINFOS(ba, ws);
  write_CELLTABLE(ba, ws, idx, opts);
  write_SHEETPROTECT(ba, ws);
  write_AUTOFILTER(ba, ws, wb, idx);
  write_MERGECELLS(ba, ws);
  write_HLINKS(ba, ws, rels);
  if (ws["!margins"])
    write_record(ba, 476, write_BrtMargins(ws["!margins"]));
  if (!opts || opts.ignoreEC || opts.ignoreEC == void 0)
    write_IGNOREECS(ba, ws);
  write_LEGACYDRAWING(ba, ws, idx, rels);
  write_record(
    ba,
    130
    /* BrtEndSheet */
  );
  return ba.end();
}
__name(write_ws_bin, "write_ws_bin");
function parse_BrtCsProp(data, length) {
  data.l += 10;
  var name = parse_XLWideString(data);
  return { name };
}
__name(parse_BrtCsProp, "parse_BrtCsProp");
var WBPropsDef = [
  ["allowRefreshQuery", false, "bool"],
  ["autoCompressPictures", true, "bool"],
  ["backupFile", false, "bool"],
  ["checkCompatibility", false, "bool"],
  ["CodeName", ""],
  ["date1904", false, "bool"],
  ["defaultThemeVersion", 0, "int"],
  ["filterPrivacy", false, "bool"],
  ["hidePivotFieldList", false, "bool"],
  ["promptedSolutions", false, "bool"],
  ["publishItems", false, "bool"],
  ["refreshAllConnections", false, "bool"],
  ["saveExternalLinkValues", true, "bool"],
  ["showBorderUnselectedTables", true, "bool"],
  ["showInkAnnotation", true, "bool"],
  ["showObjects", "all"],
  ["showPivotChartFilter", false, "bool"],
  ["updateLinks", "userSet"]
];
function safe1904(wb) {
  if (!wb.Workbook)
    return "false";
  if (!wb.Workbook.WBProps)
    return "false";
  return parsexmlbool(wb.Workbook.WBProps.date1904) ? "true" : "false";
}
__name(safe1904, "safe1904");
var badchars = /* @__PURE__ */ "][*?/\\".split("");
function check_ws_name(n2, safe) {
  if (n2.length > 31) {
    if (safe)
      return false;
    throw new Error("Sheet names cannot exceed 31 chars");
  }
  var _good = true;
  badchars.forEach(function(c2) {
    if (n2.indexOf(c2) == -1)
      return;
    if (!safe)
      throw new Error("Sheet name cannot contain : \\ / ? * [ ]");
    _good = false;
  });
  return _good;
}
__name(check_ws_name, "check_ws_name");
function check_wb_names(N2, S2, codes) {
  N2.forEach(function(n2, i2) {
    check_ws_name(n2);
    for (var j2 = 0; j2 < i2; ++j2)
      if (n2 == N2[j2])
        throw new Error("Duplicate Sheet Name: " + n2);
    if (codes) {
      var cn = S2 && S2[i2] && S2[i2].CodeName || n2;
      if (cn.charCodeAt(0) == 95 && cn.length > 22)
        throw new Error("Bad Code Name: Worksheet" + cn);
    }
  });
}
__name(check_wb_names, "check_wb_names");
function check_wb(wb) {
  if (!wb || !wb.SheetNames || !wb.Sheets)
    throw new Error("Invalid Workbook");
  if (!wb.SheetNames.length)
    throw new Error("Workbook is empty");
  var Sheets = wb.Workbook && wb.Workbook.Sheets || [];
  check_wb_names(wb.SheetNames, Sheets, !!wb.vbaraw);
  for (var i2 = 0; i2 < wb.SheetNames.length; ++i2)
    check_ws(wb.Sheets[wb.SheetNames[i2]], wb.SheetNames[i2], i2);
}
__name(check_wb, "check_wb");
function write_wb_xml(wb) {
  var o2 = [XML_HEADER];
  o2[o2.length] = writextag("workbook", null, {
    "xmlns": XMLNS_main[0],
    //'xmlns:mx': XMLNS.mx,
    //'xmlns:s': XMLNS_main[0],
    "xmlns:r": XMLNS.r
  });
  var write_names = wb.Workbook && (wb.Workbook.Names || []).length > 0;
  var workbookPr = { codeName: "ThisWorkbook" };
  if (wb.Workbook && wb.Workbook.WBProps) {
    WBPropsDef.forEach(function(x2) {
      if (wb.Workbook.WBProps[x2[0]] == null)
        return;
      if (wb.Workbook.WBProps[x2[0]] == x2[1])
        return;
      workbookPr[x2[0]] = wb.Workbook.WBProps[x2[0]];
    });
    if (wb.Workbook.WBProps.CodeName) {
      workbookPr.codeName = wb.Workbook.WBProps.CodeName;
      delete workbookPr.CodeName;
    }
  }
  o2[o2.length] = writextag("workbookPr", null, workbookPr);
  var sheets = wb.Workbook && wb.Workbook.Sheets || [];
  var i2 = 0;
  if (sheets && sheets[0] && !!sheets[0].Hidden) {
    o2[o2.length] = "<bookViews>";
    for (i2 = 0; i2 != wb.SheetNames.length; ++i2) {
      if (!sheets[i2])
        break;
      if (!sheets[i2].Hidden)
        break;
    }
    if (i2 == wb.SheetNames.length)
      i2 = 0;
    o2[o2.length] = '<workbookView firstSheet="' + i2 + '" activeTab="' + i2 + '"/>';
    o2[o2.length] = "</bookViews>";
  }
  o2[o2.length] = "<sheets>";
  for (i2 = 0; i2 != wb.SheetNames.length; ++i2) {
    var sht = { name: escapexml(wb.SheetNames[i2].slice(0, 31)) };
    sht.sheetId = "" + (i2 + 1);
    sht["r:id"] = "rId" + (i2 + 1);
    if (sheets[i2])
      switch (sheets[i2].Hidden) {
        case 1:
          sht.state = "hidden";
          break;
        case 2:
          sht.state = "veryHidden";
          break;
      }
    o2[o2.length] = writextag("sheet", null, sht);
  }
  o2[o2.length] = "</sheets>";
  if (write_names) {
    o2[o2.length] = "<definedNames>";
    if (wb.Workbook && wb.Workbook.Names)
      wb.Workbook.Names.forEach(function(n2) {
        var d2 = { name: n2.Name };
        if (n2.Comment)
          d2.comment = n2.Comment;
        if (n2.Sheet != null)
          d2.localSheetId = "" + n2.Sheet;
        if (n2.Hidden)
          d2.hidden = "1";
        if (!n2.Ref)
          return;
        o2[o2.length] = writextag("definedName", escapexml(n2.Ref), d2);
      });
    o2[o2.length] = "</definedNames>";
  }
  if (o2.length > 2) {
    o2[o2.length] = "</workbook>";
    o2[1] = o2[1].replace("/>", ">");
  }
  return o2.join("");
}
__name(write_wb_xml, "write_wb_xml");
function parse_BrtBundleSh(data, length) {
  var z2 = {};
  z2.Hidden = data.read_shift(4);
  z2.iTabID = data.read_shift(4);
  z2.strRelID = parse_RelID(data);
  z2.name = parse_XLWideString(data);
  return z2;
}
__name(parse_BrtBundleSh, "parse_BrtBundleSh");
function write_BrtBundleSh(data, o2) {
  if (!o2)
    o2 = new_buf(127);
  o2.write_shift(4, data.Hidden);
  o2.write_shift(4, data.iTabID);
  write_RelID(data.strRelID, o2);
  write_XLWideString(data.name.slice(0, 31), o2);
  return o2.length > o2.l ? o2.slice(0, o2.l) : o2;
}
__name(write_BrtBundleSh, "write_BrtBundleSh");
function parse_BrtWbProp(data, length) {
  var o2 = {};
  var flags = data.read_shift(4);
  o2.defaultThemeVersion = data.read_shift(4);
  var strName = length > 8 ? parse_XLWideString(data) : "";
  if (strName.length > 0)
    o2.CodeName = strName;
  o2.autoCompressPictures = !!(flags & 65536);
  o2.backupFile = !!(flags & 64);
  o2.checkCompatibility = !!(flags & 4096);
  o2.date1904 = !!(flags & 1);
  o2.filterPrivacy = !!(flags & 8);
  o2.hidePivotFieldList = !!(flags & 1024);
  o2.promptedSolutions = !!(flags & 16);
  o2.publishItems = !!(flags & 2048);
  o2.refreshAllConnections = !!(flags & 262144);
  o2.saveExternalLinkValues = !!(flags & 128);
  o2.showBorderUnselectedTables = !!(flags & 4);
  o2.showInkAnnotation = !!(flags & 32);
  o2.showObjects = ["all", "placeholders", "none"][flags >> 13 & 3];
  o2.showPivotChartFilter = !!(flags & 32768);
  o2.updateLinks = ["userSet", "never", "always"][flags >> 8 & 3];
  return o2;
}
__name(parse_BrtWbProp, "parse_BrtWbProp");
function write_BrtWbProp(data, o2) {
  if (!o2)
    o2 = new_buf(72);
  var flags = 0;
  if (data) {
    if (data.filterPrivacy)
      flags |= 8;
  }
  o2.write_shift(4, flags);
  o2.write_shift(4, 0);
  write_XLSBCodeName(data && data.CodeName || "ThisWorkbook", o2);
  return o2.slice(0, o2.l);
}
__name(write_BrtWbProp, "write_BrtWbProp");
function parse_BrtName(data, length, opts) {
  var end = data.l + length;
  data.l += 4;
  data.l += 1;
  var itab = data.read_shift(4);
  var name = parse_XLNameWideString(data);
  var formula = parse_XLSBNameParsedFormula(data, 0, opts);
  var comment = parse_XLNullableWideString(data);
  data.l = end;
  var out = { Name: name, Ptg: formula };
  if (itab < 268435455)
    out.Sheet = itab;
  if (comment)
    out.Comment = comment;
  return out;
}
__name(parse_BrtName, "parse_BrtName");
function write_BUNDLESHS(ba, wb) {
  write_record(
    ba,
    143
    /* BrtBeginBundleShs */
  );
  for (var idx = 0; idx != wb.SheetNames.length; ++idx) {
    var viz = wb.Workbook && wb.Workbook.Sheets && wb.Workbook.Sheets[idx] && wb.Workbook.Sheets[idx].Hidden || 0;
    var d2 = { Hidden: viz, iTabID: idx + 1, strRelID: "rId" + (idx + 1), name: wb.SheetNames[idx] };
    write_record(ba, 156, write_BrtBundleSh(d2));
  }
  write_record(
    ba,
    144
    /* BrtEndBundleShs */
  );
}
__name(write_BUNDLESHS, "write_BUNDLESHS");
function write_BrtFileVersion(data, o2) {
  if (!o2)
    o2 = new_buf(127);
  for (var i2 = 0; i2 != 4; ++i2)
    o2.write_shift(4, 0);
  write_XLWideString("SheetJS", o2);
  write_XLWideString(XLSX.version, o2);
  write_XLWideString(XLSX.version, o2);
  write_XLWideString("7262", o2);
  return o2.length > o2.l ? o2.slice(0, o2.l) : o2;
}
__name(write_BrtFileVersion, "write_BrtFileVersion");
function write_BrtBookView(idx, o2) {
  if (!o2)
    o2 = new_buf(29);
  o2.write_shift(-4, 0);
  o2.write_shift(-4, 460);
  o2.write_shift(4, 28800);
  o2.write_shift(4, 17600);
  o2.write_shift(4, 500);
  o2.write_shift(4, idx);
  o2.write_shift(4, idx);
  var flags = 120;
  o2.write_shift(1, flags);
  return o2.length > o2.l ? o2.slice(0, o2.l) : o2;
}
__name(write_BrtBookView, "write_BrtBookView");
function write_BOOKVIEWS(ba, wb) {
  if (!wb.Workbook || !wb.Workbook.Sheets)
    return;
  var sheets = wb.Workbook.Sheets;
  var i2 = 0, vistab = -1, hidden = -1;
  for (; i2 < sheets.length; ++i2) {
    if (!sheets[i2] || !sheets[i2].Hidden && vistab == -1)
      vistab = i2;
    else if (sheets[i2].Hidden == 1 && hidden == -1)
      hidden = i2;
  }
  if (hidden > vistab)
    return;
  write_record(
    ba,
    135
    /* BrtBeginBookViews */
  );
  write_record(ba, 158, write_BrtBookView(vistab));
  write_record(
    ba,
    136
    /* BrtEndBookViews */
  );
}
__name(write_BOOKVIEWS, "write_BOOKVIEWS");
function write_wb_bin(wb, opts) {
  var ba = buf_array();
  write_record(
    ba,
    131
    /* BrtBeginBook */
  );
  write_record(ba, 128, write_BrtFileVersion());
  write_record(ba, 153, write_BrtWbProp(wb.Workbook && wb.Workbook.WBProps || null));
  write_BOOKVIEWS(ba, wb);
  write_BUNDLESHS(ba, wb);
  write_record(
    ba,
    132
    /* BrtEndBook */
  );
  return ba.end();
}
__name(write_wb_bin, "write_wb_bin");
function write_wb(wb, name, opts) {
  return (name.slice(-4) === ".bin" ? write_wb_bin : write_wb_xml)(wb);
}
__name(write_wb, "write_wb");
function write_ws(data, name, opts, wb, rels) {
  return (name.slice(-4) === ".bin" ? write_ws_bin : write_ws_xml)(data, opts, wb, rels);
}
__name(write_ws, "write_ws");
function write_sty(data, name, opts) {
  return (name.slice(-4) === ".bin" ? write_sty_bin : write_sty_xml)(data, opts);
}
__name(write_sty, "write_sty");
function write_sst(data, name, opts) {
  return (name.slice(-4) === ".bin" ? write_sst_bin : write_sst_xml)(data, opts);
}
__name(write_sst, "write_sst");
function write_cmnt(data, name, opts) {
  return (name.slice(-4) === ".bin" ? write_comments_bin : write_comments_xml)(data);
}
__name(write_cmnt, "write_cmnt");
function write_xlmeta(name) {
  return (name.slice(-4) === ".bin" ? write_xlmeta_bin : write_xlmeta_xml)();
}
__name(write_xlmeta, "write_xlmeta");
function write_props_xlml(wb, opts) {
  var o2 = [];
  if (wb.Props)
    o2.push(xlml_write_docprops(wb.Props, opts));
  if (wb.Custprops)
    o2.push(xlml_write_custprops(wb.Props, wb.Custprops));
  return o2.join("");
}
__name(write_props_xlml, "write_props_xlml");
function write_wb_xlml() {
  return "";
}
__name(write_wb_xlml, "write_wb_xlml");
function write_sty_xlml(wb, opts) {
  var styles = ['<Style ss:ID="Default" ss:Name="Normal"><NumberFormat/></Style>'];
  opts.cellXfs.forEach(function(xf, id) {
    var payload = [];
    payload.push(writextag("NumberFormat", null, { "ss:Format": escapexml(table_fmt[xf.numFmtId]) }));
    var o2 = (
      /*::(*/
      { "ss:ID": "s" + (21 + id) }
    );
    styles.push(writextag("Style", payload.join(""), o2));
  });
  return writextag("Styles", styles.join(""));
}
__name(write_sty_xlml, "write_sty_xlml");
function write_name_xlml(n2) {
  return writextag("NamedRange", null, { "ss:Name": n2.Name, "ss:RefersTo": "=" + a1_to_rc(n2.Ref, { r: 0, c: 0 }) });
}
__name(write_name_xlml, "write_name_xlml");
function write_names_xlml(wb) {
  if (!((wb || {}).Workbook || {}).Names)
    return "";
  var names2 = wb.Workbook.Names;
  var out = [];
  for (var i2 = 0; i2 < names2.length; ++i2) {
    var n2 = names2[i2];
    if (n2.Sheet != null)
      continue;
    if (n2.Name.match(/^_xlfn\./))
      continue;
    out.push(write_name_xlml(n2));
  }
  return writextag("Names", out.join(""));
}
__name(write_names_xlml, "write_names_xlml");
function write_ws_xlml_names(ws, opts, idx, wb) {
  if (!ws)
    return "";
  if (!((wb || {}).Workbook || {}).Names)
    return "";
  var names2 = wb.Workbook.Names;
  var out = [];
  for (var i2 = 0; i2 < names2.length; ++i2) {
    var n2 = names2[i2];
    if (n2.Sheet != idx)
      continue;
    if (n2.Name.match(/^_xlfn\./))
      continue;
    out.push(write_name_xlml(n2));
  }
  return out.join("");
}
__name(write_ws_xlml_names, "write_ws_xlml_names");
function write_ws_xlml_wsopts(ws, opts, idx, wb) {
  if (!ws)
    return "";
  var o2 = [];
  if (ws["!margins"]) {
    o2.push("<PageSetup>");
    if (ws["!margins"].header)
      o2.push(writextag("Header", null, { "x:Margin": ws["!margins"].header }));
    if (ws["!margins"].footer)
      o2.push(writextag("Footer", null, { "x:Margin": ws["!margins"].footer }));
    o2.push(writextag("PageMargins", null, {
      "x:Bottom": ws["!margins"].bottom || "0.75",
      "x:Left": ws["!margins"].left || "0.7",
      "x:Right": ws["!margins"].right || "0.7",
      "x:Top": ws["!margins"].top || "0.75"
    }));
    o2.push("</PageSetup>");
  }
  if (wb && wb.Workbook && wb.Workbook.Sheets && wb.Workbook.Sheets[idx]) {
    if (wb.Workbook.Sheets[idx].Hidden)
      o2.push(writextag("Visible", wb.Workbook.Sheets[idx].Hidden == 1 ? "SheetHidden" : "SheetVeryHidden", {}));
    else {
      for (var i2 = 0; i2 < idx; ++i2)
        if (wb.Workbook.Sheets[i2] && !wb.Workbook.Sheets[i2].Hidden)
          break;
      if (i2 == idx)
        o2.push("<Selected/>");
    }
  }
  if (((((wb || {}).Workbook || {}).Views || [])[0] || {}).RTL)
    o2.push("<DisplayRightToLeft/>");
  if (ws["!protect"]) {
    o2.push(writetag("ProtectContents", "True"));
    if (ws["!protect"].objects)
      o2.push(writetag("ProtectObjects", "True"));
    if (ws["!protect"].scenarios)
      o2.push(writetag("ProtectScenarios", "True"));
    if (ws["!protect"].selectLockedCells != null && !ws["!protect"].selectLockedCells)
      o2.push(writetag("EnableSelection", "NoSelection"));
    else if (ws["!protect"].selectUnlockedCells != null && !ws["!protect"].selectUnlockedCells)
      o2.push(writetag("EnableSelection", "UnlockedCells"));
    [
      ["formatCells", "AllowFormatCells"],
      ["formatColumns", "AllowSizeCols"],
      ["formatRows", "AllowSizeRows"],
      ["insertColumns", "AllowInsertCols"],
      ["insertRows", "AllowInsertRows"],
      ["insertHyperlinks", "AllowInsertHyperlinks"],
      ["deleteColumns", "AllowDeleteCols"],
      ["deleteRows", "AllowDeleteRows"],
      ["sort", "AllowSort"],
      ["autoFilter", "AllowFilter"],
      ["pivotTables", "AllowUsePivotTables"]
    ].forEach(function(x2) {
      if (ws["!protect"][x2[0]])
        o2.push("<" + x2[1] + "/>");
    });
  }
  if (o2.length == 0)
    return "";
  return writextag("WorksheetOptions", o2.join(""), { xmlns: XLMLNS.x });
}
__name(write_ws_xlml_wsopts, "write_ws_xlml_wsopts");
function write_ws_xlml_comment(comments) {
  return comments.map(function(c2) {
    var t2 = xlml_unfixstr(c2.t || "");
    var d2 = writextag("ss:Data", t2, { "xmlns": "http://www.w3.org/TR/REC-html40" });
    return writextag("Comment", d2, { "ss:Author": c2.a });
  }).join("");
}
__name(write_ws_xlml_comment, "write_ws_xlml_comment");
function write_ws_xlml_cell(cell, ref, ws, opts, idx, wb, addr) {
  if (!cell || cell.v == void 0 && cell.f == void 0)
    return "";
  var attr = {};
  if (cell.f)
    attr["ss:Formula"] = "=" + escapexml(a1_to_rc(cell.f, addr));
  if (cell.F && cell.F.slice(0, ref.length) == ref) {
    var end = decode_cell(cell.F.slice(ref.length + 1));
    attr["ss:ArrayRange"] = "RC:R" + (end.r == addr.r ? "" : "[" + (end.r - addr.r) + "]") + "C" + (end.c == addr.c ? "" : "[" + (end.c - addr.c) + "]");
  }
  if (cell.l && cell.l.Target) {
    attr["ss:HRef"] = escapexml(cell.l.Target);
    if (cell.l.Tooltip)
      attr["x:HRefScreenTip"] = escapexml(cell.l.Tooltip);
  }
  if (ws["!merges"]) {
    var marr = ws["!merges"];
    for (var mi = 0; mi != marr.length; ++mi) {
      if (marr[mi].s.c != addr.c || marr[mi].s.r != addr.r)
        continue;
      if (marr[mi].e.c > marr[mi].s.c)
        attr["ss:MergeAcross"] = marr[mi].e.c - marr[mi].s.c;
      if (marr[mi].e.r > marr[mi].s.r)
        attr["ss:MergeDown"] = marr[mi].e.r - marr[mi].s.r;
    }
  }
  var t2 = "", p2 = "";
  switch (cell.t) {
    case "z":
      if (!opts.sheetStubs)
        return "";
      break;
    case "n":
      t2 = "Number";
      p2 = String(cell.v);
      break;
    case "b":
      t2 = "Boolean";
      p2 = cell.v ? "1" : "0";
      break;
    case "e":
      t2 = "Error";
      p2 = BErr[cell.v];
      break;
    case "d":
      t2 = "DateTime";
      p2 = new Date(cell.v).toISOString();
      if (cell.z == null)
        cell.z = cell.z || table_fmt[14];
      break;
    case "s":
      t2 = "String";
      p2 = escapexlml(cell.v || "");
      break;
  }
  var os = get_cell_style(opts.cellXfs, cell, opts);
  attr["ss:StyleID"] = "s" + (21 + os);
  attr["ss:Index"] = addr.c + 1;
  var _v = cell.v != null ? p2 : "";
  var m2 = cell.t == "z" ? "" : '<Data ss:Type="' + t2 + '">' + _v + "</Data>";
  if ((cell.c || []).length > 0)
    m2 += write_ws_xlml_comment(cell.c);
  return writextag("Cell", m2, attr);
}
__name(write_ws_xlml_cell, "write_ws_xlml_cell");
function write_ws_xlml_row(R2, row) {
  var o2 = '<Row ss:Index="' + (R2 + 1) + '"';
  if (row) {
    if (row.hpt && !row.hpx)
      row.hpx = pt2px(row.hpt);
    if (row.hpx)
      o2 += ' ss:AutoFitHeight="0" ss:Height="' + row.hpx + '"';
    if (row.hidden)
      o2 += ' ss:Hidden="1"';
  }
  return o2 + ">";
}
__name(write_ws_xlml_row, "write_ws_xlml_row");
function write_ws_xlml_table(ws, opts, idx, wb) {
  if (!ws["!ref"])
    return "";
  var range = safe_decode_range(ws["!ref"]);
  var marr = ws["!merges"] || [], mi = 0;
  var o2 = [];
  if (ws["!cols"])
    ws["!cols"].forEach(function(n2, i2) {
      process_col(n2);
      var w2 = !!n2.width;
      var p2 = col_obj_w(i2, n2);
      var k2 = { "ss:Index": i2 + 1 };
      if (w2)
        k2["ss:Width"] = width2px(p2.width);
      if (n2.hidden)
        k2["ss:Hidden"] = "1";
      o2.push(writextag("Column", null, k2));
    });
  var dense = Array.isArray(ws);
  for (var R2 = range.s.r; R2 <= range.e.r; ++R2) {
    var row = [write_ws_xlml_row(R2, (ws["!rows"] || [])[R2])];
    for (var C2 = range.s.c; C2 <= range.e.c; ++C2) {
      var skip2 = false;
      for (mi = 0; mi != marr.length; ++mi) {
        if (marr[mi].s.c > C2)
          continue;
        if (marr[mi].s.r > R2)
          continue;
        if (marr[mi].e.c < C2)
          continue;
        if (marr[mi].e.r < R2)
          continue;
        if (marr[mi].s.c != C2 || marr[mi].s.r != R2)
          skip2 = true;
        break;
      }
      if (skip2)
        continue;
      var addr = { r: R2, c: C2 };
      var ref = encode_cell(addr), cell = dense ? (ws[R2] || [])[C2] : ws[ref];
      row.push(write_ws_xlml_cell(cell, ref, ws, opts, idx, wb, addr));
    }
    row.push("</Row>");
    if (row.length > 2)
      o2.push(row.join(""));
  }
  return o2.join("");
}
__name(write_ws_xlml_table, "write_ws_xlml_table");
function write_ws_xlml(idx, opts, wb) {
  var o2 = [];
  var s2 = wb.SheetNames[idx];
  var ws = wb.Sheets[s2];
  var t2 = ws ? write_ws_xlml_names(ws, opts, idx, wb) : "";
  if (t2.length > 0)
    o2.push("<Names>" + t2 + "</Names>");
  t2 = ws ? write_ws_xlml_table(ws, opts, idx, wb) : "";
  if (t2.length > 0)
    o2.push("<Table>" + t2 + "</Table>");
  o2.push(write_ws_xlml_wsopts(ws, opts, idx, wb));
  return o2.join("");
}
__name(write_ws_xlml, "write_ws_xlml");
function write_xlml(wb, opts) {
  if (!opts)
    opts = {};
  if (!wb.SSF)
    wb.SSF = dup(table_fmt);
  if (wb.SSF) {
    make_ssf();
    SSF_load_table(wb.SSF);
    opts.revssf = evert_num(wb.SSF);
    opts.revssf[wb.SSF[65535]] = 0;
    opts.ssf = wb.SSF;
    opts.cellXfs = [];
    get_cell_style(opts.cellXfs, {}, { revssf: { "General": 0 } });
  }
  var d2 = [];
  d2.push(write_props_xlml(wb, opts));
  d2.push(write_wb_xlml());
  d2.push("");
  d2.push("");
  for (var i2 = 0; i2 < wb.SheetNames.length; ++i2)
    d2.push(writextag("Worksheet", write_ws_xlml(i2, opts, wb), { "ss:Name": escapexml(wb.SheetNames[i2]) }));
  d2[2] = write_sty_xlml(wb, opts);
  d2[3] = write_names_xlml(wb);
  return XML_HEADER + writextag("Workbook", d2.join(""), {
    "xmlns": XLMLNS.ss,
    "xmlns:o": XLMLNS.o,
    "xmlns:x": XLMLNS.x,
    "xmlns:ss": XLMLNS.ss,
    "xmlns:dt": XLMLNS.dt,
    "xmlns:html": XLMLNS.html
  });
}
__name(write_xlml, "write_xlml");
var PSCLSID = {
  SI: "e0859ff2f94f6810ab9108002b27b3d9",
  DSI: "02d5cdd59c2e1b10939708002b2cf9ae",
  UDI: "05d5cdd59c2e1b10939708002b2cf9ae"
};
function write_xls_props(wb, cfb) {
  var DSEntries = [], SEntries = [], CEntries = [];
  var i2 = 0, Keys;
  var DocSummaryRE = evert_key(DocSummaryPIDDSI, "n");
  var SummaryRE = evert_key(SummaryPIDSI, "n");
  if (wb.Props) {
    Keys = keys(wb.Props);
    for (i2 = 0; i2 < Keys.length; ++i2)
      (Object.prototype.hasOwnProperty.call(DocSummaryRE, Keys[i2]) ? DSEntries : Object.prototype.hasOwnProperty.call(SummaryRE, Keys[i2]) ? SEntries : CEntries).push([Keys[i2], wb.Props[Keys[i2]]]);
  }
  if (wb.Custprops) {
    Keys = keys(wb.Custprops);
    for (i2 = 0; i2 < Keys.length; ++i2)
      if (!Object.prototype.hasOwnProperty.call(wb.Props || {}, Keys[i2]))
        (Object.prototype.hasOwnProperty.call(DocSummaryRE, Keys[i2]) ? DSEntries : Object.prototype.hasOwnProperty.call(SummaryRE, Keys[i2]) ? SEntries : CEntries).push([Keys[i2], wb.Custprops[Keys[i2]]]);
  }
  var CEntries2 = [];
  for (i2 = 0; i2 < CEntries.length; ++i2) {
    if (XLSPSSkip.indexOf(CEntries[i2][0]) > -1 || PseudoPropsPairs.indexOf(CEntries[i2][0]) > -1)
      continue;
    if (CEntries[i2][1] == null)
      continue;
    CEntries2.push(CEntries[i2]);
  }
  if (SEntries.length)
    CFB.utils.cfb_add(cfb, "/SummaryInformation", write_PropertySetStream(SEntries, PSCLSID.SI, SummaryRE, SummaryPIDSI));
  if (DSEntries.length || CEntries2.length)
    CFB.utils.cfb_add(cfb, "/DocumentSummaryInformation", write_PropertySetStream(DSEntries, PSCLSID.DSI, DocSummaryRE, DocSummaryPIDDSI, CEntries2.length ? CEntries2 : null, PSCLSID.UDI));
}
__name(write_xls_props, "write_xls_props");
function write_xlscfb(wb, opts) {
  var o2 = opts || {};
  var cfb = CFB.utils.cfb_new({ root: "R" });
  var wbpath = "/Workbook";
  switch (o2.bookType || "xls") {
    case "xls":
      o2.bookType = "biff8";
    case "xla":
      if (!o2.bookType)
        o2.bookType = "xla";
    case "biff8":
      wbpath = "/Workbook";
      o2.biff = 8;
      break;
    case "biff5":
      wbpath = "/Book";
      o2.biff = 5;
      break;
    default:
      throw new Error("invalid type " + o2.bookType + " for XLS CFB");
  }
  CFB.utils.cfb_add(cfb, wbpath, write_biff_buf(wb, o2));
  if (o2.biff == 8 && (wb.Props || wb.Custprops))
    write_xls_props(wb, cfb);
  if (o2.biff == 8 && wb.vbaraw)
    fill_vba_xls(cfb, CFB.read(wb.vbaraw, { type: typeof wb.vbaraw == "string" ? "binary" : "buffer" }));
  return cfb;
}
__name(write_xlscfb, "write_xlscfb");
var XLSBRecordEnum = {
  /*::[*/
  0: {
    /* n:"BrtRowHdr", */
    f: parse_BrtRowHdr
  },
  /*::[*/
  1: {
    /* n:"BrtCellBlank", */
    f: parse_BrtCellBlank
  },
  /*::[*/
  2: {
    /* n:"BrtCellRk", */
    f: parse_BrtCellRk
  },
  /*::[*/
  3: {
    /* n:"BrtCellError", */
    f: parse_BrtCellError
  },
  /*::[*/
  4: {
    /* n:"BrtCellBool", */
    f: parse_BrtCellBool
  },
  /*::[*/
  5: {
    /* n:"BrtCellReal", */
    f: parse_BrtCellReal
  },
  /*::[*/
  6: {
    /* n:"BrtCellSt", */
    f: parse_BrtCellSt
  },
  /*::[*/
  7: {
    /* n:"BrtCellIsst", */
    f: parse_BrtCellIsst
  },
  /*::[*/
  8: {
    /* n:"BrtFmlaString", */
    f: parse_BrtFmlaString
  },
  /*::[*/
  9: {
    /* n:"BrtFmlaNum", */
    f: parse_BrtFmlaNum
  },
  /*::[*/
  10: {
    /* n:"BrtFmlaBool", */
    f: parse_BrtFmlaBool
  },
  /*::[*/
  11: {
    /* n:"BrtFmlaError", */
    f: parse_BrtFmlaError
  },
  /*::[*/
  12: {
    /* n:"BrtShortBlank", */
    f: parse_BrtShortBlank
  },
  /*::[*/
  13: {
    /* n:"BrtShortRk", */
    f: parse_BrtShortRk
  },
  /*::[*/
  14: {
    /* n:"BrtShortError", */
    f: parse_BrtShortError
  },
  /*::[*/
  15: {
    /* n:"BrtShortBool", */
    f: parse_BrtShortBool
  },
  /*::[*/
  16: {
    /* n:"BrtShortReal", */
    f: parse_BrtShortReal
  },
  /*::[*/
  17: {
    /* n:"BrtShortSt", */
    f: parse_BrtShortSt
  },
  /*::[*/
  18: {
    /* n:"BrtShortIsst", */
    f: parse_BrtShortIsst
  },
  /*::[*/
  19: {
    /* n:"BrtSSTItem", */
    f: parse_RichStr
  },
  /*::[*/
  20: {
    /* n:"BrtPCDIMissing" */
  },
  /*::[*/
  21: {
    /* n:"BrtPCDINumber" */
  },
  /*::[*/
  22: {
    /* n:"BrtPCDIBoolean" */
  },
  /*::[*/
  23: {
    /* n:"BrtPCDIError" */
  },
  /*::[*/
  24: {
    /* n:"BrtPCDIString" */
  },
  /*::[*/
  25: {
    /* n:"BrtPCDIDatetime" */
  },
  /*::[*/
  26: {
    /* n:"BrtPCDIIndex" */
  },
  /*::[*/
  27: {
    /* n:"BrtPCDIAMissing" */
  },
  /*::[*/
  28: {
    /* n:"BrtPCDIANumber" */
  },
  /*::[*/
  29: {
    /* n:"BrtPCDIABoolean" */
  },
  /*::[*/
  30: {
    /* n:"BrtPCDIAError" */
  },
  /*::[*/
  31: {
    /* n:"BrtPCDIAString" */
  },
  /*::[*/
  32: {
    /* n:"BrtPCDIADatetime" */
  },
  /*::[*/
  33: {
    /* n:"BrtPCRRecord" */
  },
  /*::[*/
  34: {
    /* n:"BrtPCRRecordDt" */
  },
  /*::[*/
  35: {
    /* n:"BrtFRTBegin", */
    T: 1
  },
  /*::[*/
  36: {
    /* n:"BrtFRTEnd", */
    T: -1
  },
  /*::[*/
  37: {
    /* n:"BrtACBegin", */
    T: 1
  },
  /*::[*/
  38: {
    /* n:"BrtACEnd", */
    T: -1
  },
  /*::[*/
  39: {
    /* n:"BrtName", */
    f: parse_BrtName
  },
  /*::[*/
  40: {
    /* n:"BrtIndexRowBlock" */
  },
  /*::[*/
  42: {
    /* n:"BrtIndexBlock" */
  },
  /*::[*/
  43: {
    /* n:"BrtFont", */
    f: parse_BrtFont
  },
  /*::[*/
  44: {
    /* n:"BrtFmt", */
    f: parse_BrtFmt
  },
  /*::[*/
  45: {
    /* n:"BrtFill", */
    f: parse_BrtFill
  },
  /*::[*/
  46: {
    /* n:"BrtBorder", */
    f: parse_BrtBorder
  },
  /*::[*/
  47: {
    /* n:"BrtXF", */
    f: parse_BrtXF
  },
  /*::[*/
  48: {
    /* n:"BrtStyle" */
  },
  /*::[*/
  49: {
    /* n:"BrtCellMeta", */
    f: parse_Int32LE
  },
  /*::[*/
  50: {
    /* n:"BrtValueMeta" */
  },
  /*::[*/
  51: {
    /* n:"BrtMdb" */
    f: parse_BrtMdb
  },
  /*::[*/
  52: {
    /* n:"BrtBeginFmd", */
    T: 1
  },
  /*::[*/
  53: {
    /* n:"BrtEndFmd", */
    T: -1
  },
  /*::[*/
  54: {
    /* n:"BrtBeginMdx", */
    T: 1
  },
  /*::[*/
  55: {
    /* n:"BrtEndMdx", */
    T: -1
  },
  /*::[*/
  56: {
    /* n:"BrtBeginMdxTuple", */
    T: 1
  },
  /*::[*/
  57: {
    /* n:"BrtEndMdxTuple", */
    T: -1
  },
  /*::[*/
  58: {
    /* n:"BrtMdxMbrIstr" */
  },
  /*::[*/
  59: {
    /* n:"BrtStr" */
  },
  /*::[*/
  60: {
    /* n:"BrtColInfo", */
    f: parse_ColInfo
  },
  /*::[*/
  62: {
    /* n:"BrtCellRString", */
    f: parse_BrtCellRString
  },
  /*::[*/
  63: {
    /* n:"BrtCalcChainItem$", */
    f: parse_BrtCalcChainItem$
  },
  /*::[*/
  64: {
    /* n:"BrtDVal", */
    f: parse_BrtDVal
  },
  /*::[*/
  65: {
    /* n:"BrtSxvcellNum" */
  },
  /*::[*/
  66: {
    /* n:"BrtSxvcellStr" */
  },
  /*::[*/
  67: {
    /* n:"BrtSxvcellBool" */
  },
  /*::[*/
  68: {
    /* n:"BrtSxvcellErr" */
  },
  /*::[*/
  69: {
    /* n:"BrtSxvcellDate" */
  },
  /*::[*/
  70: {
    /* n:"BrtSxvcellNil" */
  },
  /*::[*/
  128: {
    /* n:"BrtFileVersion" */
  },
  /*::[*/
  129: {
    /* n:"BrtBeginSheet", */
    T: 1
  },
  /*::[*/
  130: {
    /* n:"BrtEndSheet", */
    T: -1
  },
  /*::[*/
  131: {
    /* n:"BrtBeginBook", */
    T: 1,
    f: parsenoop,
    p: 0
  },
  /*::[*/
  132: {
    /* n:"BrtEndBook", */
    T: -1
  },
  /*::[*/
  133: {
    /* n:"BrtBeginWsViews", */
    T: 1
  },
  /*::[*/
  134: {
    /* n:"BrtEndWsViews", */
    T: -1
  },
  /*::[*/
  135: {
    /* n:"BrtBeginBookViews", */
    T: 1
  },
  /*::[*/
  136: {
    /* n:"BrtEndBookViews", */
    T: -1
  },
  /*::[*/
  137: {
    /* n:"BrtBeginWsView", */
    T: 1,
    f: parse_BrtBeginWsView
  },
  /*::[*/
  138: {
    /* n:"BrtEndWsView", */
    T: -1
  },
  /*::[*/
  139: {
    /* n:"BrtBeginCsViews", */
    T: 1
  },
  /*::[*/
  140: {
    /* n:"BrtEndCsViews", */
    T: -1
  },
  /*::[*/
  141: {
    /* n:"BrtBeginCsView", */
    T: 1
  },
  /*::[*/
  142: {
    /* n:"BrtEndCsView", */
    T: -1
  },
  /*::[*/
  143: {
    /* n:"BrtBeginBundleShs", */
    T: 1
  },
  /*::[*/
  144: {
    /* n:"BrtEndBundleShs", */
    T: -1
  },
  /*::[*/
  145: {
    /* n:"BrtBeginSheetData", */
    T: 1
  },
  /*::[*/
  146: {
    /* n:"BrtEndSheetData", */
    T: -1
  },
  /*::[*/
  147: {
    /* n:"BrtWsProp", */
    f: parse_BrtWsProp
  },
  /*::[*/
  148: {
    /* n:"BrtWsDim", */
    f: parse_BrtWsDim,
    p: 16
  },
  /*::[*/
  151: {
    /* n:"BrtPane", */
    f: parse_BrtPane
  },
  /*::[*/
  152: {
    /* n:"BrtSel" */
  },
  /*::[*/
  153: {
    /* n:"BrtWbProp", */
    f: parse_BrtWbProp
  },
  /*::[*/
  154: {
    /* n:"BrtWbFactoid" */
  },
  /*::[*/
  155: {
    /* n:"BrtFileRecover" */
  },
  /*::[*/
  156: {
    /* n:"BrtBundleSh", */
    f: parse_BrtBundleSh
  },
  /*::[*/
  157: {
    /* n:"BrtCalcProp" */
  },
  /*::[*/
  158: {
    /* n:"BrtBookView" */
  },
  /*::[*/
  159: {
    /* n:"BrtBeginSst", */
    T: 1,
    f: parse_BrtBeginSst
  },
  /*::[*/
  160: {
    /* n:"BrtEndSst", */
    T: -1
  },
  /*::[*/
  161: {
    /* n:"BrtBeginAFilter", */
    T: 1,
    f: parse_UncheckedRfX
  },
  /*::[*/
  162: {
    /* n:"BrtEndAFilter", */
    T: -1
  },
  /*::[*/
  163: {
    /* n:"BrtBeginFilterColumn", */
    T: 1
  },
  /*::[*/
  164: {
    /* n:"BrtEndFilterColumn", */
    T: -1
  },
  /*::[*/
  165: {
    /* n:"BrtBeginFilters", */
    T: 1
  },
  /*::[*/
  166: {
    /* n:"BrtEndFilters", */
    T: -1
  },
  /*::[*/
  167: {
    /* n:"BrtFilter" */
  },
  /*::[*/
  168: {
    /* n:"BrtColorFilter" */
  },
  /*::[*/
  169: {
    /* n:"BrtIconFilter" */
  },
  /*::[*/
  170: {
    /* n:"BrtTop10Filter" */
  },
  /*::[*/
  171: {
    /* n:"BrtDynamicFilter" */
  },
  /*::[*/
  172: {
    /* n:"BrtBeginCustomFilters", */
    T: 1
  },
  /*::[*/
  173: {
    /* n:"BrtEndCustomFilters", */
    T: -1
  },
  /*::[*/
  174: {
    /* n:"BrtCustomFilter" */
  },
  /*::[*/
  175: {
    /* n:"BrtAFilterDateGroupItem" */
  },
  /*::[*/
  176: {
    /* n:"BrtMergeCell", */
    f: parse_BrtMergeCell
  },
  /*::[*/
  177: {
    /* n:"BrtBeginMergeCells", */
    T: 1
  },
  /*::[*/
  178: {
    /* n:"BrtEndMergeCells", */
    T: -1
  },
  /*::[*/
  179: {
    /* n:"BrtBeginPivotCacheDef", */
    T: 1
  },
  /*::[*/
  180: {
    /* n:"BrtEndPivotCacheDef", */
    T: -1
  },
  /*::[*/
  181: {
    /* n:"BrtBeginPCDFields", */
    T: 1
  },
  /*::[*/
  182: {
    /* n:"BrtEndPCDFields", */
    T: -1
  },
  /*::[*/
  183: {
    /* n:"BrtBeginPCDField", */
    T: 1
  },
  /*::[*/
  184: {
    /* n:"BrtEndPCDField", */
    T: -1
  },
  /*::[*/
  185: {
    /* n:"BrtBeginPCDSource", */
    T: 1
  },
  /*::[*/
  186: {
    /* n:"BrtEndPCDSource", */
    T: -1
  },
  /*::[*/
  187: {
    /* n:"BrtBeginPCDSRange", */
    T: 1
  },
  /*::[*/
  188: {
    /* n:"BrtEndPCDSRange", */
    T: -1
  },
  /*::[*/
  189: {
    /* n:"BrtBeginPCDFAtbl", */
    T: 1
  },
  /*::[*/
  190: {
    /* n:"BrtEndPCDFAtbl", */
    T: -1
  },
  /*::[*/
  191: {
    /* n:"BrtBeginPCDIRun", */
    T: 1
  },
  /*::[*/
  192: {
    /* n:"BrtEndPCDIRun", */
    T: -1
  },
  /*::[*/
  193: {
    /* n:"BrtBeginPivotCacheRecords", */
    T: 1
  },
  /*::[*/
  194: {
    /* n:"BrtEndPivotCacheRecords", */
    T: -1
  },
  /*::[*/
  195: {
    /* n:"BrtBeginPCDHierarchies", */
    T: 1
  },
  /*::[*/
  196: {
    /* n:"BrtEndPCDHierarchies", */
    T: -1
  },
  /*::[*/
  197: {
    /* n:"BrtBeginPCDHierarchy", */
    T: 1
  },
  /*::[*/
  198: {
    /* n:"BrtEndPCDHierarchy", */
    T: -1
  },
  /*::[*/
  199: {
    /* n:"BrtBeginPCDHFieldsUsage", */
    T: 1
  },
  /*::[*/
  200: {
    /* n:"BrtEndPCDHFieldsUsage", */
    T: -1
  },
  /*::[*/
  201: {
    /* n:"BrtBeginExtConnection", */
    T: 1
  },
  /*::[*/
  202: {
    /* n:"BrtEndExtConnection", */
    T: -1
  },
  /*::[*/
  203: {
    /* n:"BrtBeginECDbProps", */
    T: 1
  },
  /*::[*/
  204: {
    /* n:"BrtEndECDbProps", */
    T: -1
  },
  /*::[*/
  205: {
    /* n:"BrtBeginECOlapProps", */
    T: 1
  },
  /*::[*/
  206: {
    /* n:"BrtEndECOlapProps", */
    T: -1
  },
  /*::[*/
  207: {
    /* n:"BrtBeginPCDSConsol", */
    T: 1
  },
  /*::[*/
  208: {
    /* n:"BrtEndPCDSConsol", */
    T: -1
  },
  /*::[*/
  209: {
    /* n:"BrtBeginPCDSCPages", */
    T: 1
  },
  /*::[*/
  210: {
    /* n:"BrtEndPCDSCPages", */
    T: -1
  },
  /*::[*/
  211: {
    /* n:"BrtBeginPCDSCPage", */
    T: 1
  },
  /*::[*/
  212: {
    /* n:"BrtEndPCDSCPage", */
    T: -1
  },
  /*::[*/
  213: {
    /* n:"BrtBeginPCDSCPItem", */
    T: 1
  },
  /*::[*/
  214: {
    /* n:"BrtEndPCDSCPItem", */
    T: -1
  },
  /*::[*/
  215: {
    /* n:"BrtBeginPCDSCSets", */
    T: 1
  },
  /*::[*/
  216: {
    /* n:"BrtEndPCDSCSets", */
    T: -1
  },
  /*::[*/
  217: {
    /* n:"BrtBeginPCDSCSet", */
    T: 1
  },
  /*::[*/
  218: {
    /* n:"BrtEndPCDSCSet", */
    T: -1
  },
  /*::[*/
  219: {
    /* n:"BrtBeginPCDFGroup", */
    T: 1
  },
  /*::[*/
  220: {
    /* n:"BrtEndPCDFGroup", */
    T: -1
  },
  /*::[*/
  221: {
    /* n:"BrtBeginPCDFGItems", */
    T: 1
  },
  /*::[*/
  222: {
    /* n:"BrtEndPCDFGItems", */
    T: -1
  },
  /*::[*/
  223: {
    /* n:"BrtBeginPCDFGRange", */
    T: 1
  },
  /*::[*/
  224: {
    /* n:"BrtEndPCDFGRange", */
    T: -1
  },
  /*::[*/
  225: {
    /* n:"BrtBeginPCDFGDiscrete", */
    T: 1
  },
  /*::[*/
  226: {
    /* n:"BrtEndPCDFGDiscrete", */
    T: -1
  },
  /*::[*/
  227: {
    /* n:"BrtBeginPCDSDTupleCache", */
    T: 1
  },
  /*::[*/
  228: {
    /* n:"BrtEndPCDSDTupleCache", */
    T: -1
  },
  /*::[*/
  229: {
    /* n:"BrtBeginPCDSDTCEntries", */
    T: 1
  },
  /*::[*/
  230: {
    /* n:"BrtEndPCDSDTCEntries", */
    T: -1
  },
  /*::[*/
  231: {
    /* n:"BrtBeginPCDSDTCEMembers", */
    T: 1
  },
  /*::[*/
  232: {
    /* n:"BrtEndPCDSDTCEMembers", */
    T: -1
  },
  /*::[*/
  233: {
    /* n:"BrtBeginPCDSDTCEMember", */
    T: 1
  },
  /*::[*/
  234: {
    /* n:"BrtEndPCDSDTCEMember", */
    T: -1
  },
  /*::[*/
  235: {
    /* n:"BrtBeginPCDSDTCQueries", */
    T: 1
  },
  /*::[*/
  236: {
    /* n:"BrtEndPCDSDTCQueries", */
    T: -1
  },
  /*::[*/
  237: {
    /* n:"BrtBeginPCDSDTCQuery", */
    T: 1
  },
  /*::[*/
  238: {
    /* n:"BrtEndPCDSDTCQuery", */
    T: -1
  },
  /*::[*/
  239: {
    /* n:"BrtBeginPCDSDTCSets", */
    T: 1
  },
  /*::[*/
  240: {
    /* n:"BrtEndPCDSDTCSets", */
    T: -1
  },
  /*::[*/
  241: {
    /* n:"BrtBeginPCDSDTCSet", */
    T: 1
  },
  /*::[*/
  242: {
    /* n:"BrtEndPCDSDTCSet", */
    T: -1
  },
  /*::[*/
  243: {
    /* n:"BrtBeginPCDCalcItems", */
    T: 1
  },
  /*::[*/
  244: {
    /* n:"BrtEndPCDCalcItems", */
    T: -1
  },
  /*::[*/
  245: {
    /* n:"BrtBeginPCDCalcItem", */
    T: 1
  },
  /*::[*/
  246: {
    /* n:"BrtEndPCDCalcItem", */
    T: -1
  },
  /*::[*/
  247: {
    /* n:"BrtBeginPRule", */
    T: 1
  },
  /*::[*/
  248: {
    /* n:"BrtEndPRule", */
    T: -1
  },
  /*::[*/
  249: {
    /* n:"BrtBeginPRFilters", */
    T: 1
  },
  /*::[*/
  250: {
    /* n:"BrtEndPRFilters", */
    T: -1
  },
  /*::[*/
  251: {
    /* n:"BrtBeginPRFilter", */
    T: 1
  },
  /*::[*/
  252: {
    /* n:"BrtEndPRFilter", */
    T: -1
  },
  /*::[*/
  253: {
    /* n:"BrtBeginPNames", */
    T: 1
  },
  /*::[*/
  254: {
    /* n:"BrtEndPNames", */
    T: -1
  },
  /*::[*/
  255: {
    /* n:"BrtBeginPName", */
    T: 1
  },
  /*::[*/
  256: {
    /* n:"BrtEndPName", */
    T: -1
  },
  /*::[*/
  257: {
    /* n:"BrtBeginPNPairs", */
    T: 1
  },
  /*::[*/
  258: {
    /* n:"BrtEndPNPairs", */
    T: -1
  },
  /*::[*/
  259: {
    /* n:"BrtBeginPNPair", */
    T: 1
  },
  /*::[*/
  260: {
    /* n:"BrtEndPNPair", */
    T: -1
  },
  /*::[*/
  261: {
    /* n:"BrtBeginECWebProps", */
    T: 1
  },
  /*::[*/
  262: {
    /* n:"BrtEndECWebProps", */
    T: -1
  },
  /*::[*/
  263: {
    /* n:"BrtBeginEcWpTables", */
    T: 1
  },
  /*::[*/
  264: {
    /* n:"BrtEndECWPTables", */
    T: -1
  },
  /*::[*/
  265: {
    /* n:"BrtBeginECParams", */
    T: 1
  },
  /*::[*/
  266: {
    /* n:"BrtEndECParams", */
    T: -1
  },
  /*::[*/
  267: {
    /* n:"BrtBeginECParam", */
    T: 1
  },
  /*::[*/
  268: {
    /* n:"BrtEndECParam", */
    T: -1
  },
  /*::[*/
  269: {
    /* n:"BrtBeginPCDKPIs", */
    T: 1
  },
  /*::[*/
  270: {
    /* n:"BrtEndPCDKPIs", */
    T: -1
  },
  /*::[*/
  271: {
    /* n:"BrtBeginPCDKPI", */
    T: 1
  },
  /*::[*/
  272: {
    /* n:"BrtEndPCDKPI", */
    T: -1
  },
  /*::[*/
  273: {
    /* n:"BrtBeginDims", */
    T: 1
  },
  /*::[*/
  274: {
    /* n:"BrtEndDims", */
    T: -1
  },
  /*::[*/
  275: {
    /* n:"BrtBeginDim", */
    T: 1
  },
  /*::[*/
  276: {
    /* n:"BrtEndDim", */
    T: -1
  },
  /*::[*/
  277: {
    /* n:"BrtIndexPartEnd" */
  },
  /*::[*/
  278: {
    /* n:"BrtBeginStyleSheet", */
    T: 1
  },
  /*::[*/
  279: {
    /* n:"BrtEndStyleSheet", */
    T: -1
  },
  /*::[*/
  280: {
    /* n:"BrtBeginSXView", */
    T: 1
  },
  /*::[*/
  281: {
    /* n:"BrtEndSXVI", */
    T: -1
  },
  /*::[*/
  282: {
    /* n:"BrtBeginSXVI", */
    T: 1
  },
  /*::[*/
  283: {
    /* n:"BrtBeginSXVIs", */
    T: 1
  },
  /*::[*/
  284: {
    /* n:"BrtEndSXVIs", */
    T: -1
  },
  /*::[*/
  285: {
    /* n:"BrtBeginSXVD", */
    T: 1
  },
  /*::[*/
  286: {
    /* n:"BrtEndSXVD", */
    T: -1
  },
  /*::[*/
  287: {
    /* n:"BrtBeginSXVDs", */
    T: 1
  },
  /*::[*/
  288: {
    /* n:"BrtEndSXVDs", */
    T: -1
  },
  /*::[*/
  289: {
    /* n:"BrtBeginSXPI", */
    T: 1
  },
  /*::[*/
  290: {
    /* n:"BrtEndSXPI", */
    T: -1
  },
  /*::[*/
  291: {
    /* n:"BrtBeginSXPIs", */
    T: 1
  },
  /*::[*/
  292: {
    /* n:"BrtEndSXPIs", */
    T: -1
  },
  /*::[*/
  293: {
    /* n:"BrtBeginSXDI", */
    T: 1
  },
  /*::[*/
  294: {
    /* n:"BrtEndSXDI", */
    T: -1
  },
  /*::[*/
  295: {
    /* n:"BrtBeginSXDIs", */
    T: 1
  },
  /*::[*/
  296: {
    /* n:"BrtEndSXDIs", */
    T: -1
  },
  /*::[*/
  297: {
    /* n:"BrtBeginSXLI", */
    T: 1
  },
  /*::[*/
  298: {
    /* n:"BrtEndSXLI", */
    T: -1
  },
  /*::[*/
  299: {
    /* n:"BrtBeginSXLIRws", */
    T: 1
  },
  /*::[*/
  300: {
    /* n:"BrtEndSXLIRws", */
    T: -1
  },
  /*::[*/
  301: {
    /* n:"BrtBeginSXLICols", */
    T: 1
  },
  /*::[*/
  302: {
    /* n:"BrtEndSXLICols", */
    T: -1
  },
  /*::[*/
  303: {
    /* n:"BrtBeginSXFormat", */
    T: 1
  },
  /*::[*/
  304: {
    /* n:"BrtEndSXFormat", */
    T: -1
  },
  /*::[*/
  305: {
    /* n:"BrtBeginSXFormats", */
    T: 1
  },
  /*::[*/
  306: {
    /* n:"BrtEndSxFormats", */
    T: -1
  },
  /*::[*/
  307: {
    /* n:"BrtBeginSxSelect", */
    T: 1
  },
  /*::[*/
  308: {
    /* n:"BrtEndSxSelect", */
    T: -1
  },
  /*::[*/
  309: {
    /* n:"BrtBeginISXVDRws", */
    T: 1
  },
  /*::[*/
  310: {
    /* n:"BrtEndISXVDRws", */
    T: -1
  },
  /*::[*/
  311: {
    /* n:"BrtBeginISXVDCols", */
    T: 1
  },
  /*::[*/
  312: {
    /* n:"BrtEndISXVDCols", */
    T: -1
  },
  /*::[*/
  313: {
    /* n:"BrtEndSXLocation", */
    T: -1
  },
  /*::[*/
  314: {
    /* n:"BrtBeginSXLocation", */
    T: 1
  },
  /*::[*/
  315: {
    /* n:"BrtEndSXView", */
    T: -1
  },
  /*::[*/
  316: {
    /* n:"BrtBeginSXTHs", */
    T: 1
  },
  /*::[*/
  317: {
    /* n:"BrtEndSXTHs", */
    T: -1
  },
  /*::[*/
  318: {
    /* n:"BrtBeginSXTH", */
    T: 1
  },
  /*::[*/
  319: {
    /* n:"BrtEndSXTH", */
    T: -1
  },
  /*::[*/
  320: {
    /* n:"BrtBeginISXTHRws", */
    T: 1
  },
  /*::[*/
  321: {
    /* n:"BrtEndISXTHRws", */
    T: -1
  },
  /*::[*/
  322: {
    /* n:"BrtBeginISXTHCols", */
    T: 1
  },
  /*::[*/
  323: {
    /* n:"BrtEndISXTHCols", */
    T: -1
  },
  /*::[*/
  324: {
    /* n:"BrtBeginSXTDMPS", */
    T: 1
  },
  /*::[*/
  325: {
    /* n:"BrtEndSXTDMPs", */
    T: -1
  },
  /*::[*/
  326: {
    /* n:"BrtBeginSXTDMP", */
    T: 1
  },
  /*::[*/
  327: {
    /* n:"BrtEndSXTDMP", */
    T: -1
  },
  /*::[*/
  328: {
    /* n:"BrtBeginSXTHItems", */
    T: 1
  },
  /*::[*/
  329: {
    /* n:"BrtEndSXTHItems", */
    T: -1
  },
  /*::[*/
  330: {
    /* n:"BrtBeginSXTHItem", */
    T: 1
  },
  /*::[*/
  331: {
    /* n:"BrtEndSXTHItem", */
    T: -1
  },
  /*::[*/
  332: {
    /* n:"BrtBeginMetadata", */
    T: 1
  },
  /*::[*/
  333: {
    /* n:"BrtEndMetadata", */
    T: -1
  },
  /*::[*/
  334: {
    /* n:"BrtBeginEsmdtinfo", */
    T: 1
  },
  /*::[*/
  335: {
    /* n:"BrtMdtinfo", */
    f: parse_BrtMdtinfo
  },
  /*::[*/
  336: {
    /* n:"BrtEndEsmdtinfo", */
    T: -1
  },
  /*::[*/
  337: {
    /* n:"BrtBeginEsmdb", */
    f: parse_BrtBeginEsmdb,
    T: 1
  },
  /*::[*/
  338: {
    /* n:"BrtEndEsmdb", */
    T: -1
  },
  /*::[*/
  339: {
    /* n:"BrtBeginEsfmd", */
    T: 1
  },
  /*::[*/
  340: {
    /* n:"BrtEndEsfmd", */
    T: -1
  },
  /*::[*/
  341: {
    /* n:"BrtBeginSingleCells", */
    T: 1
  },
  /*::[*/
  342: {
    /* n:"BrtEndSingleCells", */
    T: -1
  },
  /*::[*/
  343: {
    /* n:"BrtBeginList", */
    T: 1
  },
  /*::[*/
  344: {
    /* n:"BrtEndList", */
    T: -1
  },
  /*::[*/
  345: {
    /* n:"BrtBeginListCols", */
    T: 1
  },
  /*::[*/
  346: {
    /* n:"BrtEndListCols", */
    T: -1
  },
  /*::[*/
  347: {
    /* n:"BrtBeginListCol", */
    T: 1
  },
  /*::[*/
  348: {
    /* n:"BrtEndListCol", */
    T: -1
  },
  /*::[*/
  349: {
    /* n:"BrtBeginListXmlCPr", */
    T: 1
  },
  /*::[*/
  350: {
    /* n:"BrtEndListXmlCPr", */
    T: -1
  },
  /*::[*/
  351: {
    /* n:"BrtListCCFmla" */
  },
  /*::[*/
  352: {
    /* n:"BrtListTrFmla" */
  },
  /*::[*/
  353: {
    /* n:"BrtBeginExternals", */
    T: 1
  },
  /*::[*/
  354: {
    /* n:"BrtEndExternals", */
    T: -1
  },
  /*::[*/
  355: {
    /* n:"BrtSupBookSrc", */
    f: parse_RelID
  },
  /*::[*/
  357: {
    /* n:"BrtSupSelf" */
  },
  /*::[*/
  358: {
    /* n:"BrtSupSame" */
  },
  /*::[*/
  359: {
    /* n:"BrtSupTabs" */
  },
  /*::[*/
  360: {
    /* n:"BrtBeginSupBook", */
    T: 1
  },
  /*::[*/
  361: {
    /* n:"BrtPlaceholderName" */
  },
  /*::[*/
  362: {
    /* n:"BrtExternSheet", */
    f: parse_ExternSheet
  },
  /*::[*/
  363: {
    /* n:"BrtExternTableStart" */
  },
  /*::[*/
  364: {
    /* n:"BrtExternTableEnd" */
  },
  /*::[*/
  366: {
    /* n:"BrtExternRowHdr" */
  },
  /*::[*/
  367: {
    /* n:"BrtExternCellBlank" */
  },
  /*::[*/
  368: {
    /* n:"BrtExternCellReal" */
  },
  /*::[*/
  369: {
    /* n:"BrtExternCellBool" */
  },
  /*::[*/
  370: {
    /* n:"BrtExternCellError" */
  },
  /*::[*/
  371: {
    /* n:"BrtExternCellString" */
  },
  /*::[*/
  372: {
    /* n:"BrtBeginEsmdx", */
    T: 1
  },
  /*::[*/
  373: {
    /* n:"BrtEndEsmdx", */
    T: -1
  },
  /*::[*/
  374: {
    /* n:"BrtBeginMdxSet", */
    T: 1
  },
  /*::[*/
  375: {
    /* n:"BrtEndMdxSet", */
    T: -1
  },
  /*::[*/
  376: {
    /* n:"BrtBeginMdxMbrProp", */
    T: 1
  },
  /*::[*/
  377: {
    /* n:"BrtEndMdxMbrProp", */
    T: -1
  },
  /*::[*/
  378: {
    /* n:"BrtBeginMdxKPI", */
    T: 1
  },
  /*::[*/
  379: {
    /* n:"BrtEndMdxKPI", */
    T: -1
  },
  /*::[*/
  380: {
    /* n:"BrtBeginEsstr", */
    T: 1
  },
  /*::[*/
  381: {
    /* n:"BrtEndEsstr", */
    T: -1
  },
  /*::[*/
  382: {
    /* n:"BrtBeginPRFItem", */
    T: 1
  },
  /*::[*/
  383: {
    /* n:"BrtEndPRFItem", */
    T: -1
  },
  /*::[*/
  384: {
    /* n:"BrtBeginPivotCacheIDs", */
    T: 1
  },
  /*::[*/
  385: {
    /* n:"BrtEndPivotCacheIDs", */
    T: -1
  },
  /*::[*/
  386: {
    /* n:"BrtBeginPivotCacheID", */
    T: 1
  },
  /*::[*/
  387: {
    /* n:"BrtEndPivotCacheID", */
    T: -1
  },
  /*::[*/
  388: {
    /* n:"BrtBeginISXVIs", */
    T: 1
  },
  /*::[*/
  389: {
    /* n:"BrtEndISXVIs", */
    T: -1
  },
  /*::[*/
  390: {
    /* n:"BrtBeginColInfos", */
    T: 1
  },
  /*::[*/
  391: {
    /* n:"BrtEndColInfos", */
    T: -1
  },
  /*::[*/
  392: {
    /* n:"BrtBeginRwBrk", */
    T: 1
  },
  /*::[*/
  393: {
    /* n:"BrtEndRwBrk", */
    T: -1
  },
  /*::[*/
  394: {
    /* n:"BrtBeginColBrk", */
    T: 1
  },
  /*::[*/
  395: {
    /* n:"BrtEndColBrk", */
    T: -1
  },
  /*::[*/
  396: {
    /* n:"BrtBrk" */
  },
  /*::[*/
  397: {
    /* n:"BrtUserBookView" */
  },
  /*::[*/
  398: {
    /* n:"BrtInfo" */
  },
  /*::[*/
  399: {
    /* n:"BrtCUsr" */
  },
  /*::[*/
  400: {
    /* n:"BrtUsr" */
  },
  /*::[*/
  401: {
    /* n:"BrtBeginUsers", */
    T: 1
  },
  /*::[*/
  403: {
    /* n:"BrtEOF" */
  },
  /*::[*/
  404: {
    /* n:"BrtUCR" */
  },
  /*::[*/
  405: {
    /* n:"BrtRRInsDel" */
  },
  /*::[*/
  406: {
    /* n:"BrtRREndInsDel" */
  },
  /*::[*/
  407: {
    /* n:"BrtRRMove" */
  },
  /*::[*/
  408: {
    /* n:"BrtRREndMove" */
  },
  /*::[*/
  409: {
    /* n:"BrtRRChgCell" */
  },
  /*::[*/
  410: {
    /* n:"BrtRREndChgCell" */
  },
  /*::[*/
  411: {
    /* n:"BrtRRHeader" */
  },
  /*::[*/
  412: {
    /* n:"BrtRRUserView" */
  },
  /*::[*/
  413: {
    /* n:"BrtRRRenSheet" */
  },
  /*::[*/
  414: {
    /* n:"BrtRRInsertSh" */
  },
  /*::[*/
  415: {
    /* n:"BrtRRDefName" */
  },
  /*::[*/
  416: {
    /* n:"BrtRRNote" */
  },
  /*::[*/
  417: {
    /* n:"BrtRRConflict" */
  },
  /*::[*/
  418: {
    /* n:"BrtRRTQSIF" */
  },
  /*::[*/
  419: {
    /* n:"BrtRRFormat" */
  },
  /*::[*/
  420: {
    /* n:"BrtRREndFormat" */
  },
  /*::[*/
  421: {
    /* n:"BrtRRAutoFmt" */
  },
  /*::[*/
  422: {
    /* n:"BrtBeginUserShViews", */
    T: 1
  },
  /*::[*/
  423: {
    /* n:"BrtBeginUserShView", */
    T: 1
  },
  /*::[*/
  424: {
    /* n:"BrtEndUserShView", */
    T: -1
  },
  /*::[*/
  425: {
    /* n:"BrtEndUserShViews", */
    T: -1
  },
  /*::[*/
  426: {
    /* n:"BrtArrFmla", */
    f: parse_BrtArrFmla
  },
  /*::[*/
  427: {
    /* n:"BrtShrFmla", */
    f: parse_BrtShrFmla
  },
  /*::[*/
  428: {
    /* n:"BrtTable" */
  },
  /*::[*/
  429: {
    /* n:"BrtBeginExtConnections", */
    T: 1
  },
  /*::[*/
  430: {
    /* n:"BrtEndExtConnections", */
    T: -1
  },
  /*::[*/
  431: {
    /* n:"BrtBeginPCDCalcMems", */
    T: 1
  },
  /*::[*/
  432: {
    /* n:"BrtEndPCDCalcMems", */
    T: -1
  },
  /*::[*/
  433: {
    /* n:"BrtBeginPCDCalcMem", */
    T: 1
  },
  /*::[*/
  434: {
    /* n:"BrtEndPCDCalcMem", */
    T: -1
  },
  /*::[*/
  435: {
    /* n:"BrtBeginPCDHGLevels", */
    T: 1
  },
  /*::[*/
  436: {
    /* n:"BrtEndPCDHGLevels", */
    T: -1
  },
  /*::[*/
  437: {
    /* n:"BrtBeginPCDHGLevel", */
    T: 1
  },
  /*::[*/
  438: {
    /* n:"BrtEndPCDHGLevel", */
    T: -1
  },
  /*::[*/
  439: {
    /* n:"BrtBeginPCDHGLGroups", */
    T: 1
  },
  /*::[*/
  440: {
    /* n:"BrtEndPCDHGLGroups", */
    T: -1
  },
  /*::[*/
  441: {
    /* n:"BrtBeginPCDHGLGroup", */
    T: 1
  },
  /*::[*/
  442: {
    /* n:"BrtEndPCDHGLGroup", */
    T: -1
  },
  /*::[*/
  443: {
    /* n:"BrtBeginPCDHGLGMembers", */
    T: 1
  },
  /*::[*/
  444: {
    /* n:"BrtEndPCDHGLGMembers", */
    T: -1
  },
  /*::[*/
  445: {
    /* n:"BrtBeginPCDHGLGMember", */
    T: 1
  },
  /*::[*/
  446: {
    /* n:"BrtEndPCDHGLGMember", */
    T: -1
  },
  /*::[*/
  447: {
    /* n:"BrtBeginQSI", */
    T: 1
  },
  /*::[*/
  448: {
    /* n:"BrtEndQSI", */
    T: -1
  },
  /*::[*/
  449: {
    /* n:"BrtBeginQSIR", */
    T: 1
  },
  /*::[*/
  450: {
    /* n:"BrtEndQSIR", */
    T: -1
  },
  /*::[*/
  451: {
    /* n:"BrtBeginDeletedNames", */
    T: 1
  },
  /*::[*/
  452: {
    /* n:"BrtEndDeletedNames", */
    T: -1
  },
  /*::[*/
  453: {
    /* n:"BrtBeginDeletedName", */
    T: 1
  },
  /*::[*/
  454: {
    /* n:"BrtEndDeletedName", */
    T: -1
  },
  /*::[*/
  455: {
    /* n:"BrtBeginQSIFs", */
    T: 1
  },
  /*::[*/
  456: {
    /* n:"BrtEndQSIFs", */
    T: -1
  },
  /*::[*/
  457: {
    /* n:"BrtBeginQSIF", */
    T: 1
  },
  /*::[*/
  458: {
    /* n:"BrtEndQSIF", */
    T: -1
  },
  /*::[*/
  459: {
    /* n:"BrtBeginAutoSortScope", */
    T: 1
  },
  /*::[*/
  460: {
    /* n:"BrtEndAutoSortScope", */
    T: -1
  },
  /*::[*/
  461: {
    /* n:"BrtBeginConditionalFormatting", */
    T: 1
  },
  /*::[*/
  462: {
    /* n:"BrtEndConditionalFormatting", */
    T: -1
  },
  /*::[*/
  463: {
    /* n:"BrtBeginCFRule", */
    T: 1
  },
  /*::[*/
  464: {
    /* n:"BrtEndCFRule", */
    T: -1
  },
  /*::[*/
  465: {
    /* n:"BrtBeginIconSet", */
    T: 1
  },
  /*::[*/
  466: {
    /* n:"BrtEndIconSet", */
    T: -1
  },
  /*::[*/
  467: {
    /* n:"BrtBeginDatabar", */
    T: 1
  },
  /*::[*/
  468: {
    /* n:"BrtEndDatabar", */
    T: -1
  },
  /*::[*/
  469: {
    /* n:"BrtBeginColorScale", */
    T: 1
  },
  /*::[*/
  470: {
    /* n:"BrtEndColorScale", */
    T: -1
  },
  /*::[*/
  471: {
    /* n:"BrtCFVO" */
  },
  /*::[*/
  472: {
    /* n:"BrtExternValueMeta" */
  },
  /*::[*/
  473: {
    /* n:"BrtBeginColorPalette", */
    T: 1
  },
  /*::[*/
  474: {
    /* n:"BrtEndColorPalette", */
    T: -1
  },
  /*::[*/
  475: {
    /* n:"BrtIndexedColor" */
  },
  /*::[*/
  476: {
    /* n:"BrtMargins", */
    f: parse_BrtMargins
  },
  /*::[*/
  477: {
    /* n:"BrtPrintOptions" */
  },
  /*::[*/
  478: {
    /* n:"BrtPageSetup" */
  },
  /*::[*/
  479: {
    /* n:"BrtBeginHeaderFooter", */
    T: 1
  },
  /*::[*/
  480: {
    /* n:"BrtEndHeaderFooter", */
    T: -1
  },
  /*::[*/
  481: {
    /* n:"BrtBeginSXCrtFormat", */
    T: 1
  },
  /*::[*/
  482: {
    /* n:"BrtEndSXCrtFormat", */
    T: -1
  },
  /*::[*/
  483: {
    /* n:"BrtBeginSXCrtFormats", */
    T: 1
  },
  /*::[*/
  484: {
    /* n:"BrtEndSXCrtFormats", */
    T: -1
  },
  /*::[*/
  485: {
    /* n:"BrtWsFmtInfo", */
    f: parse_BrtWsFmtInfo
  },
  /*::[*/
  486: {
    /* n:"BrtBeginMgs", */
    T: 1
  },
  /*::[*/
  487: {
    /* n:"BrtEndMGs", */
    T: -1
  },
  /*::[*/
  488: {
    /* n:"BrtBeginMGMaps", */
    T: 1
  },
  /*::[*/
  489: {
    /* n:"BrtEndMGMaps", */
    T: -1
  },
  /*::[*/
  490: {
    /* n:"BrtBeginMG", */
    T: 1
  },
  /*::[*/
  491: {
    /* n:"BrtEndMG", */
    T: -1
  },
  /*::[*/
  492: {
    /* n:"BrtBeginMap", */
    T: 1
  },
  /*::[*/
  493: {
    /* n:"BrtEndMap", */
    T: -1
  },
  /*::[*/
  494: {
    /* n:"BrtHLink", */
    f: parse_BrtHLink
  },
  /*::[*/
  495: {
    /* n:"BrtBeginDCon", */
    T: 1
  },
  /*::[*/
  496: {
    /* n:"BrtEndDCon", */
    T: -1
  },
  /*::[*/
  497: {
    /* n:"BrtBeginDRefs", */
    T: 1
  },
  /*::[*/
  498: {
    /* n:"BrtEndDRefs", */
    T: -1
  },
  /*::[*/
  499: {
    /* n:"BrtDRef" */
  },
  /*::[*/
  500: {
    /* n:"BrtBeginScenMan", */
    T: 1
  },
  /*::[*/
  501: {
    /* n:"BrtEndScenMan", */
    T: -1
  },
  /*::[*/
  502: {
    /* n:"BrtBeginSct", */
    T: 1
  },
  /*::[*/
  503: {
    /* n:"BrtEndSct", */
    T: -1
  },
  /*::[*/
  504: {
    /* n:"BrtSlc" */
  },
  /*::[*/
  505: {
    /* n:"BrtBeginDXFs", */
    T: 1
  },
  /*::[*/
  506: {
    /* n:"BrtEndDXFs", */
    T: -1
  },
  /*::[*/
  507: {
    /* n:"BrtDXF" */
  },
  /*::[*/
  508: {
    /* n:"BrtBeginTableStyles", */
    T: 1
  },
  /*::[*/
  509: {
    /* n:"BrtEndTableStyles", */
    T: -1
  },
  /*::[*/
  510: {
    /* n:"BrtBeginTableStyle", */
    T: 1
  },
  /*::[*/
  511: {
    /* n:"BrtEndTableStyle", */
    T: -1
  },
  /*::[*/
  512: {
    /* n:"BrtTableStyleElement" */
  },
  /*::[*/
  513: {
    /* n:"BrtTableStyleClient" */
  },
  /*::[*/
  514: {
    /* n:"BrtBeginVolDeps", */
    T: 1
  },
  /*::[*/
  515: {
    /* n:"BrtEndVolDeps", */
    T: -1
  },
  /*::[*/
  516: {
    /* n:"BrtBeginVolType", */
    T: 1
  },
  /*::[*/
  517: {
    /* n:"BrtEndVolType", */
    T: -1
  },
  /*::[*/
  518: {
    /* n:"BrtBeginVolMain", */
    T: 1
  },
  /*::[*/
  519: {
    /* n:"BrtEndVolMain", */
    T: -1
  },
  /*::[*/
  520: {
    /* n:"BrtBeginVolTopic", */
    T: 1
  },
  /*::[*/
  521: {
    /* n:"BrtEndVolTopic", */
    T: -1
  },
  /*::[*/
  522: {
    /* n:"BrtVolSubtopic" */
  },
  /*::[*/
  523: {
    /* n:"BrtVolRef" */
  },
  /*::[*/
  524: {
    /* n:"BrtVolNum" */
  },
  /*::[*/
  525: {
    /* n:"BrtVolErr" */
  },
  /*::[*/
  526: {
    /* n:"BrtVolStr" */
  },
  /*::[*/
  527: {
    /* n:"BrtVolBool" */
  },
  /*::[*/
  528: {
    /* n:"BrtBeginCalcChain$", */
    T: 1
  },
  /*::[*/
  529: {
    /* n:"BrtEndCalcChain$", */
    T: -1
  },
  /*::[*/
  530: {
    /* n:"BrtBeginSortState", */
    T: 1
  },
  /*::[*/
  531: {
    /* n:"BrtEndSortState", */
    T: -1
  },
  /*::[*/
  532: {
    /* n:"BrtBeginSortCond", */
    T: 1
  },
  /*::[*/
  533: {
    /* n:"BrtEndSortCond", */
    T: -1
  },
  /*::[*/
  534: {
    /* n:"BrtBookProtection" */
  },
  /*::[*/
  535: {
    /* n:"BrtSheetProtection" */
  },
  /*::[*/
  536: {
    /* n:"BrtRangeProtection" */
  },
  /*::[*/
  537: {
    /* n:"BrtPhoneticInfo" */
  },
  /*::[*/
  538: {
    /* n:"BrtBeginECTxtWiz", */
    T: 1
  },
  /*::[*/
  539: {
    /* n:"BrtEndECTxtWiz", */
    T: -1
  },
  /*::[*/
  540: {
    /* n:"BrtBeginECTWFldInfoLst", */
    T: 1
  },
  /*::[*/
  541: {
    /* n:"BrtEndECTWFldInfoLst", */
    T: -1
  },
  /*::[*/
  542: {
    /* n:"BrtBeginECTwFldInfo", */
    T: 1
  },
  /*::[*/
  548: {
    /* n:"BrtFileSharing" */
  },
  /*::[*/
  549: {
    /* n:"BrtOleSize" */
  },
  /*::[*/
  550: {
    /* n:"BrtDrawing", */
    f: parse_RelID
  },
  /*::[*/
  551: {
    /* n:"BrtLegacyDrawing" */
  },
  /*::[*/
  552: {
    /* n:"BrtLegacyDrawingHF" */
  },
  /*::[*/
  553: {
    /* n:"BrtWebOpt" */
  },
  /*::[*/
  554: {
    /* n:"BrtBeginWebPubItems", */
    T: 1
  },
  /*::[*/
  555: {
    /* n:"BrtEndWebPubItems", */
    T: -1
  },
  /*::[*/
  556: {
    /* n:"BrtBeginWebPubItem", */
    T: 1
  },
  /*::[*/
  557: {
    /* n:"BrtEndWebPubItem", */
    T: -1
  },
  /*::[*/
  558: {
    /* n:"BrtBeginSXCondFmt", */
    T: 1
  },
  /*::[*/
  559: {
    /* n:"BrtEndSXCondFmt", */
    T: -1
  },
  /*::[*/
  560: {
    /* n:"BrtBeginSXCondFmts", */
    T: 1
  },
  /*::[*/
  561: {
    /* n:"BrtEndSXCondFmts", */
    T: -1
  },
  /*::[*/
  562: {
    /* n:"BrtBkHim" */
  },
  /*::[*/
  564: {
    /* n:"BrtColor" */
  },
  /*::[*/
  565: {
    /* n:"BrtBeginIndexedColors", */
    T: 1
  },
  /*::[*/
  566: {
    /* n:"BrtEndIndexedColors", */
    T: -1
  },
  /*::[*/
  569: {
    /* n:"BrtBeginMRUColors", */
    T: 1
  },
  /*::[*/
  570: {
    /* n:"BrtEndMRUColors", */
    T: -1
  },
  /*::[*/
  572: {
    /* n:"BrtMRUColor" */
  },
  /*::[*/
  573: {
    /* n:"BrtBeginDVals", */
    T: 1
  },
  /*::[*/
  574: {
    /* n:"BrtEndDVals", */
    T: -1
  },
  /*::[*/
  577: {
    /* n:"BrtSupNameStart" */
  },
  /*::[*/
  578: {
    /* n:"BrtSupNameValueStart" */
  },
  /*::[*/
  579: {
    /* n:"BrtSupNameValueEnd" */
  },
  /*::[*/
  580: {
    /* n:"BrtSupNameNum" */
  },
  /*::[*/
  581: {
    /* n:"BrtSupNameErr" */
  },
  /*::[*/
  582: {
    /* n:"BrtSupNameSt" */
  },
  /*::[*/
  583: {
    /* n:"BrtSupNameNil" */
  },
  /*::[*/
  584: {
    /* n:"BrtSupNameBool" */
  },
  /*::[*/
  585: {
    /* n:"BrtSupNameFmla" */
  },
  /*::[*/
  586: {
    /* n:"BrtSupNameBits" */
  },
  /*::[*/
  587: {
    /* n:"BrtSupNameEnd" */
  },
  /*::[*/
  588: {
    /* n:"BrtEndSupBook", */
    T: -1
  },
  /*::[*/
  589: {
    /* n:"BrtCellSmartTagProperty" */
  },
  /*::[*/
  590: {
    /* n:"BrtBeginCellSmartTag", */
    T: 1
  },
  /*::[*/
  591: {
    /* n:"BrtEndCellSmartTag", */
    T: -1
  },
  /*::[*/
  592: {
    /* n:"BrtBeginCellSmartTags", */
    T: 1
  },
  /*::[*/
  593: {
    /* n:"BrtEndCellSmartTags", */
    T: -1
  },
  /*::[*/
  594: {
    /* n:"BrtBeginSmartTags", */
    T: 1
  },
  /*::[*/
  595: {
    /* n:"BrtEndSmartTags", */
    T: -1
  },
  /*::[*/
  596: {
    /* n:"BrtSmartTagType" */
  },
  /*::[*/
  597: {
    /* n:"BrtBeginSmartTagTypes", */
    T: 1
  },
  /*::[*/
  598: {
    /* n:"BrtEndSmartTagTypes", */
    T: -1
  },
  /*::[*/
  599: {
    /* n:"BrtBeginSXFilters", */
    T: 1
  },
  /*::[*/
  600: {
    /* n:"BrtEndSXFilters", */
    T: -1
  },
  /*::[*/
  601: {
    /* n:"BrtBeginSXFILTER", */
    T: 1
  },
  /*::[*/
  602: {
    /* n:"BrtEndSXFilter", */
    T: -1
  },
  /*::[*/
  603: {
    /* n:"BrtBeginFills", */
    T: 1
  },
  /*::[*/
  604: {
    /* n:"BrtEndFills", */
    T: -1
  },
  /*::[*/
  605: {
    /* n:"BrtBeginCellWatches", */
    T: 1
  },
  /*::[*/
  606: {
    /* n:"BrtEndCellWatches", */
    T: -1
  },
  /*::[*/
  607: {
    /* n:"BrtCellWatch" */
  },
  /*::[*/
  608: {
    /* n:"BrtBeginCRErrs", */
    T: 1
  },
  /*::[*/
  609: {
    /* n:"BrtEndCRErrs", */
    T: -1
  },
  /*::[*/
  610: {
    /* n:"BrtCrashRecErr" */
  },
  /*::[*/
  611: {
    /* n:"BrtBeginFonts", */
    T: 1
  },
  /*::[*/
  612: {
    /* n:"BrtEndFonts", */
    T: -1
  },
  /*::[*/
  613: {
    /* n:"BrtBeginBorders", */
    T: 1
  },
  /*::[*/
  614: {
    /* n:"BrtEndBorders", */
    T: -1
  },
  /*::[*/
  615: {
    /* n:"BrtBeginFmts", */
    T: 1
  },
  /*::[*/
  616: {
    /* n:"BrtEndFmts", */
    T: -1
  },
  /*::[*/
  617: {
    /* n:"BrtBeginCellXFs", */
    T: 1
  },
  /*::[*/
  618: {
    /* n:"BrtEndCellXFs", */
    T: -1
  },
  /*::[*/
  619: {
    /* n:"BrtBeginStyles", */
    T: 1
  },
  /*::[*/
  620: {
    /* n:"BrtEndStyles", */
    T: -1
  },
  /*::[*/
  625: {
    /* n:"BrtBigName" */
  },
  /*::[*/
  626: {
    /* n:"BrtBeginCellStyleXFs", */
    T: 1
  },
  /*::[*/
  627: {
    /* n:"BrtEndCellStyleXFs", */
    T: -1
  },
  /*::[*/
  628: {
    /* n:"BrtBeginComments", */
    T: 1
  },
  /*::[*/
  629: {
    /* n:"BrtEndComments", */
    T: -1
  },
  /*::[*/
  630: {
    /* n:"BrtBeginCommentAuthors", */
    T: 1
  },
  /*::[*/
  631: {
    /* n:"BrtEndCommentAuthors", */
    T: -1
  },
  /*::[*/
  632: {
    /* n:"BrtCommentAuthor", */
    f: parse_BrtCommentAuthor
  },
  /*::[*/
  633: {
    /* n:"BrtBeginCommentList", */
    T: 1
  },
  /*::[*/
  634: {
    /* n:"BrtEndCommentList", */
    T: -1
  },
  /*::[*/
  635: {
    /* n:"BrtBeginComment", */
    T: 1,
    f: parse_BrtBeginComment
  },
  /*::[*/
  636: {
    /* n:"BrtEndComment", */
    T: -1
  },
  /*::[*/
  637: {
    /* n:"BrtCommentText", */
    f: parse_BrtCommentText
  },
  /*::[*/
  638: {
    /* n:"BrtBeginOleObjects", */
    T: 1
  },
  /*::[*/
  639: {
    /* n:"BrtOleObject" */
  },
  /*::[*/
  640: {
    /* n:"BrtEndOleObjects", */
    T: -1
  },
  /*::[*/
  641: {
    /* n:"BrtBeginSxrules", */
    T: 1
  },
  /*::[*/
  642: {
    /* n:"BrtEndSxRules", */
    T: -1
  },
  /*::[*/
  643: {
    /* n:"BrtBeginActiveXControls", */
    T: 1
  },
  /*::[*/
  644: {
    /* n:"BrtActiveX" */
  },
  /*::[*/
  645: {
    /* n:"BrtEndActiveXControls", */
    T: -1
  },
  /*::[*/
  646: {
    /* n:"BrtBeginPCDSDTCEMembersSortBy", */
    T: 1
  },
  /*::[*/
  648: {
    /* n:"BrtBeginCellIgnoreECs", */
    T: 1
  },
  /*::[*/
  649: {
    /* n:"BrtCellIgnoreEC" */
  },
  /*::[*/
  650: {
    /* n:"BrtEndCellIgnoreECs", */
    T: -1
  },
  /*::[*/
  651: {
    /* n:"BrtCsProp", */
    f: parse_BrtCsProp
  },
  /*::[*/
  652: {
    /* n:"BrtCsPageSetup" */
  },
  /*::[*/
  653: {
    /* n:"BrtBeginUserCsViews", */
    T: 1
  },
  /*::[*/
  654: {
    /* n:"BrtEndUserCsViews", */
    T: -1
  },
  /*::[*/
  655: {
    /* n:"BrtBeginUserCsView", */
    T: 1
  },
  /*::[*/
  656: {
    /* n:"BrtEndUserCsView", */
    T: -1
  },
  /*::[*/
  657: {
    /* n:"BrtBeginPcdSFCIEntries", */
    T: 1
  },
  /*::[*/
  658: {
    /* n:"BrtEndPCDSFCIEntries", */
    T: -1
  },
  /*::[*/
  659: {
    /* n:"BrtPCDSFCIEntry" */
  },
  /*::[*/
  660: {
    /* n:"BrtBeginListParts", */
    T: 1
  },
  /*::[*/
  661: {
    /* n:"BrtListPart" */
  },
  /*::[*/
  662: {
    /* n:"BrtEndListParts", */
    T: -1
  },
  /*::[*/
  663: {
    /* n:"BrtSheetCalcProp" */
  },
  /*::[*/
  664: {
    /* n:"BrtBeginFnGroup", */
    T: 1
  },
  /*::[*/
  665: {
    /* n:"BrtFnGroup" */
  },
  /*::[*/
  666: {
    /* n:"BrtEndFnGroup", */
    T: -1
  },
  /*::[*/
  667: {
    /* n:"BrtSupAddin" */
  },
  /*::[*/
  668: {
    /* n:"BrtSXTDMPOrder" */
  },
  /*::[*/
  669: {
    /* n:"BrtCsProtection" */
  },
  /*::[*/
  671: {
    /* n:"BrtBeginWsSortMap", */
    T: 1
  },
  /*::[*/
  672: {
    /* n:"BrtEndWsSortMap", */
    T: -1
  },
  /*::[*/
  673: {
    /* n:"BrtBeginRRSort", */
    T: 1
  },
  /*::[*/
  674: {
    /* n:"BrtEndRRSort", */
    T: -1
  },
  /*::[*/
  675: {
    /* n:"BrtRRSortItem" */
  },
  /*::[*/
  676: {
    /* n:"BrtFileSharingIso" */
  },
  /*::[*/
  677: {
    /* n:"BrtBookProtectionIso" */
  },
  /*::[*/
  678: {
    /* n:"BrtSheetProtectionIso" */
  },
  /*::[*/
  679: {
    /* n:"BrtCsProtectionIso" */
  },
  /*::[*/
  680: {
    /* n:"BrtRangeProtectionIso" */
  },
  /*::[*/
  681: {
    /* n:"BrtDValList" */
  },
  /*::[*/
  1024: {
    /* n:"BrtRwDescent" */
  },
  /*::[*/
  1025: {
    /* n:"BrtKnownFonts" */
  },
  /*::[*/
  1026: {
    /* n:"BrtBeginSXTupleSet", */
    T: 1
  },
  /*::[*/
  1027: {
    /* n:"BrtEndSXTupleSet", */
    T: -1
  },
  /*::[*/
  1028: {
    /* n:"BrtBeginSXTupleSetHeader", */
    T: 1
  },
  /*::[*/
  1029: {
    /* n:"BrtEndSXTupleSetHeader", */
    T: -1
  },
  /*::[*/
  1030: {
    /* n:"BrtSXTupleSetHeaderItem" */
  },
  /*::[*/
  1031: {
    /* n:"BrtBeginSXTupleSetData", */
    T: 1
  },
  /*::[*/
  1032: {
    /* n:"BrtEndSXTupleSetData", */
    T: -1
  },
  /*::[*/
  1033: {
    /* n:"BrtBeginSXTupleSetRow", */
    T: 1
  },
  /*::[*/
  1034: {
    /* n:"BrtEndSXTupleSetRow", */
    T: -1
  },
  /*::[*/
  1035: {
    /* n:"BrtSXTupleSetRowItem" */
  },
  /*::[*/
  1036: {
    /* n:"BrtNameExt" */
  },
  /*::[*/
  1037: {
    /* n:"BrtPCDH14" */
  },
  /*::[*/
  1038: {
    /* n:"BrtBeginPCDCalcMem14", */
    T: 1
  },
  /*::[*/
  1039: {
    /* n:"BrtEndPCDCalcMem14", */
    T: -1
  },
  /*::[*/
  1040: {
    /* n:"BrtSXTH14" */
  },
  /*::[*/
  1041: {
    /* n:"BrtBeginSparklineGroup", */
    T: 1
  },
  /*::[*/
  1042: {
    /* n:"BrtEndSparklineGroup", */
    T: -1
  },
  /*::[*/
  1043: {
    /* n:"BrtSparkline" */
  },
  /*::[*/
  1044: {
    /* n:"BrtSXDI14" */
  },
  /*::[*/
  1045: {
    /* n:"BrtWsFmtInfoEx14" */
  },
  /*::[*/
  1046: {
    /* n:"BrtBeginConditionalFormatting14", */
    T: 1
  },
  /*::[*/
  1047: {
    /* n:"BrtEndConditionalFormatting14", */
    T: -1
  },
  /*::[*/
  1048: {
    /* n:"BrtBeginCFRule14", */
    T: 1
  },
  /*::[*/
  1049: {
    /* n:"BrtEndCFRule14", */
    T: -1
  },
  /*::[*/
  1050: {
    /* n:"BrtCFVO14" */
  },
  /*::[*/
  1051: {
    /* n:"BrtBeginDatabar14", */
    T: 1
  },
  /*::[*/
  1052: {
    /* n:"BrtBeginIconSet14", */
    T: 1
  },
  /*::[*/
  1053: {
    /* n:"BrtDVal14", */
    f: parse_BrtDVal14
  },
  /*::[*/
  1054: {
    /* n:"BrtBeginDVals14", */
    T: 1
  },
  /*::[*/
  1055: {
    /* n:"BrtColor14" */
  },
  /*::[*/
  1056: {
    /* n:"BrtBeginSparklines", */
    T: 1
  },
  /*::[*/
  1057: {
    /* n:"BrtEndSparklines", */
    T: -1
  },
  /*::[*/
  1058: {
    /* n:"BrtBeginSparklineGroups", */
    T: 1
  },
  /*::[*/
  1059: {
    /* n:"BrtEndSparklineGroups", */
    T: -1
  },
  /*::[*/
  1061: {
    /* n:"BrtSXVD14" */
  },
  /*::[*/
  1062: {
    /* n:"BrtBeginSXView14", */
    T: 1
  },
  /*::[*/
  1063: {
    /* n:"BrtEndSXView14", */
    T: -1
  },
  /*::[*/
  1064: {
    /* n:"BrtBeginSXView16", */
    T: 1
  },
  /*::[*/
  1065: {
    /* n:"BrtEndSXView16", */
    T: -1
  },
  /*::[*/
  1066: {
    /* n:"BrtBeginPCD14", */
    T: 1
  },
  /*::[*/
  1067: {
    /* n:"BrtEndPCD14", */
    T: -1
  },
  /*::[*/
  1068: {
    /* n:"BrtBeginExtConn14", */
    T: 1
  },
  /*::[*/
  1069: {
    /* n:"BrtEndExtConn14", */
    T: -1
  },
  /*::[*/
  1070: {
    /* n:"BrtBeginSlicerCacheIDs", */
    T: 1
  },
  /*::[*/
  1071: {
    /* n:"BrtEndSlicerCacheIDs", */
    T: -1
  },
  /*::[*/
  1072: {
    /* n:"BrtBeginSlicerCacheID", */
    T: 1
  },
  /*::[*/
  1073: {
    /* n:"BrtEndSlicerCacheID", */
    T: -1
  },
  /*::[*/
  1075: {
    /* n:"BrtBeginSlicerCache", */
    T: 1
  },
  /*::[*/
  1076: {
    /* n:"BrtEndSlicerCache", */
    T: -1
  },
  /*::[*/
  1077: {
    /* n:"BrtBeginSlicerCacheDef", */
    T: 1
  },
  /*::[*/
  1078: {
    /* n:"BrtEndSlicerCacheDef", */
    T: -1
  },
  /*::[*/
  1079: {
    /* n:"BrtBeginSlicersEx", */
    T: 1
  },
  /*::[*/
  1080: {
    /* n:"BrtEndSlicersEx", */
    T: -1
  },
  /*::[*/
  1081: {
    /* n:"BrtBeginSlicerEx", */
    T: 1
  },
  /*::[*/
  1082: {
    /* n:"BrtEndSlicerEx", */
    T: -1
  },
  /*::[*/
  1083: {
    /* n:"BrtBeginSlicer", */
    T: 1
  },
  /*::[*/
  1084: {
    /* n:"BrtEndSlicer", */
    T: -1
  },
  /*::[*/
  1085: {
    /* n:"BrtSlicerCachePivotTables" */
  },
  /*::[*/
  1086: {
    /* n:"BrtBeginSlicerCacheOlapImpl", */
    T: 1
  },
  /*::[*/
  1087: {
    /* n:"BrtEndSlicerCacheOlapImpl", */
    T: -1
  },
  /*::[*/
  1088: {
    /* n:"BrtBeginSlicerCacheLevelsData", */
    T: 1
  },
  /*::[*/
  1089: {
    /* n:"BrtEndSlicerCacheLevelsData", */
    T: -1
  },
  /*::[*/
  1090: {
    /* n:"BrtBeginSlicerCacheLevelData", */
    T: 1
  },
  /*::[*/
  1091: {
    /* n:"BrtEndSlicerCacheLevelData", */
    T: -1
  },
  /*::[*/
  1092: {
    /* n:"BrtBeginSlicerCacheSiRanges", */
    T: 1
  },
  /*::[*/
  1093: {
    /* n:"BrtEndSlicerCacheSiRanges", */
    T: -1
  },
  /*::[*/
  1094: {
    /* n:"BrtBeginSlicerCacheSiRange", */
    T: 1
  },
  /*::[*/
  1095: {
    /* n:"BrtEndSlicerCacheSiRange", */
    T: -1
  },
  /*::[*/
  1096: {
    /* n:"BrtSlicerCacheOlapItem" */
  },
  /*::[*/
  1097: {
    /* n:"BrtBeginSlicerCacheSelections", */
    T: 1
  },
  /*::[*/
  1098: {
    /* n:"BrtSlicerCacheSelection" */
  },
  /*::[*/
  1099: {
    /* n:"BrtEndSlicerCacheSelections", */
    T: -1
  },
  /*::[*/
  1100: {
    /* n:"BrtBeginSlicerCacheNative", */
    T: 1
  },
  /*::[*/
  1101: {
    /* n:"BrtEndSlicerCacheNative", */
    T: -1
  },
  /*::[*/
  1102: {
    /* n:"BrtSlicerCacheNativeItem" */
  },
  /*::[*/
  1103: {
    /* n:"BrtRangeProtection14" */
  },
  /*::[*/
  1104: {
    /* n:"BrtRangeProtectionIso14" */
  },
  /*::[*/
  1105: {
    /* n:"BrtCellIgnoreEC14" */
  },
  /*::[*/
  1111: {
    /* n:"BrtList14" */
  },
  /*::[*/
  1112: {
    /* n:"BrtCFIcon" */
  },
  /*::[*/
  1113: {
    /* n:"BrtBeginSlicerCachesPivotCacheIDs", */
    T: 1
  },
  /*::[*/
  1114: {
    /* n:"BrtEndSlicerCachesPivotCacheIDs", */
    T: -1
  },
  /*::[*/
  1115: {
    /* n:"BrtBeginSlicers", */
    T: 1
  },
  /*::[*/
  1116: {
    /* n:"BrtEndSlicers", */
    T: -1
  },
  /*::[*/
  1117: {
    /* n:"BrtWbProp14" */
  },
  /*::[*/
  1118: {
    /* n:"BrtBeginSXEdit", */
    T: 1
  },
  /*::[*/
  1119: {
    /* n:"BrtEndSXEdit", */
    T: -1
  },
  /*::[*/
  1120: {
    /* n:"BrtBeginSXEdits", */
    T: 1
  },
  /*::[*/
  1121: {
    /* n:"BrtEndSXEdits", */
    T: -1
  },
  /*::[*/
  1122: {
    /* n:"BrtBeginSXChange", */
    T: 1
  },
  /*::[*/
  1123: {
    /* n:"BrtEndSXChange", */
    T: -1
  },
  /*::[*/
  1124: {
    /* n:"BrtBeginSXChanges", */
    T: 1
  },
  /*::[*/
  1125: {
    /* n:"BrtEndSXChanges", */
    T: -1
  },
  /*::[*/
  1126: {
    /* n:"BrtSXTupleItems" */
  },
  /*::[*/
  1128: {
    /* n:"BrtBeginSlicerStyle", */
    T: 1
  },
  /*::[*/
  1129: {
    /* n:"BrtEndSlicerStyle", */
    T: -1
  },
  /*::[*/
  1130: {
    /* n:"BrtSlicerStyleElement" */
  },
  /*::[*/
  1131: {
    /* n:"BrtBeginStyleSheetExt14", */
    T: 1
  },
  /*::[*/
  1132: {
    /* n:"BrtEndStyleSheetExt14", */
    T: -1
  },
  /*::[*/
  1133: {
    /* n:"BrtBeginSlicerCachesPivotCacheID", */
    T: 1
  },
  /*::[*/
  1134: {
    /* n:"BrtEndSlicerCachesPivotCacheID", */
    T: -1
  },
  /*::[*/
  1135: {
    /* n:"BrtBeginConditionalFormattings", */
    T: 1
  },
  /*::[*/
  1136: {
    /* n:"BrtEndConditionalFormattings", */
    T: -1
  },
  /*::[*/
  1137: {
    /* n:"BrtBeginPCDCalcMemExt", */
    T: 1
  },
  /*::[*/
  1138: {
    /* n:"BrtEndPCDCalcMemExt", */
    T: -1
  },
  /*::[*/
  1139: {
    /* n:"BrtBeginPCDCalcMemsExt", */
    T: 1
  },
  /*::[*/
  1140: {
    /* n:"BrtEndPCDCalcMemsExt", */
    T: -1
  },
  /*::[*/
  1141: {
    /* n:"BrtPCDField14" */
  },
  /*::[*/
  1142: {
    /* n:"BrtBeginSlicerStyles", */
    T: 1
  },
  /*::[*/
  1143: {
    /* n:"BrtEndSlicerStyles", */
    T: -1
  },
  /*::[*/
  1144: {
    /* n:"BrtBeginSlicerStyleElements", */
    T: 1
  },
  /*::[*/
  1145: {
    /* n:"BrtEndSlicerStyleElements", */
    T: -1
  },
  /*::[*/
  1146: {
    /* n:"BrtCFRuleExt" */
  },
  /*::[*/
  1147: {
    /* n:"BrtBeginSXCondFmt14", */
    T: 1
  },
  /*::[*/
  1148: {
    /* n:"BrtEndSXCondFmt14", */
    T: -1
  },
  /*::[*/
  1149: {
    /* n:"BrtBeginSXCondFmts14", */
    T: 1
  },
  /*::[*/
  1150: {
    /* n:"BrtEndSXCondFmts14", */
    T: -1
  },
  /*::[*/
  1152: {
    /* n:"BrtBeginSortCond14", */
    T: 1
  },
  /*::[*/
  1153: {
    /* n:"BrtEndSortCond14", */
    T: -1
  },
  /*::[*/
  1154: {
    /* n:"BrtEndDVals14", */
    T: -1
  },
  /*::[*/
  1155: {
    /* n:"BrtEndIconSet14", */
    T: -1
  },
  /*::[*/
  1156: {
    /* n:"BrtEndDatabar14", */
    T: -1
  },
  /*::[*/
  1157: {
    /* n:"BrtBeginColorScale14", */
    T: 1
  },
  /*::[*/
  1158: {
    /* n:"BrtEndColorScale14", */
    T: -1
  },
  /*::[*/
  1159: {
    /* n:"BrtBeginSxrules14", */
    T: 1
  },
  /*::[*/
  1160: {
    /* n:"BrtEndSxrules14", */
    T: -1
  },
  /*::[*/
  1161: {
    /* n:"BrtBeginPRule14", */
    T: 1
  },
  /*::[*/
  1162: {
    /* n:"BrtEndPRule14", */
    T: -1
  },
  /*::[*/
  1163: {
    /* n:"BrtBeginPRFilters14", */
    T: 1
  },
  /*::[*/
  1164: {
    /* n:"BrtEndPRFilters14", */
    T: -1
  },
  /*::[*/
  1165: {
    /* n:"BrtBeginPRFilter14", */
    T: 1
  },
  /*::[*/
  1166: {
    /* n:"BrtEndPRFilter14", */
    T: -1
  },
  /*::[*/
  1167: {
    /* n:"BrtBeginPRFItem14", */
    T: 1
  },
  /*::[*/
  1168: {
    /* n:"BrtEndPRFItem14", */
    T: -1
  },
  /*::[*/
  1169: {
    /* n:"BrtBeginCellIgnoreECs14", */
    T: 1
  },
  /*::[*/
  1170: {
    /* n:"BrtEndCellIgnoreECs14", */
    T: -1
  },
  /*::[*/
  1171: {
    /* n:"BrtDxf14" */
  },
  /*::[*/
  1172: {
    /* n:"BrtBeginDxF14s", */
    T: 1
  },
  /*::[*/
  1173: {
    /* n:"BrtEndDxf14s", */
    T: -1
  },
  /*::[*/
  1177: {
    /* n:"BrtFilter14" */
  },
  /*::[*/
  1178: {
    /* n:"BrtBeginCustomFilters14", */
    T: 1
  },
  /*::[*/
  1180: {
    /* n:"BrtCustomFilter14" */
  },
  /*::[*/
  1181: {
    /* n:"BrtIconFilter14" */
  },
  /*::[*/
  1182: {
    /* n:"BrtPivotCacheConnectionName" */
  },
  /*::[*/
  2048: {
    /* n:"BrtBeginDecoupledPivotCacheIDs", */
    T: 1
  },
  /*::[*/
  2049: {
    /* n:"BrtEndDecoupledPivotCacheIDs", */
    T: -1
  },
  /*::[*/
  2050: {
    /* n:"BrtDecoupledPivotCacheID" */
  },
  /*::[*/
  2051: {
    /* n:"BrtBeginPivotTableRefs", */
    T: 1
  },
  /*::[*/
  2052: {
    /* n:"BrtEndPivotTableRefs", */
    T: -1
  },
  /*::[*/
  2053: {
    /* n:"BrtPivotTableRef" */
  },
  /*::[*/
  2054: {
    /* n:"BrtSlicerCacheBookPivotTables" */
  },
  /*::[*/
  2055: {
    /* n:"BrtBeginSxvcells", */
    T: 1
  },
  /*::[*/
  2056: {
    /* n:"BrtEndSxvcells", */
    T: -1
  },
  /*::[*/
  2057: {
    /* n:"BrtBeginSxRow", */
    T: 1
  },
  /*::[*/
  2058: {
    /* n:"BrtEndSxRow", */
    T: -1
  },
  /*::[*/
  2060: {
    /* n:"BrtPcdCalcMem15" */
  },
  /*::[*/
  2067: {
    /* n:"BrtQsi15" */
  },
  /*::[*/
  2068: {
    /* n:"BrtBeginWebExtensions", */
    T: 1
  },
  /*::[*/
  2069: {
    /* n:"BrtEndWebExtensions", */
    T: -1
  },
  /*::[*/
  2070: {
    /* n:"BrtWebExtension" */
  },
  /*::[*/
  2071: {
    /* n:"BrtAbsPath15" */
  },
  /*::[*/
  2072: {
    /* n:"BrtBeginPivotTableUISettings", */
    T: 1
  },
  /*::[*/
  2073: {
    /* n:"BrtEndPivotTableUISettings", */
    T: -1
  },
  /*::[*/
  2075: {
    /* n:"BrtTableSlicerCacheIDs" */
  },
  /*::[*/
  2076: {
    /* n:"BrtTableSlicerCacheID" */
  },
  /*::[*/
  2077: {
    /* n:"BrtBeginTableSlicerCache", */
    T: 1
  },
  /*::[*/
  2078: {
    /* n:"BrtEndTableSlicerCache", */
    T: -1
  },
  /*::[*/
  2079: {
    /* n:"BrtSxFilter15" */
  },
  /*::[*/
  2080: {
    /* n:"BrtBeginTimelineCachePivotCacheIDs", */
    T: 1
  },
  /*::[*/
  2081: {
    /* n:"BrtEndTimelineCachePivotCacheIDs", */
    T: -1
  },
  /*::[*/
  2082: {
    /* n:"BrtTimelineCachePivotCacheID" */
  },
  /*::[*/
  2083: {
    /* n:"BrtBeginTimelineCacheIDs", */
    T: 1
  },
  /*::[*/
  2084: {
    /* n:"BrtEndTimelineCacheIDs", */
    T: -1
  },
  /*::[*/
  2085: {
    /* n:"BrtBeginTimelineCacheID", */
    T: 1
  },
  /*::[*/
  2086: {
    /* n:"BrtEndTimelineCacheID", */
    T: -1
  },
  /*::[*/
  2087: {
    /* n:"BrtBeginTimelinesEx", */
    T: 1
  },
  /*::[*/
  2088: {
    /* n:"BrtEndTimelinesEx", */
    T: -1
  },
  /*::[*/
  2089: {
    /* n:"BrtBeginTimelineEx", */
    T: 1
  },
  /*::[*/
  2090: {
    /* n:"BrtEndTimelineEx", */
    T: -1
  },
  /*::[*/
  2091: {
    /* n:"BrtWorkBookPr15" */
  },
  /*::[*/
  2092: {
    /* n:"BrtPCDH15" */
  },
  /*::[*/
  2093: {
    /* n:"BrtBeginTimelineStyle", */
    T: 1
  },
  /*::[*/
  2094: {
    /* n:"BrtEndTimelineStyle", */
    T: -1
  },
  /*::[*/
  2095: {
    /* n:"BrtTimelineStyleElement" */
  },
  /*::[*/
  2096: {
    /* n:"BrtBeginTimelineStylesheetExt15", */
    T: 1
  },
  /*::[*/
  2097: {
    /* n:"BrtEndTimelineStylesheetExt15", */
    T: -1
  },
  /*::[*/
  2098: {
    /* n:"BrtBeginTimelineStyles", */
    T: 1
  },
  /*::[*/
  2099: {
    /* n:"BrtEndTimelineStyles", */
    T: -1
  },
  /*::[*/
  2100: {
    /* n:"BrtBeginTimelineStyleElements", */
    T: 1
  },
  /*::[*/
  2101: {
    /* n:"BrtEndTimelineStyleElements", */
    T: -1
  },
  /*::[*/
  2102: {
    /* n:"BrtDxf15" */
  },
  /*::[*/
  2103: {
    /* n:"BrtBeginDxfs15", */
    T: 1
  },
  /*::[*/
  2104: {
    /* n:"BrtEndDxfs15", */
    T: -1
  },
  /*::[*/
  2105: {
    /* n:"BrtSlicerCacheHideItemsWithNoData" */
  },
  /*::[*/
  2106: {
    /* n:"BrtBeginItemUniqueNames", */
    T: 1
  },
  /*::[*/
  2107: {
    /* n:"BrtEndItemUniqueNames", */
    T: -1
  },
  /*::[*/
  2108: {
    /* n:"BrtItemUniqueName" */
  },
  /*::[*/
  2109: {
    /* n:"BrtBeginExtConn15", */
    T: 1
  },
  /*::[*/
  2110: {
    /* n:"BrtEndExtConn15", */
    T: -1
  },
  /*::[*/
  2111: {
    /* n:"BrtBeginOledbPr15", */
    T: 1
  },
  /*::[*/
  2112: {
    /* n:"BrtEndOledbPr15", */
    T: -1
  },
  /*::[*/
  2113: {
    /* n:"BrtBeginDataFeedPr15", */
    T: 1
  },
  /*::[*/
  2114: {
    /* n:"BrtEndDataFeedPr15", */
    T: -1
  },
  /*::[*/
  2115: {
    /* n:"BrtTextPr15" */
  },
  /*::[*/
  2116: {
    /* n:"BrtRangePr15" */
  },
  /*::[*/
  2117: {
    /* n:"BrtDbCommand15" */
  },
  /*::[*/
  2118: {
    /* n:"BrtBeginDbTables15", */
    T: 1
  },
  /*::[*/
  2119: {
    /* n:"BrtEndDbTables15", */
    T: -1
  },
  /*::[*/
  2120: {
    /* n:"BrtDbTable15" */
  },
  /*::[*/
  2121: {
    /* n:"BrtBeginDataModel", */
    T: 1
  },
  /*::[*/
  2122: {
    /* n:"BrtEndDataModel", */
    T: -1
  },
  /*::[*/
  2123: {
    /* n:"BrtBeginModelTables", */
    T: 1
  },
  /*::[*/
  2124: {
    /* n:"BrtEndModelTables", */
    T: -1
  },
  /*::[*/
  2125: {
    /* n:"BrtModelTable" */
  },
  /*::[*/
  2126: {
    /* n:"BrtBeginModelRelationships", */
    T: 1
  },
  /*::[*/
  2127: {
    /* n:"BrtEndModelRelationships", */
    T: -1
  },
  /*::[*/
  2128: {
    /* n:"BrtModelRelationship" */
  },
  /*::[*/
  2129: {
    /* n:"BrtBeginECTxtWiz15", */
    T: 1
  },
  /*::[*/
  2130: {
    /* n:"BrtEndECTxtWiz15", */
    T: -1
  },
  /*::[*/
  2131: {
    /* n:"BrtBeginECTWFldInfoLst15", */
    T: 1
  },
  /*::[*/
  2132: {
    /* n:"BrtEndECTWFldInfoLst15", */
    T: -1
  },
  /*::[*/
  2133: {
    /* n:"BrtBeginECTWFldInfo15", */
    T: 1
  },
  /*::[*/
  2134: {
    /* n:"BrtFieldListActiveItem" */
  },
  /*::[*/
  2135: {
    /* n:"BrtPivotCacheIdVersion" */
  },
  /*::[*/
  2136: {
    /* n:"BrtSXDI15" */
  },
  /*::[*/
  2137: {
    /* n:"BrtBeginModelTimeGroupings", */
    T: 1
  },
  /*::[*/
  2138: {
    /* n:"BrtEndModelTimeGroupings", */
    T: -1
  },
  /*::[*/
  2139: {
    /* n:"BrtBeginModelTimeGrouping", */
    T: 1
  },
  /*::[*/
  2140: {
    /* n:"BrtEndModelTimeGrouping", */
    T: -1
  },
  /*::[*/
  2141: {
    /* n:"BrtModelTimeGroupingCalcCol" */
  },
  /*::[*/
  3072: {
    /* n:"BrtUid" */
  },
  /*::[*/
  3073: {
    /* n:"BrtRevisionPtr" */
  },
  /*::[*/
  4096: {
    /* n:"BrtBeginDynamicArrayPr", */
    T: 1
  },
  /*::[*/
  4097: {
    /* n:"BrtEndDynamicArrayPr", */
    T: -1
  },
  /*::[*/
  5002: {
    /* n:"BrtBeginRichValueBlock", */
    T: 1
  },
  /*::[*/
  5003: {
    /* n:"BrtEndRichValueBlock", */
    T: -1
  },
  /*::[*/
  5081: {
    /* n:"BrtBeginRichFilters", */
    T: 1
  },
  /*::[*/
  5082: {
    /* n:"BrtEndRichFilters", */
    T: -1
  },
  /*::[*/
  5083: {
    /* n:"BrtRichFilter" */
  },
  /*::[*/
  5084: {
    /* n:"BrtBeginRichFilterColumn", */
    T: 1
  },
  /*::[*/
  5085: {
    /* n:"BrtEndRichFilterColumn", */
    T: -1
  },
  /*::[*/
  5086: {
    /* n:"BrtBeginCustomRichFilters", */
    T: 1
  },
  /*::[*/
  5087: {
    /* n:"BrtEndCustomRichFilters", */
    T: -1
  },
  /*::[*/
  5088: {
    /* n:"BrtCustomRichFilter" */
  },
  /*::[*/
  5089: {
    /* n:"BrtTop10RichFilter" */
  },
  /*::[*/
  5090: {
    /* n:"BrtDynamicRichFilter" */
  },
  /*::[*/
  5092: {
    /* n:"BrtBeginRichSortCondition", */
    T: 1
  },
  /*::[*/
  5093: {
    /* n:"BrtEndRichSortCondition", */
    T: -1
  },
  /*::[*/
  5094: {
    /* n:"BrtRichFilterDateGroupItem" */
  },
  /*::[*/
  5095: {
    /* n:"BrtBeginCalcFeatures", */
    T: 1
  },
  /*::[*/
  5096: {
    /* n:"BrtEndCalcFeatures", */
    T: -1
  },
  /*::[*/
  5097: {
    /* n:"BrtCalcFeature" */
  },
  /*::[*/
  5099: {
    /* n:"BrtExternalLinksPr" */
  },
  /*::[*/
  65535: { n: "" }
};
function write_biff_rec(ba, type, payload, length) {
  var t2 = type;
  if (isNaN(t2))
    return;
  var len = length || (payload || []).length || 0;
  var o2 = ba.next(4);
  o2.write_shift(2, t2);
  o2.write_shift(2, len);
  if (
    /*:: len != null &&*/
    len > 0 && is_buf(payload)
  )
    ba.push(payload);
}
__name(write_biff_rec, "write_biff_rec");
function write_biff_continue(ba, type, payload, length) {
  var len = length || (payload || []).length || 0;
  if (len <= 8224)
    return write_biff_rec(ba, type, payload, len);
  var t2 = type;
  if (isNaN(t2))
    return;
  var parts = payload.parts || [], sidx = 0;
  var i2 = 0, w2 = 0;
  while (w2 + (parts[sidx] || 8224) <= 8224) {
    w2 += parts[sidx] || 8224;
    sidx++;
  }
  var o2 = ba.next(4);
  o2.write_shift(2, t2);
  o2.write_shift(2, w2);
  ba.push(payload.slice(i2, i2 + w2));
  i2 += w2;
  while (i2 < len) {
    o2 = ba.next(4);
    o2.write_shift(2, 60);
    w2 = 0;
    while (w2 + (parts[sidx] || 8224) <= 8224) {
      w2 += parts[sidx] || 8224;
      sidx++;
    }
    o2.write_shift(2, w2);
    ba.push(payload.slice(i2, i2 + w2));
    i2 += w2;
  }
}
__name(write_biff_continue, "write_biff_continue");
function write_BIFF2Cell(out, r, c2) {
  if (!out)
    out = new_buf(7);
  out.write_shift(2, r);
  out.write_shift(2, c2);
  out.write_shift(2, 0);
  out.write_shift(1, 0);
  return out;
}
__name(write_BIFF2Cell, "write_BIFF2Cell");
function write_BIFF2BERR(r, c2, val, t2) {
  var out = new_buf(9);
  write_BIFF2Cell(out, r, c2);
  write_Bes(val, t2 || "b", out);
  return out;
}
__name(write_BIFF2BERR, "write_BIFF2BERR");
function write_BIFF2LABEL(r, c2, val) {
  var out = new_buf(8 + 2 * val.length);
  write_BIFF2Cell(out, r, c2);
  out.write_shift(1, val.length);
  out.write_shift(val.length, val, "sbcs");
  return out.l < out.length ? out.slice(0, out.l) : out;
}
__name(write_BIFF2LABEL, "write_BIFF2LABEL");
function write_ws_biff2_cell(ba, cell, R2, C2) {
  if (cell.v != null)
    switch (cell.t) {
      case "d":
      case "n":
        var v2 = cell.t == "d" ? datenum(parseDate(cell.v)) : cell.v;
        if (v2 == (v2 | 0) && v2 >= 0 && v2 < 65536)
          write_biff_rec(ba, 2, write_BIFF2INT(R2, C2, v2));
        else
          write_biff_rec(ba, 3, write_BIFF2NUM(R2, C2, v2));
        return;
      case "b":
      case "e":
        write_biff_rec(ba, 5, write_BIFF2BERR(R2, C2, cell.v, cell.t));
        return;
      case "s":
      case "str":
        write_biff_rec(ba, 4, write_BIFF2LABEL(R2, C2, (cell.v || "").slice(0, 255)));
        return;
    }
  write_biff_rec(ba, 1, write_BIFF2Cell(null, R2, C2));
}
__name(write_ws_biff2_cell, "write_ws_biff2_cell");
function write_ws_biff2(ba, ws, idx, opts) {
  var dense = Array.isArray(ws);
  var range = safe_decode_range(ws["!ref"] || "A1"), ref, rr = "", cols = [];
  if (range.e.c > 255 || range.e.r > 16383) {
    if (opts.WTF)
      throw new Error("Range " + (ws["!ref"] || "A1") + " exceeds format limit A1:IV16384");
    range.e.c = Math.min(range.e.c, 255);
    range.e.r = Math.min(range.e.c, 16383);
    ref = encode_range(range);
  }
  for (var R2 = range.s.r; R2 <= range.e.r; ++R2) {
    rr = encode_row(R2);
    for (var C2 = range.s.c; C2 <= range.e.c; ++C2) {
      if (R2 === range.s.r)
        cols[C2] = encode_col(C2);
      ref = cols[C2] + rr;
      var cell = dense ? (ws[R2] || [])[C2] : ws[ref];
      if (!cell)
        continue;
      write_ws_biff2_cell(ba, cell, R2, C2);
    }
  }
}
__name(write_ws_biff2, "write_ws_biff2");
function write_biff2_buf(wb, opts) {
  var o2 = opts || {};
  var ba = buf_array();
  var idx = 0;
  for (var i2 = 0; i2 < wb.SheetNames.length; ++i2)
    if (wb.SheetNames[i2] == o2.sheet)
      idx = i2;
  if (idx == 0 && !!o2.sheet && wb.SheetNames[0] != o2.sheet)
    throw new Error("Sheet not found: " + o2.sheet);
  write_biff_rec(ba, o2.biff == 4 ? 1033 : o2.biff == 3 ? 521 : 9, write_BOF(wb, 16, o2));
  write_ws_biff2(ba, wb.Sheets[wb.SheetNames[idx]], idx, o2);
  write_biff_rec(ba, 10);
  return ba.end();
}
__name(write_biff2_buf, "write_biff2_buf");
function write_FONTS_biff8(ba, data, opts) {
  write_biff_rec(ba, 49, write_Font({
    sz: 12,
    color: { theme: 1 },
    name: "Arial",
    family: 2,
    scheme: "minor"
  }, opts));
}
__name(write_FONTS_biff8, "write_FONTS_biff8");
function write_FMTS_biff8(ba, NF, opts) {
  if (!NF)
    return;
  [[5, 8], [23, 26], [41, 44], [
    /*63*/
    50,
    /*66],[164,*/
    392
  ]].forEach(function(r) {
    for (var i2 = r[0]; i2 <= r[1]; ++i2)
      if (NF[i2] != null)
        write_biff_rec(ba, 1054, write_Format(i2, NF[i2], opts));
  });
}
__name(write_FMTS_biff8, "write_FMTS_biff8");
function write_FEAT(ba, ws) {
  var o2 = new_buf(19);
  o2.write_shift(4, 2151);
  o2.write_shift(4, 0);
  o2.write_shift(4, 0);
  o2.write_shift(2, 3);
  o2.write_shift(1, 1);
  o2.write_shift(4, 0);
  write_biff_rec(ba, 2151, o2);
  o2 = new_buf(39);
  o2.write_shift(4, 2152);
  o2.write_shift(4, 0);
  o2.write_shift(4, 0);
  o2.write_shift(2, 3);
  o2.write_shift(1, 0);
  o2.write_shift(4, 0);
  o2.write_shift(2, 1);
  o2.write_shift(4, 4);
  o2.write_shift(2, 0);
  write_Ref8U(safe_decode_range(ws["!ref"] || "A1"), o2);
  o2.write_shift(4, 4);
  write_biff_rec(ba, 2152, o2);
}
__name(write_FEAT, "write_FEAT");
function write_CELLXFS_biff8(ba, opts) {
  for (var i2 = 0; i2 < 16; ++i2)
    write_biff_rec(ba, 224, write_XF({ numFmtId: 0, style: true }, 0, opts));
  opts.cellXfs.forEach(function(c2) {
    write_biff_rec(ba, 224, write_XF(c2, 0, opts));
  });
}
__name(write_CELLXFS_biff8, "write_CELLXFS_biff8");
function write_ws_biff8_hlinks(ba, ws) {
  for (var R2 = 0; R2 < ws["!links"].length; ++R2) {
    var HL = ws["!links"][R2];
    write_biff_rec(ba, 440, write_HLink(HL));
    if (HL[1].Tooltip)
      write_biff_rec(ba, 2048, write_HLinkTooltip(HL));
  }
  delete ws["!links"];
}
__name(write_ws_biff8_hlinks, "write_ws_biff8_hlinks");
function write_ws_cols_biff8(ba, cols) {
  if (!cols)
    return;
  var cnt = 0;
  cols.forEach(function(col, idx) {
    if (++cnt <= 256 && col) {
      write_biff_rec(ba, 125, write_ColInfo(col_obj_w(idx, col), idx));
    }
  });
}
__name(write_ws_cols_biff8, "write_ws_cols_biff8");
function write_ws_biff8_cell(ba, cell, R2, C2, opts) {
  var os = 16 + get_cell_style(opts.cellXfs, cell, opts);
  if (cell.v == null && !cell.bf) {
    write_biff_rec(ba, 513, write_XLSCell(R2, C2, os));
    return;
  }
  if (cell.bf)
    write_biff_rec(ba, 6, write_Formula(cell, R2, C2, opts, os));
  else
    switch (cell.t) {
      case "d":
      case "n":
        var v2 = cell.t == "d" ? datenum(parseDate(cell.v)) : cell.v;
        write_biff_rec(ba, 515, write_Number(R2, C2, v2, os));
        break;
      case "b":
      case "e":
        write_biff_rec(ba, 517, write_BoolErr(R2, C2, cell.v, os, opts, cell.t));
        break;
      case "s":
      case "str":
        if (opts.bookSST) {
          var isst = get_sst_id(opts.Strings, cell.v, opts.revStrings);
          write_biff_rec(ba, 253, write_LabelSst(R2, C2, isst, os));
        } else
          write_biff_rec(ba, 516, write_Label(R2, C2, (cell.v || "").slice(0, 255), os, opts));
        break;
      default:
        write_biff_rec(ba, 513, write_XLSCell(R2, C2, os));
    }
}
__name(write_ws_biff8_cell, "write_ws_biff8_cell");
function write_ws_biff8(idx, opts, wb) {
  var ba = buf_array();
  var s2 = wb.SheetNames[idx], ws = wb.Sheets[s2] || {};
  var _WB = (wb || {}).Workbook || {};
  var _sheet = (_WB.Sheets || [])[idx] || {};
  var dense = Array.isArray(ws);
  var b8 = opts.biff == 8;
  var ref, rr = "", cols = [];
  var range = safe_decode_range(ws["!ref"] || "A1");
  var MAX_ROWS = b8 ? 65536 : 16384;
  if (range.e.c > 255 || range.e.r >= MAX_ROWS) {
    if (opts.WTF)
      throw new Error("Range " + (ws["!ref"] || "A1") + " exceeds format limit A1:IV16384");
    range.e.c = Math.min(range.e.c, 255);
    range.e.r = Math.min(range.e.c, MAX_ROWS - 1);
  }
  write_biff_rec(ba, 2057, write_BOF(wb, 16, opts));
  write_biff_rec(ba, 13, writeuint16(1));
  write_biff_rec(ba, 12, writeuint16(100));
  write_biff_rec(ba, 15, writebool(true));
  write_biff_rec(ba, 17, writebool(false));
  write_biff_rec(ba, 16, write_Xnum(1e-3));
  write_biff_rec(ba, 95, writebool(true));
  write_biff_rec(ba, 42, writebool(false));
  write_biff_rec(ba, 43, writebool(false));
  write_biff_rec(ba, 130, writeuint16(1));
  write_biff_rec(ba, 128, write_Guts([0, 0]));
  write_biff_rec(ba, 131, writebool(false));
  write_biff_rec(ba, 132, writebool(false));
  if (b8)
    write_ws_cols_biff8(ba, ws["!cols"]);
  write_biff_rec(ba, 512, write_Dimensions(range, opts));
  if (b8)
    ws["!links"] = [];
  for (var R2 = range.s.r; R2 <= range.e.r; ++R2) {
    rr = encode_row(R2);
    for (var C2 = range.s.c; C2 <= range.e.c; ++C2) {
      if (R2 === range.s.r)
        cols[C2] = encode_col(C2);
      ref = cols[C2] + rr;
      var cell = dense ? (ws[R2] || [])[C2] : ws[ref];
      if (!cell)
        continue;
      write_ws_biff8_cell(ba, cell, R2, C2, opts);
      if (b8 && cell.l)
        ws["!links"].push([ref, cell.l]);
    }
  }
  var cname = _sheet.CodeName || _sheet.name || s2;
  if (b8)
    write_biff_rec(ba, 574, write_Window2((_WB.Views || [])[0]));
  if (b8 && (ws["!merges"] || []).length)
    write_biff_rec(ba, 229, write_MergeCells(ws["!merges"]));
  if (b8)
    write_ws_biff8_hlinks(ba, ws);
  write_biff_rec(ba, 442, write_XLUnicodeString(cname));
  if (b8)
    write_FEAT(ba, ws);
  write_biff_rec(
    ba,
    10
    /* EOF */
  );
  return ba.end();
}
__name(write_ws_biff8, "write_ws_biff8");
function write_biff8_global(wb, bufs, opts) {
  var A2 = buf_array();
  var _WB = (wb || {}).Workbook || {};
  var _sheets = _WB.Sheets || [];
  var _wb = (
    /*::((*/
    _WB.WBProps || {
      /*::CodeName:"ThisWorkbook"*/
    }
  );
  var b8 = opts.biff == 8, b5 = opts.biff == 5;
  write_biff_rec(A2, 2057, write_BOF(wb, 5, opts));
  if (opts.bookType == "xla")
    write_biff_rec(
      A2,
      135
      /* Addin */
    );
  write_biff_rec(A2, 225, b8 ? writeuint16(1200) : null);
  write_biff_rec(A2, 193, writezeroes(2));
  if (b5)
    write_biff_rec(
      A2,
      191
      /* ToolbarHdr */
    );
  if (b5)
    write_biff_rec(
      A2,
      192
      /* ToolbarEnd */
    );
  write_biff_rec(
    A2,
    226
    /* InterfaceEnd */
  );
  write_biff_rec(A2, 92, write_WriteAccess("SheetJS", opts));
  write_biff_rec(A2, 66, writeuint16(b8 ? 1200 : 1252));
  if (b8)
    write_biff_rec(A2, 353, writeuint16(0));
  if (b8)
    write_biff_rec(
      A2,
      448
      /* Excel9File */
    );
  write_biff_rec(A2, 317, write_RRTabId(wb.SheetNames.length));
  if (b8 && wb.vbaraw)
    write_biff_rec(
      A2,
      211
      /* ObProj */
    );
  if (b8 && wb.vbaraw) {
    var cname = _wb.CodeName || "ThisWorkbook";
    write_biff_rec(A2, 442, write_XLUnicodeString(cname));
  }
  write_biff_rec(A2, 156, writeuint16(17));
  write_biff_rec(A2, 25, writebool(false));
  write_biff_rec(A2, 18, writebool(false));
  write_biff_rec(A2, 19, writeuint16(0));
  if (b8)
    write_biff_rec(A2, 431, writebool(false));
  if (b8)
    write_biff_rec(A2, 444, writeuint16(0));
  write_biff_rec(A2, 61, write_Window1());
  write_biff_rec(A2, 64, writebool(false));
  write_biff_rec(A2, 141, writeuint16(0));
  write_biff_rec(A2, 34, writebool(safe1904(wb) == "true"));
  write_biff_rec(A2, 14, writebool(true));
  if (b8)
    write_biff_rec(A2, 439, writebool(false));
  write_biff_rec(A2, 218, writeuint16(0));
  write_FONTS_biff8(A2, wb, opts);
  write_FMTS_biff8(A2, wb.SSF, opts);
  write_CELLXFS_biff8(A2, opts);
  if (b8)
    write_biff_rec(A2, 352, writebool(false));
  var a2 = A2.end();
  var C2 = buf_array();
  if (b8)
    write_biff_rec(C2, 140, write_Country());
  if (b8 && opts.Strings)
    write_biff_continue(C2, 252, write_SST(opts.Strings));
  write_biff_rec(
    C2,
    10
    /* EOF */
  );
  var c2 = C2.end();
  var B2 = buf_array();
  var blen = 0, j2 = 0;
  for (j2 = 0; j2 < wb.SheetNames.length; ++j2)
    blen += (b8 ? 12 : 11) + (b8 ? 2 : 1) * wb.SheetNames[j2].length;
  var start = a2.length + blen + c2.length;
  for (j2 = 0; j2 < wb.SheetNames.length; ++j2) {
    var _sheet = _sheets[j2] || {};
    write_biff_rec(B2, 133, write_BoundSheet8({ pos: start, hs: _sheet.Hidden || 0, dt: 0, name: wb.SheetNames[j2] }, opts));
    start += bufs[j2].length;
  }
  var b2 = B2.end();
  if (blen != b2.length)
    throw new Error("BS8 " + blen + " != " + b2.length);
  var out = [];
  if (a2.length)
    out.push(a2);
  if (b2.length)
    out.push(b2);
  if (c2.length)
    out.push(c2);
  return bconcat(out);
}
__name(write_biff8_global, "write_biff8_global");
function write_biff8_buf(wb, opts) {
  var o2 = opts || {};
  var bufs = [];
  if (wb && !wb.SSF) {
    wb.SSF = dup(table_fmt);
  }
  if (wb && wb.SSF) {
    make_ssf();
    SSF_load_table(wb.SSF);
    o2.revssf = evert_num(wb.SSF);
    o2.revssf[wb.SSF[65535]] = 0;
    o2.ssf = wb.SSF;
  }
  o2.Strings = /*::((*/
  [];
  o2.Strings.Count = 0;
  o2.Strings.Unique = 0;
  fix_write_opts(o2);
  o2.cellXfs = [];
  get_cell_style(o2.cellXfs, {}, { revssf: { "General": 0 } });
  if (!wb.Props)
    wb.Props = {};
  for (var i2 = 0; i2 < wb.SheetNames.length; ++i2)
    bufs[bufs.length] = write_ws_biff8(i2, o2, wb);
  bufs.unshift(write_biff8_global(wb, bufs, o2));
  return bconcat(bufs);
}
__name(write_biff8_buf, "write_biff8_buf");
function write_biff_buf(wb, opts) {
  for (var i2 = 0; i2 <= wb.SheetNames.length; ++i2) {
    var ws = wb.Sheets[wb.SheetNames[i2]];
    if (!ws || !ws["!ref"])
      continue;
    var range = decode_range(ws["!ref"]);
    if (range.e.c > 255) {
      if (typeof console != "undefined" && console.error)
        console.error("Worksheet '" + wb.SheetNames[i2] + "' extends beyond column IV (255).  Data may be lost.");
    }
  }
  var o2 = opts || {};
  switch (o2.biff || 2) {
    case 8:
    case 5:
      return write_biff8_buf(wb, opts);
    case 4:
    case 3:
    case 2:
      return write_biff2_buf(wb, opts);
  }
  throw new Error("invalid type " + o2.bookType + " for BIFF");
}
__name(write_biff_buf, "write_biff_buf");
function make_html_row(ws, r, R2, o2) {
  var M2 = ws["!merges"] || [];
  var oo = [];
  for (var C2 = r.s.c; C2 <= r.e.c; ++C2) {
    var RS = 0, CS = 0;
    for (var j2 = 0; j2 < M2.length; ++j2) {
      if (M2[j2].s.r > R2 || M2[j2].s.c > C2)
        continue;
      if (M2[j2].e.r < R2 || M2[j2].e.c < C2)
        continue;
      if (M2[j2].s.r < R2 || M2[j2].s.c < C2) {
        RS = -1;
        break;
      }
      RS = M2[j2].e.r - M2[j2].s.r + 1;
      CS = M2[j2].e.c - M2[j2].s.c + 1;
      break;
    }
    if (RS < 0)
      continue;
    var coord = encode_cell({ r: R2, c: C2 });
    var cell = o2.dense ? (ws[R2] || [])[C2] : ws[coord];
    var w2 = cell && cell.v != null && (cell.h || escapehtml(cell.w || (format_cell(cell), cell.w) || "")) || "";
    var sp = {};
    if (RS > 1)
      sp.rowspan = RS;
    if (CS > 1)
      sp.colspan = CS;
    if (o2.editable)
      w2 = '<span contenteditable="true">' + w2 + "</span>";
    else if (cell) {
      sp["data-t"] = cell && cell.t || "z";
      if (cell.v != null)
        sp["data-v"] = cell.v;
      if (cell.z != null)
        sp["data-z"] = cell.z;
      if (cell.l && (cell.l.Target || "#").charAt(0) != "#")
        w2 = '<a href="' + cell.l.Target + '">' + w2 + "</a>";
    }
    sp.id = (o2.id || "sjs") + "-" + coord;
    oo.push(writextag("td", w2, sp));
  }
  var preamble = "<tr>";
  return preamble + oo.join("") + "</tr>";
}
__name(make_html_row, "make_html_row");
var HTML_BEGIN = '<html><head><meta charset="utf-8"/><title>SheetJS Table Export</title></head><body>';
var HTML_END = "</body></html>";
function make_html_preamble(ws, R2, o2) {
  var out = [];
  return out.join("") + "<table" + (o2 && o2.id ? ' id="' + o2.id + '"' : "") + ">";
}
__name(make_html_preamble, "make_html_preamble");
function sheet_to_html(ws, opts) {
  var o2 = opts || {};
  var header = o2.header != null ? o2.header : HTML_BEGIN;
  var footer = o2.footer != null ? o2.footer : HTML_END;
  var out = [header];
  var r = decode_range(ws["!ref"]);
  o2.dense = Array.isArray(ws);
  out.push(make_html_preamble(ws, r, o2));
  for (var R2 = r.s.r; R2 <= r.e.r; ++R2)
    out.push(make_html_row(ws, r, R2, o2));
  out.push("</table>" + footer);
  return out.join("");
}
__name(sheet_to_html, "sheet_to_html");
function sheet_add_dom(ws, table, _opts) {
  var opts = _opts || {};
  var or_R = 0, or_C = 0;
  if (opts.origin != null) {
    if (typeof opts.origin == "number")
      or_R = opts.origin;
    else {
      var _origin = typeof opts.origin == "string" ? decode_cell(opts.origin) : opts.origin;
      or_R = _origin.r;
      or_C = _origin.c;
    }
  }
  var rows = table.getElementsByTagName("tr");
  var sheetRows = Math.min(opts.sheetRows || 1e7, rows.length);
  var range = { s: { r: 0, c: 0 }, e: { r: or_R, c: or_C } };
  if (ws["!ref"]) {
    var _range = decode_range(ws["!ref"]);
    range.s.r = Math.min(range.s.r, _range.s.r);
    range.s.c = Math.min(range.s.c, _range.s.c);
    range.e.r = Math.max(range.e.r, _range.e.r);
    range.e.c = Math.max(range.e.c, _range.e.c);
    if (or_R == -1)
      range.e.r = or_R = _range.e.r + 1;
  }
  var merges = [], midx = 0;
  var rowinfo = ws["!rows"] || (ws["!rows"] = []);
  var _R = 0, R2 = 0, _C = 0, C2 = 0, RS = 0, CS = 0;
  if (!ws["!cols"])
    ws["!cols"] = [];
  for (; _R < rows.length && R2 < sheetRows; ++_R) {
    var row = rows[_R];
    if (is_dom_element_hidden(row)) {
      if (opts.display)
        continue;
      rowinfo[R2] = { hidden: true };
    }
    var elts = row.children;
    for (_C = C2 = 0; _C < elts.length; ++_C) {
      var elt = elts[_C];
      if (opts.display && is_dom_element_hidden(elt))
        continue;
      var v2 = elt.hasAttribute("data-v") ? elt.getAttribute("data-v") : elt.hasAttribute("v") ? elt.getAttribute("v") : htmldecode(elt.innerHTML);
      var z2 = elt.getAttribute("data-z") || elt.getAttribute("z");
      for (midx = 0; midx < merges.length; ++midx) {
        var m2 = merges[midx];
        if (m2.s.c == C2 + or_C && m2.s.r < R2 + or_R && R2 + or_R <= m2.e.r) {
          C2 = m2.e.c + 1 - or_C;
          midx = -1;
        }
      }
      CS = +elt.getAttribute("colspan") || 1;
      if ((RS = +elt.getAttribute("rowspan") || 1) > 1 || CS > 1)
        merges.push({ s: { r: R2 + or_R, c: C2 + or_C }, e: { r: R2 + or_R + (RS || 1) - 1, c: C2 + or_C + (CS || 1) - 1 } });
      var o2 = { t: "s", v: v2 };
      var _t2 = elt.getAttribute("data-t") || elt.getAttribute("t") || "";
      if (v2 != null) {
        if (v2.length == 0)
          o2.t = _t2 || "z";
        else if (opts.raw || v2.trim().length == 0 || _t2 == "s")
          ;
        else if (v2 === "TRUE")
          o2 = { t: "b", v: true };
        else if (v2 === "FALSE")
          o2 = { t: "b", v: false };
        else if (!isNaN(fuzzynum(v2)))
          o2 = { t: "n", v: fuzzynum(v2) };
        else if (!isNaN(fuzzydate(v2).getDate())) {
          o2 = { t: "d", v: parseDate(v2) };
          if (!opts.cellDates)
            o2 = { t: "n", v: datenum(o2.v) };
          o2.z = opts.dateNF || table_fmt[14];
        }
      }
      if (o2.z === void 0 && z2 != null)
        o2.z = z2;
      var l2 = "", Aelts = elt.getElementsByTagName("A");
      if (Aelts && Aelts.length) {
        for (var Aelti = 0; Aelti < Aelts.length; ++Aelti)
          if (Aelts[Aelti].hasAttribute("href")) {
            l2 = Aelts[Aelti].getAttribute("href");
            if (l2.charAt(0) != "#")
              break;
          }
      }
      if (l2 && l2.charAt(0) != "#")
        o2.l = { Target: l2 };
      if (opts.dense) {
        if (!ws[R2 + or_R])
          ws[R2 + or_R] = [];
        ws[R2 + or_R][C2 + or_C] = o2;
      } else
        ws[encode_cell({ c: C2 + or_C, r: R2 + or_R })] = o2;
      if (range.e.c < C2 + or_C)
        range.e.c = C2 + or_C;
      C2 += CS;
    }
    ++R2;
  }
  if (merges.length)
    ws["!merges"] = (ws["!merges"] || []).concat(merges);
  range.e.r = Math.max(range.e.r, R2 - 1 + or_R);
  ws["!ref"] = encode_range(range);
  if (R2 >= sheetRows)
    ws["!fullref"] = encode_range((range.e.r = rows.length - _R + R2 - 1 + or_R, range));
  return ws;
}
__name(sheet_add_dom, "sheet_add_dom");
function parse_dom_table(table, _opts) {
  var opts = _opts || {};
  var ws = opts.dense ? [] : {};
  return sheet_add_dom(ws, table, _opts);
}
__name(parse_dom_table, "parse_dom_table");
function table_to_book(table, opts) {
  return sheet_to_workbook(parse_dom_table(table, opts), opts);
}
__name(table_to_book, "table_to_book");
function is_dom_element_hidden(element) {
  var display = "";
  var get_computed_style = get_get_computed_style_function(element);
  if (get_computed_style)
    display = get_computed_style(element).getPropertyValue("display");
  if (!display)
    display = element.style && element.style.display;
  return display === "none";
}
__name(is_dom_element_hidden, "is_dom_element_hidden");
function get_get_computed_style_function(element) {
  if (element.ownerDocument.defaultView && typeof element.ownerDocument.defaultView.getComputedStyle === "function")
    return element.ownerDocument.defaultView.getComputedStyle;
  if (typeof getComputedStyle === "function")
    return getComputedStyle;
  return null;
}
__name(get_get_computed_style_function, "get_get_computed_style_function");
var write_styles_ods = /* @__PURE__ */ function() {
  var master_styles = [
    "<office:master-styles>",
    '<style:master-page style:name="mp1" style:page-layout-name="mp1">',
    "<style:header/>",
    '<style:header-left style:display="false"/>',
    "<style:footer/>",
    '<style:footer-left style:display="false"/>',
    "</style:master-page>",
    "</office:master-styles>"
  ].join("");
  var payload = "<office:document-styles " + wxt_helper({
    "xmlns:office": "urn:oasis:names:tc:opendocument:xmlns:office:1.0",
    "xmlns:table": "urn:oasis:names:tc:opendocument:xmlns:table:1.0",
    "xmlns:style": "urn:oasis:names:tc:opendocument:xmlns:style:1.0",
    "xmlns:text": "urn:oasis:names:tc:opendocument:xmlns:text:1.0",
    "xmlns:draw": "urn:oasis:names:tc:opendocument:xmlns:drawing:1.0",
    "xmlns:fo": "urn:oasis:names:tc:opendocument:xmlns:xsl-fo-compatible:1.0",
    "xmlns:xlink": "http://www.w3.org/1999/xlink",
    "xmlns:dc": "http://purl.org/dc/elements/1.1/",
    "xmlns:number": "urn:oasis:names:tc:opendocument:xmlns:datastyle:1.0",
    "xmlns:svg": "urn:oasis:names:tc:opendocument:xmlns:svg-compatible:1.0",
    "xmlns:of": "urn:oasis:names:tc:opendocument:xmlns:of:1.2",
    "office:version": "1.2"
  }) + ">" + master_styles + "</office:document-styles>";
  return /* @__PURE__ */ __name(function wso() {
    return XML_HEADER + payload;
  }, "wso");
}();
var write_content_ods = /* @__PURE__ */ function() {
  var write_text_p = /* @__PURE__ */ __name(function(text) {
    return escapexml(text).replace(/  +/g, function($$) {
      return '<text:s text:c="' + $$.length + '"/>';
    }).replace(/\t/g, "<text:tab/>").replace(/\n/g, "</text:p><text:p>").replace(/^ /, "<text:s/>").replace(/ $/, "<text:s/>");
  }, "write_text_p");
  var null_cell_xml = "          <table:table-cell />\n";
  var covered_cell_xml = "          <table:covered-table-cell/>\n";
  var write_ws2 = /* @__PURE__ */ __name(function(ws, wb, i2) {
    var o2 = [];
    o2.push('      <table:table table:name="' + escapexml(wb.SheetNames[i2]) + '" table:style-name="ta1">\n');
    var R2 = 0, C2 = 0, range = decode_range(ws["!ref"] || "A1");
    var marr = ws["!merges"] || [], mi = 0;
    var dense = Array.isArray(ws);
    if (ws["!cols"]) {
      for (C2 = 0; C2 <= range.e.c; ++C2)
        o2.push("        <table:table-column" + (ws["!cols"][C2] ? ' table:style-name="co' + ws["!cols"][C2].ods + '"' : "") + "></table:table-column>\n");
    }
    var H2 = "", ROWS = ws["!rows"] || [];
    for (R2 = 0; R2 < range.s.r; ++R2) {
      H2 = ROWS[R2] ? ' table:style-name="ro' + ROWS[R2].ods + '"' : "";
      o2.push("        <table:table-row" + H2 + "></table:table-row>\n");
    }
    for (; R2 <= range.e.r; ++R2) {
      H2 = ROWS[R2] ? ' table:style-name="ro' + ROWS[R2].ods + '"' : "";
      o2.push("        <table:table-row" + H2 + ">\n");
      for (C2 = 0; C2 < range.s.c; ++C2)
        o2.push(null_cell_xml);
      for (; C2 <= range.e.c; ++C2) {
        var skip2 = false, ct2 = {}, textp = "";
        for (mi = 0; mi != marr.length; ++mi) {
          if (marr[mi].s.c > C2)
            continue;
          if (marr[mi].s.r > R2)
            continue;
          if (marr[mi].e.c < C2)
            continue;
          if (marr[mi].e.r < R2)
            continue;
          if (marr[mi].s.c != C2 || marr[mi].s.r != R2)
            skip2 = true;
          ct2["table:number-columns-spanned"] = marr[mi].e.c - marr[mi].s.c + 1;
          ct2["table:number-rows-spanned"] = marr[mi].e.r - marr[mi].s.r + 1;
          break;
        }
        if (skip2) {
          o2.push(covered_cell_xml);
          continue;
        }
        var ref = encode_cell({ r: R2, c: C2 }), cell = dense ? (ws[R2] || [])[C2] : ws[ref];
        if (cell && cell.f) {
          ct2["table:formula"] = escapexml(csf_to_ods_formula(cell.f));
          if (cell.F) {
            if (cell.F.slice(0, ref.length) == ref) {
              var _Fref = decode_range(cell.F);
              ct2["table:number-matrix-columns-spanned"] = _Fref.e.c - _Fref.s.c + 1;
              ct2["table:number-matrix-rows-spanned"] = _Fref.e.r - _Fref.s.r + 1;
            }
          }
        }
        if (!cell) {
          o2.push(null_cell_xml);
          continue;
        }
        switch (cell.t) {
          case "b":
            textp = cell.v ? "TRUE" : "FALSE";
            ct2["office:value-type"] = "boolean";
            ct2["office:boolean-value"] = cell.v ? "true" : "false";
            break;
          case "n":
            textp = cell.w || String(cell.v || 0);
            ct2["office:value-type"] = "float";
            ct2["office:value"] = cell.v || 0;
            break;
          case "s":
          case "str":
            textp = cell.v == null ? "" : cell.v;
            ct2["office:value-type"] = "string";
            break;
          case "d":
            textp = cell.w || parseDate(cell.v).toISOString();
            ct2["office:value-type"] = "date";
            ct2["office:date-value"] = parseDate(cell.v).toISOString();
            ct2["table:style-name"] = "ce1";
            break;
          default:
            o2.push(null_cell_xml);
            continue;
        }
        var text_p = write_text_p(textp);
        if (cell.l && cell.l.Target) {
          var _tgt = cell.l.Target;
          _tgt = _tgt.charAt(0) == "#" ? "#" + csf_to_ods_3D(_tgt.slice(1)) : _tgt;
          if (_tgt.charAt(0) != "#" && !_tgt.match(/^\w+:/))
            _tgt = "../" + _tgt;
          text_p = writextag("text:a", text_p, { "xlink:href": _tgt.replace(/&/g, "&amp;") });
        }
        o2.push("          " + writextag("table:table-cell", writextag("text:p", text_p, {}), ct2) + "\n");
      }
      o2.push("        </table:table-row>\n");
    }
    o2.push("      </table:table>\n");
    return o2.join("");
  }, "write_ws");
  var write_automatic_styles_ods = /* @__PURE__ */ __name(function(o2, wb) {
    o2.push(" <office:automatic-styles>\n");
    o2.push('  <number:date-style style:name="N37" number:automatic-order="true">\n');
    o2.push('   <number:month number:style="long"/>\n');
    o2.push("   <number:text>/</number:text>\n");
    o2.push('   <number:day number:style="long"/>\n');
    o2.push("   <number:text>/</number:text>\n");
    o2.push("   <number:year/>\n");
    o2.push("  </number:date-style>\n");
    var cidx = 0;
    wb.SheetNames.map(function(n2) {
      return wb.Sheets[n2];
    }).forEach(function(ws) {
      if (!ws)
        return;
      if (ws["!cols"]) {
        for (var C2 = 0; C2 < ws["!cols"].length; ++C2)
          if (ws["!cols"][C2]) {
            var colobj = ws["!cols"][C2];
            if (colobj.width == null && colobj.wpx == null && colobj.wch == null)
              continue;
            process_col(colobj);
            colobj.ods = cidx;
            var w2 = ws["!cols"][C2].wpx + "px";
            o2.push('  <style:style style:name="co' + cidx + '" style:family="table-column">\n');
            o2.push('   <style:table-column-properties fo:break-before="auto" style:column-width="' + w2 + '"/>\n');
            o2.push("  </style:style>\n");
            ++cidx;
          }
      }
    });
    var ridx = 0;
    wb.SheetNames.map(function(n2) {
      return wb.Sheets[n2];
    }).forEach(function(ws) {
      if (!ws)
        return;
      if (ws["!rows"]) {
        for (var R2 = 0; R2 < ws["!rows"].length; ++R2)
          if (ws["!rows"][R2]) {
            ws["!rows"][R2].ods = ridx;
            var h3 = ws["!rows"][R2].hpx + "px";
            o2.push('  <style:style style:name="ro' + ridx + '" style:family="table-row">\n');
            o2.push('   <style:table-row-properties fo:break-before="auto" style:row-height="' + h3 + '"/>\n');
            o2.push("  </style:style>\n");
            ++ridx;
          }
      }
    });
    o2.push('  <style:style style:name="ta1" style:family="table" style:master-page-name="mp1">\n');
    o2.push('   <style:table-properties table:display="true" style:writing-mode="lr-tb"/>\n');
    o2.push("  </style:style>\n");
    o2.push('  <style:style style:name="ce1" style:family="table-cell" style:parent-style-name="Default" style:data-style-name="N37"/>\n');
    o2.push(" </office:automatic-styles>\n");
  }, "write_automatic_styles_ods");
  return /* @__PURE__ */ __name(function wcx(wb, opts) {
    var o2 = [XML_HEADER];
    var attr = wxt_helper({
      "xmlns:office": "urn:oasis:names:tc:opendocument:xmlns:office:1.0",
      "xmlns:table": "urn:oasis:names:tc:opendocument:xmlns:table:1.0",
      "xmlns:style": "urn:oasis:names:tc:opendocument:xmlns:style:1.0",
      "xmlns:text": "urn:oasis:names:tc:opendocument:xmlns:text:1.0",
      "xmlns:draw": "urn:oasis:names:tc:opendocument:xmlns:drawing:1.0",
      "xmlns:fo": "urn:oasis:names:tc:opendocument:xmlns:xsl-fo-compatible:1.0",
      "xmlns:xlink": "http://www.w3.org/1999/xlink",
      "xmlns:dc": "http://purl.org/dc/elements/1.1/",
      "xmlns:meta": "urn:oasis:names:tc:opendocument:xmlns:meta:1.0",
      "xmlns:number": "urn:oasis:names:tc:opendocument:xmlns:datastyle:1.0",
      "xmlns:presentation": "urn:oasis:names:tc:opendocument:xmlns:presentation:1.0",
      "xmlns:svg": "urn:oasis:names:tc:opendocument:xmlns:svg-compatible:1.0",
      "xmlns:chart": "urn:oasis:names:tc:opendocument:xmlns:chart:1.0",
      "xmlns:dr3d": "urn:oasis:names:tc:opendocument:xmlns:dr3d:1.0",
      "xmlns:math": "http://www.w3.org/1998/Math/MathML",
      "xmlns:form": "urn:oasis:names:tc:opendocument:xmlns:form:1.0",
      "xmlns:script": "urn:oasis:names:tc:opendocument:xmlns:script:1.0",
      "xmlns:ooo": "http://openoffice.org/2004/office",
      "xmlns:ooow": "http://openoffice.org/2004/writer",
      "xmlns:oooc": "http://openoffice.org/2004/calc",
      "xmlns:dom": "http://www.w3.org/2001/xml-events",
      "xmlns:xforms": "http://www.w3.org/2002/xforms",
      "xmlns:xsd": "http://www.w3.org/2001/XMLSchema",
      "xmlns:xsi": "http://www.w3.org/2001/XMLSchema-instance",
      "xmlns:sheet": "urn:oasis:names:tc:opendocument:sh33tjs:1.0",
      "xmlns:rpt": "http://openoffice.org/2005/report",
      "xmlns:of": "urn:oasis:names:tc:opendocument:xmlns:of:1.2",
      "xmlns:xhtml": "http://www.w3.org/1999/xhtml",
      "xmlns:grddl": "http://www.w3.org/2003/g/data-view#",
      "xmlns:tableooo": "http://openoffice.org/2009/table",
      "xmlns:drawooo": "http://openoffice.org/2010/draw",
      "xmlns:calcext": "urn:org:documentfoundation:names:experimental:calc:xmlns:calcext:1.0",
      "xmlns:loext": "urn:org:documentfoundation:names:experimental:office:xmlns:loext:1.0",
      "xmlns:field": "urn:openoffice:names:experimental:ooo-ms-interop:xmlns:field:1.0",
      "xmlns:formx": "urn:openoffice:names:experimental:ooxml-odf-interop:xmlns:form:1.0",
      "xmlns:css3t": "http://www.w3.org/TR/css3-text/",
      "office:version": "1.2"
    });
    var fods = wxt_helper({
      "xmlns:config": "urn:oasis:names:tc:opendocument:xmlns:config:1.0",
      "office:mimetype": "application/vnd.oasis.opendocument.spreadsheet"
    });
    if (opts.bookType == "fods") {
      o2.push("<office:document" + attr + fods + ">\n");
      o2.push(write_meta_ods().replace(/office:document-meta/g, "office:meta"));
    } else
      o2.push("<office:document-content" + attr + ">\n");
    write_automatic_styles_ods(o2, wb);
    o2.push("  <office:body>\n");
    o2.push("    <office:spreadsheet>\n");
    for (var i2 = 0; i2 != wb.SheetNames.length; ++i2)
      o2.push(write_ws2(wb.Sheets[wb.SheetNames[i2]], wb, i2));
    o2.push("    </office:spreadsheet>\n");
    o2.push("  </office:body>\n");
    if (opts.bookType == "fods")
      o2.push("</office:document>");
    else
      o2.push("</office:document-content>");
    return o2.join("");
  }, "wcx");
}();
function write_ods(wb, opts) {
  if (opts.bookType == "fods")
    return write_content_ods(wb, opts);
  var zip = zip_new();
  var f2 = "";
  var manifest = [];
  var rdf = [];
  f2 = "mimetype";
  zip_add_file(zip, f2, "application/vnd.oasis.opendocument.spreadsheet");
  f2 = "content.xml";
  zip_add_file(zip, f2, write_content_ods(wb, opts));
  manifest.push([f2, "text/xml"]);
  rdf.push([f2, "ContentFile"]);
  f2 = "styles.xml";
  zip_add_file(zip, f2, write_styles_ods(wb, opts));
  manifest.push([f2, "text/xml"]);
  rdf.push([f2, "StylesFile"]);
  f2 = "meta.xml";
  zip_add_file(zip, f2, XML_HEADER + write_meta_ods(
    /*::wb, opts*/
  ));
  manifest.push([f2, "text/xml"]);
  rdf.push([f2, "MetadataFile"]);
  f2 = "manifest.rdf";
  zip_add_file(zip, f2, write_rdf(
    rdf
    /*, opts*/
  ));
  manifest.push([f2, "application/rdf+xml"]);
  f2 = "META-INF/manifest.xml";
  zip_add_file(zip, f2, write_manifest(
    manifest
    /*, opts*/
  ));
  return zip;
}
__name(write_ods, "write_ods");
/*! sheetjs (C) 2013-present SheetJS -- http://sheetjs.com */
function u8_to_dataview(array) {
  return new DataView(array.buffer, array.byteOffset, array.byteLength);
}
__name(u8_to_dataview, "u8_to_dataview");
function stru8(str) {
  return typeof TextEncoder != "undefined" ? new TextEncoder().encode(str) : s2a(utf8write(str));
}
__name(stru8, "stru8");
function u8contains(body, search) {
  outer:
    for (var L2 = 0; L2 <= body.length - search.length; ++L2) {
      for (var j2 = 0; j2 < search.length; ++j2)
        if (body[L2 + j2] != search[j2])
          continue outer;
      return true;
    }
  return false;
}
__name(u8contains, "u8contains");
function u8concat(u8a) {
  var len = u8a.reduce(function(acc, x2) {
    return acc + x2.length;
  }, 0);
  var out = new Uint8Array(len);
  var off = 0;
  u8a.forEach(function(u82) {
    out.set(u82, off);
    off += u82.length;
  });
  return out;
}
__name(u8concat, "u8concat");
function writeDecimal128LE(buf, offset, value) {
  var exp = Math.floor(value == 0 ? 0 : Math.LOG10E * Math.log(Math.abs(value))) + 6176 - 20;
  var mantissa = value / Math.pow(10, exp - 6176);
  buf[offset + 15] |= exp >> 7;
  buf[offset + 14] |= (exp & 127) << 1;
  for (var i2 = 0; mantissa >= 1; ++i2, mantissa /= 256)
    buf[offset + i2] = mantissa & 255;
  buf[offset + 15] |= value >= 0 ? 0 : 128;
}
__name(writeDecimal128LE, "writeDecimal128LE");
function parse_varint49(buf, ptr) {
  var l2 = ptr ? ptr[0] : 0;
  var usz = buf[l2] & 127;
  varint:
    if (buf[l2++] >= 128) {
      usz |= (buf[l2] & 127) << 7;
      if (buf[l2++] < 128)
        break varint;
      usz |= (buf[l2] & 127) << 14;
      if (buf[l2++] < 128)
        break varint;
      usz |= (buf[l2] & 127) << 21;
      if (buf[l2++] < 128)
        break varint;
      usz += (buf[l2] & 127) * Math.pow(2, 28);
      ++l2;
      if (buf[l2++] < 128)
        break varint;
      usz += (buf[l2] & 127) * Math.pow(2, 35);
      ++l2;
      if (buf[l2++] < 128)
        break varint;
      usz += (buf[l2] & 127) * Math.pow(2, 42);
      ++l2;
      if (buf[l2++] < 128)
        break varint;
    }
  if (ptr)
    ptr[0] = l2;
  return usz;
}
__name(parse_varint49, "parse_varint49");
function write_varint49(v2) {
  var usz = new Uint8Array(7);
  usz[0] = v2 & 127;
  var L2 = 1;
  sz:
    if (v2 > 127) {
      usz[L2 - 1] |= 128;
      usz[L2] = v2 >> 7 & 127;
      ++L2;
      if (v2 <= 16383)
        break sz;
      usz[L2 - 1] |= 128;
      usz[L2] = v2 >> 14 & 127;
      ++L2;
      if (v2 <= 2097151)
        break sz;
      usz[L2 - 1] |= 128;
      usz[L2] = v2 >> 21 & 127;
      ++L2;
      if (v2 <= 268435455)
        break sz;
      usz[L2 - 1] |= 128;
      usz[L2] = v2 / 256 >>> 21 & 127;
      ++L2;
      if (v2 <= 34359738367)
        break sz;
      usz[L2 - 1] |= 128;
      usz[L2] = v2 / 65536 >>> 21 & 127;
      ++L2;
      if (v2 <= 4398046511103)
        break sz;
      usz[L2 - 1] |= 128;
      usz[L2] = v2 / 16777216 >>> 21 & 127;
      ++L2;
    }
  return usz.slice(0, L2);
}
__name(write_varint49, "write_varint49");
function varint_to_i32(buf) {
  var l2 = 0, i322 = buf[l2] & 127;
  varint:
    if (buf[l2++] >= 128) {
      i322 |= (buf[l2] & 127) << 7;
      if (buf[l2++] < 128)
        break varint;
      i322 |= (buf[l2] & 127) << 14;
      if (buf[l2++] < 128)
        break varint;
      i322 |= (buf[l2] & 127) << 21;
      if (buf[l2++] < 128)
        break varint;
      i322 |= (buf[l2] & 127) << 28;
    }
  return i322;
}
__name(varint_to_i32, "varint_to_i32");
function parse_shallow(buf) {
  var out = [], ptr = [0];
  while (ptr[0] < buf.length) {
    var off = ptr[0];
    var num = parse_varint49(buf, ptr);
    var type = num & 7;
    num = Math.floor(num / 8);
    var len = 0;
    var res;
    if (num == 0)
      break;
    switch (type) {
      case 0:
        {
          var l2 = ptr[0];
          while (buf[ptr[0]++] >= 128)
            ;
          res = buf.slice(l2, ptr[0]);
        }
        break;
      case 5:
        len = 4;
        res = buf.slice(ptr[0], ptr[0] + len);
        ptr[0] += len;
        break;
      case 1:
        len = 8;
        res = buf.slice(ptr[0], ptr[0] + len);
        ptr[0] += len;
        break;
      case 2:
        len = parse_varint49(buf, ptr);
        res = buf.slice(ptr[0], ptr[0] + len);
        ptr[0] += len;
        break;
      case 3:
      case 4:
      default:
        throw new Error("PB Type ".concat(type, " for Field ").concat(num, " at offset ").concat(off));
    }
    var v2 = { data: res, type };
    if (out[num] == null)
      out[num] = [v2];
    else
      out[num].push(v2);
  }
  return out;
}
__name(parse_shallow, "parse_shallow");
function write_shallow(proto) {
  var out = [];
  proto.forEach(function(field, idx) {
    field.forEach(function(item) {
      if (!item.data)
        return;
      out.push(write_varint49(idx * 8 + item.type));
      if (item.type == 2)
        out.push(write_varint49(item.data.length));
      out.push(item.data);
    });
  });
  return u8concat(out);
}
__name(write_shallow, "write_shallow");
function parse_iwa_file(buf) {
  var _a3;
  var out = [], ptr = [0];
  while (ptr[0] < buf.length) {
    var len = parse_varint49(buf, ptr);
    var ai = parse_shallow(buf.slice(ptr[0], ptr[0] + len));
    ptr[0] += len;
    var res = {
      id: varint_to_i32(ai[1][0].data),
      messages: []
    };
    ai[2].forEach(function(b2) {
      var mi = parse_shallow(b2.data);
      var fl2 = varint_to_i32(mi[3][0].data);
      res.messages.push({
        meta: mi,
        data: buf.slice(ptr[0], ptr[0] + fl2)
      });
      ptr[0] += fl2;
    });
    if ((_a3 = ai[3]) == null ? void 0 : _a3[0])
      res.merge = varint_to_i32(ai[3][0].data) >>> 0 > 0;
    out.push(res);
  }
  return out;
}
__name(parse_iwa_file, "parse_iwa_file");
function write_iwa_file(ias) {
  var bufs = [];
  ias.forEach(function(ia) {
    var ai = [];
    ai[1] = [{ data: write_varint49(ia.id), type: 0 }];
    ai[2] = [];
    if (ia.merge != null)
      ai[3] = [{ data: write_varint49(+!!ia.merge), type: 0 }];
    var midata = [];
    ia.messages.forEach(function(mi) {
      midata.push(mi.data);
      mi.meta[3] = [{ type: 0, data: write_varint49(mi.data.length) }];
      ai[2].push({ data: write_shallow(mi.meta), type: 2 });
    });
    var aipayload = write_shallow(ai);
    bufs.push(write_varint49(aipayload.length));
    bufs.push(aipayload);
    midata.forEach(function(mid) {
      return bufs.push(mid);
    });
  });
  return u8concat(bufs);
}
__name(write_iwa_file, "write_iwa_file");
function parse_snappy_chunk(type, buf) {
  if (type != 0)
    throw new Error("Unexpected Snappy chunk type ".concat(type));
  var ptr = [0];
  var usz = parse_varint49(buf, ptr);
  var chunks = [];
  while (ptr[0] < buf.length) {
    var tag = buf[ptr[0]] & 3;
    if (tag == 0) {
      var len = buf[ptr[0]++] >> 2;
      if (len < 60)
        ++len;
      else {
        var c2 = len - 59;
        len = buf[ptr[0]];
        if (c2 > 1)
          len |= buf[ptr[0] + 1] << 8;
        if (c2 > 2)
          len |= buf[ptr[0] + 2] << 16;
        if (c2 > 3)
          len |= buf[ptr[0] + 3] << 24;
        len >>>= 0;
        len++;
        ptr[0] += c2;
      }
      chunks.push(buf.slice(ptr[0], ptr[0] + len));
      ptr[0] += len;
      continue;
    } else {
      var offset = 0, length = 0;
      if (tag == 1) {
        length = (buf[ptr[0]] >> 2 & 7) + 4;
        offset = (buf[ptr[0]++] & 224) << 3;
        offset |= buf[ptr[0]++];
      } else {
        length = (buf[ptr[0]++] >> 2) + 1;
        if (tag == 2) {
          offset = buf[ptr[0]] | buf[ptr[0] + 1] << 8;
          ptr[0] += 2;
        } else {
          offset = (buf[ptr[0]] | buf[ptr[0] + 1] << 8 | buf[ptr[0] + 2] << 16 | buf[ptr[0] + 3] << 24) >>> 0;
          ptr[0] += 4;
        }
      }
      chunks = [u8concat(chunks)];
      if (offset == 0)
        throw new Error("Invalid offset 0");
      if (offset > chunks[0].length)
        throw new Error("Invalid offset beyond length");
      if (length >= offset) {
        chunks.push(chunks[0].slice(-offset));
        length -= offset;
        while (length >= chunks[chunks.length - 1].length) {
          chunks.push(chunks[chunks.length - 1]);
          length -= chunks[chunks.length - 1].length;
        }
      }
      chunks.push(chunks[0].slice(-offset, -offset + length));
    }
  }
  var o2 = u8concat(chunks);
  if (o2.length != usz)
    throw new Error("Unexpected length: ".concat(o2.length, " != ").concat(usz));
  return o2;
}
__name(parse_snappy_chunk, "parse_snappy_chunk");
function decompress_iwa_file(buf) {
  var out = [];
  var l2 = 0;
  while (l2 < buf.length) {
    var t2 = buf[l2++];
    var len = buf[l2] | buf[l2 + 1] << 8 | buf[l2 + 2] << 16;
    l2 += 3;
    out.push(parse_snappy_chunk(t2, buf.slice(l2, l2 + len)));
    l2 += len;
  }
  if (l2 !== buf.length)
    throw new Error("data is not a valid framed stream!");
  return u8concat(out);
}
__name(decompress_iwa_file, "decompress_iwa_file");
function compress_iwa_file(buf) {
  var out = [];
  var l2 = 0;
  while (l2 < buf.length) {
    var c2 = Math.min(buf.length - l2, 268435455);
    var frame = new Uint8Array(4);
    out.push(frame);
    var usz = write_varint49(c2);
    var L2 = usz.length;
    out.push(usz);
    if (c2 <= 60) {
      L2++;
      out.push(new Uint8Array([c2 - 1 << 2]));
    } else if (c2 <= 256) {
      L2 += 2;
      out.push(new Uint8Array([240, c2 - 1 & 255]));
    } else if (c2 <= 65536) {
      L2 += 3;
      out.push(new Uint8Array([244, c2 - 1 & 255, c2 - 1 >> 8 & 255]));
    } else if (c2 <= 16777216) {
      L2 += 4;
      out.push(new Uint8Array([248, c2 - 1 & 255, c2 - 1 >> 8 & 255, c2 - 1 >> 16 & 255]));
    } else if (c2 <= 4294967296) {
      L2 += 5;
      out.push(new Uint8Array([252, c2 - 1 & 255, c2 - 1 >> 8 & 255, c2 - 1 >> 16 & 255, c2 - 1 >>> 24 & 255]));
    }
    out.push(buf.slice(l2, l2 + c2));
    L2 += c2;
    frame[0] = 0;
    frame[1] = L2 & 255;
    frame[2] = L2 >> 8 & 255;
    frame[3] = L2 >> 16 & 255;
    l2 += c2;
  }
  return u8concat(out);
}
__name(compress_iwa_file, "compress_iwa_file");
function write_new_storage(cell, sst) {
  var out = new Uint8Array(32), dv = u8_to_dataview(out), l2 = 12, flags = 0;
  out[0] = 5;
  switch (cell.t) {
    case "n":
      out[1] = 2;
      writeDecimal128LE(out, l2, cell.v);
      flags |= 1;
      l2 += 16;
      break;
    case "b":
      out[1] = 6;
      dv.setFloat64(l2, cell.v ? 1 : 0, true);
      flags |= 2;
      l2 += 8;
      break;
    case "s":
      if (sst.indexOf(cell.v) == -1)
        throw new Error("Value ".concat(cell.v, " missing from SST!"));
      out[1] = 3;
      dv.setUint32(l2, sst.indexOf(cell.v), true);
      flags |= 8;
      l2 += 4;
      break;
    default:
      throw "unsupported cell type " + cell.t;
  }
  dv.setUint32(8, flags, true);
  return out.slice(0, l2);
}
__name(write_new_storage, "write_new_storage");
function write_old_storage(cell, sst) {
  var out = new Uint8Array(32), dv = u8_to_dataview(out), l2 = 12, flags = 0;
  out[0] = 3;
  switch (cell.t) {
    case "n":
      out[2] = 2;
      dv.setFloat64(l2, cell.v, true);
      flags |= 32;
      l2 += 8;
      break;
    case "b":
      out[2] = 6;
      dv.setFloat64(l2, cell.v ? 1 : 0, true);
      flags |= 32;
      l2 += 8;
      break;
    case "s":
      if (sst.indexOf(cell.v) == -1)
        throw new Error("Value ".concat(cell.v, " missing from SST!"));
      out[2] = 3;
      dv.setUint32(l2, sst.indexOf(cell.v), true);
      flags |= 16;
      l2 += 4;
      break;
    default:
      throw "unsupported cell type " + cell.t;
  }
  dv.setUint32(4, flags, true);
  return out.slice(0, l2);
}
__name(write_old_storage, "write_old_storage");
function parse_TSP_Reference(buf) {
  var pb = parse_shallow(buf);
  return parse_varint49(pb[1][0].data);
}
__name(parse_TSP_Reference, "parse_TSP_Reference");
function write_tile_row(tri, data, SST) {
  var _a3, _b2, _c, _d;
  if (!((_a3 = tri[6]) == null ? void 0 : _a3[0]) || !((_b2 = tri[7]) == null ? void 0 : _b2[0]))
    throw "Mutation only works on post-BNC storages!";
  var wide_offsets = ((_d = (_c = tri[8]) == null ? void 0 : _c[0]) == null ? void 0 : _d.data) && varint_to_i32(tri[8][0].data) > 0 || false;
  if (wide_offsets)
    throw "Math only works with normal offsets";
  var cnt = 0;
  var dv = u8_to_dataview(tri[7][0].data), last_offset = 0, cell_storage = [];
  var _dv = u8_to_dataview(tri[4][0].data), _last_offset = 0, _cell_storage = [];
  for (var C2 = 0; C2 < data.length; ++C2) {
    if (data[C2] == null) {
      dv.setUint16(C2 * 2, 65535, true);
      _dv.setUint16(C2 * 2, 65535);
      continue;
    }
    dv.setUint16(C2 * 2, last_offset, true);
    _dv.setUint16(C2 * 2, _last_offset, true);
    var celload, _celload;
    switch (typeof data[C2]) {
      case "string":
        celload = write_new_storage({ t: "s", v: data[C2] }, SST);
        _celload = write_old_storage({ t: "s", v: data[C2] }, SST);
        break;
      case "number":
        celload = write_new_storage({ t: "n", v: data[C2] }, SST);
        _celload = write_old_storage({ t: "n", v: data[C2] }, SST);
        break;
      case "boolean":
        celload = write_new_storage({ t: "b", v: data[C2] }, SST);
        _celload = write_old_storage({ t: "b", v: data[C2] }, SST);
        break;
      default:
        throw new Error("Unsupported value " + data[C2]);
    }
    cell_storage.push(celload);
    last_offset += celload.length;
    _cell_storage.push(_celload);
    _last_offset += _celload.length;
    ++cnt;
  }
  tri[2][0].data = write_varint49(cnt);
  for (; C2 < tri[7][0].data.length / 2; ++C2) {
    dv.setUint16(C2 * 2, 65535, true);
    _dv.setUint16(C2 * 2, 65535, true);
  }
  tri[6][0].data = u8concat(cell_storage);
  tri[3][0].data = u8concat(_cell_storage);
  return cnt;
}
__name(write_tile_row, "write_tile_row");
function write_numbers_iwa(wb, opts) {
  if (!opts || !opts.numbers)
    throw new Error("Must pass a `numbers` option -- check the README");
  var ws = wb.Sheets[wb.SheetNames[0]];
  if (wb.SheetNames.length > 1)
    console.error("The Numbers writer currently writes only the first table");
  var range = decode_range(ws["!ref"]);
  range.s.r = range.s.c = 0;
  var trunc = false;
  if (range.e.c > 9) {
    trunc = true;
    range.e.c = 9;
  }
  if (range.e.r > 49) {
    trunc = true;
    range.e.r = 49;
  }
  if (trunc)
    console.error("The Numbers writer is currently limited to ".concat(encode_range(range)));
  var data = sheet_to_json(ws, { range, header: 1 });
  var SST = ["~Sh33tJ5~"];
  data.forEach(function(row) {
    return row.forEach(function(cell) {
      if (typeof cell == "string")
        SST.push(cell);
    });
  });
  var dependents = {};
  var indices = [];
  var cfb = CFB.read(opts.numbers, { type: "base64" });
  cfb.FileIndex.map(function(fi, idx) {
    return [fi, cfb.FullPaths[idx]];
  }).forEach(function(row) {
    var fi = row[0], fp = row[1];
    if (fi.type != 2)
      return;
    if (!fi.name.match(/\.iwa/))
      return;
    var old_content = fi.content;
    var raw1 = decompress_iwa_file(old_content);
    var x22 = parse_iwa_file(raw1);
    x22.forEach(function(packet2) {
      indices.push(packet2.id);
      dependents[packet2.id] = { deps: [], location: fp, type: varint_to_i32(packet2.messages[0].meta[1][0].data) };
    });
  });
  indices.sort(function(x22, y22) {
    return x22 - y22;
  });
  var indices_varint = indices.filter(function(x22) {
    return x22 > 1;
  }).map(function(x22) {
    return [x22, write_varint49(x22)];
  });
  cfb.FileIndex.map(function(fi, idx) {
    return [fi, cfb.FullPaths[idx]];
  }).forEach(function(row) {
    var fi = row[0];
    row[1];
    if (!fi.name.match(/\.iwa/))
      return;
    var x22 = parse_iwa_file(decompress_iwa_file(fi.content));
    x22.forEach(function(ia) {
      ia.messages.forEach(function(m2) {
        indices_varint.forEach(function(ivi) {
          if (ia.messages.some(function(mess) {
            return varint_to_i32(mess.meta[1][0].data) != 11006 && u8contains(mess.data, ivi[1]);
          })) {
            dependents[ivi[0]].deps.push(ia.id);
          }
        });
      });
    });
  });
  var entry = CFB.find(cfb, dependents[1].location);
  var x2 = parse_iwa_file(decompress_iwa_file(entry.content));
  var docroot;
  for (var xi = 0; xi < x2.length; ++xi) {
    var packet = x2[xi];
    if (packet.id == 1)
      docroot = packet;
  }
  var sheetrootref = parse_TSP_Reference(parse_shallow(docroot.messages[0].data)[1][0].data);
  entry = CFB.find(cfb, dependents[sheetrootref].location);
  x2 = parse_iwa_file(decompress_iwa_file(entry.content));
  for (xi = 0; xi < x2.length; ++xi) {
    packet = x2[xi];
    if (packet.id == sheetrootref)
      docroot = packet;
  }
  sheetrootref = parse_TSP_Reference(parse_shallow(docroot.messages[0].data)[2][0].data);
  entry = CFB.find(cfb, dependents[sheetrootref].location);
  x2 = parse_iwa_file(decompress_iwa_file(entry.content));
  for (xi = 0; xi < x2.length; ++xi) {
    packet = x2[xi];
    if (packet.id == sheetrootref)
      docroot = packet;
  }
  sheetrootref = parse_TSP_Reference(parse_shallow(docroot.messages[0].data)[2][0].data);
  entry = CFB.find(cfb, dependents[sheetrootref].location);
  x2 = parse_iwa_file(decompress_iwa_file(entry.content));
  for (xi = 0; xi < x2.length; ++xi) {
    packet = x2[xi];
    if (packet.id == sheetrootref)
      docroot = packet;
  }
  var pb = parse_shallow(docroot.messages[0].data);
  {
    pb[6][0].data = write_varint49(range.e.r + 1);
    pb[7][0].data = write_varint49(range.e.c + 1);
    var cruidsref = parse_TSP_Reference(pb[46][0].data);
    var oldbucket = CFB.find(cfb, dependents[cruidsref].location);
    var _x = parse_iwa_file(decompress_iwa_file(oldbucket.content));
    {
      for (var j2 = 0; j2 < _x.length; ++j2) {
        if (_x[j2].id == cruidsref)
          break;
      }
      if (_x[j2].id != cruidsref)
        throw "Bad ColumnRowUIDMapArchive";
      var cruids = parse_shallow(_x[j2].messages[0].data);
      cruids[1] = [];
      cruids[2] = [], cruids[3] = [];
      for (var C2 = 0; C2 <= range.e.c; ++C2) {
        var uuid = [];
        uuid[1] = uuid[2] = [{ type: 0, data: write_varint49(C2 + 420690) }];
        cruids[1].push({ type: 2, data: write_shallow(uuid) });
        cruids[2].push({ type: 0, data: write_varint49(C2) });
        cruids[3].push({ type: 0, data: write_varint49(C2) });
      }
      cruids[4] = [];
      cruids[5] = [], cruids[6] = [];
      for (var R2 = 0; R2 <= range.e.r; ++R2) {
        uuid = [];
        uuid[1] = uuid[2] = [{ type: 0, data: write_varint49(R2 + 726270) }];
        cruids[4].push({ type: 2, data: write_shallow(uuid) });
        cruids[5].push({ type: 0, data: write_varint49(R2) });
        cruids[6].push({ type: 0, data: write_varint49(R2) });
      }
      _x[j2].messages[0].data = write_shallow(cruids);
    }
    oldbucket.content = compress_iwa_file(write_iwa_file(_x));
    oldbucket.size = oldbucket.content.length;
    delete pb[46];
    var store = parse_shallow(pb[4][0].data);
    {
      store[7][0].data = write_varint49(range.e.r + 1);
      var row_headers = parse_shallow(store[1][0].data);
      var row_header_ref = parse_TSP_Reference(row_headers[2][0].data);
      oldbucket = CFB.find(cfb, dependents[row_header_ref].location);
      _x = parse_iwa_file(decompress_iwa_file(oldbucket.content));
      {
        if (_x[0].id != row_header_ref)
          throw "Bad HeaderStorageBucket";
        var base_bucket = parse_shallow(_x[0].messages[0].data);
        for (R2 = 0; R2 < data.length; ++R2) {
          var _bucket = parse_shallow(base_bucket[2][0].data);
          _bucket[1][0].data = write_varint49(R2);
          _bucket[4][0].data = write_varint49(data[R2].length);
          base_bucket[2][R2] = { type: base_bucket[2][0].type, data: write_shallow(_bucket) };
        }
        _x[0].messages[0].data = write_shallow(base_bucket);
      }
      oldbucket.content = compress_iwa_file(write_iwa_file(_x));
      oldbucket.size = oldbucket.content.length;
      var col_header_ref = parse_TSP_Reference(store[2][0].data);
      oldbucket = CFB.find(cfb, dependents[col_header_ref].location);
      _x = parse_iwa_file(decompress_iwa_file(oldbucket.content));
      {
        if (_x[0].id != col_header_ref)
          throw "Bad HeaderStorageBucket";
        base_bucket = parse_shallow(_x[0].messages[0].data);
        for (C2 = 0; C2 <= range.e.c; ++C2) {
          _bucket = parse_shallow(base_bucket[2][0].data);
          _bucket[1][0].data = write_varint49(C2);
          _bucket[4][0].data = write_varint49(range.e.r + 1);
          base_bucket[2][C2] = { type: base_bucket[2][0].type, data: write_shallow(_bucket) };
        }
        _x[0].messages[0].data = write_shallow(base_bucket);
      }
      oldbucket.content = compress_iwa_file(write_iwa_file(_x));
      oldbucket.size = oldbucket.content.length;
      var sstref = parse_TSP_Reference(store[4][0].data);
      (function() {
        var sentry = CFB.find(cfb, dependents[sstref].location);
        var sx = parse_iwa_file(decompress_iwa_file(sentry.content));
        var sstroot;
        for (var sxi = 0; sxi < sx.length; ++sxi) {
          var packet2 = sx[sxi];
          if (packet2.id == sstref)
            sstroot = packet2;
        }
        var sstdata = parse_shallow(sstroot.messages[0].data);
        {
          sstdata[3] = [];
          var newsst = [];
          SST.forEach(function(str, i2) {
            newsst[1] = [{ type: 0, data: write_varint49(i2) }];
            newsst[2] = [{ type: 0, data: write_varint49(1) }];
            newsst[3] = [{ type: 2, data: stru8(str) }];
            sstdata[3].push({ type: 2, data: write_shallow(newsst) });
          });
        }
        sstroot.messages[0].data = write_shallow(sstdata);
        var sy = write_iwa_file(sx);
        var raw32 = compress_iwa_file(sy);
        sentry.content = raw32;
        sentry.size = sentry.content.length;
      })();
      var tile = parse_shallow(store[3][0].data);
      {
        var t2 = tile[1][0];
        delete tile[2];
        var tl = parse_shallow(t2.data);
        {
          var tileref = parse_TSP_Reference(tl[2][0].data);
          (function() {
            var tentry = CFB.find(cfb, dependents[tileref].location);
            var tx = parse_iwa_file(decompress_iwa_file(tentry.content));
            var tileroot;
            for (var sxi = 0; sxi < tx.length; ++sxi) {
              var packet2 = tx[sxi];
              if (packet2.id == tileref)
                tileroot = packet2;
            }
            var tiledata = parse_shallow(tileroot.messages[0].data);
            {
              delete tiledata[6];
              delete tile[7];
              var rowload = new Uint8Array(tiledata[5][0].data);
              tiledata[5] = [];
              var cnt = 0;
              for (var R22 = 0; R22 <= range.e.r; ++R22) {
                var tilerow = parse_shallow(rowload);
                cnt += write_tile_row(tilerow, data[R22], SST);
                tilerow[1][0].data = write_varint49(R22);
                tiledata[5].push({ data: write_shallow(tilerow), type: 2 });
              }
              tiledata[1] = [{ type: 0, data: write_varint49(range.e.c + 1) }];
              tiledata[2] = [{ type: 0, data: write_varint49(range.e.r + 1) }];
              tiledata[3] = [{ type: 0, data: write_varint49(cnt) }];
              tiledata[4] = [{ type: 0, data: write_varint49(range.e.r + 1) }];
            }
            tileroot.messages[0].data = write_shallow(tiledata);
            var ty = write_iwa_file(tx);
            var raw32 = compress_iwa_file(ty);
            tentry.content = raw32;
            tentry.size = tentry.content.length;
          })();
        }
        t2.data = write_shallow(tl);
      }
      store[3][0].data = write_shallow(tile);
    }
    pb[4][0].data = write_shallow(store);
  }
  docroot.messages[0].data = write_shallow(pb);
  var y2 = write_iwa_file(x2);
  var raw3 = compress_iwa_file(y2);
  entry.content = raw3;
  entry.size = entry.content.length;
  return cfb;
}
__name(write_numbers_iwa, "write_numbers_iwa");
function fix_opts_func(defaults2) {
  return /* @__PURE__ */ __name(function fix_opts(opts) {
    for (var i2 = 0; i2 != defaults2.length; ++i2) {
      var d2 = defaults2[i2];
      if (opts[d2[0]] === void 0)
        opts[d2[0]] = d2[1];
      if (d2[2] === "n")
        opts[d2[0]] = Number(opts[d2[0]]);
    }
  }, "fix_opts");
}
__name(fix_opts_func, "fix_opts_func");
function fix_write_opts(opts) {
  fix_opts_func([
    ["cellDates", false],
    /* write date cells with type `d` */
    ["bookSST", false],
    /* Generate Shared String Table */
    ["bookType", "xlsx"],
    /* Type of workbook (xlsx/m/b) */
    ["compression", false],
    /* Use file compression */
    ["WTF", false]
    /* WTF mode (throws errors) */
  ])(opts);
}
__name(fix_write_opts, "fix_write_opts");
function write_zip(wb, opts) {
  if (opts.bookType == "ods")
    return write_ods(wb, opts);
  if (opts.bookType == "numbers")
    return write_numbers_iwa(wb, opts);
  if (opts.bookType == "xlsb")
    return write_zip_xlsxb(wb, opts);
  return write_zip_xlsx(wb, opts);
}
__name(write_zip, "write_zip");
function write_zip_xlsxb(wb, opts) {
  _shapeid = 1024;
  if (wb && !wb.SSF) {
    wb.SSF = dup(table_fmt);
  }
  if (wb && wb.SSF) {
    make_ssf();
    SSF_load_table(wb.SSF);
    opts.revssf = evert_num(wb.SSF);
    opts.revssf[wb.SSF[65535]] = 0;
    opts.ssf = wb.SSF;
  }
  opts.rels = {};
  opts.wbrels = {};
  opts.Strings = /*::((*/
  [];
  opts.Strings.Count = 0;
  opts.Strings.Unique = 0;
  if (browser_has_Map)
    opts.revStrings = /* @__PURE__ */ new Map();
  else {
    opts.revStrings = {};
    opts.revStrings.foo = [];
    delete opts.revStrings.foo;
  }
  var wbext = opts.bookType == "xlsb" ? "bin" : "xml";
  var vbafmt = VBAFMTS.indexOf(opts.bookType) > -1;
  var ct2 = new_ct();
  fix_write_opts(opts = opts || {});
  var zip = zip_new();
  var f2 = "", rId = 0;
  opts.cellXfs = [];
  get_cell_style(opts.cellXfs, {}, { revssf: { "General": 0 } });
  if (!wb.Props)
    wb.Props = {};
  f2 = "docProps/core.xml";
  zip_add_file(zip, f2, write_core_props(wb.Props, opts));
  ct2.coreprops.push(f2);
  add_rels(opts.rels, 2, f2, RELS.CORE_PROPS);
  f2 = "docProps/app.xml";
  if (wb.Props && wb.Props.SheetNames)
    ;
  else if (!wb.Workbook || !wb.Workbook.Sheets)
    wb.Props.SheetNames = wb.SheetNames;
  else {
    var _sn = [];
    for (var _i = 0; _i < wb.SheetNames.length; ++_i)
      if ((wb.Workbook.Sheets[_i] || {}).Hidden != 2)
        _sn.push(wb.SheetNames[_i]);
    wb.Props.SheetNames = _sn;
  }
  wb.Props.Worksheets = wb.Props.SheetNames.length;
  zip_add_file(zip, f2, write_ext_props(wb.Props));
  ct2.extprops.push(f2);
  add_rels(opts.rels, 3, f2, RELS.EXT_PROPS);
  if (wb.Custprops !== wb.Props && keys(wb.Custprops || {}).length > 0) {
    f2 = "docProps/custom.xml";
    zip_add_file(zip, f2, write_cust_props(wb.Custprops));
    ct2.custprops.push(f2);
    add_rels(opts.rels, 4, f2, RELS.CUST_PROPS);
  }
  for (rId = 1; rId <= wb.SheetNames.length; ++rId) {
    var wsrels = { "!id": {} };
    var ws = wb.Sheets[wb.SheetNames[rId - 1]];
    var _type = (ws || {})["!type"] || "sheet";
    switch (_type) {
      case "chart":
      default:
        f2 = "xl/worksheets/sheet" + rId + "." + wbext;
        zip_add_file(zip, f2, write_ws(rId - 1, f2, opts, wb, wsrels));
        ct2.sheets.push(f2);
        add_rels(opts.wbrels, -1, "worksheets/sheet" + rId + "." + wbext, RELS.WS[0]);
    }
    if (ws) {
      var comments = ws["!comments"];
      var need_vml = false;
      var cf = "";
      if (comments && comments.length > 0) {
        cf = "xl/comments" + rId + "." + wbext;
        zip_add_file(zip, cf, write_cmnt(comments, cf));
        ct2.comments.push(cf);
        add_rels(wsrels, -1, "../comments" + rId + "." + wbext, RELS.CMNT);
        need_vml = true;
      }
      if (ws["!legacy"]) {
        if (need_vml)
          zip_add_file(zip, "xl/drawings/vmlDrawing" + rId + ".vml", write_comments_vml(rId, ws["!comments"]));
      }
      delete ws["!comments"];
      delete ws["!legacy"];
    }
    if (wsrels["!id"].rId1)
      zip_add_file(zip, get_rels_path(f2), write_rels(wsrels));
  }
  if (opts.Strings != null && opts.Strings.length > 0) {
    f2 = "xl/sharedStrings." + wbext;
    zip_add_file(zip, f2, write_sst(opts.Strings, f2, opts));
    ct2.strs.push(f2);
    add_rels(opts.wbrels, -1, "sharedStrings." + wbext, RELS.SST);
  }
  f2 = "xl/workbook." + wbext;
  zip_add_file(zip, f2, write_wb(wb, f2));
  ct2.workbooks.push(f2);
  add_rels(opts.rels, 1, f2, RELS.WB);
  f2 = "xl/theme/theme1.xml";
  zip_add_file(zip, f2, write_theme(wb.Themes, opts));
  ct2.themes.push(f2);
  add_rels(opts.wbrels, -1, "theme/theme1.xml", RELS.THEME);
  f2 = "xl/styles." + wbext;
  zip_add_file(zip, f2, write_sty(wb, f2, opts));
  ct2.styles.push(f2);
  add_rels(opts.wbrels, -1, "styles." + wbext, RELS.STY);
  if (wb.vbaraw && vbafmt) {
    f2 = "xl/vbaProject.bin";
    zip_add_file(zip, f2, wb.vbaraw);
    ct2.vba.push(f2);
    add_rels(opts.wbrels, -1, "vbaProject.bin", RELS.VBA);
  }
  f2 = "xl/metadata." + wbext;
  zip_add_file(zip, f2, write_xlmeta(f2));
  ct2.metadata.push(f2);
  add_rels(opts.wbrels, -1, "metadata." + wbext, RELS.XLMETA);
  zip_add_file(zip, "[Content_Types].xml", write_ct(ct2, opts));
  zip_add_file(zip, "_rels/.rels", write_rels(opts.rels));
  zip_add_file(zip, "xl/_rels/workbook." + wbext + ".rels", write_rels(opts.wbrels));
  delete opts.revssf;
  delete opts.ssf;
  return zip;
}
__name(write_zip_xlsxb, "write_zip_xlsxb");
function write_zip_xlsx(wb, opts) {
  _shapeid = 1024;
  if (wb && !wb.SSF) {
    wb.SSF = dup(table_fmt);
  }
  if (wb && wb.SSF) {
    make_ssf();
    SSF_load_table(wb.SSF);
    opts.revssf = evert_num(wb.SSF);
    opts.revssf[wb.SSF[65535]] = 0;
    opts.ssf = wb.SSF;
  }
  opts.rels = {};
  opts.wbrels = {};
  opts.Strings = /*::((*/
  [];
  opts.Strings.Count = 0;
  opts.Strings.Unique = 0;
  if (browser_has_Map)
    opts.revStrings = /* @__PURE__ */ new Map();
  else {
    opts.revStrings = {};
    opts.revStrings.foo = [];
    delete opts.revStrings.foo;
  }
  var wbext = "xml";
  var vbafmt = VBAFMTS.indexOf(opts.bookType) > -1;
  var ct2 = new_ct();
  fix_write_opts(opts = opts || {});
  var zip = zip_new();
  var f2 = "", rId = 0;
  opts.cellXfs = [];
  get_cell_style(opts.cellXfs, {}, { revssf: { "General": 0 } });
  if (!wb.Props)
    wb.Props = {};
  f2 = "docProps/core.xml";
  zip_add_file(zip, f2, write_core_props(wb.Props, opts));
  ct2.coreprops.push(f2);
  add_rels(opts.rels, 2, f2, RELS.CORE_PROPS);
  f2 = "docProps/app.xml";
  if (wb.Props && wb.Props.SheetNames)
    ;
  else if (!wb.Workbook || !wb.Workbook.Sheets)
    wb.Props.SheetNames = wb.SheetNames;
  else {
    var _sn = [];
    for (var _i = 0; _i < wb.SheetNames.length; ++_i)
      if ((wb.Workbook.Sheets[_i] || {}).Hidden != 2)
        _sn.push(wb.SheetNames[_i]);
    wb.Props.SheetNames = _sn;
  }
  wb.Props.Worksheets = wb.Props.SheetNames.length;
  zip_add_file(zip, f2, write_ext_props(wb.Props));
  ct2.extprops.push(f2);
  add_rels(opts.rels, 3, f2, RELS.EXT_PROPS);
  if (wb.Custprops !== wb.Props && keys(wb.Custprops || {}).length > 0) {
    f2 = "docProps/custom.xml";
    zip_add_file(zip, f2, write_cust_props(wb.Custprops));
    ct2.custprops.push(f2);
    add_rels(opts.rels, 4, f2, RELS.CUST_PROPS);
  }
  var people = ["SheetJ5"];
  opts.tcid = 0;
  for (rId = 1; rId <= wb.SheetNames.length; ++rId) {
    var wsrels = { "!id": {} };
    var ws = wb.Sheets[wb.SheetNames[rId - 1]];
    var _type = (ws || {})["!type"] || "sheet";
    switch (_type) {
      case "chart":
      default:
        f2 = "xl/worksheets/sheet" + rId + "." + wbext;
        zip_add_file(zip, f2, write_ws_xml(rId - 1, opts, wb, wsrels));
        ct2.sheets.push(f2);
        add_rels(opts.wbrels, -1, "worksheets/sheet" + rId + "." + wbext, RELS.WS[0]);
    }
    if (ws) {
      var comments = ws["!comments"];
      var need_vml = false;
      var cf = "";
      if (comments && comments.length > 0) {
        var needtc = false;
        comments.forEach(function(carr) {
          carr[1].forEach(function(c2) {
            if (c2.T == true)
              needtc = true;
          });
        });
        if (needtc) {
          cf = "xl/threadedComments/threadedComment" + rId + "." + wbext;
          zip_add_file(zip, cf, write_tcmnt_xml(comments, people, opts));
          ct2.threadedcomments.push(cf);
          add_rels(wsrels, -1, "../threadedComments/threadedComment" + rId + "." + wbext, RELS.TCMNT);
        }
        cf = "xl/comments" + rId + "." + wbext;
        zip_add_file(zip, cf, write_comments_xml(comments));
        ct2.comments.push(cf);
        add_rels(wsrels, -1, "../comments" + rId + "." + wbext, RELS.CMNT);
        need_vml = true;
      }
      if (ws["!legacy"]) {
        if (need_vml)
          zip_add_file(zip, "xl/drawings/vmlDrawing" + rId + ".vml", write_comments_vml(rId, ws["!comments"]));
      }
      delete ws["!comments"];
      delete ws["!legacy"];
    }
    if (wsrels["!id"].rId1)
      zip_add_file(zip, get_rels_path(f2), write_rels(wsrels));
  }
  if (opts.Strings != null && opts.Strings.length > 0) {
    f2 = "xl/sharedStrings." + wbext;
    zip_add_file(zip, f2, write_sst_xml(opts.Strings, opts));
    ct2.strs.push(f2);
    add_rels(opts.wbrels, -1, "sharedStrings." + wbext, RELS.SST);
  }
  f2 = "xl/workbook." + wbext;
  zip_add_file(zip, f2, write_wb_xml(wb));
  ct2.workbooks.push(f2);
  add_rels(opts.rels, 1, f2, RELS.WB);
  f2 = "xl/theme/theme1.xml";
  zip_add_file(zip, f2, write_theme(wb.Themes, opts));
  ct2.themes.push(f2);
  add_rels(opts.wbrels, -1, "theme/theme1.xml", RELS.THEME);
  f2 = "xl/styles." + wbext;
  zip_add_file(zip, f2, write_sty_xml(wb, opts));
  ct2.styles.push(f2);
  add_rels(opts.wbrels, -1, "styles." + wbext, RELS.STY);
  if (wb.vbaraw && vbafmt) {
    f2 = "xl/vbaProject.bin";
    zip_add_file(zip, f2, wb.vbaraw);
    ct2.vba.push(f2);
    add_rels(opts.wbrels, -1, "vbaProject.bin", RELS.VBA);
  }
  f2 = "xl/metadata." + wbext;
  zip_add_file(zip, f2, write_xlmeta_xml());
  ct2.metadata.push(f2);
  add_rels(opts.wbrels, -1, "metadata." + wbext, RELS.XLMETA);
  if (people.length > 1) {
    f2 = "xl/persons/person.xml";
    zip_add_file(zip, f2, write_people_xml(people));
    ct2.people.push(f2);
    add_rels(opts.wbrels, -1, "persons/person.xml", RELS.PEOPLE);
  }
  zip_add_file(zip, "[Content_Types].xml", write_ct(ct2, opts));
  zip_add_file(zip, "_rels/.rels", write_rels(opts.rels));
  zip_add_file(zip, "xl/_rels/workbook." + wbext + ".rels", write_rels(opts.wbrels));
  delete opts.revssf;
  delete opts.ssf;
  return zip;
}
__name(write_zip_xlsx, "write_zip_xlsx");
function firstbyte(f2, o2) {
  var x2 = "";
  switch ((o2 || {}).type || "base64") {
    case "buffer":
      return [f2[0], f2[1], f2[2], f2[3], f2[4], f2[5], f2[6], f2[7]];
    case "base64":
      x2 = Base64_decode(f2.slice(0, 12));
      break;
    case "binary":
      x2 = f2;
      break;
    case "array":
      return [f2[0], f2[1], f2[2], f2[3], f2[4], f2[5], f2[6], f2[7]];
    default:
      throw new Error("Unrecognized type " + (o2 && o2.type || "undefined"));
  }
  return [x2.charCodeAt(0), x2.charCodeAt(1), x2.charCodeAt(2), x2.charCodeAt(3), x2.charCodeAt(4), x2.charCodeAt(5), x2.charCodeAt(6), x2.charCodeAt(7)];
}
__name(firstbyte, "firstbyte");
function write_cfb_ctr(cfb, o2) {
  switch (o2.type) {
    case "base64":
    case "binary":
      break;
    case "buffer":
    case "array":
      o2.type = "";
      break;
    case "file":
      return write_dl(o2.file, CFB.write(cfb, { type: has_buf ? "buffer" : "" }));
    case "string":
      throw new Error("'string' output type invalid for '" + o2.bookType + "' files");
    default:
      throw new Error("Unrecognized type " + o2.type);
  }
  return CFB.write(cfb, o2);
}
__name(write_cfb_ctr, "write_cfb_ctr");
function write_zip_type(wb, opts) {
  var o2 = dup(opts || {});
  var z2 = write_zip(wb, o2);
  return write_zip_denouement(z2, o2);
}
__name(write_zip_type, "write_zip_type");
function write_zip_denouement(z2, o2) {
  var oopts = {};
  var ftype = has_buf ? "nodebuffer" : typeof Uint8Array !== "undefined" ? "array" : "string";
  if (o2.compression)
    oopts.compression = "DEFLATE";
  if (o2.password)
    oopts.type = ftype;
  else
    switch (o2.type) {
      case "base64":
        oopts.type = "base64";
        break;
      case "binary":
        oopts.type = "string";
        break;
      case "string":
        throw new Error("'string' output type invalid for '" + o2.bookType + "' files");
      case "buffer":
      case "file":
        oopts.type = ftype;
        break;
      default:
        throw new Error("Unrecognized type " + o2.type);
    }
  var out = z2.FullPaths ? CFB.write(z2, { fileType: "zip", type: (
    /*::(*/
    { "nodebuffer": "buffer", "string": "binary" }[oopts.type] || oopts.type
  ), compression: !!o2.compression }) : z2.generate(oopts);
  if (typeof Deno !== "undefined") {
    if (typeof out == "string") {
      if (o2.type == "binary" || o2.type == "base64")
        return out;
      out = new Uint8Array(s2ab(out));
    }
  }
  if (o2.password && typeof encrypt_agile !== "undefined")
    return write_cfb_ctr(encrypt_agile(out, o2.password), o2);
  if (o2.type === "file")
    return write_dl(o2.file, out);
  return o2.type == "string" ? utf8read(
    /*::(*/
    out
    /*:: :any)*/
  ) : out;
}
__name(write_zip_denouement, "write_zip_denouement");
function write_cfb_type(wb, opts) {
  var o2 = opts || {};
  var cfb = write_xlscfb(wb, o2);
  return write_cfb_ctr(cfb, o2);
}
__name(write_cfb_type, "write_cfb_type");
function write_string_type(out, opts, bom) {
  if (!bom)
    bom = "";
  var o2 = bom + out;
  switch (opts.type) {
    case "base64":
      return Base64_encode(utf8write(o2));
    case "binary":
      return utf8write(o2);
    case "string":
      return out;
    case "file":
      return write_dl(opts.file, o2, "utf8");
    case "buffer": {
      if (has_buf)
        return Buffer_from(o2, "utf8");
      else if (typeof TextEncoder !== "undefined")
        return new TextEncoder().encode(o2);
      else
        return write_string_type(o2, { type: "binary" }).split("").map(function(c2) {
          return c2.charCodeAt(0);
        });
    }
  }
  throw new Error("Unrecognized type " + opts.type);
}
__name(write_string_type, "write_string_type");
function write_stxt_type(out, opts) {
  switch (opts.type) {
    case "base64":
      return Base64_encode(out);
    case "binary":
      return out;
    case "string":
      return out;
    case "file":
      return write_dl(opts.file, out, "binary");
    case "buffer": {
      if (has_buf)
        return Buffer_from(out, "binary");
      else
        return out.split("").map(function(c2) {
          return c2.charCodeAt(0);
        });
    }
  }
  throw new Error("Unrecognized type " + opts.type);
}
__name(write_stxt_type, "write_stxt_type");
function write_binary_type(out, opts) {
  switch (opts.type) {
    case "string":
    case "base64":
    case "binary":
      var bstr = "";
      for (var i2 = 0; i2 < out.length; ++i2)
        bstr += String.fromCharCode(out[i2]);
      return opts.type == "base64" ? Base64_encode(bstr) : opts.type == "string" ? utf8read(bstr) : bstr;
    case "file":
      return write_dl(opts.file, out);
    case "buffer":
      return out;
    default:
      throw new Error("Unrecognized type " + opts.type);
  }
}
__name(write_binary_type, "write_binary_type");
function writeSync(wb, opts) {
  reset_cp();
  check_wb(wb);
  var o2 = dup(opts || {});
  if (o2.cellStyles) {
    o2.cellNF = true;
    o2.sheetStubs = true;
  }
  if (o2.type == "array") {
    o2.type = "binary";
    var out = writeSync(wb, o2);
    o2.type = "array";
    return s2ab(out);
  }
  var idx = 0;
  if (o2.sheet) {
    if (typeof o2.sheet == "number")
      idx = o2.sheet;
    else
      idx = wb.SheetNames.indexOf(o2.sheet);
    if (!wb.SheetNames[idx])
      throw new Error("Sheet not found: " + o2.sheet + " : " + typeof o2.sheet);
  }
  switch (o2.bookType || "xlsb") {
    case "xml":
    case "xlml":
      return write_string_type(write_xlml(wb, o2), o2);
    case "slk":
    case "sylk":
      return write_string_type(SYLK.from_sheet(wb.Sheets[wb.SheetNames[idx]], o2), o2);
    case "htm":
    case "html":
      return write_string_type(sheet_to_html(wb.Sheets[wb.SheetNames[idx]], o2), o2);
    case "txt":
      return write_stxt_type(sheet_to_txt(wb.Sheets[wb.SheetNames[idx]], o2), o2);
    case "csv":
      return write_string_type(sheet_to_csv(wb.Sheets[wb.SheetNames[idx]], o2), o2, "\uFEFF");
    case "dif":
      return write_string_type(DIF.from_sheet(wb.Sheets[wb.SheetNames[idx]], o2), o2);
    case "dbf":
      return write_binary_type(DBF.from_sheet(wb.Sheets[wb.SheetNames[idx]], o2), o2);
    case "prn":
      return write_string_type(PRN.from_sheet(wb.Sheets[wb.SheetNames[idx]], o2), o2);
    case "rtf":
      return write_string_type(RTF.from_sheet(wb.Sheets[wb.SheetNames[idx]], o2), o2);
    case "eth":
      return write_string_type(ETH.from_sheet(wb.Sheets[wb.SheetNames[idx]], o2), o2);
    case "fods":
      return write_string_type(write_ods(wb, o2), o2);
    case "wk1":
      return write_binary_type(WK_.sheet_to_wk1(wb.Sheets[wb.SheetNames[idx]], o2), o2);
    case "wk3":
      return write_binary_type(WK_.book_to_wk3(wb, o2), o2);
    case "biff2":
      if (!o2.biff)
        o2.biff = 2;
    case "biff3":
      if (!o2.biff)
        o2.biff = 3;
    case "biff4":
      if (!o2.biff)
        o2.biff = 4;
      return write_binary_type(write_biff_buf(wb, o2), o2);
    case "biff5":
      if (!o2.biff)
        o2.biff = 5;
    case "biff8":
    case "xla":
    case "xls":
      if (!o2.biff)
        o2.biff = 8;
      return write_cfb_type(wb, o2);
    case "xlsx":
    case "xlsm":
    case "xlam":
    case "xlsb":
    case "numbers":
    case "ods":
      return write_zip_type(wb, o2);
    default:
      throw new Error("Unrecognized bookType |" + o2.bookType + "|");
  }
}
__name(writeSync, "writeSync");
function resolve_book_type(o2) {
  if (o2.bookType)
    return;
  var _BT = {
    "xls": "biff8",
    "htm": "html",
    "slk": "sylk",
    "socialcalc": "eth",
    "Sh33tJS": "WTF"
  };
  var ext = o2.file.slice(o2.file.lastIndexOf(".")).toLowerCase();
  if (ext.match(/^\.[a-z]+$/))
    o2.bookType = ext.slice(1);
  o2.bookType = _BT[o2.bookType] || o2.bookType;
}
__name(resolve_book_type, "resolve_book_type");
function writeFileSync(wb, filename, opts) {
  var o2 = opts || {};
  o2.type = "file";
  o2.file = filename;
  resolve_book_type(o2);
  return writeSync(wb, o2);
}
__name(writeFileSync, "writeFileSync");
function make_json_row(sheet, r, R2, cols, header, hdr, dense, o2) {
  var rr = encode_row(R2);
  var defval = o2.defval, raw = o2.raw || !Object.prototype.hasOwnProperty.call(o2, "raw");
  var isempty = true;
  var row = header === 1 ? [] : {};
  if (header !== 1) {
    if (Object.defineProperty)
      try {
        Object.defineProperty(row, "__rowNum__", { value: R2, enumerable: false });
      } catch (e) {
        row.__rowNum__ = R2;
      }
    else
      row.__rowNum__ = R2;
  }
  if (!dense || sheet[R2])
    for (var C2 = r.s.c; C2 <= r.e.c; ++C2) {
      var val = dense ? sheet[R2][C2] : sheet[cols[C2] + rr];
      if (val === void 0 || val.t === void 0) {
        if (defval === void 0)
          continue;
        if (hdr[C2] != null) {
          row[hdr[C2]] = defval;
        }
        continue;
      }
      var v2 = val.v;
      switch (val.t) {
        case "z":
          if (v2 == null)
            break;
          continue;
        case "e":
          v2 = v2 == 0 ? null : void 0;
          break;
        case "s":
        case "d":
        case "b":
        case "n":
          break;
        default:
          throw new Error("unrecognized type " + val.t);
      }
      if (hdr[C2] != null) {
        if (v2 == null) {
          if (val.t == "e" && v2 === null)
            row[hdr[C2]] = null;
          else if (defval !== void 0)
            row[hdr[C2]] = defval;
          else if (raw && v2 === null)
            row[hdr[C2]] = null;
          else
            continue;
        } else {
          row[hdr[C2]] = raw && (val.t !== "n" || val.t === "n" && o2.rawNumbers !== false) ? v2 : format_cell(val, v2, o2);
        }
        if (v2 != null)
          isempty = false;
      }
    }
  return { row, isempty };
}
__name(make_json_row, "make_json_row");
function sheet_to_json(sheet, opts) {
  if (sheet == null || sheet["!ref"] == null)
    return [];
  var val = { t: "n", v: 0 }, header = 0, offset = 1, hdr = [], v2 = 0, vv = "";
  var r = { s: { r: 0, c: 0 }, e: { r: 0, c: 0 } };
  var o2 = opts || {};
  var range = o2.range != null ? o2.range : sheet["!ref"];
  if (o2.header === 1)
    header = 1;
  else if (o2.header === "A")
    header = 2;
  else if (Array.isArray(o2.header))
    header = 3;
  else if (o2.header == null)
    header = 0;
  switch (typeof range) {
    case "string":
      r = safe_decode_range(range);
      break;
    case "number":
      r = safe_decode_range(sheet["!ref"]);
      r.s.r = range;
      break;
    default:
      r = range;
  }
  if (header > 0)
    offset = 0;
  var rr = encode_row(r.s.r);
  var cols = [];
  var out = [];
  var outi = 0, counter = 0;
  var dense = Array.isArray(sheet);
  var R2 = r.s.r, C2 = 0;
  var header_cnt = {};
  if (dense && !sheet[R2])
    sheet[R2] = [];
  var colinfo = o2.skipHidden && sheet["!cols"] || [];
  var rowinfo = o2.skipHidden && sheet["!rows"] || [];
  for (C2 = r.s.c; C2 <= r.e.c; ++C2) {
    if ((colinfo[C2] || {}).hidden)
      continue;
    cols[C2] = encode_col(C2);
    val = dense ? sheet[R2][C2] : sheet[cols[C2] + rr];
    switch (header) {
      case 1:
        hdr[C2] = C2 - r.s.c;
        break;
      case 2:
        hdr[C2] = cols[C2];
        break;
      case 3:
        hdr[C2] = o2.header[C2 - r.s.c];
        break;
      default:
        if (val == null)
          val = { w: "__EMPTY", t: "s" };
        vv = v2 = format_cell(val, null, o2);
        counter = header_cnt[v2] || 0;
        if (!counter)
          header_cnt[v2] = 1;
        else {
          do {
            vv = v2 + "_" + counter++;
          } while (header_cnt[vv]);
          header_cnt[v2] = counter;
          header_cnt[vv] = 1;
        }
        hdr[C2] = vv;
    }
  }
  for (R2 = r.s.r + offset; R2 <= r.e.r; ++R2) {
    if ((rowinfo[R2] || {}).hidden)
      continue;
    var row = make_json_row(sheet, r, R2, cols, header, hdr, dense, o2);
    if (row.isempty === false || (header === 1 ? o2.blankrows !== false : !!o2.blankrows))
      out[outi++] = row.row;
  }
  out.length = outi;
  return out;
}
__name(sheet_to_json, "sheet_to_json");
var qreg = /"/g;
function make_csv_row(sheet, r, R2, cols, fs, rs, FS, o2) {
  var isempty = true;
  var row = [], txt = "", rr = encode_row(R2);
  for (var C2 = r.s.c; C2 <= r.e.c; ++C2) {
    if (!cols[C2])
      continue;
    var val = o2.dense ? (sheet[R2] || [])[C2] : sheet[cols[C2] + rr];
    if (val == null)
      txt = "";
    else if (val.v != null) {
      isempty = false;
      txt = "" + (o2.rawNumbers && val.t == "n" ? val.v : format_cell(val, null, o2));
      for (var i2 = 0, cc = 0; i2 !== txt.length; ++i2)
        if ((cc = txt.charCodeAt(i2)) === fs || cc === rs || cc === 34 || o2.forceQuotes) {
          txt = '"' + txt.replace(qreg, '""') + '"';
          break;
        }
      if (txt == "ID")
        txt = '"ID"';
    } else if (val.f != null && !val.F) {
      isempty = false;
      txt = "=" + val.f;
      if (txt.indexOf(",") >= 0)
        txt = '"' + txt.replace(qreg, '""') + '"';
    } else
      txt = "";
    row.push(txt);
  }
  if (o2.blankrows === false && isempty)
    return null;
  return row.join(FS);
}
__name(make_csv_row, "make_csv_row");
function sheet_to_csv(sheet, opts) {
  var out = [];
  var o2 = opts == null ? {} : opts;
  if (sheet == null || sheet["!ref"] == null)
    return "";
  var r = safe_decode_range(sheet["!ref"]);
  var FS = o2.FS !== void 0 ? o2.FS : ",", fs = FS.charCodeAt(0);
  var RS = o2.RS !== void 0 ? o2.RS : "\n", rs = RS.charCodeAt(0);
  var endregex = new RegExp((FS == "|" ? "\\|" : FS) + "+$");
  var row = "", cols = [];
  o2.dense = Array.isArray(sheet);
  var colinfo = o2.skipHidden && sheet["!cols"] || [];
  var rowinfo = o2.skipHidden && sheet["!rows"] || [];
  for (var C2 = r.s.c; C2 <= r.e.c; ++C2)
    if (!(colinfo[C2] || {}).hidden)
      cols[C2] = encode_col(C2);
  var w2 = 0;
  for (var R2 = r.s.r; R2 <= r.e.r; ++R2) {
    if ((rowinfo[R2] || {}).hidden)
      continue;
    row = make_csv_row(sheet, r, R2, cols, fs, rs, FS, o2);
    if (row == null) {
      continue;
    }
    if (o2.strip)
      row = row.replace(endregex, "");
    if (row || o2.blankrows !== false)
      out.push((w2++ ? RS : "") + row);
  }
  delete o2.dense;
  return out.join("");
}
__name(sheet_to_csv, "sheet_to_csv");
function sheet_to_txt(sheet, opts) {
  if (!opts)
    opts = {};
  opts.FS = "	";
  opts.RS = "\n";
  var s2 = sheet_to_csv(sheet, opts);
  return s2;
}
__name(sheet_to_txt, "sheet_to_txt");
function sheet_to_formulae(sheet) {
  var y2 = "", x2, val = "";
  if (sheet == null || sheet["!ref"] == null)
    return [];
  var r = safe_decode_range(sheet["!ref"]), rr = "", cols = [], C2;
  var cmds = [];
  var dense = Array.isArray(sheet);
  for (C2 = r.s.c; C2 <= r.e.c; ++C2)
    cols[C2] = encode_col(C2);
  for (var R2 = r.s.r; R2 <= r.e.r; ++R2) {
    rr = encode_row(R2);
    for (C2 = r.s.c; C2 <= r.e.c; ++C2) {
      y2 = cols[C2] + rr;
      x2 = dense ? (sheet[R2] || [])[C2] : sheet[y2];
      val = "";
      if (x2 === void 0)
        continue;
      else if (x2.F != null) {
        y2 = x2.F;
        if (!x2.f)
          continue;
        val = x2.f;
        if (y2.indexOf(":") == -1)
          y2 = y2 + ":" + y2;
      }
      if (x2.f != null)
        val = x2.f;
      else if (x2.t == "z")
        continue;
      else if (x2.t == "n" && x2.v != null)
        val = "" + x2.v;
      else if (x2.t == "b")
        val = x2.v ? "TRUE" : "FALSE";
      else if (x2.w !== void 0)
        val = "'" + x2.w;
      else if (x2.v === void 0)
        continue;
      else if (x2.t == "s")
        val = "'" + x2.v;
      else
        val = "" + x2.v;
      cmds[cmds.length] = y2 + "=" + val;
    }
  }
  return cmds;
}
__name(sheet_to_formulae, "sheet_to_formulae");
function sheet_add_json(_ws, js, opts) {
  var o2 = opts || {};
  var offset = +!o2.skipHeader;
  var ws = _ws || {};
  var _R = 0, _C = 0;
  if (ws && o2.origin != null) {
    if (typeof o2.origin == "number")
      _R = o2.origin;
    else {
      var _origin = typeof o2.origin == "string" ? decode_cell(o2.origin) : o2.origin;
      _R = _origin.r;
      _C = _origin.c;
    }
  }
  var cell;
  var range = { s: { c: 0, r: 0 }, e: { c: _C, r: _R + js.length - 1 + offset } };
  if (ws["!ref"]) {
    var _range = safe_decode_range(ws["!ref"]);
    range.e.c = Math.max(range.e.c, _range.e.c);
    range.e.r = Math.max(range.e.r, _range.e.r);
    if (_R == -1) {
      _R = _range.e.r + 1;
      range.e.r = _R + js.length - 1 + offset;
    }
  } else {
    if (_R == -1) {
      _R = 0;
      range.e.r = js.length - 1 + offset;
    }
  }
  var hdr = o2.header || [], C2 = 0;
  js.forEach(function(JS, R2) {
    keys(JS).forEach(function(k2) {
      if ((C2 = hdr.indexOf(k2)) == -1)
        hdr[C2 = hdr.length] = k2;
      var v2 = JS[k2];
      var t2 = "z";
      var z2 = "";
      var ref = encode_cell({ c: _C + C2, r: _R + R2 + offset });
      cell = ws_get_cell_stub(ws, ref);
      if (v2 && typeof v2 === "object" && !(v2 instanceof Date)) {
        ws[ref] = v2;
      } else {
        if (typeof v2 == "number")
          t2 = "n";
        else if (typeof v2 == "boolean")
          t2 = "b";
        else if (typeof v2 == "string")
          t2 = "s";
        else if (v2 instanceof Date) {
          t2 = "d";
          if (!o2.cellDates) {
            t2 = "n";
            v2 = datenum(v2);
          }
          z2 = o2.dateNF || table_fmt[14];
        } else if (v2 === null && o2.nullError) {
          t2 = "e";
          v2 = 0;
        }
        if (!cell)
          ws[ref] = cell = { t: t2, v: v2 };
        else {
          cell.t = t2;
          cell.v = v2;
          delete cell.w;
          delete cell.R;
          if (z2)
            cell.z = z2;
        }
        if (z2)
          cell.z = z2;
      }
    });
  });
  range.e.c = Math.max(range.e.c, _C + hdr.length - 1);
  var __R = encode_row(_R);
  if (offset)
    for (C2 = 0; C2 < hdr.length; ++C2)
      ws[encode_col(C2 + _C) + __R] = { t: "s", v: hdr[C2] };
  ws["!ref"] = encode_range(range);
  return ws;
}
__name(sheet_add_json, "sheet_add_json");
function json_to_sheet(js, opts) {
  return sheet_add_json(null, js, opts);
}
__name(json_to_sheet, "json_to_sheet");
function ws_get_cell_stub(ws, R2, C2) {
  if (typeof R2 == "string") {
    if (Array.isArray(ws)) {
      var RC = decode_cell(R2);
      if (!ws[RC.r])
        ws[RC.r] = [];
      return ws[RC.r][RC.c] || (ws[RC.r][RC.c] = { t: "z" });
    }
    return ws[R2] || (ws[R2] = { t: "z" });
  }
  if (typeof R2 != "number")
    return ws_get_cell_stub(ws, encode_cell(R2));
  return ws_get_cell_stub(ws, encode_cell({ r: R2, c: C2 || 0 }));
}
__name(ws_get_cell_stub, "ws_get_cell_stub");
function wb_sheet_idx(wb, sh) {
  if (typeof sh == "number") {
    if (sh >= 0 && wb.SheetNames.length > sh)
      return sh;
    throw new Error("Cannot find sheet # " + sh);
  } else if (typeof sh == "string") {
    var idx = wb.SheetNames.indexOf(sh);
    if (idx > -1)
      return idx;
    throw new Error("Cannot find sheet name |" + sh + "|");
  } else
    throw new Error("Cannot find sheet |" + sh + "|");
}
__name(wb_sheet_idx, "wb_sheet_idx");
function book_new() {
  return { SheetNames: [], Sheets: {} };
}
__name(book_new, "book_new");
function book_append_sheet(wb, ws, name, roll) {
  var i2 = 1;
  if (!name) {
    for (; i2 <= 65535; ++i2, name = void 0)
      if (wb.SheetNames.indexOf(name = "Sheet" + i2) == -1)
        break;
  }
  if (!name || wb.SheetNames.length >= 65535)
    throw new Error("Too many worksheets");
  if (roll && wb.SheetNames.indexOf(name) >= 0) {
    var m2 = name.match(/(^.*?)(\d+)$/);
    i2 = m2 && +m2[2] || 0;
    var root = m2 && m2[1] || name;
    for (++i2; i2 <= 65535; ++i2)
      if (wb.SheetNames.indexOf(name = root + i2) == -1)
        break;
  }
  check_ws_name(name);
  if (wb.SheetNames.indexOf(name) >= 0)
    throw new Error("Worksheet with name |" + name + "| already exists!");
  wb.SheetNames.push(name);
  wb.Sheets[name] = ws;
  return name;
}
__name(book_append_sheet, "book_append_sheet");
function book_set_sheet_visibility(wb, sh, vis) {
  if (!wb.Workbook)
    wb.Workbook = {};
  if (!wb.Workbook.Sheets)
    wb.Workbook.Sheets = [];
  var idx = wb_sheet_idx(wb, sh);
  if (!wb.Workbook.Sheets[idx])
    wb.Workbook.Sheets[idx] = {};
  switch (vis) {
    case 0:
    case 1:
    case 2:
      break;
    default:
      throw new Error("Bad sheet visibility setting " + vis);
  }
  wb.Workbook.Sheets[idx].Hidden = vis;
}
__name(book_set_sheet_visibility, "book_set_sheet_visibility");
function cell_set_number_format(cell, fmt) {
  cell.z = fmt;
  return cell;
}
__name(cell_set_number_format, "cell_set_number_format");
function cell_set_hyperlink(cell, target, tooltip) {
  if (!target) {
    delete cell.l;
  } else {
    cell.l = { Target: target };
    if (tooltip)
      cell.l.Tooltip = tooltip;
  }
  return cell;
}
__name(cell_set_hyperlink, "cell_set_hyperlink");
function cell_set_internal_link(cell, range, tooltip) {
  return cell_set_hyperlink(cell, "#" + range, tooltip);
}
__name(cell_set_internal_link, "cell_set_internal_link");
function cell_add_comment(cell, text, author) {
  if (!cell.c)
    cell.c = [];
  cell.c.push({ t: text, a: author || "SheetJS" });
}
__name(cell_add_comment, "cell_add_comment");
function sheet_set_array_formula(ws, range, formula, dynamic) {
  var rng = typeof range != "string" ? range : safe_decode_range(range);
  var rngstr = typeof range == "string" ? range : encode_range(range);
  for (var R2 = rng.s.r; R2 <= rng.e.r; ++R2)
    for (var C2 = rng.s.c; C2 <= rng.e.c; ++C2) {
      var cell = ws_get_cell_stub(ws, R2, C2);
      cell.t = "n";
      cell.F = rngstr;
      delete cell.v;
      if (R2 == rng.s.r && C2 == rng.s.c) {
        cell.f = formula;
        if (dynamic)
          cell.D = true;
      }
    }
  return ws;
}
__name(sheet_set_array_formula, "sheet_set_array_formula");
var utils = {
  encode_col,
  encode_row,
  encode_cell,
  encode_range,
  decode_col,
  decode_row,
  split_cell,
  decode_cell,
  decode_range,
  format_cell,
  sheet_add_aoa,
  sheet_add_json,
  sheet_add_dom,
  aoa_to_sheet,
  json_to_sheet,
  table_to_sheet: parse_dom_table,
  table_to_book,
  sheet_to_csv,
  sheet_to_txt,
  sheet_to_json,
  sheet_to_html,
  sheet_to_formulae,
  sheet_to_row_object_array: sheet_to_json,
  sheet_get_cell: ws_get_cell_stub,
  book_new,
  book_append_sheet,
  book_set_sheet_visibility,
  cell_set_number_format,
  cell_set_hyperlink,
  cell_set_internal_link,
  cell_add_comment,
  sheet_set_array_formula,
  consts: {
    SHEET_VISIBLE: 0,
    SHEET_HIDDEN: 1,
    SHEET_VERY_HIDDEN: 2
  }
};
const scriptRel = "modulepreload";
const assetsURL = /* @__PURE__ */ __name(function(dep) {
  return "/" + dep;
}, "assetsURL");
const seen = {};
const __vitePreload = /* @__PURE__ */ __name(function preload(baseModule, deps, importerUrl) {
  if (!deps || deps.length === 0) {
    return baseModule();
  }
  const links = document.getElementsByTagName("link");
  return Promise.all(deps.map((dep) => {
    dep = assetsURL(dep);
    if (dep in seen)
      return;
    seen[dep] = true;
    const isCss = dep.endsWith(".css");
    const cssSelector = isCss ? '[rel="stylesheet"]' : "";
    const isBaseRelative = !!importerUrl;
    if (isBaseRelative) {
      for (let i2 = links.length - 1; i2 >= 0; i2--) {
        const link2 = links[i2];
        if (link2.href === dep && (!isCss || link2.rel === "stylesheet")) {
          return;
        }
      }
    } else if (document.querySelector(`link[href="${dep}"]${cssSelector}`)) {
      return;
    }
    const link = document.createElement("link");
    link.rel = isCss ? "stylesheet" : scriptRel;
    if (!isCss) {
      link.as = "script";
      link.crossOrigin = "";
    }
    link.href = dep;
    document.head.appendChild(link);
    if (isCss) {
      return new Promise((res, rej) => {
        link.addEventListener("load", res);
        link.addEventListener("error", () => rej(new Error(`Unable to preload CSS for ${dep}`)));
      });
    }
  })).then(() => baseModule()).catch((err2) => {
    const e = new Event("vite:preloadError", { cancelable: true });
    e.payload = err2;
    window.dispatchEvent(e);
    if (!e.defaultPrevented) {
      throw err2;
    }
  });
}, "preload");
function _typeof(o2) {
  "@babel/helpers - typeof";
  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o3) {
    return typeof o3;
  } : function(o3) {
    return o3 && "function" == typeof Symbol && o3.constructor === Symbol && o3 !== Symbol.prototype ? "symbol" : typeof o3;
  }, _typeof(o2);
}
__name(_typeof, "_typeof");
var u8 = Uint8Array, u16 = Uint16Array, i32 = Int32Array;
var fleb = new u8([
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  1,
  1,
  1,
  2,
  2,
  2,
  2,
  3,
  3,
  3,
  3,
  4,
  4,
  4,
  4,
  5,
  5,
  5,
  5,
  0,
  /* unused */
  0,
  0,
  /* impossible */
  0
]);
var fdeb = new u8([
  0,
  0,
  0,
  0,
  1,
  1,
  2,
  2,
  3,
  3,
  4,
  4,
  5,
  5,
  6,
  6,
  7,
  7,
  8,
  8,
  9,
  9,
  10,
  10,
  11,
  11,
  12,
  12,
  13,
  13,
  /* unused */
  0,
  0
]);
var clim = new u8([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
var freb = /* @__PURE__ */ __name(function(eb, start) {
  var b2 = new u16(31);
  for (var i2 = 0; i2 < 31; ++i2) {
    b2[i2] = start += 1 << eb[i2 - 1];
  }
  var r = new i32(b2[30]);
  for (var i2 = 1; i2 < 30; ++i2) {
    for (var j2 = b2[i2]; j2 < b2[i2 + 1]; ++j2) {
      r[j2] = j2 - b2[i2] << 5 | i2;
    }
  }
  return { b: b2, r };
}, "freb");
var _a = freb(fleb, 2), fl = _a.b, revfl = _a.r;
fl[28] = 258, revfl[258] = 28;
var _b = freb(fdeb, 0), fd = _b.b, revfd = _b.r;
var rev = new u16(32768);
for (var i$1 = 0; i$1 < 32768; ++i$1) {
  var x$1 = (i$1 & 43690) >> 1 | (i$1 & 21845) << 1;
  x$1 = (x$1 & 52428) >> 2 | (x$1 & 13107) << 2;
  x$1 = (x$1 & 61680) >> 4 | (x$1 & 3855) << 4;
  rev[i$1] = ((x$1 & 65280) >> 8 | (x$1 & 255) << 8) >> 1;
}
var hMap = /* @__PURE__ */ __name(function(cd, mb, r) {
  var s2 = cd.length;
  var i2 = 0;
  var l2 = new u16(mb);
  for (; i2 < s2; ++i2) {
    if (cd[i2])
      ++l2[cd[i2] - 1];
  }
  var le2 = new u16(mb);
  for (i2 = 1; i2 < mb; ++i2) {
    le2[i2] = le2[i2 - 1] + l2[i2 - 1] << 1;
  }
  var co;
  if (r) {
    co = new u16(1 << mb);
    var rvb = 15 - mb;
    for (i2 = 0; i2 < s2; ++i2) {
      if (cd[i2]) {
        var sv = i2 << 4 | cd[i2];
        var r_1 = mb - cd[i2];
        var v2 = le2[cd[i2] - 1]++ << r_1;
        for (var m2 = v2 | (1 << r_1) - 1; v2 <= m2; ++v2) {
          co[rev[v2] >> rvb] = sv;
        }
      }
    }
  } else {
    co = new u16(s2);
    for (i2 = 0; i2 < s2; ++i2) {
      if (cd[i2]) {
        co[i2] = rev[le2[cd[i2] - 1]++] >> 15 - cd[i2];
      }
    }
  }
  return co;
}, "hMap");
var flt = new u8(288);
for (var i$1 = 0; i$1 < 144; ++i$1)
  flt[i$1] = 8;
for (var i$1 = 144; i$1 < 256; ++i$1)
  flt[i$1] = 9;
for (var i$1 = 256; i$1 < 280; ++i$1)
  flt[i$1] = 7;
for (var i$1 = 280; i$1 < 288; ++i$1)
  flt[i$1] = 8;
var fdt = new u8(32);
for (var i$1 = 0; i$1 < 32; ++i$1)
  fdt[i$1] = 5;
var flm = /* @__PURE__ */ hMap(flt, 9, 0), flrm = /* @__PURE__ */ hMap(flt, 9, 1);
var fdm = /* @__PURE__ */ hMap(fdt, 5, 0), fdrm = /* @__PURE__ */ hMap(fdt, 5, 1);
var max = /* @__PURE__ */ __name(function(a2) {
  var m2 = a2[0];
  for (var i2 = 1; i2 < a2.length; ++i2) {
    if (a2[i2] > m2)
      m2 = a2[i2];
  }
  return m2;
}, "max");
var bits = /* @__PURE__ */ __name(function(d2, p2, m2) {
  var o2 = p2 / 8 | 0;
  return (d2[o2] | d2[o2 + 1] << 8) >> (p2 & 7) & m2;
}, "bits");
var bits16 = /* @__PURE__ */ __name(function(d2, p2) {
  var o2 = p2 / 8 | 0;
  return (d2[o2] | d2[o2 + 1] << 8 | d2[o2 + 2] << 16) >> (p2 & 7);
}, "bits16");
var shft = /* @__PURE__ */ __name(function(p2) {
  return (p2 + 7) / 8 | 0;
}, "shft");
var slc = /* @__PURE__ */ __name(function(v2, s2, e) {
  if (s2 == null || s2 < 0)
    s2 = 0;
  if (e == null || e > v2.length)
    e = v2.length;
  return new u8(v2.subarray(s2, e));
}, "slc");
var ec = [
  "unexpected EOF",
  "invalid block type",
  "invalid length/literal",
  "invalid distance",
  "stream finished",
  "no stream handler",
  ,
  "no callback",
  "invalid UTF-8 data",
  "extra field too long",
  "date not in range 1980-2099",
  "filename too long",
  "stream finishing",
  "invalid zip data"
  // determined by unknown compression method
];
var err = /* @__PURE__ */ __name(function(ind, msg, nt2) {
  var e = new Error(msg || ec[ind]);
  e.code = ind;
  if (Error.captureStackTrace)
    Error.captureStackTrace(e, err);
  if (!nt2)
    throw e;
  return e;
}, "err");
var inflt = /* @__PURE__ */ __name(function(dat, st2, buf, dict) {
  var sl = dat.length, dl = dict ? dict.length : 0;
  if (!sl || st2.f && !st2.l)
    return buf || new u8(0);
  var noBuf = !buf;
  var resize = noBuf || st2.i != 2;
  var noSt = st2.i;
  if (noBuf)
    buf = new u8(sl * 3);
  var cbuf = /* @__PURE__ */ __name(function(l3) {
    var bl = buf.length;
    if (l3 > bl) {
      var nbuf = new u8(Math.max(bl * 2, l3));
      nbuf.set(buf);
      buf = nbuf;
    }
  }, "cbuf");
  var final = st2.f || 0, pos = st2.p || 0, bt2 = st2.b || 0, lm = st2.l, dm = st2.d, lbt = st2.m, dbt = st2.n;
  var tbts = sl * 8;
  do {
    if (!lm) {
      final = bits(dat, pos, 1);
      var type = bits(dat, pos + 1, 3);
      pos += 3;
      if (!type) {
        var s2 = shft(pos) + 4, l2 = dat[s2 - 4] | dat[s2 - 3] << 8, t2 = s2 + l2;
        if (t2 > sl) {
          if (noSt)
            err(0);
          break;
        }
        if (resize)
          cbuf(bt2 + l2);
        buf.set(dat.subarray(s2, t2), bt2);
        st2.b = bt2 += l2, st2.p = pos = t2 * 8, st2.f = final;
        continue;
      } else if (type == 1)
        lm = flrm, dm = fdrm, lbt = 9, dbt = 5;
      else if (type == 2) {
        var hLit = bits(dat, pos, 31) + 257, hcLen = bits(dat, pos + 10, 15) + 4;
        var tl = hLit + bits(dat, pos + 5, 31) + 1;
        pos += 14;
        var ldt = new u8(tl);
        var clt = new u8(19);
        for (var i2 = 0; i2 < hcLen; ++i2) {
          clt[clim[i2]] = bits(dat, pos + i2 * 3, 7);
        }
        pos += hcLen * 3;
        var clb = max(clt), clbmsk = (1 << clb) - 1;
        var clm = hMap(clt, clb, 1);
        for (var i2 = 0; i2 < tl; ) {
          var r = clm[bits(dat, pos, clbmsk)];
          pos += r & 15;
          var s2 = r >> 4;
          if (s2 < 16) {
            ldt[i2++] = s2;
          } else {
            var c2 = 0, n2 = 0;
            if (s2 == 16)
              n2 = 3 + bits(dat, pos, 3), pos += 2, c2 = ldt[i2 - 1];
            else if (s2 == 17)
              n2 = 3 + bits(dat, pos, 7), pos += 3;
            else if (s2 == 18)
              n2 = 11 + bits(dat, pos, 127), pos += 7;
            while (n2--)
              ldt[i2++] = c2;
          }
        }
        var lt2 = ldt.subarray(0, hLit), dt2 = ldt.subarray(hLit);
        lbt = max(lt2);
        dbt = max(dt2);
        lm = hMap(lt2, lbt, 1);
        dm = hMap(dt2, dbt, 1);
      } else
        err(1);
      if (pos > tbts) {
        if (noSt)
          err(0);
        break;
      }
    }
    if (resize)
      cbuf(bt2 + 131072);
    var lms = (1 << lbt) - 1, dms = (1 << dbt) - 1;
    var lpos = pos;
    for (; ; lpos = pos) {
      var c2 = lm[bits16(dat, pos) & lms], sym = c2 >> 4;
      pos += c2 & 15;
      if (pos > tbts) {
        if (noSt)
          err(0);
        break;
      }
      if (!c2)
        err(2);
      if (sym < 256)
        buf[bt2++] = sym;
      else if (sym == 256) {
        lpos = pos, lm = null;
        break;
      } else {
        var add = sym - 254;
        if (sym > 264) {
          var i2 = sym - 257, b2 = fleb[i2];
          add = bits(dat, pos, (1 << b2) - 1) + fl[i2];
          pos += b2;
        }
        var d2 = dm[bits16(dat, pos) & dms], dsym = d2 >> 4;
        if (!d2)
          err(3);
        pos += d2 & 15;
        var dt2 = fd[dsym];
        if (dsym > 3) {
          var b2 = fdeb[dsym];
          dt2 += bits16(dat, pos) & (1 << b2) - 1, pos += b2;
        }
        if (pos > tbts) {
          if (noSt)
            err(0);
          break;
        }
        if (resize)
          cbuf(bt2 + 131072);
        var end = bt2 + add;
        if (bt2 < dt2) {
          var shift = dl - dt2, dend = Math.min(dt2, end);
          if (shift + bt2 < 0)
            err(3);
          for (; bt2 < dend; ++bt2)
            buf[bt2] = dict[shift + bt2];
        }
        for (; bt2 < end; ++bt2)
          buf[bt2] = buf[bt2 - dt2];
      }
    }
    st2.l = lm, st2.p = lpos, st2.b = bt2, st2.f = final;
    if (lm)
      final = 1, st2.m = lbt, st2.d = dm, st2.n = dbt;
  } while (!final);
  return bt2 != buf.length && noBuf ? slc(buf, 0, bt2) : buf.subarray(0, bt2);
}, "inflt");
var wbits = /* @__PURE__ */ __name(function(d2, p2, v2) {
  v2 <<= p2 & 7;
  var o2 = p2 / 8 | 0;
  d2[o2] |= v2;
  d2[o2 + 1] |= v2 >> 8;
}, "wbits");
var wbits16 = /* @__PURE__ */ __name(function(d2, p2, v2) {
  v2 <<= p2 & 7;
  var o2 = p2 / 8 | 0;
  d2[o2] |= v2;
  d2[o2 + 1] |= v2 >> 8;
  d2[o2 + 2] |= v2 >> 16;
}, "wbits16");
var hTree = /* @__PURE__ */ __name(function(d2, mb) {
  var t2 = [];
  for (var i2 = 0; i2 < d2.length; ++i2) {
    if (d2[i2])
      t2.push({ s: i2, f: d2[i2] });
  }
  var s2 = t2.length;
  var t22 = t2.slice();
  if (!s2)
    return { t: et$1, l: 0 };
  if (s2 == 1) {
    var v2 = new u8(t2[0].s + 1);
    v2[t2[0].s] = 1;
    return { t: v2, l: 1 };
  }
  t2.sort(function(a2, b2) {
    return a2.f - b2.f;
  });
  t2.push({ s: -1, f: 25001 });
  var l2 = t2[0], r = t2[1], i0 = 0, i1 = 1, i22 = 2;
  t2[0] = { s: -1, f: l2.f + r.f, l: l2, r };
  while (i1 != s2 - 1) {
    l2 = t2[t2[i0].f < t2[i22].f ? i0++ : i22++];
    r = t2[i0 != i1 && t2[i0].f < t2[i22].f ? i0++ : i22++];
    t2[i1++] = { s: -1, f: l2.f + r.f, l: l2, r };
  }
  var maxSym = t22[0].s;
  for (var i2 = 1; i2 < s2; ++i2) {
    if (t22[i2].s > maxSym)
      maxSym = t22[i2].s;
  }
  var tr = new u16(maxSym + 1);
  var mbt = ln(t2[i1 - 1], tr, 0);
  if (mbt > mb) {
    var i2 = 0, dt2 = 0;
    var lft = mbt - mb, cst = 1 << lft;
    t22.sort(function(a2, b2) {
      return tr[b2.s] - tr[a2.s] || a2.f - b2.f;
    });
    for (; i2 < s2; ++i2) {
      var i2_1 = t22[i2].s;
      if (tr[i2_1] > mb) {
        dt2 += cst - (1 << mbt - tr[i2_1]);
        tr[i2_1] = mb;
      } else
        break;
    }
    dt2 >>= lft;
    while (dt2 > 0) {
      var i2_2 = t22[i2].s;
      if (tr[i2_2] < mb)
        dt2 -= 1 << mb - tr[i2_2]++ - 1;
      else
        ++i2;
    }
    for (; i2 >= 0 && dt2; --i2) {
      var i2_3 = t22[i2].s;
      if (tr[i2_3] == mb) {
        --tr[i2_3];
        ++dt2;
      }
    }
    mbt = mb;
  }
  return { t: new u8(tr), l: mbt };
}, "hTree");
var ln = /* @__PURE__ */ __name(function(n2, l2, d2) {
  return n2.s == -1 ? Math.max(ln(n2.l, l2, d2 + 1), ln(n2.r, l2, d2 + 1)) : l2[n2.s] = d2;
}, "ln");
var lc = /* @__PURE__ */ __name(function(c2) {
  var s2 = c2.length;
  while (s2 && !c2[--s2])
    ;
  var cl = new u16(++s2);
  var cli = 0, cln = c2[0], cls = 1;
  var w2 = /* @__PURE__ */ __name(function(v2) {
    cl[cli++] = v2;
  }, "w");
  for (var i2 = 1; i2 <= s2; ++i2) {
    if (c2[i2] == cln && i2 != s2)
      ++cls;
    else {
      if (!cln && cls > 2) {
        for (; cls > 138; cls -= 138)
          w2(32754);
        if (cls > 2) {
          w2(cls > 10 ? cls - 11 << 5 | 28690 : cls - 3 << 5 | 12305);
          cls = 0;
        }
      } else if (cls > 3) {
        w2(cln), --cls;
        for (; cls > 6; cls -= 6)
          w2(8304);
        if (cls > 2)
          w2(cls - 3 << 5 | 8208), cls = 0;
      }
      while (cls--)
        w2(cln);
      cls = 1;
      cln = c2[i2];
    }
  }
  return { c: cl.subarray(0, cli), n: s2 };
}, "lc");
var clen = /* @__PURE__ */ __name(function(cf, cl) {
  var l2 = 0;
  for (var i2 = 0; i2 < cl.length; ++i2)
    l2 += cf[i2] * cl[i2];
  return l2;
}, "clen");
var wfblk = /* @__PURE__ */ __name(function(out, pos, dat) {
  var s2 = dat.length;
  var o2 = shft(pos + 2);
  out[o2] = s2 & 255;
  out[o2 + 1] = s2 >> 8;
  out[o2 + 2] = out[o2] ^ 255;
  out[o2 + 3] = out[o2 + 1] ^ 255;
  for (var i2 = 0; i2 < s2; ++i2)
    out[o2 + i2 + 4] = dat[i2];
  return (o2 + 4 + s2) * 8;
}, "wfblk");
var wblk = /* @__PURE__ */ __name(function(dat, out, final, syms, lf, df, eb, li, bs, bl, p2) {
  wbits(out, p2++, final);
  ++lf[256];
  var _a3 = hTree(lf, 15), dlt = _a3.t, mlb = _a3.l;
  var _b2 = hTree(df, 15), ddt = _b2.t, mdb = _b2.l;
  var _c = lc(dlt), lclt = _c.c, nlc = _c.n;
  var _d = lc(ddt), lcdt = _d.c, ndc = _d.n;
  var lcfreq = new u16(19);
  for (var i2 = 0; i2 < lclt.length; ++i2)
    ++lcfreq[lclt[i2] & 31];
  for (var i2 = 0; i2 < lcdt.length; ++i2)
    ++lcfreq[lcdt[i2] & 31];
  var _e = hTree(lcfreq, 7), lct = _e.t, mlcb = _e.l;
  var nlcc = 19;
  for (; nlcc > 4 && !lct[clim[nlcc - 1]]; --nlcc)
    ;
  var flen = bl + 5 << 3;
  var ftlen = clen(lf, flt) + clen(df, fdt) + eb;
  var dtlen = clen(lf, dlt) + clen(df, ddt) + eb + 14 + 3 * nlcc + clen(lcfreq, lct) + 2 * lcfreq[16] + 3 * lcfreq[17] + 7 * lcfreq[18];
  if (bs >= 0 && flen <= ftlen && flen <= dtlen)
    return wfblk(out, p2, dat.subarray(bs, bs + bl));
  var lm, ll, dm, dl;
  wbits(out, p2, 1 + (dtlen < ftlen)), p2 += 2;
  if (dtlen < ftlen) {
    lm = hMap(dlt, mlb, 0), ll = dlt, dm = hMap(ddt, mdb, 0), dl = ddt;
    var llm = hMap(lct, mlcb, 0);
    wbits(out, p2, nlc - 257);
    wbits(out, p2 + 5, ndc - 1);
    wbits(out, p2 + 10, nlcc - 4);
    p2 += 14;
    for (var i2 = 0; i2 < nlcc; ++i2)
      wbits(out, p2 + 3 * i2, lct[clim[i2]]);
    p2 += 3 * nlcc;
    var lcts = [lclt, lcdt];
    for (var it2 = 0; it2 < 2; ++it2) {
      var clct = lcts[it2];
      for (var i2 = 0; i2 < clct.length; ++i2) {
        var len = clct[i2] & 31;
        wbits(out, p2, llm[len]), p2 += lct[len];
        if (len > 15)
          wbits(out, p2, clct[i2] >> 5 & 127), p2 += clct[i2] >> 12;
      }
    }
  } else {
    lm = flm, ll = flt, dm = fdm, dl = fdt;
  }
  for (var i2 = 0; i2 < li; ++i2) {
    var sym = syms[i2];
    if (sym > 255) {
      var len = sym >> 18 & 31;
      wbits16(out, p2, lm[len + 257]), p2 += ll[len + 257];
      if (len > 7)
        wbits(out, p2, sym >> 23 & 31), p2 += fleb[len];
      var dst = sym & 31;
      wbits16(out, p2, dm[dst]), p2 += dl[dst];
      if (dst > 3)
        wbits16(out, p2, sym >> 5 & 8191), p2 += fdeb[dst];
    } else {
      wbits16(out, p2, lm[sym]), p2 += ll[sym];
    }
  }
  wbits16(out, p2, lm[256]);
  return p2 + ll[256];
}, "wblk");
var deo = /* @__PURE__ */ new i32([65540, 131080, 131088, 131104, 262176, 1048704, 1048832, 2114560, 2117632]);
var et$1 = /* @__PURE__ */ new u8(0);
var dflt = /* @__PURE__ */ __name(function(dat, lvl, plvl, pre, post, st2) {
  var s2 = st2.z || dat.length;
  var o2 = new u8(pre + s2 + 5 * (1 + Math.ceil(s2 / 7e3)) + post);
  var w2 = o2.subarray(pre, o2.length - post);
  var lst = st2.l;
  var pos = (st2.r || 0) & 7;
  if (lvl) {
    if (pos)
      w2[0] = st2.r >> 3;
    var opt = deo[lvl - 1];
    var n2 = opt >> 13, c2 = opt & 8191;
    var msk_1 = (1 << plvl) - 1;
    var prev = st2.p || new u16(32768), head = st2.h || new u16(msk_1 + 1);
    var bs1_1 = Math.ceil(plvl / 3), bs2_1 = 2 * bs1_1;
    var hsh = /* @__PURE__ */ __name(function(i3) {
      return (dat[i3] ^ dat[i3 + 1] << bs1_1 ^ dat[i3 + 2] << bs2_1) & msk_1;
    }, "hsh");
    var syms = new i32(25e3);
    var lf = new u16(288), df = new u16(32);
    var lc_1 = 0, eb = 0, i2 = st2.i || 0, li = 0, wi = st2.w || 0, bs = 0;
    for (; i2 + 2 < s2; ++i2) {
      var hv = hsh(i2);
      var imod = i2 & 32767, pimod = head[hv];
      prev[imod] = pimod;
      head[hv] = imod;
      if (wi <= i2) {
        var rem = s2 - i2;
        if ((lc_1 > 7e3 || li > 24576) && (rem > 423 || !lst)) {
          pos = wblk(dat, w2, 0, syms, lf, df, eb, li, bs, i2 - bs, pos);
          li = lc_1 = eb = 0, bs = i2;
          for (var j2 = 0; j2 < 286; ++j2)
            lf[j2] = 0;
          for (var j2 = 0; j2 < 30; ++j2)
            df[j2] = 0;
        }
        var l2 = 2, d2 = 0, ch_1 = c2, dif = imod - pimod & 32767;
        if (rem > 2 && hv == hsh(i2 - dif)) {
          var maxn = Math.min(n2, rem) - 1;
          var maxd = Math.min(32767, i2);
          var ml = Math.min(258, rem);
          while (dif <= maxd && --ch_1 && imod != pimod) {
            if (dat[i2 + l2] == dat[i2 + l2 - dif]) {
              var nl = 0;
              for (; nl < ml && dat[i2 + nl] == dat[i2 + nl - dif]; ++nl)
                ;
              if (nl > l2) {
                l2 = nl, d2 = dif;
                if (nl > maxn)
                  break;
                var mmd = Math.min(dif, nl - 2);
                var md = 0;
                for (var j2 = 0; j2 < mmd; ++j2) {
                  var ti = i2 - dif + j2 & 32767;
                  var pti = prev[ti];
                  var cd = ti - pti & 32767;
                  if (cd > md)
                    md = cd, pimod = ti;
                }
              }
            }
            imod = pimod, pimod = prev[imod];
            dif += imod - pimod & 32767;
          }
        }
        if (d2) {
          syms[li++] = 268435456 | revfl[l2] << 18 | revfd[d2];
          var lin = revfl[l2] & 31, din = revfd[d2] & 31;
          eb += fleb[lin] + fdeb[din];
          ++lf[257 + lin];
          ++df[din];
          wi = i2 + l2;
          ++lc_1;
        } else {
          syms[li++] = dat[i2];
          ++lf[dat[i2]];
        }
      }
    }
    for (i2 = Math.max(i2, wi); i2 < s2; ++i2) {
      syms[li++] = dat[i2];
      ++lf[dat[i2]];
    }
    pos = wblk(dat, w2, lst, syms, lf, df, eb, li, bs, i2 - bs, pos);
    if (!lst) {
      st2.r = pos & 7 | w2[pos / 8 | 0] << 3;
      pos -= 7;
      st2.h = head, st2.p = prev, st2.i = i2, st2.w = wi;
    }
  } else {
    for (var i2 = st2.w || 0; i2 < s2 + lst; i2 += 65535) {
      var e = i2 + 65535;
      if (e >= s2) {
        w2[pos / 8 | 0] = lst;
        e = s2;
      }
      pos = wfblk(w2, pos + 1, dat.subarray(i2, e));
    }
    st2.i = s2;
  }
  return slc(o2, 0, pre + shft(pos) + post);
}, "dflt");
var adler = /* @__PURE__ */ __name(function() {
  var a2 = 1, b2 = 0;
  return {
    p: function(d2) {
      var n2 = a2, m2 = b2;
      var l2 = d2.length | 0;
      for (var i2 = 0; i2 != l2; ) {
        var e = Math.min(i2 + 2655, l2);
        for (; i2 < e; ++i2)
          m2 += n2 += d2[i2];
        n2 = (n2 & 65535) + 15 * (n2 >> 16), m2 = (m2 & 65535) + 15 * (m2 >> 16);
      }
      a2 = n2, b2 = m2;
    },
    d: function() {
      a2 %= 65521, b2 %= 65521;
      return (a2 & 255) << 24 | (a2 & 65280) << 8 | (b2 & 255) << 8 | b2 >> 8;
    }
  };
}, "adler");
var dopt = /* @__PURE__ */ __name(function(dat, opt, pre, post, st2) {
  if (!st2) {
    st2 = { l: 1 };
    if (opt.dictionary) {
      var dict = opt.dictionary.subarray(-32768);
      var newDat = new u8(dict.length + dat.length);
      newDat.set(dict);
      newDat.set(dat, dict.length);
      dat = newDat;
      st2.w = dict.length;
    }
  }
  return dflt(dat, opt.level == null ? 6 : opt.level, opt.mem == null ? st2.l ? Math.ceil(Math.max(8, Math.min(13, Math.log(dat.length))) * 1.5) : 20 : 12 + opt.mem, pre, post, st2);
}, "dopt");
var wbytes = /* @__PURE__ */ __name(function(d2, b2, v2) {
  for (; v2; ++b2)
    d2[b2] = v2, v2 >>>= 8;
}, "wbytes");
var zlh = /* @__PURE__ */ __name(function(c2, o2) {
  var lv = o2.level, fl2 = lv == 0 ? 0 : lv < 6 ? 1 : lv == 9 ? 3 : 2;
  c2[0] = 120, c2[1] = fl2 << 6 | (o2.dictionary && 32);
  c2[1] |= 31 - (c2[0] << 8 | c2[1]) % 31;
  if (o2.dictionary) {
    var h3 = adler();
    h3.p(o2.dictionary);
    wbytes(c2, 2, h3.d());
  }
}, "zlh");
var zls = /* @__PURE__ */ __name(function(d2, dict) {
  if ((d2[0] & 15) != 8 || d2[0] >> 4 > 7 || (d2[0] << 8 | d2[1]) % 31)
    err(6, "invalid zlib data");
  if ((d2[1] >> 5 & 1) == +!dict)
    err(6, "invalid zlib data: " + (d2[1] & 32 ? "need" : "unexpected") + " dictionary");
  return (d2[1] >> 3 & 4) + 2;
}, "zls");
function zlibSync(data, opts) {
  if (!opts)
    opts = {};
  var a2 = adler();
  a2.p(data);
  var d2 = dopt(data, opts, opts.dictionary ? 6 : 2, 4);
  return zlh(d2, opts), wbytes(d2, d2.length - 4, a2.d()), d2;
}
__name(zlibSync, "zlibSync");
function unzlibSync(data, opts) {
  return inflt(data.subarray(zls(data, opts && opts.dictionary), -4), { i: 2 }, opts && opts.out, opts && opts.dictionary);
}
__name(unzlibSync, "unzlibSync");
var td = typeof TextDecoder != "undefined" && /* @__PURE__ */ new TextDecoder();
var tds = 0;
try {
  td.decode(et$1, { stream: true });
  tds = 1;
} catch (e) {
}
var n = function() {
  return "undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : this;
}();
function i() {
  n.console && "function" == typeof n.console.log && n.console.log.apply(n.console, arguments);
}
__name(i, "i");
var a = { log: i, warn: function(t2) {
  n.console && ("function" == typeof n.console.warn ? n.console.warn.apply(n.console, arguments) : i.call(null, arguments));
}, error: function(t2) {
  n.console && ("function" == typeof n.console.error ? n.console.error.apply(n.console, arguments) : i(t2));
} };
function o(t2, e, r) {
  var n2 = new XMLHttpRequest();
  n2.open("GET", t2), n2.responseType = "blob", n2.onload = function() {
    l(n2.response, e, r);
  }, n2.onerror = function() {
    a.error("could not download file");
  }, n2.send();
}
__name(o, "o");
function s(t2) {
  var e = new XMLHttpRequest();
  e.open("HEAD", t2, false);
  try {
    e.send();
  } catch (t3) {
  }
  return e.status >= 200 && e.status <= 299;
}
__name(s, "s");
function c(t2) {
  try {
    t2.dispatchEvent(new MouseEvent("click"));
  } catch (r) {
    var e = document.createEvent("MouseEvents");
    e.initMouseEvent("click", true, true, window, 0, 0, 0, 80, 20, false, false, false, false, 0, null), t2.dispatchEvent(e);
  }
}
__name(c, "c");
var u, h, l = n.saveAs || ("object" !== ("undefined" == typeof window ? "undefined" : _typeof(window)) || window !== n ? function() {
} : "undefined" != typeof HTMLAnchorElement && "download" in HTMLAnchorElement.prototype ? function(t2, e, r) {
  var i2 = n.URL || n.webkitURL, a2 = document.createElement("a");
  e = e || t2.name || "download", a2.download = e, a2.rel = "noopener", "string" == typeof t2 ? (a2.href = t2, a2.origin !== location.origin ? s(a2.href) ? o(t2, e, r) : c(a2, a2.target = "_blank") : c(a2)) : (a2.href = i2.createObjectURL(t2), setTimeout(function() {
    i2.revokeObjectURL(a2.href);
  }, 4e4), setTimeout(function() {
    c(a2);
  }, 0));
} : "msSaveOrOpenBlob" in navigator ? function(e, r, n2) {
  if (r = r || e.name || "download", "string" == typeof e)
    if (s(e))
      o(e, r, n2);
    else {
      var i2 = document.createElement("a");
      i2.href = e, i2.target = "_blank", setTimeout(function() {
        c(i2);
      });
    }
  else
    navigator.msSaveOrOpenBlob(function(e2, r2) {
      return void 0 === r2 ? r2 = { autoBom: false } : "object" !== _typeof(r2) && (a.warn("Deprecated: Expected third argument to be a object"), r2 = { autoBom: !r2 }), r2.autoBom && /^\s*(?:text\/\S*|application\/xml|\S*\/\S*\+xml)\s*;.*charset\s*=\s*utf-8/i.test(e2.type) ? new Blob([String.fromCharCode(65279), e2], { type: e2.type }) : e2;
    }(e, n2), r);
} : function(e, r, i2, a2) {
  if ((a2 = a2 || open("", "_blank")) && (a2.document.title = a2.document.body.innerText = "downloading..."), "string" == typeof e)
    return o(e, r, i2);
  var s2 = "application/octet-stream" === e.type, c2 = /constructor/i.test(n.HTMLElement) || n.safari, u2 = /CriOS\/[\d]+/.test(navigator.userAgent);
  if ((u2 || s2 && c2) && "object" === ("undefined" == typeof FileReader ? "undefined" : _typeof(FileReader))) {
    var h3 = new FileReader();
    h3.onloadend = function() {
      var t2 = h3.result;
      t2 = u2 ? t2 : t2.replace(/^data:[^;]*;/, "data:attachment/file;"), a2 ? a2.location.href = t2 : location = t2, a2 = null;
    }, h3.readAsDataURL(e);
  } else {
    var l2 = n.URL || n.webkitURL, f2 = l2.createObjectURL(e);
    a2 ? a2.location = f2 : location.href = f2, a2 = null, setTimeout(function() {
      l2.revokeObjectURL(f2);
    }, 4e4);
  }
});
/**
 * A class to parse color values
 * @author Stoyan Stefanov <sstoo@gmail.com>
 * {@link   http://www.phpied.com/rgb-color-parser-in-javascript/}
 * @license Use it if you like it
 */
function f(t2) {
  var e;
  t2 = t2 || "", this.ok = false, "#" == t2.charAt(0) && (t2 = t2.substr(1, 6));
  t2 = { aliceblue: "f0f8ff", antiquewhite: "faebd7", aqua: "00ffff", aquamarine: "7fffd4", azure: "f0ffff", beige: "f5f5dc", bisque: "ffe4c4", black: "000000", blanchedalmond: "ffebcd", blue: "0000ff", blueviolet: "8a2be2", brown: "a52a2a", burlywood: "deb887", cadetblue: "5f9ea0", chartreuse: "7fff00", chocolate: "d2691e", coral: "ff7f50", cornflowerblue: "6495ed", cornsilk: "fff8dc", crimson: "dc143c", cyan: "00ffff", darkblue: "00008b", darkcyan: "008b8b", darkgoldenrod: "b8860b", darkgray: "a9a9a9", darkgreen: "006400", darkkhaki: "bdb76b", darkmagenta: "8b008b", darkolivegreen: "556b2f", darkorange: "ff8c00", darkorchid: "9932cc", darkred: "8b0000", darksalmon: "e9967a", darkseagreen: "8fbc8f", darkslateblue: "483d8b", darkslategray: "2f4f4f", darkturquoise: "00ced1", darkviolet: "9400d3", deeppink: "ff1493", deepskyblue: "00bfff", dimgray: "696969", dodgerblue: "1e90ff", feldspar: "d19275", firebrick: "b22222", floralwhite: "fffaf0", forestgreen: "228b22", fuchsia: "ff00ff", gainsboro: "dcdcdc", ghostwhite: "f8f8ff", gold: "ffd700", goldenrod: "daa520", gray: "808080", green: "008000", greenyellow: "adff2f", honeydew: "f0fff0", hotpink: "ff69b4", indianred: "cd5c5c", indigo: "4b0082", ivory: "fffff0", khaki: "f0e68c", lavender: "e6e6fa", lavenderblush: "fff0f5", lawngreen: "7cfc00", lemonchiffon: "fffacd", lightblue: "add8e6", lightcoral: "f08080", lightcyan: "e0ffff", lightgoldenrodyellow: "fafad2", lightgrey: "d3d3d3", lightgreen: "90ee90", lightpink: "ffb6c1", lightsalmon: "ffa07a", lightseagreen: "20b2aa", lightskyblue: "87cefa", lightslateblue: "8470ff", lightslategray: "778899", lightsteelblue: "b0c4de", lightyellow: "ffffe0", lime: "00ff00", limegreen: "32cd32", linen: "faf0e6", magenta: "ff00ff", maroon: "800000", mediumaquamarine: "66cdaa", mediumblue: "0000cd", mediumorchid: "ba55d3", mediumpurple: "9370d8", mediumseagreen: "3cb371", mediumslateblue: "7b68ee", mediumspringgreen: "00fa9a", mediumturquoise: "48d1cc", mediumvioletred: "c71585", midnightblue: "191970", mintcream: "f5fffa", mistyrose: "ffe4e1", moccasin: "ffe4b5", navajowhite: "ffdead", navy: "000080", oldlace: "fdf5e6", olive: "808000", olivedrab: "6b8e23", orange: "ffa500", orangered: "ff4500", orchid: "da70d6", palegoldenrod: "eee8aa", palegreen: "98fb98", paleturquoise: "afeeee", palevioletred: "d87093", papayawhip: "ffefd5", peachpuff: "ffdab9", peru: "cd853f", pink: "ffc0cb", plum: "dda0dd", powderblue: "b0e0e6", purple: "800080", red: "ff0000", rosybrown: "bc8f8f", royalblue: "4169e1", saddlebrown: "8b4513", salmon: "fa8072", sandybrown: "f4a460", seagreen: "2e8b57", seashell: "fff5ee", sienna: "a0522d", silver: "c0c0c0", skyblue: "87ceeb", slateblue: "6a5acd", slategray: "708090", snow: "fffafa", springgreen: "00ff7f", steelblue: "4682b4", tan: "d2b48c", teal: "008080", thistle: "d8bfd8", tomato: "ff6347", turquoise: "40e0d0", violet: "ee82ee", violetred: "d02090", wheat: "f5deb3", white: "ffffff", whitesmoke: "f5f5f5", yellow: "ffff00", yellowgreen: "9acd32" }[t2 = (t2 = t2.replace(/ /g, "")).toLowerCase()] || t2;
  for (var r = [{ re: /^rgb\((\d{1,3}),\s*(\d{1,3}),\s*(\d{1,3})\)$/, example: ["rgb(123, 234, 45)", "rgb(255,234,245)"], process: function(t3) {
    return [parseInt(t3[1]), parseInt(t3[2]), parseInt(t3[3])];
  } }, { re: /^(\w{2})(\w{2})(\w{2})$/, example: ["#00ff00", "336699"], process: function(t3) {
    return [parseInt(t3[1], 16), parseInt(t3[2], 16), parseInt(t3[3], 16)];
  } }, { re: /^(\w{1})(\w{1})(\w{1})$/, example: ["#fb0", "f0f"], process: function(t3) {
    return [parseInt(t3[1] + t3[1], 16), parseInt(t3[2] + t3[2], 16), parseInt(t3[3] + t3[3], 16)];
  } }], n2 = 0; n2 < r.length; n2++) {
    var i2 = r[n2].re, a2 = r[n2].process, o2 = i2.exec(t2);
    o2 && (e = a2(o2), this.r = e[0], this.g = e[1], this.b = e[2], this.ok = true);
  }
  this.r = this.r < 0 || isNaN(this.r) ? 0 : this.r > 255 ? 255 : this.r, this.g = this.g < 0 || isNaN(this.g) ? 0 : this.g > 255 ? 255 : this.g, this.b = this.b < 0 || isNaN(this.b) ? 0 : this.b > 255 ? 255 : this.b, this.toRGB = function() {
    return "rgb(" + this.r + ", " + this.g + ", " + this.b + ")";
  }, this.toHex = function() {
    var t3 = this.r.toString(16), e2 = this.g.toString(16), r2 = this.b.toString(16);
    return 1 == t3.length && (t3 = "0" + t3), 1 == e2.length && (e2 = "0" + e2), 1 == r2.length && (r2 = "0" + r2), "#" + t3 + e2 + r2;
  };
}
__name(f, "f");
/**
 * @license
 * Joseph Myers does not specify a particular license for his work.
 *
 * Author: Joseph Myers
 * Accessed from: http://www.myersdaily.org/joseph/javascript/md5.js
 *
 * Modified by: Owen Leong
 */
function d(t2, e) {
  var r = t2[0], n2 = t2[1], i2 = t2[2], a2 = t2[3];
  r = g(r, n2, i2, a2, e[0], 7, -680876936), a2 = g(a2, r, n2, i2, e[1], 12, -389564586), i2 = g(i2, a2, r, n2, e[2], 17, 606105819), n2 = g(n2, i2, a2, r, e[3], 22, -1044525330), r = g(r, n2, i2, a2, e[4], 7, -176418897), a2 = g(a2, r, n2, i2, e[5], 12, 1200080426), i2 = g(i2, a2, r, n2, e[6], 17, -1473231341), n2 = g(n2, i2, a2, r, e[7], 22, -45705983), r = g(r, n2, i2, a2, e[8], 7, 1770035416), a2 = g(a2, r, n2, i2, e[9], 12, -1958414417), i2 = g(i2, a2, r, n2, e[10], 17, -42063), n2 = g(n2, i2, a2, r, e[11], 22, -1990404162), r = g(r, n2, i2, a2, e[12], 7, 1804603682), a2 = g(a2, r, n2, i2, e[13], 12, -40341101), i2 = g(i2, a2, r, n2, e[14], 17, -1502002290), r = m(r, n2 = g(n2, i2, a2, r, e[15], 22, 1236535329), i2, a2, e[1], 5, -165796510), a2 = m(a2, r, n2, i2, e[6], 9, -1069501632), i2 = m(i2, a2, r, n2, e[11], 14, 643717713), n2 = m(n2, i2, a2, r, e[0], 20, -373897302), r = m(r, n2, i2, a2, e[5], 5, -701558691), a2 = m(a2, r, n2, i2, e[10], 9, 38016083), i2 = m(i2, a2, r, n2, e[15], 14, -660478335), n2 = m(n2, i2, a2, r, e[4], 20, -405537848), r = m(r, n2, i2, a2, e[9], 5, 568446438), a2 = m(a2, r, n2, i2, e[14], 9, -1019803690), i2 = m(i2, a2, r, n2, e[3], 14, -187363961), n2 = m(n2, i2, a2, r, e[8], 20, 1163531501), r = m(r, n2, i2, a2, e[13], 5, -1444681467), a2 = m(a2, r, n2, i2, e[2], 9, -51403784), i2 = m(i2, a2, r, n2, e[7], 14, 1735328473), r = v(r, n2 = m(n2, i2, a2, r, e[12], 20, -1926607734), i2, a2, e[5], 4, -378558), a2 = v(a2, r, n2, i2, e[8], 11, -2022574463), i2 = v(i2, a2, r, n2, e[11], 16, 1839030562), n2 = v(n2, i2, a2, r, e[14], 23, -35309556), r = v(r, n2, i2, a2, e[1], 4, -1530992060), a2 = v(a2, r, n2, i2, e[4], 11, 1272893353), i2 = v(i2, a2, r, n2, e[7], 16, -155497632), n2 = v(n2, i2, a2, r, e[10], 23, -1094730640), r = v(r, n2, i2, a2, e[13], 4, 681279174), a2 = v(a2, r, n2, i2, e[0], 11, -358537222), i2 = v(i2, a2, r, n2, e[3], 16, -722521979), n2 = v(n2, i2, a2, r, e[6], 23, 76029189), r = v(r, n2, i2, a2, e[9], 4, -640364487), a2 = v(a2, r, n2, i2, e[12], 11, -421815835), i2 = v(i2, a2, r, n2, e[15], 16, 530742520), r = b(r, n2 = v(n2, i2, a2, r, e[2], 23, -995338651), i2, a2, e[0], 6, -198630844), a2 = b(a2, r, n2, i2, e[7], 10, 1126891415), i2 = b(i2, a2, r, n2, e[14], 15, -1416354905), n2 = b(n2, i2, a2, r, e[5], 21, -57434055), r = b(r, n2, i2, a2, e[12], 6, 1700485571), a2 = b(a2, r, n2, i2, e[3], 10, -1894986606), i2 = b(i2, a2, r, n2, e[10], 15, -1051523), n2 = b(n2, i2, a2, r, e[1], 21, -2054922799), r = b(r, n2, i2, a2, e[8], 6, 1873313359), a2 = b(a2, r, n2, i2, e[15], 10, -30611744), i2 = b(i2, a2, r, n2, e[6], 15, -1560198380), n2 = b(n2, i2, a2, r, e[13], 21, 1309151649), r = b(r, n2, i2, a2, e[4], 6, -145523070), a2 = b(a2, r, n2, i2, e[11], 10, -1120210379), i2 = b(i2, a2, r, n2, e[2], 15, 718787259), n2 = b(n2, i2, a2, r, e[9], 21, -343485551), t2[0] = _(r, t2[0]), t2[1] = _(n2, t2[1]), t2[2] = _(i2, t2[2]), t2[3] = _(a2, t2[3]);
}
__name(d, "d");
function p(t2, e, r, n2, i2, a2) {
  return e = _(_(e, t2), _(n2, a2)), _(e << i2 | e >>> 32 - i2, r);
}
__name(p, "p");
function g(t2, e, r, n2, i2, a2, o2) {
  return p(e & r | ~e & n2, t2, e, i2, a2, o2);
}
__name(g, "g");
function m(t2, e, r, n2, i2, a2, o2) {
  return p(e & n2 | r & ~n2, t2, e, i2, a2, o2);
}
__name(m, "m");
function v(t2, e, r, n2, i2, a2, o2) {
  return p(e ^ r ^ n2, t2, e, i2, a2, o2);
}
__name(v, "v");
function b(t2, e, r, n2, i2, a2, o2) {
  return p(r ^ (e | ~n2), t2, e, i2, a2, o2);
}
__name(b, "b");
function y(t2) {
  var e, r = t2.length, n2 = [1732584193, -271733879, -1732584194, 271733878];
  for (e = 64; e <= t2.length; e += 64)
    d(n2, w(t2.substring(e - 64, e)));
  t2 = t2.substring(e - 64);
  var i2 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
  for (e = 0; e < t2.length; e++)
    i2[e >> 2] |= t2.charCodeAt(e) << (e % 4 << 3);
  if (i2[e >> 2] |= 128 << (e % 4 << 3), e > 55)
    for (d(n2, i2), e = 0; e < 16; e++)
      i2[e] = 0;
  return i2[14] = 8 * r, d(n2, i2), n2;
}
__name(y, "y");
function w(t2) {
  var e, r = [];
  for (e = 0; e < 64; e += 4)
    r[e >> 2] = t2.charCodeAt(e) + (t2.charCodeAt(e + 1) << 8) + (t2.charCodeAt(e + 2) << 16) + (t2.charCodeAt(e + 3) << 24);
  return r;
}
__name(w, "w");
u = n.atob.bind(n), h = n.btoa.bind(n);
var N = "0123456789abcdef".split("");
function L(t2) {
  for (var e = "", r = 0; r < 4; r++)
    e += N[t2 >> 8 * r + 4 & 15] + N[t2 >> 8 * r & 15];
  return e;
}
__name(L, "L");
function A(t2) {
  return String.fromCharCode((255 & t2) >> 0, (65280 & t2) >> 8, (16711680 & t2) >> 16, (4278190080 & t2) >> 24);
}
__name(A, "A");
function x(t2) {
  return y(t2).map(A).join("");
}
__name(x, "x");
var S = "5d41402abc4b2a76b9719d911017c592" != function(t2) {
  for (var e = 0; e < t2.length; e++)
    t2[e] = L(t2[e]);
  return t2.join("");
}(y("hello"));
function _(t2, e) {
  if (S) {
    var r = (65535 & t2) + (65535 & e);
    return (t2 >> 16) + (e >> 16) + (r >> 16) << 16 | 65535 & r;
  }
  return t2 + e & 4294967295;
}
__name(_, "_");
/**
 * @license
 * FPDF is released under a permissive license: there is no usage restriction.
 * You may embed it freely in your application (commercial or not), with or
 * without modifications.
 *
 * Reference: http://www.fpdf.org/en/script/script37.php
 */
function P(t2, e) {
  var r, n2, i2, a2;
  if (t2 !== r) {
    for (var o2 = (i2 = t2, a2 = 1 + (256 / t2.length >> 0), new Array(a2 + 1).join(i2)), s2 = [], c2 = 0; c2 < 256; c2++)
      s2[c2] = c2;
    var u2 = 0;
    for (c2 = 0; c2 < 256; c2++) {
      var h3 = s2[c2];
      u2 = (u2 + h3 + o2.charCodeAt(c2)) % 256, s2[c2] = s2[u2], s2[u2] = h3;
    }
    r = t2, n2 = s2;
  } else
    s2 = n2;
  var l2 = e.length, f2 = 0, d2 = 0, p2 = "";
  for (c2 = 0; c2 < l2; c2++)
    d2 = (d2 + (h3 = s2[f2 = (f2 + 1) % 256])) % 256, s2[f2] = s2[d2], s2[d2] = h3, o2 = s2[(s2[f2] + s2[d2]) % 256], p2 += String.fromCharCode(e.charCodeAt(c2) ^ o2);
  return p2;
}
__name(P, "P");
/**
 * @license
 * Licensed under the MIT License.
 * http://opensource.org/licenses/mit-license
 * Author: Owen Leong (@owenl131)
 * Date: 15 Oct 2020
 * References:
 * https://www.cs.cmu.edu/~dst/Adobe/Gallery/anon21jul01-pdf-encryption.txt
 * https://github.com/foliojs/pdfkit/blob/master/lib/security.js
 * http://www.fpdf.org/en/script/script37.php
 */
var k = { print: 4, modify: 8, copy: 16, "annot-forms": 32 };
function I(t2, e, r, n2) {
  this.v = 1, this.r = 2;
  var i2 = 192;
  t2.forEach(function(t3) {
    if (void 0 !== k.perm)
      throw new Error("Invalid permission: " + t3);
    i2 += k[t3];
  }), this.padding = "(N^NuAd\0NV\b..\0h>/\fdSiz";
  var a2 = (e + this.padding).substr(0, 32), o2 = (r + this.padding).substr(0, 32);
  this.O = this.processOwnerPassword(a2, o2), this.P = -(1 + (255 ^ i2)), this.encryptionKey = x(a2 + this.O + this.lsbFirstWord(this.P) + this.hexToBytes(n2)).substr(0, 5), this.U = P(this.encryptionKey, this.padding);
}
__name(I, "I");
function F(t2) {
  if (/[^\u0000-\u00ff]/.test(t2))
    throw new Error("Invalid PDF Name Object: " + t2 + ", Only accept ASCII characters.");
  for (var e = "", r = t2.length, n2 = 0; n2 < r; n2++) {
    var i2 = t2.charCodeAt(n2);
    if (i2 < 33 || 35 === i2 || 37 === i2 || 40 === i2 || 41 === i2 || 47 === i2 || 60 === i2 || 62 === i2 || 91 === i2 || 93 === i2 || 123 === i2 || 125 === i2 || i2 > 126)
      e += "#" + ("0" + i2.toString(16)).slice(-2);
    else
      e += t2[n2];
  }
  return e;
}
__name(F, "F");
function C(e) {
  if ("object" !== _typeof(e))
    throw new Error("Invalid Context passed to initialize PubSub (jsPDF-module)");
  var r = {};
  this.subscribe = function(t2, e2, n2) {
    if (n2 = n2 || false, "string" != typeof t2 || "function" != typeof e2 || "boolean" != typeof n2)
      throw new Error("Invalid arguments passed to PubSub.subscribe (jsPDF-module)");
    r.hasOwnProperty(t2) || (r[t2] = {});
    var i2 = Math.random().toString(35);
    return r[t2][i2] = [e2, !!n2], i2;
  }, this.unsubscribe = function(t2) {
    for (var e2 in r)
      if (r[e2][t2])
        return delete r[e2][t2], 0 === Object.keys(r[e2]).length && delete r[e2], true;
    return false;
  }, this.publish = function(t2) {
    if (r.hasOwnProperty(t2)) {
      var i2 = Array.prototype.slice.call(arguments, 1), o2 = [];
      for (var s2 in r[t2]) {
        var c2 = r[t2][s2];
        try {
          c2[0].apply(e, i2);
        } catch (t3) {
          n.console && a.error("jsPDF PubSub Error", t3.message, t3);
        }
        c2[1] && o2.push(s2);
      }
      o2.length && o2.forEach(this.unsubscribe);
    }
  }, this.getTopics = function() {
    return r;
  };
}
__name(C, "C");
function j(t2) {
  if (!(this instanceof j))
    return new j(t2);
  var e = "opacity,stroke-opacity".split(",");
  for (var r in t2)
    t2.hasOwnProperty(r) && e.indexOf(r) >= 0 && (this[r] = t2[r]);
  this.id = "", this.objectNumber = -1;
}
__name(j, "j");
function O(t2, e) {
  this.gState = t2, this.matrix = e, this.id = "", this.objectNumber = -1;
}
__name(O, "O");
function B(t2, e, r, n2, i2) {
  if (!(this instanceof B))
    return new B(t2, e, r, n2, i2);
  this.type = "axial" === t2 ? 2 : 3, this.coords = e, this.colors = r, O.call(this, n2, i2);
}
__name(B, "B");
function M(t2, e, r, n2, i2) {
  if (!(this instanceof M))
    return new M(t2, e, r, n2, i2);
  this.boundingBox = t2, this.xStep = e, this.yStep = r, this.stream = "", this.cloneIndex = 0, O.call(this, n2, i2);
}
__name(M, "M");
function E(e) {
  var r, i2 = "string" == typeof arguments[0] ? arguments[0] : "p", o2 = arguments[1], s2 = arguments[2], c2 = arguments[3], u2 = [], d2 = 1, p2 = 16, g2 = "S", m2 = null;
  "object" === _typeof(e = e || {}) && (i2 = e.orientation, o2 = e.unit || o2, s2 = e.format || s2, c2 = e.compress || e.compressPdf || c2, null !== (m2 = e.encryption || null) && (m2.userPassword = m2.userPassword || "", m2.ownerPassword = m2.ownerPassword || "", m2.userPermissions = m2.userPermissions || []), d2 = "number" == typeof e.userUnit ? Math.abs(e.userUnit) : 1, void 0 !== e.precision && (r = e.precision), void 0 !== e.floatPrecision && (p2 = e.floatPrecision), g2 = e.defaultPathOperation || "S"), u2 = e.filters || (true === c2 ? ["FlateEncode"] : u2), o2 = o2 || "mm", i2 = ("" + (i2 || "P")).toLowerCase();
  var v2 = e.putOnlyUsedFonts || false, b2 = {}, y2 = { internal: {}, __private__: {} };
  y2.__private__.PubSub = C;
  var w2 = "1.3", N2 = y2.__private__.getPdfVersion = function() {
    return w2;
  };
  y2.__private__.setPdfVersion = function(t2) {
    w2 = t2;
  };
  var L2 = { a0: [2383.94, 3370.39], a1: [1683.78, 2383.94], a2: [1190.55, 1683.78], a3: [841.89, 1190.55], a4: [595.28, 841.89], a5: [419.53, 595.28], a6: [297.64, 419.53], a7: [209.76, 297.64], a8: [147.4, 209.76], a9: [104.88, 147.4], a10: [73.7, 104.88], b0: [2834.65, 4008.19], b1: [2004.09, 2834.65], b2: [1417.32, 2004.09], b3: [1000.63, 1417.32], b4: [708.66, 1000.63], b5: [498.9, 708.66], b6: [354.33, 498.9], b7: [249.45, 354.33], b8: [175.75, 249.45], b9: [124.72, 175.75], b10: [87.87, 124.72], c0: [2599.37, 3676.54], c1: [1836.85, 2599.37], c2: [1298.27, 1836.85], c3: [918.43, 1298.27], c4: [649.13, 918.43], c5: [459.21, 649.13], c6: [323.15, 459.21], c7: [229.61, 323.15], c8: [161.57, 229.61], c9: [113.39, 161.57], c10: [79.37, 113.39], dl: [311.81, 623.62], letter: [612, 792], "government-letter": [576, 756], legal: [612, 1008], "junior-legal": [576, 360], ledger: [1224, 792], tabloid: [792, 1224], "credit-card": [153, 243] };
  y2.__private__.getPageFormats = function() {
    return L2;
  };
  var A2 = y2.__private__.getPageFormat = function(t2) {
    return L2[t2];
  };
  s2 = s2 || "a4";
  var x2 = { COMPAT: "compat", ADVANCED: "advanced" }, S2 = x2.COMPAT;
  function _2() {
    this.saveGraphicsState(), lt2(new Vt2(_t2, 0, 0, -_t2, 0, Rr() * _t2).toString() + " cm"), this.setFontSize(this.getFontSize() / _t2), g2 = "n", S2 = x2.ADVANCED;
  }
  __name(_2, "_");
  function P2() {
    this.restoreGraphicsState(), g2 = "S", S2 = x2.COMPAT;
  }
  __name(P2, "P");
  var k2 = y2.__private__.combineFontStyleAndFontWeight = function(t2, e2) {
    if ("bold" == t2 && "normal" == e2 || "bold" == t2 && 400 == e2 || "normal" == t2 && "italic" == e2 || "bold" == t2 && "italic" == e2)
      throw new Error("Invalid Combination of fontweight and fontstyle");
    return e2 && (t2 = 400 == e2 || "normal" === e2 ? "italic" === t2 ? "italic" : "normal" : 700 != e2 && "bold" !== e2 || "normal" !== t2 ? (700 == e2 ? "bold" : e2) + "" + t2 : "bold"), t2;
  };
  y2.advancedAPI = function(t2) {
    var e2 = S2 === x2.COMPAT;
    return e2 && _2.call(this), "function" != typeof t2 || (t2(this), e2 && P2.call(this)), this;
  }, y2.compatAPI = function(t2) {
    var e2 = S2 === x2.ADVANCED;
    return e2 && P2.call(this), "function" != typeof t2 || (t2(this), e2 && _2.call(this)), this;
  }, y2.isAdvancedAPI = function() {
    return S2 === x2.ADVANCED;
  };
  var O2, q2 = /* @__PURE__ */ __name(function(t2) {
    if (S2 !== x2.ADVANCED)
      throw new Error(t2 + " is only available in 'advanced' API mode. You need to call advancedAPI() first.");
  }, "q"), D2 = y2.roundToPrecision = y2.__private__.roundToPrecision = function(t2, e2) {
    var n2 = r || e2;
    if (isNaN(t2) || isNaN(n2))
      throw new Error("Invalid argument passed to jsPDF.roundToPrecision");
    return t2.toFixed(n2).replace(/0+$/, "");
  };
  O2 = y2.hpf = y2.__private__.hpf = "number" == typeof p2 ? function(t2) {
    if (isNaN(t2))
      throw new Error("Invalid argument passed to jsPDF.hpf");
    return D2(t2, p2);
  } : "smart" === p2 ? function(t2) {
    if (isNaN(t2))
      throw new Error("Invalid argument passed to jsPDF.hpf");
    return D2(t2, t2 > -1 && t2 < 1 ? 16 : 5);
  } : function(t2) {
    if (isNaN(t2))
      throw new Error("Invalid argument passed to jsPDF.hpf");
    return D2(t2, 16);
  };
  var R2 = y2.f2 = y2.__private__.f2 = function(t2) {
    if (isNaN(t2))
      throw new Error("Invalid argument passed to jsPDF.f2");
    return D2(t2, 2);
  }, T2 = y2.__private__.f3 = function(t2) {
    if (isNaN(t2))
      throw new Error("Invalid argument passed to jsPDF.f3");
    return D2(t2, 3);
  }, U2 = y2.scale = y2.__private__.scale = function(t2) {
    if (isNaN(t2))
      throw new Error("Invalid argument passed to jsPDF.scale");
    return S2 === x2.COMPAT ? t2 * _t2 : S2 === x2.ADVANCED ? t2 : void 0;
  }, z2 = /* @__PURE__ */ __name(function(t2) {
    return S2 === x2.COMPAT ? Rr() - t2 : S2 === x2.ADVANCED ? t2 : void 0;
  }, "z"), H2 = /* @__PURE__ */ __name(function(t2) {
    return U2(z2(t2));
  }, "H");
  y2.__private__.setPrecision = y2.setPrecision = function(t2) {
    "number" == typeof parseInt(t2, 10) && (r = parseInt(t2, 10));
  };
  var W2, V2 = "00000000000000000000000000000000", G2 = y2.__private__.getFileId = function() {
    return V2;
  }, Y2 = y2.__private__.setFileId = function(t2) {
    return V2 = void 0 !== t2 && /^[a-fA-F0-9]{32}$/.test(t2) ? t2.toUpperCase() : V2.split("").map(function() {
      return "ABCDEF0123456789".charAt(Math.floor(16 * Math.random()));
    }).join(""), null !== m2 && (Ye = new I(m2.userPermissions, m2.userPassword, m2.ownerPassword, V2)), V2;
  };
  y2.setFileId = function(t2) {
    return Y2(t2), this;
  }, y2.getFileId = function() {
    return G2();
  };
  var J2 = y2.__private__.convertDateToPDFDate = function(t2) {
    var e2 = t2.getTimezoneOffset(), r2 = e2 < 0 ? "+" : "-", n2 = Math.floor(Math.abs(e2 / 60)), i3 = Math.abs(e2 % 60), a2 = [r2, Q2(n2), "'", Q2(i3), "'"].join("");
    return ["D:", t2.getFullYear(), Q2(t2.getMonth() + 1), Q2(t2.getDate()), Q2(t2.getHours()), Q2(t2.getMinutes()), Q2(t2.getSeconds()), a2].join("");
  }, X2 = y2.__private__.convertPDFDateToDate = function(t2) {
    var e2 = parseInt(t2.substr(2, 4), 10), r2 = parseInt(t2.substr(6, 2), 10) - 1, n2 = parseInt(t2.substr(8, 2), 10), i3 = parseInt(t2.substr(10, 2), 10), a2 = parseInt(t2.substr(12, 2), 10), o3 = parseInt(t2.substr(14, 2), 10);
    return new Date(e2, r2, n2, i3, a2, o3, 0);
  }, K2 = y2.__private__.setCreationDate = function(t2) {
    var e2;
    if (void 0 === t2 && (t2 = /* @__PURE__ */ new Date()), t2 instanceof Date)
      e2 = J2(t2);
    else {
      if (!/^D:(20[0-2][0-9]|203[0-7]|19[7-9][0-9])(0[0-9]|1[0-2])([0-2][0-9]|3[0-1])(0[0-9]|1[0-9]|2[0-3])(0[0-9]|[1-5][0-9])(0[0-9]|[1-5][0-9])(\+0[0-9]|\+1[0-4]|-0[0-9]|-1[0-1])'(0[0-9]|[1-5][0-9])'?$/.test(t2))
        throw new Error("Invalid argument passed to jsPDF.setCreationDate");
      e2 = t2;
    }
    return W2 = e2;
  }, Z2 = y2.__private__.getCreationDate = function(t2) {
    var e2 = W2;
    return "jsDate" === t2 && (e2 = X2(W2)), e2;
  };
  y2.setCreationDate = function(t2) {
    return K2(t2), this;
  }, y2.getCreationDate = function(t2) {
    return Z2(t2);
  };
  var $2, Q2 = y2.__private__.padd2 = function(t2) {
    return ("0" + parseInt(t2)).slice(-2);
  }, tt2 = y2.__private__.padd2Hex = function(t2) {
    return ("00" + (t2 = t2.toString())).substr(t2.length);
  }, et2 = 0, rt2 = [], nt2 = [], it2 = 0, at2 = [], ot2 = [], st2 = false, ct2 = nt2, ut2 = /* @__PURE__ */ __name(function() {
    et2 = 0, it2 = 0, nt2 = [], rt2 = [], at2 = [], Qt2 = Kt2(), te2 = Kt2();
  }, "ut");
  y2.__private__.setCustomOutputDestination = function(t2) {
    st2 = true, ct2 = t2;
  };
  var ht2 = /* @__PURE__ */ __name(function(t2) {
    st2 || (ct2 = t2);
  }, "ht");
  y2.__private__.resetCustomOutputDestination = function() {
    st2 = false, ct2 = nt2;
  };
  var lt2 = y2.__private__.out = function(t2) {
    return t2 = t2.toString(), it2 += t2.length + 1, ct2.push(t2), ct2;
  }, ft2 = y2.__private__.write = function(t2) {
    return lt2(1 === arguments.length ? t2.toString() : Array.prototype.join.call(arguments, " "));
  }, dt2 = y2.__private__.getArrayBuffer = function(t2) {
    for (var e2 = t2.length, r2 = new ArrayBuffer(e2), n2 = new Uint8Array(r2); e2--; )
      n2[e2] = t2.charCodeAt(e2);
    return r2;
  }, pt2 = [["Helvetica", "helvetica", "normal", "WinAnsiEncoding"], ["Helvetica-Bold", "helvetica", "bold", "WinAnsiEncoding"], ["Helvetica-Oblique", "helvetica", "italic", "WinAnsiEncoding"], ["Helvetica-BoldOblique", "helvetica", "bolditalic", "WinAnsiEncoding"], ["Courier", "courier", "normal", "WinAnsiEncoding"], ["Courier-Bold", "courier", "bold", "WinAnsiEncoding"], ["Courier-Oblique", "courier", "italic", "WinAnsiEncoding"], ["Courier-BoldOblique", "courier", "bolditalic", "WinAnsiEncoding"], ["Times-Roman", "times", "normal", "WinAnsiEncoding"], ["Times-Bold", "times", "bold", "WinAnsiEncoding"], ["Times-Italic", "times", "italic", "WinAnsiEncoding"], ["Times-BoldItalic", "times", "bolditalic", "WinAnsiEncoding"], ["ZapfDingbats", "zapfdingbats", "normal", null], ["Symbol", "symbol", "normal", null]];
  y2.__private__.getStandardFonts = function() {
    return pt2;
  };
  var gt2 = e.fontSize || 16;
  y2.__private__.setFontSize = y2.setFontSize = function(t2) {
    return gt2 = S2 === x2.ADVANCED ? t2 / _t2 : t2, this;
  };
  var mt2, vt2 = y2.__private__.getFontSize = y2.getFontSize = function() {
    return S2 === x2.COMPAT ? gt2 : gt2 * _t2;
  }, bt2 = e.R2L || false;
  y2.__private__.setR2L = y2.setR2L = function(t2) {
    return bt2 = t2, this;
  }, y2.__private__.getR2L = y2.getR2L = function() {
    return bt2;
  };
  var yt2, wt2 = y2.__private__.setZoomMode = function(t2) {
    var e2 = [void 0, null, "fullwidth", "fullheight", "fullpage", "original"];
    if (/^(?:\d+\.\d*|\d*\.\d+|\d+)%$/.test(t2))
      mt2 = t2;
    else if (isNaN(t2)) {
      if (-1 === e2.indexOf(t2))
        throw new Error('zoom must be Integer (e.g. 2), a percentage Value (e.g. 300%) or fullwidth, fullheight, fullpage, original. "' + t2 + '" is not recognized.');
      mt2 = t2;
    } else
      mt2 = parseInt(t2, 10);
  };
  y2.__private__.getZoomMode = function() {
    return mt2;
  };
  var Nt2, Lt2 = y2.__private__.setPageMode = function(t2) {
    if (-1 == [void 0, null, "UseNone", "UseOutlines", "UseThumbs", "FullScreen"].indexOf(t2))
      throw new Error('Page mode must be one of UseNone, UseOutlines, UseThumbs, or FullScreen. "' + t2 + '" is not recognized.');
    yt2 = t2;
  };
  y2.__private__.getPageMode = function() {
    return yt2;
  };
  var At2 = y2.__private__.setLayoutMode = function(t2) {
    if (-1 == [void 0, null, "continuous", "single", "twoleft", "tworight", "two"].indexOf(t2))
      throw new Error('Layout mode must be one of continuous, single, twoleft, tworight. "' + t2 + '" is not recognized.');
    Nt2 = t2;
  };
  y2.__private__.getLayoutMode = function() {
    return Nt2;
  }, y2.__private__.setDisplayMode = y2.setDisplayMode = function(t2, e2, r2) {
    return wt2(t2), At2(e2), Lt2(r2), this;
  };
  var xt2 = { title: "", subject: "", author: "", keywords: "", creator: "" };
  y2.__private__.getDocumentProperty = function(t2) {
    if (-1 === Object.keys(xt2).indexOf(t2))
      throw new Error("Invalid argument passed to jsPDF.getDocumentProperty");
    return xt2[t2];
  }, y2.__private__.getDocumentProperties = function() {
    return xt2;
  }, y2.__private__.setDocumentProperties = y2.setProperties = y2.setDocumentProperties = function(t2) {
    for (var e2 in xt2)
      xt2.hasOwnProperty(e2) && t2[e2] && (xt2[e2] = t2[e2]);
    return this;
  }, y2.__private__.setDocumentProperty = function(t2, e2) {
    if (-1 === Object.keys(xt2).indexOf(t2))
      throw new Error("Invalid arguments passed to jsPDF.setDocumentProperty");
    return xt2[t2] = e2;
  };
  var St2, _t2, Pt2, kt2, It2, Ft2 = {}, Ct2 = {}, jt2 = [], Ot2 = {}, Bt2 = {}, Mt2 = {}, Et2 = {}, qt2 = null, Dt2 = 0, Rt2 = [], Tt2 = new C(y2), Ut2 = e.hotfixes || [], zt2 = {}, Ht2 = {}, Wt2 = [], Vt2 = /* @__PURE__ */ __name(function t2(e2, r2, n2, i3, a2, o3) {
    if (!(this instanceof t2))
      return new t2(e2, r2, n2, i3, a2, o3);
    isNaN(e2) && (e2 = 1), isNaN(r2) && (r2 = 0), isNaN(n2) && (n2 = 0), isNaN(i3) && (i3 = 1), isNaN(a2) && (a2 = 0), isNaN(o3) && (o3 = 0), this._matrix = [e2, r2, n2, i3, a2, o3];
  }, "t");
  Object.defineProperty(Vt2.prototype, "sx", { get: function() {
    return this._matrix[0];
  }, set: function(t2) {
    this._matrix[0] = t2;
  } }), Object.defineProperty(Vt2.prototype, "shy", { get: function() {
    return this._matrix[1];
  }, set: function(t2) {
    this._matrix[1] = t2;
  } }), Object.defineProperty(Vt2.prototype, "shx", { get: function() {
    return this._matrix[2];
  }, set: function(t2) {
    this._matrix[2] = t2;
  } }), Object.defineProperty(Vt2.prototype, "sy", { get: function() {
    return this._matrix[3];
  }, set: function(t2) {
    this._matrix[3] = t2;
  } }), Object.defineProperty(Vt2.prototype, "tx", { get: function() {
    return this._matrix[4];
  }, set: function(t2) {
    this._matrix[4] = t2;
  } }), Object.defineProperty(Vt2.prototype, "ty", { get: function() {
    return this._matrix[5];
  }, set: function(t2) {
    this._matrix[5] = t2;
  } }), Object.defineProperty(Vt2.prototype, "a", { get: function() {
    return this._matrix[0];
  }, set: function(t2) {
    this._matrix[0] = t2;
  } }), Object.defineProperty(Vt2.prototype, "b", { get: function() {
    return this._matrix[1];
  }, set: function(t2) {
    this._matrix[1] = t2;
  } }), Object.defineProperty(Vt2.prototype, "c", { get: function() {
    return this._matrix[2];
  }, set: function(t2) {
    this._matrix[2] = t2;
  } }), Object.defineProperty(Vt2.prototype, "d", { get: function() {
    return this._matrix[3];
  }, set: function(t2) {
    this._matrix[3] = t2;
  } }), Object.defineProperty(Vt2.prototype, "e", { get: function() {
    return this._matrix[4];
  }, set: function(t2) {
    this._matrix[4] = t2;
  } }), Object.defineProperty(Vt2.prototype, "f", { get: function() {
    return this._matrix[5];
  }, set: function(t2) {
    this._matrix[5] = t2;
  } }), Object.defineProperty(Vt2.prototype, "rotation", { get: function() {
    return Math.atan2(this.shx, this.sx);
  } }), Object.defineProperty(Vt2.prototype, "scaleX", { get: function() {
    return this.decompose().scale.sx;
  } }), Object.defineProperty(Vt2.prototype, "scaleY", { get: function() {
    return this.decompose().scale.sy;
  } }), Object.defineProperty(Vt2.prototype, "isIdentity", { get: function() {
    return 1 === this.sx && (0 === this.shy && (0 === this.shx && (1 === this.sy && (0 === this.tx && 0 === this.ty))));
  } }), Vt2.prototype.join = function(t2) {
    return [this.sx, this.shy, this.shx, this.sy, this.tx, this.ty].map(O2).join(t2);
  }, Vt2.prototype.multiply = function(t2) {
    var e2 = t2.sx * this.sx + t2.shy * this.shx, r2 = t2.sx * this.shy + t2.shy * this.sy, n2 = t2.shx * this.sx + t2.sy * this.shx, i3 = t2.shx * this.shy + t2.sy * this.sy, a2 = t2.tx * this.sx + t2.ty * this.shx + this.tx, o3 = t2.tx * this.shy + t2.ty * this.sy + this.ty;
    return new Vt2(e2, r2, n2, i3, a2, o3);
  }, Vt2.prototype.decompose = function() {
    var t2 = this.sx, e2 = this.shy, r2 = this.shx, n2 = this.sy, i3 = this.tx, a2 = this.ty, o3 = Math.sqrt(t2 * t2 + e2 * e2), s3 = (t2 /= o3) * r2 + (e2 /= o3) * n2;
    r2 -= t2 * s3, n2 -= e2 * s3;
    var c3 = Math.sqrt(r2 * r2 + n2 * n2);
    return s3 /= c3, t2 * (n2 /= c3) < e2 * (r2 /= c3) && (t2 = -t2, e2 = -e2, s3 = -s3, o3 = -o3), { scale: new Vt2(o3, 0, 0, c3, 0, 0), translate: new Vt2(1, 0, 0, 1, i3, a2), rotate: new Vt2(t2, e2, -e2, t2, 0, 0), skew: new Vt2(1, 0, s3, 1, 0, 0) };
  }, Vt2.prototype.toString = function(t2) {
    return this.join(" ");
  }, Vt2.prototype.inversed = function() {
    var t2 = this.sx, e2 = this.shy, r2 = this.shx, n2 = this.sy, i3 = this.tx, a2 = this.ty, o3 = 1 / (t2 * n2 - e2 * r2), s3 = n2 * o3, c3 = -e2 * o3, u3 = -r2 * o3, h3 = t2 * o3;
    return new Vt2(s3, c3, u3, h3, -s3 * i3 - u3 * a2, -c3 * i3 - h3 * a2);
  }, Vt2.prototype.applyToPoint = function(t2) {
    var e2 = t2.x * this.sx + t2.y * this.shx + this.tx, r2 = t2.x * this.shy + t2.y * this.sy + this.ty;
    return new Cr(e2, r2);
  }, Vt2.prototype.applyToRectangle = function(t2) {
    var e2 = this.applyToPoint(t2), r2 = this.applyToPoint(new Cr(t2.x + t2.w, t2.y + t2.h));
    return new jr(e2.x, e2.y, r2.x - e2.x, r2.y - e2.y);
  }, Vt2.prototype.clone = function() {
    var t2 = this.sx, e2 = this.shy, r2 = this.shx, n2 = this.sy, i3 = this.tx, a2 = this.ty;
    return new Vt2(t2, e2, r2, n2, i3, a2);
  }, y2.Matrix = Vt2;
  var Gt2 = y2.matrixMult = function(t2, e2) {
    return e2.multiply(t2);
  }, Yt2 = new Vt2(1, 0, 0, 1, 0, 0);
  y2.unitMatrix = y2.identityMatrix = Yt2;
  var Jt2 = /* @__PURE__ */ __name(function(t2, e2) {
    if (!Bt2[t2]) {
      var r2 = (e2 instanceof B ? "Sh" : "P") + (Object.keys(Ot2).length + 1).toString(10);
      e2.id = r2, Bt2[t2] = r2, Ot2[r2] = e2, Tt2.publish("addPattern", e2);
    }
  }, "Jt");
  y2.ShadingPattern = B, y2.TilingPattern = M, y2.addShadingPattern = function(t2, e2) {
    return q2("addShadingPattern()"), Jt2(t2, e2), this;
  }, y2.beginTilingPattern = function(t2) {
    q2("beginTilingPattern()"), Br(t2.boundingBox[0], t2.boundingBox[1], t2.boundingBox[2] - t2.boundingBox[0], t2.boundingBox[3] - t2.boundingBox[1], t2.matrix);
  }, y2.endTilingPattern = function(t2, e2) {
    q2("endTilingPattern()"), e2.stream = ot2[$2].join("\n"), Jt2(t2, e2), Tt2.publish("endTilingPattern", e2), Wt2.pop().restore();
  };
  var Xt2 = y2.__private__.newObject = function() {
    var t2 = Kt2();
    return Zt2(t2, true), t2;
  }, Kt2 = y2.__private__.newObjectDeferred = function() {
    return et2++, rt2[et2] = function() {
      return it2;
    }, et2;
  }, Zt2 = /* @__PURE__ */ __name(function(t2, e2) {
    return e2 = "boolean" == typeof e2 && e2, rt2[t2] = it2, e2 && lt2(t2 + " 0 obj"), t2;
  }, "Zt"), $t2 = y2.__private__.newAdditionalObject = function() {
    var t2 = { objId: Kt2(), content: "" };
    return at2.push(t2), t2;
  }, Qt2 = Kt2(), te2 = Kt2(), ee2 = y2.__private__.decodeColorString = function(t2) {
    var e2 = t2.split(" ");
    if (2 !== e2.length || "g" !== e2[1] && "G" !== e2[1]) {
      if (5 === e2.length && ("k" === e2[4] || "K" === e2[4])) {
        e2 = [(1 - e2[0]) * (1 - e2[3]), (1 - e2[1]) * (1 - e2[3]), (1 - e2[2]) * (1 - e2[3]), "r"];
      }
    } else {
      var r2 = parseFloat(e2[0]);
      e2 = [r2, r2, r2, "r"];
    }
    for (var n2 = "#", i3 = 0; i3 < 3; i3++)
      n2 += ("0" + Math.floor(255 * parseFloat(e2[i3])).toString(16)).slice(-2);
    return n2;
  }, re2 = y2.__private__.encodeColorString = function(e2) {
    var r2;
    "string" == typeof e2 && (e2 = { ch1: e2 });
    var n2 = e2.ch1, i3 = e2.ch2, a2 = e2.ch3, o3 = e2.ch4, s3 = "draw" === e2.pdfColorType ? ["G", "RG", "K"] : ["g", "rg", "k"];
    if ("string" == typeof n2 && "#" !== n2.charAt(0)) {
      var c3 = new f(n2);
      if (c3.ok)
        n2 = c3.toHex();
      else if (!/^\d*\.?\d*$/.test(n2))
        throw new Error('Invalid color "' + n2 + '" passed to jsPDF.encodeColorString.');
    }
    if ("string" == typeof n2 && /^#[0-9A-Fa-f]{3}$/.test(n2) && (n2 = "#" + n2[1] + n2[1] + n2[2] + n2[2] + n2[3] + n2[3]), "string" == typeof n2 && /^#[0-9A-Fa-f]{6}$/.test(n2)) {
      var u3 = parseInt(n2.substr(1), 16);
      n2 = u3 >> 16 & 255, i3 = u3 >> 8 & 255, a2 = 255 & u3;
    }
    if (void 0 === i3 || void 0 === o3 && n2 === i3 && i3 === a2)
      if ("string" == typeof n2)
        r2 = n2 + " " + s3[0];
      else
        switch (e2.precision) {
          case 2:
            r2 = R2(n2 / 255) + " " + s3[0];
            break;
          case 3:
          default:
            r2 = T2(n2 / 255) + " " + s3[0];
        }
    else if (void 0 === o3 || "object" === _typeof(o3)) {
      if (o3 && !isNaN(o3.a) && 0 === o3.a)
        return r2 = ["1.", "1.", "1.", s3[1]].join(" ");
      if ("string" == typeof n2)
        r2 = [n2, i3, a2, s3[1]].join(" ");
      else
        switch (e2.precision) {
          case 2:
            r2 = [R2(n2 / 255), R2(i3 / 255), R2(a2 / 255), s3[1]].join(" ");
            break;
          default:
          case 3:
            r2 = [T2(n2 / 255), T2(i3 / 255), T2(a2 / 255), s3[1]].join(" ");
        }
    } else if ("string" == typeof n2)
      r2 = [n2, i3, a2, o3, s3[2]].join(" ");
    else
      switch (e2.precision) {
        case 2:
          r2 = [R2(n2), R2(i3), R2(a2), R2(o3), s3[2]].join(" ");
          break;
        case 3:
        default:
          r2 = [T2(n2), T2(i3), T2(a2), T2(o3), s3[2]].join(" ");
      }
    return r2;
  }, ne2 = y2.__private__.getFilters = function() {
    return u2;
  }, ie2 = y2.__private__.putStream = function(t2) {
    var e2 = (t2 = t2 || {}).data || "", r2 = t2.filters || ne2(), n2 = t2.alreadyAppliedFilters || [], i3 = t2.addLength1 || false, a2 = e2.length, o3 = t2.objectId, s3 = /* @__PURE__ */ __name(function(t3) {
      return t3;
    }, "s");
    if (null !== m2 && void 0 === o3)
      throw new Error("ObjectId must be passed to putStream for file encryption");
    null !== m2 && (s3 = Ye.encryptor(o3, 0));
    var c3 = {};
    true === r2 && (r2 = ["FlateEncode"]);
    var u3 = t2.additionalKeyValues || [], h3 = (c3 = void 0 !== E.API.processDataByFilters ? E.API.processDataByFilters(e2, r2) : { data: e2, reverseChain: [] }).reverseChain + (Array.isArray(n2) ? n2.join(" ") : n2.toString());
    if (0 !== c3.data.length && (u3.push({ key: "Length", value: c3.data.length }), true === i3 && u3.push({ key: "Length1", value: a2 })), 0 != h3.length)
      if (h3.split("/").length - 1 == 1)
        u3.push({ key: "Filter", value: h3 });
      else {
        u3.push({ key: "Filter", value: "[" + h3 + "]" });
        for (var l2 = 0; l2 < u3.length; l2 += 1)
          if ("DecodeParms" === u3[l2].key) {
            for (var f2 = [], d3 = 0; d3 < c3.reverseChain.split("/").length - 1; d3 += 1)
              f2.push("null");
            f2.push(u3[l2].value), u3[l2].value = "[" + f2.join(" ") + "]";
          }
      }
    lt2("<<");
    for (var p3 = 0; p3 < u3.length; p3++)
      lt2("/" + u3[p3].key + " " + u3[p3].value);
    lt2(">>"), 0 !== c3.data.length && (lt2("stream"), lt2(s3(c3.data)), lt2("endstream"));
  }, ae2 = y2.__private__.putPage = function(t2) {
    var e2 = t2.number, r2 = t2.data, n2 = t2.objId, i3 = t2.contentsObjId;
    Zt2(n2, true), lt2("<</Type /Page"), lt2("/Parent " + t2.rootDictionaryObjId + " 0 R"), lt2("/Resources " + t2.resourceDictionaryObjId + " 0 R"), lt2("/MediaBox [" + parseFloat(O2(t2.mediaBox.bottomLeftX)) + " " + parseFloat(O2(t2.mediaBox.bottomLeftY)) + " " + O2(t2.mediaBox.topRightX) + " " + O2(t2.mediaBox.topRightY) + "]"), null !== t2.cropBox && lt2("/CropBox [" + O2(t2.cropBox.bottomLeftX) + " " + O2(t2.cropBox.bottomLeftY) + " " + O2(t2.cropBox.topRightX) + " " + O2(t2.cropBox.topRightY) + "]"), null !== t2.bleedBox && lt2("/BleedBox [" + O2(t2.bleedBox.bottomLeftX) + " " + O2(t2.bleedBox.bottomLeftY) + " " + O2(t2.bleedBox.topRightX) + " " + O2(t2.bleedBox.topRightY) + "]"), null !== t2.trimBox && lt2("/TrimBox [" + O2(t2.trimBox.bottomLeftX) + " " + O2(t2.trimBox.bottomLeftY) + " " + O2(t2.trimBox.topRightX) + " " + O2(t2.trimBox.topRightY) + "]"), null !== t2.artBox && lt2("/ArtBox [" + O2(t2.artBox.bottomLeftX) + " " + O2(t2.artBox.bottomLeftY) + " " + O2(t2.artBox.topRightX) + " " + O2(t2.artBox.topRightY) + "]"), "number" == typeof t2.userUnit && 1 !== t2.userUnit && lt2("/UserUnit " + t2.userUnit), Tt2.publish("putPage", { objId: n2, pageContext: Rt2[e2], pageNumber: e2, page: r2 }), lt2("/Contents " + i3 + " 0 R"), lt2(">>"), lt2("endobj");
    var a2 = r2.join("\n");
    return S2 === x2.ADVANCED && (a2 += "\nQ"), Zt2(i3, true), ie2({ data: a2, filters: ne2(), objectId: i3 }), lt2("endobj"), n2;
  }, oe2 = y2.__private__.putPages = function() {
    var t2, e2, r2 = [];
    for (t2 = 1; t2 <= Dt2; t2++)
      Rt2[t2].objId = Kt2(), Rt2[t2].contentsObjId = Kt2();
    for (t2 = 1; t2 <= Dt2; t2++)
      r2.push(ae2({ number: t2, data: ot2[t2], objId: Rt2[t2].objId, contentsObjId: Rt2[t2].contentsObjId, mediaBox: Rt2[t2].mediaBox, cropBox: Rt2[t2].cropBox, bleedBox: Rt2[t2].bleedBox, trimBox: Rt2[t2].trimBox, artBox: Rt2[t2].artBox, userUnit: Rt2[t2].userUnit, rootDictionaryObjId: Qt2, resourceDictionaryObjId: te2 }));
    Zt2(Qt2, true), lt2("<</Type /Pages");
    var n2 = "/Kids [";
    for (e2 = 0; e2 < Dt2; e2++)
      n2 += r2[e2] + " 0 R ";
    lt2(n2 + "]"), lt2("/Count " + Dt2), lt2(">>"), lt2("endobj"), Tt2.publish("postPutPages");
  }, se2 = /* @__PURE__ */ __name(function(t2) {
    Tt2.publish("putFont", { font: t2, out: lt2, newObject: Xt2, putStream: ie2 }), true !== t2.isAlreadyPutted && (t2.objectNumber = Xt2(), lt2("<<"), lt2("/Type /Font"), lt2("/BaseFont /" + F(t2.postScriptName)), lt2("/Subtype /Type1"), "string" == typeof t2.encoding && lt2("/Encoding /" + t2.encoding), lt2("/FirstChar 32"), lt2("/LastChar 255"), lt2(">>"), lt2("endobj"));
  }, "se"), ce2 = /* @__PURE__ */ __name(function() {
    for (var t2 in Ft2)
      Ft2.hasOwnProperty(t2) && (false === v2 || true === v2 && b2.hasOwnProperty(t2)) && se2(Ft2[t2]);
  }, "ce"), ue2 = /* @__PURE__ */ __name(function(t2) {
    t2.objectNumber = Xt2();
    var e2 = [];
    e2.push({ key: "Type", value: "/XObject" }), e2.push({ key: "Subtype", value: "/Form" }), e2.push({ key: "BBox", value: "[" + [O2(t2.x), O2(t2.y), O2(t2.x + t2.width), O2(t2.y + t2.height)].join(" ") + "]" }), e2.push({ key: "Matrix", value: "[" + t2.matrix.toString() + "]" });
    var r2 = t2.pages[1].join("\n");
    ie2({ data: r2, additionalKeyValues: e2, objectId: t2.objectNumber }), lt2("endobj");
  }, "ue"), he2 = /* @__PURE__ */ __name(function() {
    for (var t2 in zt2)
      zt2.hasOwnProperty(t2) && ue2(zt2[t2]);
  }, "he"), le2 = /* @__PURE__ */ __name(function(t2, e2) {
    var r2, n2 = [], i3 = 1 / (e2 - 1);
    for (r2 = 0; r2 < 1; r2 += i3)
      n2.push(r2);
    if (n2.push(1), 0 != t2[0].offset) {
      var a2 = { offset: 0, color: t2[0].color };
      t2.unshift(a2);
    }
    if (1 != t2[t2.length - 1].offset) {
      var o3 = { offset: 1, color: t2[t2.length - 1].color };
      t2.push(o3);
    }
    for (var s3 = "", c3 = 0, u3 = 0; u3 < n2.length; u3++) {
      for (r2 = n2[u3]; r2 > t2[c3 + 1].offset; )
        c3++;
      var h3 = t2[c3].offset, l2 = (r2 - h3) / (t2[c3 + 1].offset - h3), f2 = t2[c3].color, d3 = t2[c3 + 1].color;
      s3 += tt2(Math.round((1 - l2) * f2[0] + l2 * d3[0]).toString(16)) + tt2(Math.round((1 - l2) * f2[1] + l2 * d3[1]).toString(16)) + tt2(Math.round((1 - l2) * f2[2] + l2 * d3[2]).toString(16));
    }
    return s3.trim();
  }, "le"), fe2 = /* @__PURE__ */ __name(function(t2, e2) {
    e2 || (e2 = 21);
    var r2 = Xt2(), n2 = le2(t2.colors, e2), i3 = [];
    i3.push({ key: "FunctionType", value: "0" }), i3.push({ key: "Domain", value: "[0.0 1.0]" }), i3.push({ key: "Size", value: "[" + e2 + "]" }), i3.push({ key: "BitsPerSample", value: "8" }), i3.push({ key: "Range", value: "[0.0 1.0 0.0 1.0 0.0 1.0]" }), i3.push({ key: "Decode", value: "[0.0 1.0 0.0 1.0 0.0 1.0]" }), ie2({ data: n2, additionalKeyValues: i3, alreadyAppliedFilters: ["/ASCIIHexDecode"], objectId: r2 }), lt2("endobj"), t2.objectNumber = Xt2(), lt2("<< /ShadingType " + t2.type), lt2("/ColorSpace /DeviceRGB");
    var a2 = "/Coords [" + O2(parseFloat(t2.coords[0])) + " " + O2(parseFloat(t2.coords[1])) + " ";
    2 === t2.type ? a2 += O2(parseFloat(t2.coords[2])) + " " + O2(parseFloat(t2.coords[3])) : a2 += O2(parseFloat(t2.coords[2])) + " " + O2(parseFloat(t2.coords[3])) + " " + O2(parseFloat(t2.coords[4])) + " " + O2(parseFloat(t2.coords[5])), lt2(a2 += "]"), t2.matrix && lt2("/Matrix [" + t2.matrix.toString() + "]"), lt2("/Function " + r2 + " 0 R"), lt2("/Extend [true true]"), lt2(">>"), lt2("endobj");
  }, "fe"), de2 = /* @__PURE__ */ __name(function(t2, e2) {
    var r2 = Kt2(), n2 = Xt2();
    e2.push({ resourcesOid: r2, objectOid: n2 }), t2.objectNumber = n2;
    var i3 = [];
    i3.push({ key: "Type", value: "/Pattern" }), i3.push({ key: "PatternType", value: "1" }), i3.push({ key: "PaintType", value: "1" }), i3.push({ key: "TilingType", value: "1" }), i3.push({ key: "BBox", value: "[" + t2.boundingBox.map(O2).join(" ") + "]" }), i3.push({ key: "XStep", value: O2(t2.xStep) }), i3.push({ key: "YStep", value: O2(t2.yStep) }), i3.push({ key: "Resources", value: r2 + " 0 R" }), t2.matrix && i3.push({ key: "Matrix", value: "[" + t2.matrix.toString() + "]" }), ie2({ data: t2.stream, additionalKeyValues: i3, objectId: t2.objectNumber }), lt2("endobj");
  }, "de"), pe2 = /* @__PURE__ */ __name(function(t2) {
    var e2;
    for (e2 in Ot2)
      Ot2.hasOwnProperty(e2) && (Ot2[e2] instanceof B ? fe2(Ot2[e2]) : Ot2[e2] instanceof M && de2(Ot2[e2], t2));
  }, "pe"), ge2 = /* @__PURE__ */ __name(function(t2) {
    for (var e2 in t2.objectNumber = Xt2(), lt2("<<"), t2)
      switch (e2) {
        case "opacity":
          lt2("/ca " + R2(t2[e2]));
          break;
        case "stroke-opacity":
          lt2("/CA " + R2(t2[e2]));
      }
    lt2(">>"), lt2("endobj");
  }, "ge"), me2 = /* @__PURE__ */ __name(function() {
    var t2;
    for (t2 in Mt2)
      Mt2.hasOwnProperty(t2) && ge2(Mt2[t2]);
  }, "me"), ve2 = /* @__PURE__ */ __name(function() {
    for (var t2 in lt2("/XObject <<"), zt2)
      zt2.hasOwnProperty(t2) && zt2[t2].objectNumber >= 0 && lt2("/" + t2 + " " + zt2[t2].objectNumber + " 0 R");
    Tt2.publish("putXobjectDict"), lt2(">>");
  }, "ve"), be2 = /* @__PURE__ */ __name(function() {
    Ye.oid = Xt2(), lt2("<<"), lt2("/Filter /Standard"), lt2("/V " + Ye.v), lt2("/R " + Ye.r), lt2("/U <" + Ye.toHexString(Ye.U) + ">"), lt2("/O <" + Ye.toHexString(Ye.O) + ">"), lt2("/P " + Ye.P), lt2(">>"), lt2("endobj");
  }, "be"), ye2 = /* @__PURE__ */ __name(function() {
    for (var t2 in lt2("/Font <<"), Ft2)
      Ft2.hasOwnProperty(t2) && (false === v2 || true === v2 && b2.hasOwnProperty(t2)) && lt2("/" + t2 + " " + Ft2[t2].objectNumber + " 0 R");
    lt2(">>");
  }, "ye"), we2 = /* @__PURE__ */ __name(function() {
    if (Object.keys(Ot2).length > 0) {
      for (var t2 in lt2("/Shading <<"), Ot2)
        Ot2.hasOwnProperty(t2) && Ot2[t2] instanceof B && Ot2[t2].objectNumber >= 0 && lt2("/" + t2 + " " + Ot2[t2].objectNumber + " 0 R");
      Tt2.publish("putShadingPatternDict"), lt2(">>");
    }
  }, "we"), Ne2 = /* @__PURE__ */ __name(function(t2) {
    if (Object.keys(Ot2).length > 0) {
      for (var e2 in lt2("/Pattern <<"), Ot2)
        Ot2.hasOwnProperty(e2) && Ot2[e2] instanceof y2.TilingPattern && Ot2[e2].objectNumber >= 0 && Ot2[e2].objectNumber < t2 && lt2("/" + e2 + " " + Ot2[e2].objectNumber + " 0 R");
      Tt2.publish("putTilingPatternDict"), lt2(">>");
    }
  }, "Ne"), Le2 = /* @__PURE__ */ __name(function() {
    if (Object.keys(Mt2).length > 0) {
      var t2;
      for (t2 in lt2("/ExtGState <<"), Mt2)
        Mt2.hasOwnProperty(t2) && Mt2[t2].objectNumber >= 0 && lt2("/" + t2 + " " + Mt2[t2].objectNumber + " 0 R");
      Tt2.publish("putGStateDict"), lt2(">>");
    }
  }, "Le"), Ae = /* @__PURE__ */ __name(function(t2) {
    Zt2(t2.resourcesOid, true), lt2("<<"), lt2("/ProcSet [/PDF /Text /ImageB /ImageC /ImageI]"), ye2(), we2(), Ne2(t2.objectOid), Le2(), ve2(), lt2(">>"), lt2("endobj");
  }, "Ae"), xe = /* @__PURE__ */ __name(function() {
    var t2 = [];
    ce2(), me2(), he2(), pe2(t2), Tt2.publish("putResources"), t2.forEach(Ae), Ae({ resourcesOid: te2, objectOid: Number.MAX_SAFE_INTEGER }), Tt2.publish("postPutResources");
  }, "xe"), Se = /* @__PURE__ */ __name(function() {
    Tt2.publish("putAdditionalObjects");
    for (var t2 = 0; t2 < at2.length; t2++) {
      var e2 = at2[t2];
      Zt2(e2.objId, true), lt2(e2.content), lt2("endobj");
    }
    Tt2.publish("postPutAdditionalObjects");
  }, "Se"), _e = /* @__PURE__ */ __name(function(t2) {
    Ct2[t2.fontName] = Ct2[t2.fontName] || {}, Ct2[t2.fontName][t2.fontStyle] = t2.id;
  }, "_e"), Pe = /* @__PURE__ */ __name(function(t2, e2, r2, n2, i3) {
    var a2 = { id: "F" + (Object.keys(Ft2).length + 1).toString(10), postScriptName: t2, fontName: e2, fontStyle: r2, encoding: n2, isStandardFont: i3 || false, metadata: {} };
    return Tt2.publish("addFont", { font: a2, instance: this }), Ft2[a2.id] = a2, _e(a2), a2.id;
  }, "Pe"), ke = /* @__PURE__ */ __name(function(t2) {
    for (var e2 = 0, r2 = pt2.length; e2 < r2; e2++) {
      var n2 = Pe.call(this, t2[e2][0], t2[e2][1], t2[e2][2], pt2[e2][3], true);
      false === v2 && (b2[n2] = true);
      var i3 = t2[e2][0].split("-");
      _e({ id: n2, fontName: i3[0], fontStyle: i3[1] || "" });
    }
    Tt2.publish("addFonts", { fonts: Ft2, dictionary: Ct2 });
  }, "ke"), Ie = /* @__PURE__ */ __name(function(t2) {
    return t2.foo = function() {
      try {
        return t2.apply(this, arguments);
      } catch (t3) {
        var e2 = t3.stack || "";
        ~e2.indexOf(" at ") && (e2 = e2.split(" at ")[1]);
        var r2 = "Error in function " + e2.split("\n")[0].split("<")[0] + ": " + t3.message;
        if (!n.console)
          throw new Error(r2);
        n.console.error(r2, t3), n.alert && alert(r2);
      }
    }, t2.foo.bar = t2, t2.foo;
  }, "Ie"), Fe = /* @__PURE__ */ __name(function(t2, e2) {
    var r2, n2, i3, a2, o3, s3, c3, u3, h3;
    if (i3 = (e2 = e2 || {}).sourceEncoding || "Unicode", o3 = e2.outputEncoding, (e2.autoencode || o3) && Ft2[St2].metadata && Ft2[St2].metadata[i3] && Ft2[St2].metadata[i3].encoding && (a2 = Ft2[St2].metadata[i3].encoding, !o3 && Ft2[St2].encoding && (o3 = Ft2[St2].encoding), !o3 && a2.codePages && (o3 = a2.codePages[0]), "string" == typeof o3 && (o3 = a2[o3]), o3)) {
      for (c3 = false, s3 = [], r2 = 0, n2 = t2.length; r2 < n2; r2++)
        (u3 = o3[t2.charCodeAt(r2)]) ? s3.push(String.fromCharCode(u3)) : s3.push(t2[r2]), s3[r2].charCodeAt(0) >> 8 && (c3 = true);
      t2 = s3.join("");
    }
    for (r2 = t2.length; void 0 === c3 && 0 !== r2; )
      t2.charCodeAt(r2 - 1) >> 8 && (c3 = true), r2--;
    if (!c3)
      return t2;
    for (s3 = e2.noBOM ? [] : [254, 255], r2 = 0, n2 = t2.length; r2 < n2; r2++) {
      if ((h3 = (u3 = t2.charCodeAt(r2)) >> 8) >> 8)
        throw new Error("Character at position " + r2 + " of string '" + t2 + "' exceeds 16bits. Cannot be encoded into UCS-2 BE");
      s3.push(h3), s3.push(u3 - (h3 << 8));
    }
    return String.fromCharCode.apply(void 0, s3);
  }, "Fe"), Ce = y2.__private__.pdfEscape = y2.pdfEscape = function(t2, e2) {
    return Fe(t2, e2).replace(/\\/g, "\\\\").replace(/\(/g, "\\(").replace(/\)/g, "\\)");
  }, je = y2.__private__.beginPage = function(t2) {
    ot2[++Dt2] = [], Rt2[Dt2] = { objId: 0, contentsObjId: 0, userUnit: Number(d2), artBox: null, bleedBox: null, cropBox: null, trimBox: null, mediaBox: { bottomLeftX: 0, bottomLeftY: 0, topRightX: Number(t2[0]), topRightY: Number(t2[1]) } }, Me(Dt2), ht2(ot2[$2]);
  }, Oe = /* @__PURE__ */ __name(function(t2, e2) {
    var r2, n2, o3;
    switch (i2 = e2 || i2, "string" == typeof t2 && (r2 = A2(t2.toLowerCase()), Array.isArray(r2) && (n2 = r2[0], o3 = r2[1])), Array.isArray(t2) && (n2 = t2[0] * _t2, o3 = t2[1] * _t2), isNaN(n2) && (n2 = s2[0], o3 = s2[1]), (n2 > 14400 || o3 > 14400) && (a.warn("A page in a PDF can not be wider or taller than 14400 userUnit. jsPDF limits the width/height to 14400"), n2 = Math.min(14400, n2), o3 = Math.min(14400, o3)), s2 = [n2, o3], i2.substr(0, 1)) {
      case "l":
        o3 > n2 && (s2 = [o3, n2]);
        break;
      case "p":
        n2 > o3 && (s2 = [o3, n2]);
    }
    je(s2), pr(fr), lt2(Lr), 0 !== kr && lt2(kr + " J"), 0 !== Ir && lt2(Ir + " j"), Tt2.publish("addPage", { pageNumber: Dt2 });
  }, "Oe"), Be = /* @__PURE__ */ __name(function(t2) {
    t2 > 0 && t2 <= Dt2 && (ot2.splice(t2, 1), Rt2.splice(t2, 1), Dt2--, $2 > Dt2 && ($2 = Dt2), this.setPage($2));
  }, "Be"), Me = /* @__PURE__ */ __name(function(t2) {
    t2 > 0 && t2 <= Dt2 && ($2 = t2);
  }, "Me"), Ee = y2.__private__.getNumberOfPages = y2.getNumberOfPages = function() {
    return ot2.length - 1;
  }, qe = /* @__PURE__ */ __name(function(t2, e2, r2) {
    var n2, i3 = void 0;
    return r2 = r2 || {}, t2 = void 0 !== t2 ? t2 : Ft2[St2].fontName, e2 = void 0 !== e2 ? e2 : Ft2[St2].fontStyle, n2 = t2.toLowerCase(), void 0 !== Ct2[n2] && void 0 !== Ct2[n2][e2] ? i3 = Ct2[n2][e2] : void 0 !== Ct2[t2] && void 0 !== Ct2[t2][e2] ? i3 = Ct2[t2][e2] : false === r2.disableWarning && a.warn("Unable to look up font label for font '" + t2 + "', '" + e2 + "'. Refer to getFontList() for available fonts."), i3 || r2.noFallback || null == (i3 = Ct2.times[e2]) && (i3 = Ct2.times.normal), i3;
  }, "qe"), De = y2.__private__.putInfo = function() {
    var t2 = Xt2(), e2 = /* @__PURE__ */ __name(function(t3) {
      return t3;
    }, "e");
    for (var r2 in null !== m2 && (e2 = Ye.encryptor(t2, 0)), lt2("<<"), lt2("/Producer (" + Ce(e2("jsPDF " + E.version)) + ")"), xt2)
      xt2.hasOwnProperty(r2) && xt2[r2] && lt2("/" + r2.substr(0, 1).toUpperCase() + r2.substr(1) + " (" + Ce(e2(xt2[r2])) + ")");
    lt2("/CreationDate (" + Ce(e2(W2)) + ")"), lt2(">>"), lt2("endobj");
  }, Re = y2.__private__.putCatalog = function(t2) {
    var e2 = (t2 = t2 || {}).rootDictionaryObjId || Qt2;
    switch (Xt2(), lt2("<<"), lt2("/Type /Catalog"), lt2("/Pages " + e2 + " 0 R"), mt2 || (mt2 = "fullwidth"), mt2) {
      case "fullwidth":
        lt2("/OpenAction [3 0 R /FitH null]");
        break;
      case "fullheight":
        lt2("/OpenAction [3 0 R /FitV null]");
        break;
      case "fullpage":
        lt2("/OpenAction [3 0 R /Fit]");
        break;
      case "original":
        lt2("/OpenAction [3 0 R /XYZ null null 1]");
        break;
      default:
        var r2 = "" + mt2;
        "%" === r2.substr(r2.length - 1) && (mt2 = parseInt(mt2) / 100), "number" == typeof mt2 && lt2("/OpenAction [3 0 R /XYZ null null " + R2(mt2) + "]");
    }
    switch (Nt2 || (Nt2 = "continuous"), Nt2) {
      case "continuous":
        lt2("/PageLayout /OneColumn");
        break;
      case "single":
        lt2("/PageLayout /SinglePage");
        break;
      case "two":
      case "twoleft":
        lt2("/PageLayout /TwoColumnLeft");
        break;
      case "tworight":
        lt2("/PageLayout /TwoColumnRight");
    }
    yt2 && lt2("/PageMode /" + yt2), Tt2.publish("putCatalog"), lt2(">>"), lt2("endobj");
  }, Te = y2.__private__.putTrailer = function() {
    lt2("trailer"), lt2("<<"), lt2("/Size " + (et2 + 1)), lt2("/Root " + et2 + " 0 R"), lt2("/Info " + (et2 - 1) + " 0 R"), null !== m2 && lt2("/Encrypt " + Ye.oid + " 0 R"), lt2("/ID [ <" + V2 + "> <" + V2 + "> ]"), lt2(">>");
  }, Ue = y2.__private__.putHeader = function() {
    lt2("%PDF-" + w2), lt2("%");
  }, ze = y2.__private__.putXRef = function() {
    var t2 = "0000000000";
    lt2("xref"), lt2("0 " + (et2 + 1)), lt2("0000000000 65535 f ");
    for (var e2 = 1; e2 <= et2; e2++) {
      "function" == typeof rt2[e2] ? lt2((t2 + rt2[e2]()).slice(-10) + " 00000 n ") : void 0 !== rt2[e2] ? lt2((t2 + rt2[e2]).slice(-10) + " 00000 n ") : lt2("0000000000 00000 n ");
    }
  }, He = y2.__private__.buildDocument = function() {
    ut2(), ht2(nt2), Tt2.publish("buildDocument"), Ue(), oe2(), Se(), xe(), null !== m2 && be2(), De(), Re();
    var t2 = it2;
    return ze(), Te(), lt2("startxref"), lt2("" + t2), lt2("%%EOF"), ht2(ot2[$2]), nt2.join("\n");
  }, We = y2.__private__.getBlob = function(t2) {
    return new Blob([dt2(t2)], { type: "application/pdf" });
  }, Ve = y2.output = y2.__private__.output = Ie(function(t2, e2) {
    switch ("string" == typeof (e2 = e2 || {}) ? e2 = { filename: e2 } : e2.filename = e2.filename || "generated.pdf", t2) {
      case void 0:
        return He();
      case "save":
        y2.save(e2.filename);
        break;
      case "arraybuffer":
        return dt2(He());
      case "blob":
        return We(He());
      case "bloburi":
      case "bloburl":
        if (void 0 !== n.URL && "function" == typeof n.URL.createObjectURL)
          return n.URL && n.URL.createObjectURL(We(He())) || void 0;
        a.warn("bloburl is not supported by your system, because URL.createObjectURL is not supported by your browser.");
        break;
      case "datauristring":
      case "dataurlstring":
        var r2 = "", i3 = He();
        try {
          r2 = h(i3);
        } catch (t3) {
          r2 = h(unescape(encodeURIComponent(i3)));
        }
        return "data:application/pdf;filename=" + e2.filename + ";base64," + r2;
      case "pdfobjectnewwindow":
        if ("[object Window]" === Object.prototype.toString.call(n)) {
          var o3 = "https://cdnjs.cloudflare.com/ajax/libs/pdfobject/2.1.1/pdfobject.min.js", s3 = ' integrity="sha512-4ze/a9/4jqu+tX9dfOqJYSvyYd5M6qum/3HpCLr+/Jqf0whc37VUbkpNGHR7/8pSnCFw47T1fmIpwBV7UySh3g==" crossorigin="anonymous"';
          e2.pdfObjectUrl && (o3 = e2.pdfObjectUrl, s3 = "");
          var c3 = '<html><style>html, body { padding: 0; margin: 0; } iframe { width: 100%; height: 100%; border: 0;}  </style><body><script src="' + o3 + '"' + s3 + '><\/script><script >PDFObject.embed("' + this.output("dataurlstring") + '", ' + JSON.stringify(e2) + ");<\/script></body></html>", u3 = n.open();
          return null !== u3 && u3.document.write(c3), u3;
        }
        throw new Error("The option pdfobjectnewwindow just works in a browser-environment.");
      case "pdfjsnewwindow":
        if ("[object Window]" === Object.prototype.toString.call(n)) {
          var l2 = '<html><style>html, body { padding: 0; margin: 0; } iframe { width: 100%; height: 100%; border: 0;}  </style><body><iframe id="pdfViewer" src="' + (e2.pdfJsUrl || "examples/PDF.js/web/viewer.html") + "?file=&downloadName=" + e2.filename + '" width="500px" height="400px" /></body></html>', f2 = n.open();
          if (null !== f2) {
            f2.document.write(l2);
            var d3 = this;
            f2.document.documentElement.querySelector("#pdfViewer").onload = function() {
              f2.document.title = e2.filename, f2.document.documentElement.querySelector("#pdfViewer").contentWindow.PDFViewerApplication.open(d3.output("bloburl"));
            };
          }
          return f2;
        }
        throw new Error("The option pdfjsnewwindow just works in a browser-environment.");
      case "dataurlnewwindow":
        if ("[object Window]" !== Object.prototype.toString.call(n))
          throw new Error("The option dataurlnewwindow just works in a browser-environment.");
        var p3 = '<html><style>html, body { padding: 0; margin: 0; } iframe { width: 100%; height: 100%; border: 0;}  </style><body><iframe src="' + this.output("datauristring", e2) + '"></iframe></body></html>', g3 = n.open();
        if (null !== g3 && (g3.document.write(p3), g3.document.title = e2.filename), g3 || "undefined" == typeof safari)
          return g3;
        break;
      case "datauri":
      case "dataurl":
        return n.document.location.href = this.output("datauristring", e2);
      default:
        return null;
    }
  }), Ge = /* @__PURE__ */ __name(function(t2) {
    return true === Array.isArray(Ut2) && Ut2.indexOf(t2) > -1;
  }, "Ge");
  switch (o2) {
    case "pt":
      _t2 = 1;
      break;
    case "mm":
      _t2 = 72 / 25.4;
      break;
    case "cm":
      _t2 = 72 / 2.54;
      break;
    case "in":
      _t2 = 72;
      break;
    case "px":
      _t2 = 1 == Ge("px_scaling") ? 0.75 : 96 / 72;
      break;
    case "pc":
    case "em":
      _t2 = 12;
      break;
    case "ex":
      _t2 = 6;
      break;
    default:
      if ("number" != typeof o2)
        throw new Error("Invalid unit: " + o2);
      _t2 = o2;
  }
  var Ye = null;
  K2(), Y2();
  var Je = /* @__PURE__ */ __name(function(t2) {
    return null !== m2 ? Ye.encryptor(t2, 0) : function(t3) {
      return t3;
    };
  }, "Je"), Xe = y2.__private__.getPageInfo = y2.getPageInfo = function(t2) {
    if (isNaN(t2) || t2 % 1 != 0)
      throw new Error("Invalid argument passed to jsPDF.getPageInfo");
    return { objId: Rt2[t2].objId, pageNumber: t2, pageContext: Rt2[t2] };
  }, Ke = y2.__private__.getPageInfoByObjId = function(t2) {
    if (isNaN(t2) || t2 % 1 != 0)
      throw new Error("Invalid argument passed to jsPDF.getPageInfoByObjId");
    for (var e2 in Rt2)
      if (Rt2[e2].objId === t2)
        break;
    return Xe(e2);
  }, Ze = y2.__private__.getCurrentPageInfo = y2.getCurrentPageInfo = function() {
    return { objId: Rt2[$2].objId, pageNumber: $2, pageContext: Rt2[$2] };
  };
  y2.addPage = function() {
    return Oe.apply(this, arguments), this;
  }, y2.setPage = function() {
    return Me.apply(this, arguments), ht2.call(this, ot2[$2]), this;
  }, y2.insertPage = function(t2) {
    return this.addPage(), this.movePage($2, t2), this;
  }, y2.movePage = function(t2, e2) {
    var r2, n2;
    if (t2 > e2) {
      r2 = ot2[t2], n2 = Rt2[t2];
      for (var i3 = t2; i3 > e2; i3--)
        ot2[i3] = ot2[i3 - 1], Rt2[i3] = Rt2[i3 - 1];
      ot2[e2] = r2, Rt2[e2] = n2, this.setPage(e2);
    } else if (t2 < e2) {
      r2 = ot2[t2], n2 = Rt2[t2];
      for (var a2 = t2; a2 < e2; a2++)
        ot2[a2] = ot2[a2 + 1], Rt2[a2] = Rt2[a2 + 1];
      ot2[e2] = r2, Rt2[e2] = n2, this.setPage(e2);
    }
    return this;
  }, y2.deletePage = function() {
    return Be.apply(this, arguments), this;
  }, y2.__private__.text = y2.text = function(e2, r2, n2, i3, a2) {
    var o3, s3, c3, u3, h3, l2, f2, d3, p3, g3 = (i3 = i3 || {}).scope || this;
    if ("number" == typeof e2 && "number" == typeof r2 && ("string" == typeof n2 || Array.isArray(n2))) {
      var m3 = n2;
      n2 = r2, r2 = e2, e2 = m3;
    }
    if (arguments[3] instanceof Vt2 == false ? (c3 = arguments[4], u3 = arguments[5], "object" === _typeof(f2 = arguments[3]) && null !== f2 || ("string" == typeof c3 && (u3 = c3, c3 = null), "string" == typeof f2 && (u3 = f2, f2 = null), "number" == typeof f2 && (c3 = f2, f2 = null), i3 = { flags: f2, angle: c3, align: u3 })) : (q2("The transform parameter of text() with a Matrix value"), p3 = a2), isNaN(r2) || isNaN(n2) || null == e2)
      throw new Error("Invalid arguments passed to jsPDF.text");
    if (0 === e2.length)
      return g3;
    var v3 = "", y3 = false, w3 = "number" == typeof i3.lineHeightFactor ? i3.lineHeightFactor : lr, N3 = g3.internal.scaleFactor;
    function L3(t2) {
      return t2 = t2.split("	").join(Array(i3.TabLen || 9).join(" ")), Ce(t2, f2);
    }
    __name(L3, "L");
    function A3(t2) {
      for (var e3, r3 = t2.concat(), n3 = [], i4 = r3.length; i4--; )
        "string" == typeof (e3 = r3.shift()) ? n3.push(e3) : Array.isArray(t2) && (1 === e3.length || void 0 === e3[1] && void 0 === e3[2]) ? n3.push(e3[0]) : n3.push([e3[0], e3[1], e3[2]]);
      return n3;
    }
    __name(A3, "A");
    function _3(t2, e3) {
      var r3;
      if ("string" == typeof t2)
        r3 = e3(t2)[0];
      else if (Array.isArray(t2)) {
        for (var n3, i4, a3 = t2.concat(), o4 = [], s4 = a3.length; s4--; )
          "string" == typeof (n3 = a3.shift()) ? o4.push(e3(n3)[0]) : Array.isArray(n3) && "string" == typeof n3[0] && (i4 = e3(n3[0], n3[1], n3[2]), o4.push([i4[0], i4[1], i4[2]]));
        r3 = o4;
      }
      return r3;
    }
    __name(_3, "_");
    var P3 = false, k3 = true;
    if ("string" == typeof e2)
      P3 = true;
    else if (Array.isArray(e2)) {
      var I2 = e2.concat();
      s3 = [];
      for (var F2, C2 = I2.length; C2--; )
        ("string" != typeof (F2 = I2.shift()) || Array.isArray(F2) && "string" != typeof F2[0]) && (k3 = false);
      P3 = k3;
    }
    if (false === P3)
      throw new Error('Type of text must be string or Array. "' + e2 + '" is not recognized.');
    "string" == typeof e2 && (e2 = e2.match(/[\r?\n]/) ? e2.split(/\r\n|\r|\n/g) : [e2]);
    var j2 = gt2 / g3.internal.scaleFactor, B2 = j2 * (w3 - 1);
    switch (i3.baseline) {
      case "bottom":
        n2 -= B2;
        break;
      case "top":
        n2 += j2 - B2;
        break;
      case "hanging":
        n2 += j2 - 2 * B2;
        break;
      case "middle":
        n2 += j2 / 2 - B2;
    }
    if ((l2 = i3.maxWidth || 0) > 0 && ("string" == typeof e2 ? e2 = g3.splitTextToSize(e2, l2) : "[object Array]" === Object.prototype.toString.call(e2) && (e2 = e2.reduce(function(t2, e3) {
      return t2.concat(g3.splitTextToSize(e3, l2));
    }, []))), o3 = { text: e2, x: r2, y: n2, options: i3, mutex: { pdfEscape: Ce, activeFontKey: St2, fonts: Ft2, activeFontSize: gt2 } }, Tt2.publish("preProcessText", o3), e2 = o3.text, c3 = (i3 = o3.options).angle, p3 instanceof Vt2 == false && c3 && "number" == typeof c3) {
      c3 *= Math.PI / 180, 0 === i3.rotationDirection && (c3 = -c3), S2 === x2.ADVANCED && (c3 = -c3);
      var M2 = Math.cos(c3), E2 = Math.sin(c3);
      p3 = new Vt2(M2, E2, -E2, M2, 0, 0);
    } else
      c3 && c3 instanceof Vt2 && (p3 = c3);
    S2 !== x2.ADVANCED || p3 || (p3 = Yt2), void 0 !== (h3 = i3.charSpace || _r) && (v3 += O2(U2(h3)) + " Tc\n", this.setCharSpace(this.getCharSpace() || 0)), void 0 !== (d3 = i3.horizontalScale) && (v3 += O2(100 * d3) + " Tz\n");
    i3.lang;
    var D3 = -1, R3 = void 0 !== i3.renderingMode ? i3.renderingMode : i3.stroke, T3 = g3.internal.getCurrentPageInfo().pageContext;
    switch (R3) {
      case 0:
      case false:
      case "fill":
        D3 = 0;
        break;
      case 1:
      case true:
      case "stroke":
        D3 = 1;
        break;
      case 2:
      case "fillThenStroke":
        D3 = 2;
        break;
      case 3:
      case "invisible":
        D3 = 3;
        break;
      case 4:
      case "fillAndAddForClipping":
        D3 = 4;
        break;
      case 5:
      case "strokeAndAddPathForClipping":
        D3 = 5;
        break;
      case 6:
      case "fillThenStrokeAndAddToPathForClipping":
        D3 = 6;
        break;
      case 7:
      case "addToPathForClipping":
        D3 = 7;
    }
    var z3 = void 0 !== T3.usedRenderingMode ? T3.usedRenderingMode : -1;
    -1 !== D3 ? v3 += D3 + " Tr\n" : -1 !== z3 && (v3 += "0 Tr\n"), -1 !== D3 && (T3.usedRenderingMode = D3), u3 = i3.align || "left";
    var H3, W3 = gt2 * w3, V3 = g3.internal.pageSize.getWidth(), G3 = Ft2[St2];
    h3 = i3.charSpace || _r, l2 = i3.maxWidth || 0, f2 = Object.assign({ autoencode: true, noBOM: true }, i3.flags);
    var Y3 = [], J3 = /* @__PURE__ */ __name(function(t2) {
      return g3.getStringUnitWidth(t2, { font: G3, charSpace: h3, fontSize: gt2, doKerning: false }) * gt2 / N3;
    }, "J");
    if ("[object Array]" === Object.prototype.toString.call(e2)) {
      var X3;
      s3 = A3(e2), "left" !== u3 && (H3 = s3.map(J3));
      var K3, Z3 = 0;
      if ("right" === u3) {
        r2 -= H3[0], e2 = [], C2 = s3.length;
        for (var $3 = 0; $3 < C2; $3++)
          0 === $3 ? (K3 = br(r2), X3 = yr(n2)) : (K3 = U2(Z3 - H3[$3]), X3 = -W3), e2.push([s3[$3], K3, X3]), Z3 = H3[$3];
      } else if ("center" === u3) {
        r2 -= H3[0] / 2, e2 = [], C2 = s3.length;
        for (var Q3 = 0; Q3 < C2; Q3++)
          0 === Q3 ? (K3 = br(r2), X3 = yr(n2)) : (K3 = U2((Z3 - H3[Q3]) / 2), X3 = -W3), e2.push([s3[Q3], K3, X3]), Z3 = H3[Q3];
      } else if ("left" === u3) {
        e2 = [], C2 = s3.length;
        for (var tt3 = 0; tt3 < C2; tt3++)
          e2.push(s3[tt3]);
      } else if ("justify" === u3 && "Identity-H" === G3.encoding) {
        e2 = [], C2 = s3.length, l2 = 0 !== l2 ? l2 : V3;
        for (var et3 = 0, rt3 = 0; rt3 < C2; rt3++)
          if (X3 = 0 === rt3 ? yr(n2) : -W3, K3 = 0 === rt3 ? br(r2) : et3, rt3 < C2 - 1) {
            var nt3 = U2((l2 - H3[rt3]) / (s3[rt3].split(" ").length - 1)), it3 = s3[rt3].split(" ");
            e2.push([it3[0] + " ", K3, X3]), et3 = 0;
            for (var at3 = 1; at3 < it3.length; at3++) {
              var ot3 = (J3(it3[at3 - 1] + " " + it3[at3]) - J3(it3[at3])) * N3 + nt3;
              at3 == it3.length - 1 ? e2.push([it3[at3], ot3, 0]) : e2.push([it3[at3] + " ", ot3, 0]), et3 -= ot3;
            }
          } else
            e2.push([s3[rt3], K3, X3]);
        e2.push(["", et3, 0]);
      } else {
        if ("justify" !== u3)
          throw new Error('Unrecognized alignment option, use "left", "center", "right" or "justify".');
        e2 = [], C2 = s3.length, l2 = 0 !== l2 ? l2 : V3;
        for (rt3 = 0; rt3 < C2; rt3++)
          X3 = 0 === rt3 ? yr(n2) : -W3, K3 = 0 === rt3 ? br(r2) : 0, rt3 < C2 - 1 ? Y3.push(O2(U2((l2 - H3[rt3]) / (s3[rt3].split(" ").length - 1)))) : Y3.push(0), e2.push([s3[rt3], K3, X3]);
      }
    }
    var st3 = "boolean" == typeof i3.R2L ? i3.R2L : bt2;
    true === st3 && (e2 = _3(e2, function(t2, e3, r3) {
      return [t2.split("").reverse().join(""), e3, r3];
    })), o3 = { text: e2, x: r2, y: n2, options: i3, mutex: { pdfEscape: Ce, activeFontKey: St2, fonts: Ft2, activeFontSize: gt2 } }, Tt2.publish("postProcessText", o3), e2 = o3.text, y3 = o3.mutex.isHex || false;
    var ct3 = Ft2[St2].encoding;
    "WinAnsiEncoding" !== ct3 && "StandardEncoding" !== ct3 || (e2 = _3(e2, function(t2, e3, r3) {
      return [L3(t2), e3, r3];
    })), s3 = A3(e2), e2 = [];
    for (var ut3, ht3, ft3, dt3 = 0, pt3 = 1, mt3 = Array.isArray(s3[0]) ? pt3 : dt3, vt3 = "", yt3 = function(t2, e3, r3) {
      var n3 = "";
      return r3 instanceof Vt2 ? (r3 = "number" == typeof i3.angle ? Gt2(r3, new Vt2(1, 0, 0, 1, t2, e3)) : Gt2(new Vt2(1, 0, 0, 1, t2, e3), r3), S2 === x2.ADVANCED && (r3 = Gt2(new Vt2(1, 0, 0, -1, 0, 0), r3)), n3 = r3.join(" ") + " Tm\n") : n3 = O2(t2) + " " + O2(e3) + " Td\n", n3;
    }, wt3 = 0; wt3 < s3.length; wt3++) {
      switch (vt3 = "", mt3) {
        case pt3:
          ft3 = (y3 ? "<" : "(") + s3[wt3][0] + (y3 ? ">" : ")"), ut3 = parseFloat(s3[wt3][1]), ht3 = parseFloat(s3[wt3][2]);
          break;
        case dt3:
          ft3 = (y3 ? "<" : "(") + s3[wt3] + (y3 ? ">" : ")"), ut3 = br(r2), ht3 = yr(n2);
      }
      void 0 !== Y3 && void 0 !== Y3[wt3] && (vt3 = Y3[wt3] + " Tw\n"), 0 === wt3 ? e2.push(vt3 + yt3(ut3, ht3, p3) + ft3) : mt3 === dt3 ? e2.push(vt3 + ft3) : mt3 === pt3 && e2.push(vt3 + yt3(ut3, ht3, p3) + ft3);
    }
    e2 = mt3 === dt3 ? e2.join(" Tj\nT* ") : e2.join(" Tj\n"), e2 += " Tj\n";
    var Nt3 = "BT\n/";
    return Nt3 += St2 + " " + gt2 + " Tf\n", Nt3 += O2(gt2 * w3) + " TL\n", Nt3 += xr + "\n", Nt3 += v3, Nt3 += e2, lt2(Nt3 += "ET"), b2[St2] = true, g3;
  };
  var $e = y2.__private__.clip = y2.clip = function(t2) {
    return lt2("evenodd" === t2 ? "W*" : "W"), this;
  };
  y2.clipEvenOdd = function() {
    return $e("evenodd");
  }, y2.__private__.discardPath = y2.discardPath = function() {
    return lt2("n"), this;
  };
  var Qe = y2.__private__.isValidStyle = function(t2) {
    var e2 = false;
    return -1 !== [void 0, null, "S", "D", "F", "DF", "FD", "f", "f*", "B", "B*", "n"].indexOf(t2) && (e2 = true), e2;
  };
  y2.__private__.setDefaultPathOperation = y2.setDefaultPathOperation = function(t2) {
    return Qe(t2) && (g2 = t2), this;
  };
  var tr = y2.__private__.getStyle = y2.getStyle = function(t2) {
    var e2 = g2;
    switch (t2) {
      case "D":
      case "S":
        e2 = "S";
        break;
      case "F":
        e2 = "f";
        break;
      case "FD":
      case "DF":
        e2 = "B";
        break;
      case "f":
      case "f*":
      case "B":
      case "B*":
        e2 = t2;
    }
    return e2;
  }, er = y2.close = function() {
    return lt2("h"), this;
  };
  y2.stroke = function() {
    return lt2("S"), this;
  }, y2.fill = function(t2) {
    return rr("f", t2), this;
  }, y2.fillEvenOdd = function(t2) {
    return rr("f*", t2), this;
  }, y2.fillStroke = function(t2) {
    return rr("B", t2), this;
  }, y2.fillStrokeEvenOdd = function(t2) {
    return rr("B*", t2), this;
  };
  var rr = /* @__PURE__ */ __name(function(e2, r2) {
    "object" === _typeof(r2) ? ar(r2, e2) : lt2(e2);
  }, "rr"), nr = /* @__PURE__ */ __name(function(t2) {
    null === t2 || S2 === x2.ADVANCED && void 0 === t2 || (t2 = tr(t2), lt2(t2));
  }, "nr");
  function ir(t2, e2, r2, n2, i3) {
    var a2 = new M(e2 || this.boundingBox, r2 || this.xStep, n2 || this.yStep, this.gState, i3 || this.matrix);
    a2.stream = this.stream;
    var o3 = t2 + "$$" + this.cloneIndex++ + "$$";
    return Jt2(o3, a2), a2;
  }
  __name(ir, "ir");
  var ar = /* @__PURE__ */ __name(function(t2, e2) {
    var r2 = Bt2[t2.key], n2 = Ot2[r2];
    if (n2 instanceof B)
      lt2("q"), lt2(or(e2)), n2.gState && y2.setGState(n2.gState), lt2(t2.matrix.toString() + " cm"), lt2("/" + r2 + " sh"), lt2("Q");
    else if (n2 instanceof M) {
      var i3 = new Vt2(1, 0, 0, -1, 0, Rr());
      t2.matrix && (i3 = i3.multiply(t2.matrix || Yt2), r2 = ir.call(n2, t2.key, t2.boundingBox, t2.xStep, t2.yStep, i3).id), lt2("q"), lt2("/Pattern cs"), lt2("/" + r2 + " scn"), n2.gState && y2.setGState(n2.gState), lt2(e2), lt2("Q");
    }
  }, "ar"), or = /* @__PURE__ */ __name(function(t2) {
    switch (t2) {
      case "f":
      case "F":
        return "W n";
      case "f*":
        return "W* n";
      case "B":
        return "W S";
      case "B*":
        return "W* S";
      case "S":
        return "W S";
      case "n":
        return "W n";
    }
  }, "or"), sr = y2.moveTo = function(t2, e2) {
    return lt2(O2(U2(t2)) + " " + O2(H2(e2)) + " m"), this;
  }, cr = y2.lineTo = function(t2, e2) {
    return lt2(O2(U2(t2)) + " " + O2(H2(e2)) + " l"), this;
  }, ur = y2.curveTo = function(t2, e2, r2, n2, i3, a2) {
    return lt2([O2(U2(t2)), O2(H2(e2)), O2(U2(r2)), O2(H2(n2)), O2(U2(i3)), O2(H2(a2)), "c"].join(" ")), this;
  };
  y2.__private__.line = y2.line = function(t2, e2, r2, n2, i3) {
    if (isNaN(t2) || isNaN(e2) || isNaN(r2) || isNaN(n2) || !Qe(i3))
      throw new Error("Invalid arguments passed to jsPDF.line");
    return S2 === x2.COMPAT ? this.lines([[r2 - t2, n2 - e2]], t2, e2, [1, 1], i3 || "S") : this.lines([[r2 - t2, n2 - e2]], t2, e2, [1, 1]).stroke();
  }, y2.__private__.lines = y2.lines = function(t2, e2, r2, n2, i3, a2) {
    var o3, s3, c3, u3, h3, l2, f2, d3, p3, g3, m3, v3;
    if ("number" == typeof t2 && (v3 = r2, r2 = e2, e2 = t2, t2 = v3), n2 = n2 || [1, 1], a2 = a2 || false, isNaN(e2) || isNaN(r2) || !Array.isArray(t2) || !Array.isArray(n2) || !Qe(i3) || "boolean" != typeof a2)
      throw new Error("Invalid arguments passed to jsPDF.lines");
    for (sr(e2, r2), o3 = n2[0], s3 = n2[1], u3 = t2.length, g3 = e2, m3 = r2, c3 = 0; c3 < u3; c3++)
      2 === (h3 = t2[c3]).length ? (g3 = h3[0] * o3 + g3, m3 = h3[1] * s3 + m3, cr(g3, m3)) : (l2 = h3[0] * o3 + g3, f2 = h3[1] * s3 + m3, d3 = h3[2] * o3 + g3, p3 = h3[3] * s3 + m3, g3 = h3[4] * o3 + g3, m3 = h3[5] * s3 + m3, ur(l2, f2, d3, p3, g3, m3));
    return a2 && er(), nr(i3), this;
  }, y2.path = function(t2) {
    for (var e2 = 0; e2 < t2.length; e2++) {
      var r2 = t2[e2], n2 = r2.c;
      switch (r2.op) {
        case "m":
          sr(n2[0], n2[1]);
          break;
        case "l":
          cr(n2[0], n2[1]);
          break;
        case "c":
          ur.apply(this, n2);
          break;
        case "h":
          er();
      }
    }
    return this;
  }, y2.__private__.rect = y2.rect = function(t2, e2, r2, n2, i3) {
    if (isNaN(t2) || isNaN(e2) || isNaN(r2) || isNaN(n2) || !Qe(i3))
      throw new Error("Invalid arguments passed to jsPDF.rect");
    return S2 === x2.COMPAT && (n2 = -n2), lt2([O2(U2(t2)), O2(H2(e2)), O2(U2(r2)), O2(U2(n2)), "re"].join(" ")), nr(i3), this;
  }, y2.__private__.triangle = y2.triangle = function(t2, e2, r2, n2, i3, a2, o3) {
    if (isNaN(t2) || isNaN(e2) || isNaN(r2) || isNaN(n2) || isNaN(i3) || isNaN(a2) || !Qe(o3))
      throw new Error("Invalid arguments passed to jsPDF.triangle");
    return this.lines([[r2 - t2, n2 - e2], [i3 - r2, a2 - n2], [t2 - i3, e2 - a2]], t2, e2, [1, 1], o3, true), this;
  }, y2.__private__.roundedRect = y2.roundedRect = function(t2, e2, r2, n2, i3, a2, o3) {
    if (isNaN(t2) || isNaN(e2) || isNaN(r2) || isNaN(n2) || isNaN(i3) || isNaN(a2) || !Qe(o3))
      throw new Error("Invalid arguments passed to jsPDF.roundedRect");
    var s3 = 4 / 3 * (Math.SQRT2 - 1);
    return i3 = Math.min(i3, 0.5 * r2), a2 = Math.min(a2, 0.5 * n2), this.lines([[r2 - 2 * i3, 0], [i3 * s3, 0, i3, a2 - a2 * s3, i3, a2], [0, n2 - 2 * a2], [0, a2 * s3, -i3 * s3, a2, -i3, a2], [2 * i3 - r2, 0], [-i3 * s3, 0, -i3, -a2 * s3, -i3, -a2], [0, 2 * a2 - n2], [0, -a2 * s3, i3 * s3, -a2, i3, -a2]], t2 + i3, e2, [1, 1], o3, true), this;
  }, y2.__private__.ellipse = y2.ellipse = function(t2, e2, r2, n2, i3) {
    if (isNaN(t2) || isNaN(e2) || isNaN(r2) || isNaN(n2) || !Qe(i3))
      throw new Error("Invalid arguments passed to jsPDF.ellipse");
    var a2 = 4 / 3 * (Math.SQRT2 - 1) * r2, o3 = 4 / 3 * (Math.SQRT2 - 1) * n2;
    return sr(t2 + r2, e2), ur(t2 + r2, e2 - o3, t2 + a2, e2 - n2, t2, e2 - n2), ur(t2 - a2, e2 - n2, t2 - r2, e2 - o3, t2 - r2, e2), ur(t2 - r2, e2 + o3, t2 - a2, e2 + n2, t2, e2 + n2), ur(t2 + a2, e2 + n2, t2 + r2, e2 + o3, t2 + r2, e2), nr(i3), this;
  }, y2.__private__.circle = y2.circle = function(t2, e2, r2, n2) {
    if (isNaN(t2) || isNaN(e2) || isNaN(r2) || !Qe(n2))
      throw new Error("Invalid arguments passed to jsPDF.circle");
    return this.ellipse(t2, e2, r2, r2, n2);
  }, y2.setFont = function(t2, e2, r2) {
    return r2 && (e2 = k2(e2, r2)), St2 = qe(t2, e2, { disableWarning: false }), this;
  };
  var hr = y2.__private__.getFont = y2.getFont = function() {
    return Ft2[qe.apply(y2, arguments)];
  };
  y2.__private__.getFontList = y2.getFontList = function() {
    var t2, e2, r2 = {};
    for (t2 in Ct2)
      if (Ct2.hasOwnProperty(t2))
        for (e2 in r2[t2] = [], Ct2[t2])
          Ct2[t2].hasOwnProperty(e2) && r2[t2].push(e2);
    return r2;
  }, y2.addFont = function(t2, e2, r2, n2, i3) {
    var a2 = ["StandardEncoding", "MacRomanEncoding", "Identity-H", "WinAnsiEncoding"];
    return arguments[3] && -1 !== a2.indexOf(arguments[3]) ? i3 = arguments[3] : arguments[3] && -1 == a2.indexOf(arguments[3]) && (r2 = k2(r2, n2)), i3 = i3 || "Identity-H", Pe.call(this, t2, e2, r2, i3);
  };
  var lr, fr = e.lineWidth || 0.200025, dr = y2.__private__.getLineWidth = y2.getLineWidth = function() {
    return fr;
  }, pr = y2.__private__.setLineWidth = y2.setLineWidth = function(t2) {
    return fr = t2, lt2(O2(U2(t2)) + " w"), this;
  };
  y2.__private__.setLineDash = E.API.setLineDash = E.API.setLineDashPattern = function(t2, e2) {
    if (t2 = t2 || [], e2 = e2 || 0, isNaN(e2) || !Array.isArray(t2))
      throw new Error("Invalid arguments passed to jsPDF.setLineDash");
    return t2 = t2.map(function(t3) {
      return O2(U2(t3));
    }).join(" "), e2 = O2(U2(e2)), lt2("[" + t2 + "] " + e2 + " d"), this;
  };
  var gr = y2.__private__.getLineHeight = y2.getLineHeight = function() {
    return gt2 * lr;
  };
  y2.__private__.getLineHeight = y2.getLineHeight = function() {
    return gt2 * lr;
  };
  var mr = y2.__private__.setLineHeightFactor = y2.setLineHeightFactor = function(t2) {
    return "number" == typeof (t2 = t2 || 1.15) && (lr = t2), this;
  }, vr = y2.__private__.getLineHeightFactor = y2.getLineHeightFactor = function() {
    return lr;
  };
  mr(e.lineHeight);
  var br = y2.__private__.getHorizontalCoordinate = function(t2) {
    return U2(t2);
  }, yr = y2.__private__.getVerticalCoordinate = function(t2) {
    return S2 === x2.ADVANCED ? t2 : Rt2[$2].mediaBox.topRightY - Rt2[$2].mediaBox.bottomLeftY - U2(t2);
  }, wr = y2.__private__.getHorizontalCoordinateString = y2.getHorizontalCoordinateString = function(t2) {
    return O2(br(t2));
  }, Nr = y2.__private__.getVerticalCoordinateString = y2.getVerticalCoordinateString = function(t2) {
    return O2(yr(t2));
  }, Lr = e.strokeColor || "0 G";
  y2.__private__.getStrokeColor = y2.getDrawColor = function() {
    return ee2(Lr);
  }, y2.__private__.setStrokeColor = y2.setDrawColor = function(t2, e2, r2, n2) {
    return Lr = re2({ ch1: t2, ch2: e2, ch3: r2, ch4: n2, pdfColorType: "draw", precision: 2 }), lt2(Lr), this;
  };
  var Ar = e.fillColor || "0 g";
  y2.__private__.getFillColor = y2.getFillColor = function() {
    return ee2(Ar);
  }, y2.__private__.setFillColor = y2.setFillColor = function(t2, e2, r2, n2) {
    return Ar = re2({ ch1: t2, ch2: e2, ch3: r2, ch4: n2, pdfColorType: "fill", precision: 2 }), lt2(Ar), this;
  };
  var xr = e.textColor || "0 g", Sr = y2.__private__.getTextColor = y2.getTextColor = function() {
    return ee2(xr);
  };
  y2.__private__.setTextColor = y2.setTextColor = function(t2, e2, r2, n2) {
    return xr = re2({ ch1: t2, ch2: e2, ch3: r2, ch4: n2, pdfColorType: "text", precision: 3 }), this;
  };
  var _r = e.charSpace, Pr = y2.__private__.getCharSpace = y2.getCharSpace = function() {
    return parseFloat(_r || 0);
  };
  y2.__private__.setCharSpace = y2.setCharSpace = function(t2) {
    if (isNaN(t2))
      throw new Error("Invalid argument passed to jsPDF.setCharSpace");
    return _r = t2, this;
  };
  var kr = 0;
  y2.CapJoinStyles = { 0: 0, butt: 0, but: 0, miter: 0, 1: 1, round: 1, rounded: 1, circle: 1, 2: 2, projecting: 2, project: 2, square: 2, bevel: 2 }, y2.__private__.setLineCap = y2.setLineCap = function(t2) {
    var e2 = y2.CapJoinStyles[t2];
    if (void 0 === e2)
      throw new Error("Line cap style of '" + t2 + "' is not recognized. See or extend .CapJoinStyles property for valid styles");
    return kr = e2, lt2(e2 + " J"), this;
  };
  var Ir = 0;
  y2.__private__.setLineJoin = y2.setLineJoin = function(t2) {
    var e2 = y2.CapJoinStyles[t2];
    if (void 0 === e2)
      throw new Error("Line join style of '" + t2 + "' is not recognized. See or extend .CapJoinStyles property for valid styles");
    return Ir = e2, lt2(e2 + " j"), this;
  }, y2.__private__.setLineMiterLimit = y2.__private__.setMiterLimit = y2.setLineMiterLimit = y2.setMiterLimit = function(t2) {
    if (t2 = t2 || 0, isNaN(t2))
      throw new Error("Invalid argument passed to jsPDF.setLineMiterLimit");
    return lt2(O2(U2(t2)) + " M"), this;
  }, y2.GState = j, y2.setGState = function(t2) {
    (t2 = "string" == typeof t2 ? Mt2[Et2[t2]] : Fr(null, t2)).equals(qt2) || (lt2("/" + t2.id + " gs"), qt2 = t2);
  };
  var Fr = /* @__PURE__ */ __name(function(t2, e2) {
    if (!t2 || !Et2[t2]) {
      var r2 = false;
      for (var n2 in Mt2)
        if (Mt2.hasOwnProperty(n2) && Mt2[n2].equals(e2)) {
          r2 = true;
          break;
        }
      if (r2)
        e2 = Mt2[n2];
      else {
        var i3 = "GS" + (Object.keys(Mt2).length + 1).toString(10);
        Mt2[i3] = e2, e2.id = i3;
      }
      return t2 && (Et2[t2] = e2.id), Tt2.publish("addGState", e2), e2;
    }
  }, "Fr");
  y2.addGState = function(t2, e2) {
    return Fr(t2, e2), this;
  }, y2.saveGraphicsState = function() {
    return lt2("q"), jt2.push({ key: St2, size: gt2, color: xr }), this;
  }, y2.restoreGraphicsState = function() {
    lt2("Q");
    var t2 = jt2.pop();
    return St2 = t2.key, gt2 = t2.size, xr = t2.color, qt2 = null, this;
  }, y2.setCurrentTransformationMatrix = function(t2) {
    return lt2(t2.toString() + " cm"), this;
  }, y2.comment = function(t2) {
    return lt2("#" + t2), this;
  };
  var Cr = /* @__PURE__ */ __name(function(t2, e2) {
    var r2 = t2 || 0;
    Object.defineProperty(this, "x", { enumerable: true, get: function() {
      return r2;
    }, set: function(t3) {
      isNaN(t3) || (r2 = parseFloat(t3));
    } });
    var n2 = e2 || 0;
    Object.defineProperty(this, "y", { enumerable: true, get: function() {
      return n2;
    }, set: function(t3) {
      isNaN(t3) || (n2 = parseFloat(t3));
    } });
    var i3 = "pt";
    return Object.defineProperty(this, "type", { enumerable: true, get: function() {
      return i3;
    }, set: function(t3) {
      i3 = t3.toString();
    } }), this;
  }, "Cr"), jr = /* @__PURE__ */ __name(function(t2, e2, r2, n2) {
    Cr.call(this, t2, e2), this.type = "rect";
    var i3 = r2 || 0;
    Object.defineProperty(this, "w", { enumerable: true, get: function() {
      return i3;
    }, set: function(t3) {
      isNaN(t3) || (i3 = parseFloat(t3));
    } });
    var a2 = n2 || 0;
    return Object.defineProperty(this, "h", { enumerable: true, get: function() {
      return a2;
    }, set: function(t3) {
      isNaN(t3) || (a2 = parseFloat(t3));
    } }), this;
  }, "jr"), Or = /* @__PURE__ */ __name(function() {
    this.page = Dt2, this.currentPage = $2, this.pages = ot2.slice(0), this.pagesContext = Rt2.slice(0), this.x = Pt2, this.y = kt2, this.matrix = It2, this.width = qr($2), this.height = Rr($2), this.outputDestination = ct2, this.id = "", this.objectNumber = -1;
  }, "Or");
  Or.prototype.restore = function() {
    Dt2 = this.page, $2 = this.currentPage, Rt2 = this.pagesContext, ot2 = this.pages, Pt2 = this.x, kt2 = this.y, It2 = this.matrix, Dr($2, this.width), Tr($2, this.height), ct2 = this.outputDestination;
  };
  var Br = /* @__PURE__ */ __name(function(t2, e2, r2, n2, i3) {
    Wt2.push(new Or()), Dt2 = $2 = 0, ot2 = [], Pt2 = t2, kt2 = e2, It2 = i3, je([r2, n2]);
  }, "Br"), Mr = /* @__PURE__ */ __name(function(t2) {
    if (Ht2[t2])
      Wt2.pop().restore();
    else {
      var e2 = new Or(), r2 = "Xo" + (Object.keys(zt2).length + 1).toString(10);
      e2.id = r2, Ht2[t2] = r2, zt2[r2] = e2, Tt2.publish("addFormObject", e2), Wt2.pop().restore();
    }
  }, "Mr");
  for (var Er in y2.beginFormObject = function(t2, e2, r2, n2, i3) {
    return Br(t2, e2, r2, n2, i3), this;
  }, y2.endFormObject = function(t2) {
    return Mr(t2), this;
  }, y2.doFormObject = function(t2, e2) {
    var r2 = zt2[Ht2[t2]];
    return lt2("q"), lt2(e2.toString() + " cm"), lt2("/" + r2.id + " Do"), lt2("Q"), this;
  }, y2.getFormObject = function(t2) {
    var e2 = zt2[Ht2[t2]];
    return { x: e2.x, y: e2.y, width: e2.width, height: e2.height, matrix: e2.matrix };
  }, y2.save = function(t2, e2) {
    return t2 = t2 || "generated.pdf", (e2 = e2 || {}).returnPromise = e2.returnPromise || false, false === e2.returnPromise ? (l(We(He()), t2), "function" == typeof l.unload && n.setTimeout && setTimeout(l.unload, 911), this) : new Promise(function(e3, r2) {
      try {
        var i3 = l(We(He()), t2);
        "function" == typeof l.unload && n.setTimeout && setTimeout(l.unload, 911), e3(i3);
      } catch (t3) {
        r2(t3.message);
      }
    });
  }, E.API)
    E.API.hasOwnProperty(Er) && ("events" === Er && E.API.events.length ? function(t2, e2) {
      var r2, n2, i3;
      for (i3 = e2.length - 1; -1 !== i3; i3--)
        r2 = e2[i3][0], n2 = e2[i3][1], t2.subscribe.apply(t2, [r2].concat("function" == typeof n2 ? [n2] : n2));
    }(Tt2, E.API.events) : y2[Er] = E.API[Er]);
  var qr = y2.getPageWidth = function(t2) {
    return (Rt2[t2 = t2 || $2].mediaBox.topRightX - Rt2[t2].mediaBox.bottomLeftX) / _t2;
  }, Dr = y2.setPageWidth = function(t2, e2) {
    Rt2[t2].mediaBox.topRightX = e2 * _t2 + Rt2[t2].mediaBox.bottomLeftX;
  }, Rr = y2.getPageHeight = function(t2) {
    return (Rt2[t2 = t2 || $2].mediaBox.topRightY - Rt2[t2].mediaBox.bottomLeftY) / _t2;
  }, Tr = y2.setPageHeight = function(t2, e2) {
    Rt2[t2].mediaBox.topRightY = e2 * _t2 + Rt2[t2].mediaBox.bottomLeftY;
  };
  return y2.internal = { pdfEscape: Ce, getStyle: tr, getFont: hr, getFontSize: vt2, getCharSpace: Pr, getTextColor: Sr, getLineHeight: gr, getLineHeightFactor: vr, getLineWidth: dr, write: ft2, getHorizontalCoordinate: br, getVerticalCoordinate: yr, getCoordinateString: wr, getVerticalCoordinateString: Nr, collections: {}, newObject: Xt2, newAdditionalObject: $t2, newObjectDeferred: Kt2, newObjectDeferredBegin: Zt2, getFilters: ne2, putStream: ie2, events: Tt2, scaleFactor: _t2, pageSize: { getWidth: function() {
    return qr($2);
  }, setWidth: function(t2) {
    Dr($2, t2);
  }, getHeight: function() {
    return Rr($2);
  }, setHeight: function(t2) {
    Tr($2, t2);
  } }, encryptionOptions: m2, encryption: Ye, getEncryptor: Je, output: Ve, getNumberOfPages: Ee, pages: ot2, out: lt2, f2: R2, f3: T2, getPageInfo: Xe, getPageInfoByObjId: Ke, getCurrentPageInfo: Ze, getPDFVersion: N2, Point: Cr, Rectangle: jr, Matrix: Vt2, hasHotfix: Ge }, Object.defineProperty(y2.internal.pageSize, "width", { get: function() {
    return qr($2);
  }, set: function(t2) {
    Dr($2, t2);
  }, enumerable: true, configurable: true }), Object.defineProperty(y2.internal.pageSize, "height", { get: function() {
    return Rr($2);
  }, set: function(t2) {
    Tr($2, t2);
  }, enumerable: true, configurable: true }), ke.call(y2, pt2), St2 = "F1", Oe(s2, i2), Tt2.publish("initialized"), y2;
}
__name(E, "E");
I.prototype.lsbFirstWord = function(t2) {
  return String.fromCharCode(t2 >> 0 & 255, t2 >> 8 & 255, t2 >> 16 & 255, t2 >> 24 & 255);
}, I.prototype.toHexString = function(t2) {
  return t2.split("").map(function(t3) {
    return ("0" + (255 & t3.charCodeAt(0)).toString(16)).slice(-2);
  }).join("");
}, I.prototype.hexToBytes = function(t2) {
  for (var e = [], r = 0; r < t2.length; r += 2)
    e.push(String.fromCharCode(parseInt(t2.substr(r, 2), 16)));
  return e.join("");
}, I.prototype.processOwnerPassword = function(t2, e) {
  return P(x(e).substr(0, 5), t2);
}, I.prototype.encryptor = function(t2, e) {
  var r = x(this.encryptionKey + String.fromCharCode(255 & t2, t2 >> 8 & 255, t2 >> 16 & 255, 255 & e, e >> 8 & 255)).substr(0, 10);
  return function(t3) {
    return P(r, t3);
  };
}, j.prototype.equals = function(e) {
  var r, n2 = "id,objectNumber,equals";
  if (!e || _typeof(e) !== _typeof(this))
    return false;
  var i2 = 0;
  for (r in this)
    if (!(n2.indexOf(r) >= 0)) {
      if (this.hasOwnProperty(r) && !e.hasOwnProperty(r))
        return false;
      if (this[r] !== e[r])
        return false;
      i2++;
    }
  for (r in e)
    e.hasOwnProperty(r) && n2.indexOf(r) < 0 && i2--;
  return 0 === i2;
}, E.API = { events: [] }, E.version = "2.5.2";
var q = E.API, D = 1, R = /* @__PURE__ */ __name(function(t2) {
  return t2.replace(/\\/g, "\\\\").replace(/\(/g, "\\(").replace(/\)/g, "\\)");
}, "R"), T = /* @__PURE__ */ __name(function(t2) {
  return t2.replace(/\\\\/g, "\\").replace(/\\\(/g, "(").replace(/\\\)/g, ")");
}, "T"), U = /* @__PURE__ */ __name(function(t2) {
  return t2.toFixed(2);
}, "U"), z = /* @__PURE__ */ __name(function(t2) {
  return t2.toFixed(5);
}, "z");
q.__acroform__ = {};
var H = /* @__PURE__ */ __name(function(t2, e) {
  t2.prototype = Object.create(e.prototype), t2.prototype.constructor = t2;
}, "H"), W = /* @__PURE__ */ __name(function(t2) {
  return t2 * D;
}, "W"), V = /* @__PURE__ */ __name(function(t2) {
  var e = new ut(), r = At.internal.getHeight(t2) || 0, n2 = At.internal.getWidth(t2) || 0;
  return e.BBox = [0, 0, Number(U(n2)), Number(U(r))], e;
}, "V"), G = q.__acroform__.setBit = function(t2, e) {
  if (t2 = t2 || 0, e = e || 0, isNaN(t2) || isNaN(e))
    throw new Error("Invalid arguments passed to jsPDF.API.__acroform__.setBit");
  return t2 |= 1 << e;
}, Y = q.__acroform__.clearBit = function(t2, e) {
  if (t2 = t2 || 0, e = e || 0, isNaN(t2) || isNaN(e))
    throw new Error("Invalid arguments passed to jsPDF.API.__acroform__.clearBit");
  return t2 &= ~(1 << e);
}, J = q.__acroform__.getBit = function(t2, e) {
  if (isNaN(t2) || isNaN(e))
    throw new Error("Invalid arguments passed to jsPDF.API.__acroform__.getBit");
  return 0 == (t2 & 1 << e) ? 0 : 1;
}, X = q.__acroform__.getBitForPdf = function(t2, e) {
  if (isNaN(t2) || isNaN(e))
    throw new Error("Invalid arguments passed to jsPDF.API.__acroform__.getBitForPdf");
  return J(t2, e - 1);
}, K = q.__acroform__.setBitForPdf = function(t2, e) {
  if (isNaN(t2) || isNaN(e))
    throw new Error("Invalid arguments passed to jsPDF.API.__acroform__.setBitForPdf");
  return G(t2, e - 1);
}, Z = q.__acroform__.clearBitForPdf = function(t2, e) {
  if (isNaN(t2) || isNaN(e))
    throw new Error("Invalid arguments passed to jsPDF.API.__acroform__.clearBitForPdf");
  return Y(t2, e - 1);
}, $$1 = q.__acroform__.calculateCoordinates = function(t2, e) {
  var r = e.internal.getHorizontalCoordinate, n2 = e.internal.getVerticalCoordinate, i2 = t2[0], a2 = t2[1], o2 = t2[2], s2 = t2[3], c2 = {};
  return c2.lowerLeft_X = r(i2) || 0, c2.lowerLeft_Y = n2(a2 + s2) || 0, c2.upperRight_X = r(i2 + o2) || 0, c2.upperRight_Y = n2(a2) || 0, [Number(U(c2.lowerLeft_X)), Number(U(c2.lowerLeft_Y)), Number(U(c2.upperRight_X)), Number(U(c2.upperRight_Y))];
}, Q = /* @__PURE__ */ __name(function(t2) {
  if (t2.appearanceStreamContent)
    return t2.appearanceStreamContent;
  if (t2.V || t2.DV) {
    var e = [], r = t2._V || t2.DV, n2 = tt(t2, r), i2 = t2.scope.internal.getFont(t2.fontName, t2.fontStyle).id;
    e.push("/Tx BMC"), e.push("q"), e.push("BT"), e.push(t2.scope.__private__.encodeColorString(t2.color)), e.push("/" + i2 + " " + U(n2.fontSize) + " Tf"), e.push("1 0 0 1 0 0 Tm"), e.push(n2.text), e.push("ET"), e.push("Q"), e.push("EMC");
    var a2 = V(t2);
    return a2.scope = t2.scope, a2.stream = e.join("\n"), a2;
  }
}, "Q"), tt = /* @__PURE__ */ __name(function(t2, e) {
  var r = 0 === t2.fontSize ? t2.maxFontSize : t2.fontSize, n2 = { text: "", fontSize: "" }, i2 = (e = ")" == (e = "(" == e.substr(0, 1) ? e.substr(1) : e).substr(e.length - 1) ? e.substr(0, e.length - 1) : e).split(" ");
  i2 = t2.multiline ? i2.map(function(t3) {
    return t3.split("\n");
  }) : i2.map(function(t3) {
    return [t3];
  });
  var a2 = r, o2 = At.internal.getHeight(t2) || 0;
  o2 = o2 < 0 ? -o2 : o2;
  var s2 = At.internal.getWidth(t2) || 0;
  s2 = s2 < 0 ? -s2 : s2;
  var c2 = /* @__PURE__ */ __name(function(e2, r2, n3) {
    if (e2 + 1 < i2.length) {
      var a3 = r2 + " " + i2[e2 + 1][0];
      return et(a3, t2, n3).width <= s2 - 4;
    }
    return false;
  }, "c");
  a2++;
  t:
    for (; a2 > 0; ) {
      e = "", a2--;
      var u2, h3, l2 = et("3", t2, a2).height, f2 = t2.multiline ? o2 - a2 : (o2 - l2) / 2, d2 = f2 += 2, p2 = 0, g2 = 0, m2 = 0;
      if (a2 <= 0) {
        e = "(...) Tj\n", e += "% Width of Text: " + et(e, t2, a2 = 12).width + ", FieldWidth:" + s2 + "\n";
        break;
      }
      for (var v2 = "", b2 = 0, y2 = 0; y2 < i2.length; y2++)
        if (i2.hasOwnProperty(y2)) {
          var w2 = false;
          if (1 !== i2[y2].length && m2 !== i2[y2].length - 1) {
            if ((l2 + 2) * (b2 + 2) + 2 > o2)
              continue t;
            v2 += i2[y2][m2], w2 = true, g2 = y2, y2--;
          } else {
            v2 = " " == (v2 += i2[y2][m2] + " ").substr(v2.length - 1) ? v2.substr(0, v2.length - 1) : v2;
            var N2 = parseInt(y2), L2 = c2(N2, v2, a2), A2 = y2 >= i2.length - 1;
            if (L2 && !A2) {
              v2 += " ", m2 = 0;
              continue;
            }
            if (L2 || A2) {
              if (A2)
                g2 = N2;
              else if (t2.multiline && (l2 + 2) * (b2 + 2) + 2 > o2)
                continue t;
            } else {
              if (!t2.multiline)
                continue t;
              if ((l2 + 2) * (b2 + 2) + 2 > o2)
                continue t;
              g2 = N2;
            }
          }
          for (var x2 = "", S2 = p2; S2 <= g2; S2++) {
            var _2 = i2[S2];
            if (t2.multiline) {
              if (S2 === g2) {
                x2 += _2[m2] + " ", m2 = (m2 + 1) % _2.length;
                continue;
              }
              if (S2 === p2) {
                x2 += _2[_2.length - 1] + " ";
                continue;
              }
            }
            x2 += _2[0] + " ";
          }
          switch (x2 = " " == x2.substr(x2.length - 1) ? x2.substr(0, x2.length - 1) : x2, h3 = et(x2, t2, a2).width, t2.textAlign) {
            case "right":
              u2 = s2 - h3 - 2;
              break;
            case "center":
              u2 = (s2 - h3) / 2;
              break;
            case "left":
            default:
              u2 = 2;
          }
          e += U(u2) + " " + U(d2) + " Td\n", e += "(" + R(x2) + ") Tj\n", e += -U(u2) + " 0 Td\n", d2 = -(a2 + 2), h3 = 0, p2 = w2 ? g2 : g2 + 1, b2++, v2 = "";
        }
      break;
    }
  return n2.text = e, n2.fontSize = a2, n2;
}, "tt"), et = /* @__PURE__ */ __name(function(t2, e, r) {
  var n2 = e.scope.internal.getFont(e.fontName, e.fontStyle), i2 = e.scope.getStringUnitWidth(t2, { font: n2, fontSize: parseFloat(r), charSpace: 0 }) * parseFloat(r);
  return { height: e.scope.getStringUnitWidth("3", { font: n2, fontSize: parseFloat(r), charSpace: 0 }) * parseFloat(r) * 1.5, width: i2 };
}, "et"), rt = { fields: [], xForms: [], acroFormDictionaryRoot: null, printedOut: false, internal: null, isInitialized: false }, nt = /* @__PURE__ */ __name(function(t2, e) {
  var r = { type: "reference", object: t2 };
  void 0 === e.internal.getPageInfo(t2.page).pageContext.annotations.find(function(t3) {
    return t3.type === r.type && t3.object === r.object;
  }) && e.internal.getPageInfo(t2.page).pageContext.annotations.push(r);
}, "nt"), it = /* @__PURE__ */ __name(function(e, r) {
  for (var n2 in e)
    if (e.hasOwnProperty(n2)) {
      var i2 = n2, a2 = e[n2];
      r.internal.newObjectDeferredBegin(a2.objId, true), "object" === _typeof(a2) && "function" == typeof a2.putStream && a2.putStream(), delete e[i2];
    }
}, "it"), at = /* @__PURE__ */ __name(function(e, r) {
  if (r.scope = e, void 0 !== e.internal && (void 0 === e.internal.acroformPlugin || false === e.internal.acroformPlugin.isInitialized)) {
    if (lt.FieldNum = 0, e.internal.acroformPlugin = JSON.parse(JSON.stringify(rt)), e.internal.acroformPlugin.acroFormDictionaryRoot)
      throw new Error("Exception while creating AcroformDictionary");
    D = e.internal.scaleFactor, e.internal.acroformPlugin.acroFormDictionaryRoot = new ht(), e.internal.acroformPlugin.acroFormDictionaryRoot.scope = e, e.internal.acroformPlugin.acroFormDictionaryRoot._eventID = e.internal.events.subscribe("postPutResources", function() {
      !function(t2) {
        t2.internal.events.unsubscribe(t2.internal.acroformPlugin.acroFormDictionaryRoot._eventID), delete t2.internal.acroformPlugin.acroFormDictionaryRoot._eventID, t2.internal.acroformPlugin.printedOut = true;
      }(e);
    }), e.internal.events.subscribe("buildDocument", function() {
      !function(t2) {
        t2.internal.acroformPlugin.acroFormDictionaryRoot.objId = void 0;
        var e2 = t2.internal.acroformPlugin.acroFormDictionaryRoot.Fields;
        for (var r2 in e2)
          if (e2.hasOwnProperty(r2)) {
            var n2 = e2[r2];
            n2.objId = void 0, n2.hasAnnotation && nt(n2, t2);
          }
      }(e);
    }), e.internal.events.subscribe("putCatalog", function() {
      !function(t2) {
        if (void 0 === t2.internal.acroformPlugin.acroFormDictionaryRoot)
          throw new Error("putCatalogCallback: Root missing.");
        t2.internal.write("/AcroForm " + t2.internal.acroformPlugin.acroFormDictionaryRoot.objId + " 0 R");
      }(e);
    }), e.internal.events.subscribe("postPutPages", function(r2) {
      !function(e2, r3) {
        var n2 = !e2;
        for (var i2 in e2 || (r3.internal.newObjectDeferredBegin(r3.internal.acroformPlugin.acroFormDictionaryRoot.objId, true), r3.internal.acroformPlugin.acroFormDictionaryRoot.putStream()), e2 = e2 || r3.internal.acroformPlugin.acroFormDictionaryRoot.Kids)
          if (e2.hasOwnProperty(i2)) {
            var a2 = e2[i2], o2 = [], s2 = a2.Rect;
            if (a2.Rect && (a2.Rect = $$1(a2.Rect, r3)), r3.internal.newObjectDeferredBegin(a2.objId, true), a2.DA = At.createDefaultAppearanceStream(a2), "object" === _typeof(a2) && "function" == typeof a2.getKeyValueListForStream && (o2 = a2.getKeyValueListForStream()), a2.Rect = s2, a2.hasAppearanceStream && !a2.appearanceStreamContent) {
              var c2 = Q(a2);
              o2.push({ key: "AP", value: "<</N " + c2 + ">>" }), r3.internal.acroformPlugin.xForms.push(c2);
            }
            if (a2.appearanceStreamContent) {
              var u2 = "";
              for (var h3 in a2.appearanceStreamContent)
                if (a2.appearanceStreamContent.hasOwnProperty(h3)) {
                  var l2 = a2.appearanceStreamContent[h3];
                  if (u2 += "/" + h3 + " ", u2 += "<<", Object.keys(l2).length >= 1 || Array.isArray(l2)) {
                    for (var i2 in l2)
                      if (l2.hasOwnProperty(i2)) {
                        var f2 = l2[i2];
                        "function" == typeof f2 && (f2 = f2.call(r3, a2)), u2 += "/" + i2 + " " + f2 + " ", r3.internal.acroformPlugin.xForms.indexOf(f2) >= 0 || r3.internal.acroformPlugin.xForms.push(f2);
                      }
                  } else
                    "function" == typeof (f2 = l2) && (f2 = f2.call(r3, a2)), u2 += "/" + i2 + " " + f2, r3.internal.acroformPlugin.xForms.indexOf(f2) >= 0 || r3.internal.acroformPlugin.xForms.push(f2);
                  u2 += ">>";
                }
              o2.push({ key: "AP", value: "<<\n" + u2 + ">>" });
            }
            r3.internal.putStream({ additionalKeyValues: o2, objectId: a2.objId }), r3.internal.out("endobj");
          }
        n2 && it(r3.internal.acroformPlugin.xForms, r3);
      }(r2, e);
    }), e.internal.acroformPlugin.isInitialized = true;
  }
}, "at"), ot = q.__acroform__.arrayToPdfArray = function(e, r, n2) {
  var i2 = /* @__PURE__ */ __name(function(t2) {
    return t2;
  }, "i");
  if (Array.isArray(e)) {
    for (var a2 = "[", o2 = 0; o2 < e.length; o2++)
      switch (0 !== o2 && (a2 += " "), _typeof(e[o2])) {
        case "boolean":
        case "number":
        case "object":
          a2 += e[o2].toString();
          break;
        case "string":
          "/" !== e[o2].substr(0, 1) ? (void 0 !== r && n2 && (i2 = n2.internal.getEncryptor(r)), a2 += "(" + R(i2(e[o2].toString())) + ")") : a2 += e[o2].toString();
      }
    return a2 += "]";
  }
  throw new Error("Invalid argument passed to jsPDF.__acroform__.arrayToPdfArray");
};
var st = /* @__PURE__ */ __name(function(t2, e, r) {
  var n2 = /* @__PURE__ */ __name(function(t3) {
    return t3;
  }, "n");
  return void 0 !== e && r && (n2 = r.internal.getEncryptor(e)), (t2 = t2 || "").toString(), t2 = "(" + R(n2(t2)) + ")";
}, "st"), ct = /* @__PURE__ */ __name(function() {
  this._objId = void 0, this._scope = void 0, Object.defineProperty(this, "objId", { get: function() {
    if (void 0 === this._objId) {
      if (void 0 === this.scope)
        return;
      this._objId = this.scope.internal.newObjectDeferred();
    }
    return this._objId;
  }, set: function(t2) {
    this._objId = t2;
  } }), Object.defineProperty(this, "scope", { value: this._scope, writable: true });
}, "ct");
ct.prototype.toString = function() {
  return this.objId + " 0 R";
}, ct.prototype.putStream = function() {
  var t2 = this.getKeyValueListForStream();
  this.scope.internal.putStream({ data: this.stream, additionalKeyValues: t2, objectId: this.objId }), this.scope.internal.out("endobj");
}, ct.prototype.getKeyValueListForStream = function() {
  var t2 = [], e = Object.getOwnPropertyNames(this).filter(function(t3) {
    return "content" != t3 && "appearanceStreamContent" != t3 && "scope" != t3 && "objId" != t3 && "_" != t3.substring(0, 1);
  });
  for (var r in e)
    if (false === Object.getOwnPropertyDescriptor(this, e[r]).configurable) {
      var n2 = e[r], i2 = this[n2];
      i2 && (Array.isArray(i2) ? t2.push({ key: n2, value: ot(i2, this.objId, this.scope) }) : i2 instanceof ct ? (i2.scope = this.scope, t2.push({ key: n2, value: i2.objId + " 0 R" })) : "function" != typeof i2 && t2.push({ key: n2, value: i2 }));
    }
  return t2;
};
var ut = /* @__PURE__ */ __name(function() {
  ct.call(this), Object.defineProperty(this, "Type", { value: "/XObject", configurable: false, writable: true }), Object.defineProperty(this, "Subtype", { value: "/Form", configurable: false, writable: true }), Object.defineProperty(this, "FormType", { value: 1, configurable: false, writable: true });
  var t2, e = [];
  Object.defineProperty(this, "BBox", { configurable: false, get: function() {
    return e;
  }, set: function(t3) {
    e = t3;
  } }), Object.defineProperty(this, "Resources", { value: "2 0 R", configurable: false, writable: true }), Object.defineProperty(this, "stream", { enumerable: false, configurable: true, set: function(e2) {
    t2 = e2.trim();
  }, get: function() {
    return t2 || null;
  } });
}, "ut");
H(ut, ct);
var ht = /* @__PURE__ */ __name(function() {
  ct.call(this);
  var t2, e = [];
  Object.defineProperty(this, "Kids", { enumerable: false, configurable: true, get: function() {
    return e.length > 0 ? e : void 0;
  } }), Object.defineProperty(this, "Fields", { enumerable: false, configurable: false, get: function() {
    return e;
  } }), Object.defineProperty(this, "DA", { enumerable: false, configurable: false, get: function() {
    if (t2) {
      var e2 = /* @__PURE__ */ __name(function(t3) {
        return t3;
      }, "e");
      return this.scope && (e2 = this.scope.internal.getEncryptor(this.objId)), "(" + R(e2(t2)) + ")";
    }
  }, set: function(e2) {
    t2 = e2;
  } });
}, "ht");
H(ht, ct);
var lt = /* @__PURE__ */ __name(function t() {
  ct.call(this);
  var e = 4;
  Object.defineProperty(this, "F", { enumerable: false, configurable: false, get: function() {
    return e;
  }, set: function(t2) {
    if (isNaN(t2))
      throw new Error('Invalid value "' + t2 + '" for attribute F supplied.');
    e = t2;
  } }), Object.defineProperty(this, "showWhenPrinted", { enumerable: true, configurable: true, get: function() {
    return Boolean(X(e, 3));
  }, set: function(t2) {
    true === Boolean(t2) ? this.F = K(e, 3) : this.F = Z(e, 3);
  } });
  var r = 0;
  Object.defineProperty(this, "Ff", { enumerable: false, configurable: false, get: function() {
    return r;
  }, set: function(t2) {
    if (isNaN(t2))
      throw new Error('Invalid value "' + t2 + '" for attribute Ff supplied.');
    r = t2;
  } });
  var n2 = [];
  Object.defineProperty(this, "Rect", { enumerable: false, configurable: false, get: function() {
    if (0 !== n2.length)
      return n2;
  }, set: function(t2) {
    n2 = void 0 !== t2 ? t2 : [];
  } }), Object.defineProperty(this, "x", { enumerable: true, configurable: true, get: function() {
    return !n2 || isNaN(n2[0]) ? 0 : n2[0];
  }, set: function(t2) {
    n2[0] = t2;
  } }), Object.defineProperty(this, "y", { enumerable: true, configurable: true, get: function() {
    return !n2 || isNaN(n2[1]) ? 0 : n2[1];
  }, set: function(t2) {
    n2[1] = t2;
  } }), Object.defineProperty(this, "width", { enumerable: true, configurable: true, get: function() {
    return !n2 || isNaN(n2[2]) ? 0 : n2[2];
  }, set: function(t2) {
    n2[2] = t2;
  } }), Object.defineProperty(this, "height", { enumerable: true, configurable: true, get: function() {
    return !n2 || isNaN(n2[3]) ? 0 : n2[3];
  }, set: function(t2) {
    n2[3] = t2;
  } });
  var i2 = "";
  Object.defineProperty(this, "FT", { enumerable: true, configurable: false, get: function() {
    return i2;
  }, set: function(t2) {
    switch (t2) {
      case "/Btn":
      case "/Tx":
      case "/Ch":
      case "/Sig":
        i2 = t2;
        break;
      default:
        throw new Error('Invalid value "' + t2 + '" for attribute FT supplied.');
    }
  } });
  var a2 = null;
  Object.defineProperty(this, "T", { enumerable: true, configurable: false, get: function() {
    if (!a2 || a2.length < 1) {
      if (this instanceof yt)
        return;
      a2 = "FieldObject" + t.FieldNum++;
    }
    var e2 = /* @__PURE__ */ __name(function(t2) {
      return t2;
    }, "e");
    return this.scope && (e2 = this.scope.internal.getEncryptor(this.objId)), "(" + R(e2(a2)) + ")";
  }, set: function(t2) {
    a2 = t2.toString();
  } }), Object.defineProperty(this, "fieldName", { configurable: true, enumerable: true, get: function() {
    return a2;
  }, set: function(t2) {
    a2 = t2;
  } });
  var o2 = "helvetica";
  Object.defineProperty(this, "fontName", { enumerable: true, configurable: true, get: function() {
    return o2;
  }, set: function(t2) {
    o2 = t2;
  } });
  var s2 = "normal";
  Object.defineProperty(this, "fontStyle", { enumerable: true, configurable: true, get: function() {
    return s2;
  }, set: function(t2) {
    s2 = t2;
  } });
  var c2 = 0;
  Object.defineProperty(this, "fontSize", { enumerable: true, configurable: true, get: function() {
    return c2;
  }, set: function(t2) {
    c2 = t2;
  } });
  var u2 = void 0;
  Object.defineProperty(this, "maxFontSize", { enumerable: true, configurable: true, get: function() {
    return void 0 === u2 ? 50 / D : u2;
  }, set: function(t2) {
    u2 = t2;
  } });
  var h3 = "black";
  Object.defineProperty(this, "color", { enumerable: true, configurable: true, get: function() {
    return h3;
  }, set: function(t2) {
    h3 = t2;
  } });
  var l2 = "/F1 0 Tf 0 g";
  Object.defineProperty(this, "DA", { enumerable: true, configurable: false, get: function() {
    if (!(!l2 || this instanceof yt || this instanceof Nt))
      return st(l2, this.objId, this.scope);
  }, set: function(t2) {
    t2 = t2.toString(), l2 = t2;
  } });
  var f2 = null;
  Object.defineProperty(this, "DV", { enumerable: false, configurable: false, get: function() {
    if (f2)
      return this instanceof mt == false ? st(f2, this.objId, this.scope) : f2;
  }, set: function(t2) {
    t2 = t2.toString(), f2 = this instanceof mt == false ? "(" === t2.substr(0, 1) ? T(t2.substr(1, t2.length - 2)) : T(t2) : t2;
  } }), Object.defineProperty(this, "defaultValue", { enumerable: true, configurable: true, get: function() {
    return this instanceof mt == true ? T(f2.substr(1, f2.length - 1)) : f2;
  }, set: function(t2) {
    t2 = t2.toString(), f2 = this instanceof mt == true ? "/" + t2 : t2;
  } });
  var d2 = null;
  Object.defineProperty(this, "_V", { enumerable: false, configurable: false, get: function() {
    if (d2)
      return d2;
  }, set: function(t2) {
    this.V = t2;
  } }), Object.defineProperty(this, "V", { enumerable: false, configurable: false, get: function() {
    if (d2)
      return this instanceof mt == false ? st(d2, this.objId, this.scope) : d2;
  }, set: function(t2) {
    t2 = t2.toString(), d2 = this instanceof mt == false ? "(" === t2.substr(0, 1) ? T(t2.substr(1, t2.length - 2)) : T(t2) : t2;
  } }), Object.defineProperty(this, "value", { enumerable: true, configurable: true, get: function() {
    return this instanceof mt == true ? T(d2.substr(1, d2.length - 1)) : d2;
  }, set: function(t2) {
    t2 = t2.toString(), d2 = this instanceof mt == true ? "/" + t2 : t2;
  } }), Object.defineProperty(this, "hasAnnotation", { enumerable: true, configurable: true, get: function() {
    return this.Rect;
  } }), Object.defineProperty(this, "Type", { enumerable: true, configurable: false, get: function() {
    return this.hasAnnotation ? "/Annot" : null;
  } }), Object.defineProperty(this, "Subtype", { enumerable: true, configurable: false, get: function() {
    return this.hasAnnotation ? "/Widget" : null;
  } });
  var p2, g2 = false;
  Object.defineProperty(this, "hasAppearanceStream", { enumerable: true, configurable: true, get: function() {
    return g2;
  }, set: function(t2) {
    t2 = Boolean(t2), g2 = t2;
  } }), Object.defineProperty(this, "page", { enumerable: true, configurable: true, get: function() {
    if (p2)
      return p2;
  }, set: function(t2) {
    p2 = t2;
  } }), Object.defineProperty(this, "readOnly", { enumerable: true, configurable: true, get: function() {
    return Boolean(X(this.Ff, 1));
  }, set: function(t2) {
    true === Boolean(t2) ? this.Ff = K(this.Ff, 1) : this.Ff = Z(this.Ff, 1);
  } }), Object.defineProperty(this, "required", { enumerable: true, configurable: true, get: function() {
    return Boolean(X(this.Ff, 2));
  }, set: function(t2) {
    true === Boolean(t2) ? this.Ff = K(this.Ff, 2) : this.Ff = Z(this.Ff, 2);
  } }), Object.defineProperty(this, "noExport", { enumerable: true, configurable: true, get: function() {
    return Boolean(X(this.Ff, 3));
  }, set: function(t2) {
    true === Boolean(t2) ? this.Ff = K(this.Ff, 3) : this.Ff = Z(this.Ff, 3);
  } });
  var m2 = null;
  Object.defineProperty(this, "Q", { enumerable: true, configurable: false, get: function() {
    if (null !== m2)
      return m2;
  }, set: function(t2) {
    if (-1 === [0, 1, 2].indexOf(t2))
      throw new Error('Invalid value "' + t2 + '" for attribute Q supplied.');
    m2 = t2;
  } }), Object.defineProperty(this, "textAlign", { get: function() {
    var t2;
    switch (m2) {
      case 0:
      default:
        t2 = "left";
        break;
      case 1:
        t2 = "center";
        break;
      case 2:
        t2 = "right";
    }
    return t2;
  }, configurable: true, enumerable: true, set: function(t2) {
    switch (t2) {
      case "right":
      case 2:
        m2 = 2;
        break;
      case "center":
      case 1:
        m2 = 1;
        break;
      case "left":
      case 0:
      default:
        m2 = 0;
    }
  } });
}, "t");
H(lt, ct);
var ft = /* @__PURE__ */ __name(function() {
  lt.call(this), this.FT = "/Ch", this.V = "()", this.fontName = "zapfdingbats";
  var t2 = 0;
  Object.defineProperty(this, "TI", { enumerable: true, configurable: false, get: function() {
    return t2;
  }, set: function(e2) {
    t2 = e2;
  } }), Object.defineProperty(this, "topIndex", { enumerable: true, configurable: true, get: function() {
    return t2;
  }, set: function(e2) {
    t2 = e2;
  } });
  var e = [];
  Object.defineProperty(this, "Opt", { enumerable: true, configurable: false, get: function() {
    return ot(e, this.objId, this.scope);
  }, set: function(t3) {
    var r, n2;
    n2 = [], "string" == typeof (r = t3) && (n2 = function(t4, e2, r2) {
      r2 || (r2 = 1);
      for (var n3, i2 = []; n3 = e2.exec(t4); )
        i2.push(n3[r2]);
      return i2;
    }(r, /\((.*?)\)/g)), e = n2;
  } }), this.getOptions = function() {
    return e;
  }, this.setOptions = function(t3) {
    e = t3, this.sort && e.sort();
  }, this.addOption = function(t3) {
    t3 = (t3 = t3 || "").toString(), e.push(t3), this.sort && e.sort();
  }, this.removeOption = function(t3, r) {
    for (r = r || false, t3 = (t3 = t3 || "").toString(); -1 !== e.indexOf(t3) && (e.splice(e.indexOf(t3), 1), false !== r); )
      ;
  }, Object.defineProperty(this, "combo", { enumerable: true, configurable: true, get: function() {
    return Boolean(X(this.Ff, 18));
  }, set: function(t3) {
    true === Boolean(t3) ? this.Ff = K(this.Ff, 18) : this.Ff = Z(this.Ff, 18);
  } }), Object.defineProperty(this, "edit", { enumerable: true, configurable: true, get: function() {
    return Boolean(X(this.Ff, 19));
  }, set: function(t3) {
    true === this.combo && (true === Boolean(t3) ? this.Ff = K(this.Ff, 19) : this.Ff = Z(this.Ff, 19));
  } }), Object.defineProperty(this, "sort", { enumerable: true, configurable: true, get: function() {
    return Boolean(X(this.Ff, 20));
  }, set: function(t3) {
    true === Boolean(t3) ? (this.Ff = K(this.Ff, 20), e.sort()) : this.Ff = Z(this.Ff, 20);
  } }), Object.defineProperty(this, "multiSelect", { enumerable: true, configurable: true, get: function() {
    return Boolean(X(this.Ff, 22));
  }, set: function(t3) {
    true === Boolean(t3) ? this.Ff = K(this.Ff, 22) : this.Ff = Z(this.Ff, 22);
  } }), Object.defineProperty(this, "doNotSpellCheck", { enumerable: true, configurable: true, get: function() {
    return Boolean(X(this.Ff, 23));
  }, set: function(t3) {
    true === Boolean(t3) ? this.Ff = K(this.Ff, 23) : this.Ff = Z(this.Ff, 23);
  } }), Object.defineProperty(this, "commitOnSelChange", { enumerable: true, configurable: true, get: function() {
    return Boolean(X(this.Ff, 27));
  }, set: function(t3) {
    true === Boolean(t3) ? this.Ff = K(this.Ff, 27) : this.Ff = Z(this.Ff, 27);
  } }), this.hasAppearanceStream = false;
}, "ft");
H(ft, lt);
var dt = /* @__PURE__ */ __name(function() {
  ft.call(this), this.fontName = "helvetica", this.combo = false;
}, "dt");
H(dt, ft);
var pt = /* @__PURE__ */ __name(function() {
  dt.call(this), this.combo = true;
}, "pt");
H(pt, dt);
var gt = /* @__PURE__ */ __name(function() {
  pt.call(this), this.edit = true;
}, "gt");
H(gt, pt);
var mt = /* @__PURE__ */ __name(function() {
  lt.call(this), this.FT = "/Btn", Object.defineProperty(this, "noToggleToOff", { enumerable: true, configurable: true, get: function() {
    return Boolean(X(this.Ff, 15));
  }, set: function(t2) {
    true === Boolean(t2) ? this.Ff = K(this.Ff, 15) : this.Ff = Z(this.Ff, 15);
  } }), Object.defineProperty(this, "radio", { enumerable: true, configurable: true, get: function() {
    return Boolean(X(this.Ff, 16));
  }, set: function(t2) {
    true === Boolean(t2) ? this.Ff = K(this.Ff, 16) : this.Ff = Z(this.Ff, 16);
  } }), Object.defineProperty(this, "pushButton", { enumerable: true, configurable: true, get: function() {
    return Boolean(X(this.Ff, 17));
  }, set: function(t2) {
    true === Boolean(t2) ? this.Ff = K(this.Ff, 17) : this.Ff = Z(this.Ff, 17);
  } }), Object.defineProperty(this, "radioIsUnison", { enumerable: true, configurable: true, get: function() {
    return Boolean(X(this.Ff, 26));
  }, set: function(t2) {
    true === Boolean(t2) ? this.Ff = K(this.Ff, 26) : this.Ff = Z(this.Ff, 26);
  } });
  var e, r = {};
  Object.defineProperty(this, "MK", { enumerable: false, configurable: false, get: function() {
    var t2 = /* @__PURE__ */ __name(function(t3) {
      return t3;
    }, "t");
    if (this.scope && (t2 = this.scope.internal.getEncryptor(this.objId)), 0 !== Object.keys(r).length) {
      var e2, n2 = [];
      for (e2 in n2.push("<<"), r)
        n2.push("/" + e2 + " (" + R(t2(r[e2])) + ")");
      return n2.push(">>"), n2.join("\n");
    }
  }, set: function(e2) {
    "object" === _typeof(e2) && (r = e2);
  } }), Object.defineProperty(this, "caption", { enumerable: true, configurable: true, get: function() {
    return r.CA || "";
  }, set: function(t2) {
    "string" == typeof t2 && (r.CA = t2);
  } }), Object.defineProperty(this, "AS", { enumerable: false, configurable: false, get: function() {
    return e;
  }, set: function(t2) {
    e = t2;
  } }), Object.defineProperty(this, "appearanceState", { enumerable: true, configurable: true, get: function() {
    return e.substr(1, e.length - 1);
  }, set: function(t2) {
    e = "/" + t2;
  } });
}, "mt");
H(mt, lt);
var vt = /* @__PURE__ */ __name(function() {
  mt.call(this), this.pushButton = true;
}, "vt");
H(vt, mt);
var bt = /* @__PURE__ */ __name(function() {
  mt.call(this), this.radio = true, this.pushButton = false;
  var t2 = [];
  Object.defineProperty(this, "Kids", { enumerable: true, configurable: false, get: function() {
    return t2;
  }, set: function(e) {
    t2 = void 0 !== e ? e : [];
  } });
}, "bt");
H(bt, mt);
var yt = /* @__PURE__ */ __name(function() {
  var e, r;
  lt.call(this), Object.defineProperty(this, "Parent", { enumerable: false, configurable: false, get: function() {
    return e;
  }, set: function(t2) {
    e = t2;
  } }), Object.defineProperty(this, "optionName", { enumerable: false, configurable: true, get: function() {
    return r;
  }, set: function(t2) {
    r = t2;
  } });
  var n2, i2 = {};
  Object.defineProperty(this, "MK", { enumerable: false, configurable: false, get: function() {
    var t2 = /* @__PURE__ */ __name(function(t3) {
      return t3;
    }, "t");
    this.scope && (t2 = this.scope.internal.getEncryptor(this.objId));
    var e2, r2 = [];
    for (e2 in r2.push("<<"), i2)
      r2.push("/" + e2 + " (" + R(t2(i2[e2])) + ")");
    return r2.push(">>"), r2.join("\n");
  }, set: function(e2) {
    "object" === _typeof(e2) && (i2 = e2);
  } }), Object.defineProperty(this, "caption", { enumerable: true, configurable: true, get: function() {
    return i2.CA || "";
  }, set: function(t2) {
    "string" == typeof t2 && (i2.CA = t2);
  } }), Object.defineProperty(this, "AS", { enumerable: false, configurable: false, get: function() {
    return n2;
  }, set: function(t2) {
    n2 = t2;
  } }), Object.defineProperty(this, "appearanceState", { enumerable: true, configurable: true, get: function() {
    return n2.substr(1, n2.length - 1);
  }, set: function(t2) {
    n2 = "/" + t2;
  } }), this.caption = "l", this.appearanceState = "Off", this._AppearanceType = At.RadioButton.Circle, this.appearanceStreamContent = this._AppearanceType.createAppearanceStream(this.optionName);
}, "yt");
H(yt, lt), bt.prototype.setAppearance = function(t2) {
  if (!("createAppearanceStream" in t2) || !("getCA" in t2))
    throw new Error("Couldn't assign Appearance to RadioButton. Appearance was Invalid!");
  for (var e in this.Kids)
    if (this.Kids.hasOwnProperty(e)) {
      var r = this.Kids[e];
      r.appearanceStreamContent = t2.createAppearanceStream(r.optionName), r.caption = t2.getCA();
    }
}, bt.prototype.createOption = function(t2) {
  var e = new yt();
  return e.Parent = this, e.optionName = t2, this.Kids.push(e), xt.call(this.scope, e), e;
};
var wt = /* @__PURE__ */ __name(function() {
  mt.call(this), this.fontName = "zapfdingbats", this.caption = "3", this.appearanceState = "On", this.value = "On", this.textAlign = "center", this.appearanceStreamContent = At.CheckBox.createAppearanceStream();
}, "wt");
H(wt, mt);
var Nt = /* @__PURE__ */ __name(function() {
  lt.call(this), this.FT = "/Tx", Object.defineProperty(this, "multiline", { enumerable: true, configurable: true, get: function() {
    return Boolean(X(this.Ff, 13));
  }, set: function(t3) {
    true === Boolean(t3) ? this.Ff = K(this.Ff, 13) : this.Ff = Z(this.Ff, 13);
  } }), Object.defineProperty(this, "fileSelect", { enumerable: true, configurable: true, get: function() {
    return Boolean(X(this.Ff, 21));
  }, set: function(t3) {
    true === Boolean(t3) ? this.Ff = K(this.Ff, 21) : this.Ff = Z(this.Ff, 21);
  } }), Object.defineProperty(this, "doNotSpellCheck", { enumerable: true, configurable: true, get: function() {
    return Boolean(X(this.Ff, 23));
  }, set: function(t3) {
    true === Boolean(t3) ? this.Ff = K(this.Ff, 23) : this.Ff = Z(this.Ff, 23);
  } }), Object.defineProperty(this, "doNotScroll", { enumerable: true, configurable: true, get: function() {
    return Boolean(X(this.Ff, 24));
  }, set: function(t3) {
    true === Boolean(t3) ? this.Ff = K(this.Ff, 24) : this.Ff = Z(this.Ff, 24);
  } }), Object.defineProperty(this, "comb", { enumerable: true, configurable: true, get: function() {
    return Boolean(X(this.Ff, 25));
  }, set: function(t3) {
    true === Boolean(t3) ? this.Ff = K(this.Ff, 25) : this.Ff = Z(this.Ff, 25);
  } }), Object.defineProperty(this, "richText", { enumerable: true, configurable: true, get: function() {
    return Boolean(X(this.Ff, 26));
  }, set: function(t3) {
    true === Boolean(t3) ? this.Ff = K(this.Ff, 26) : this.Ff = Z(this.Ff, 26);
  } });
  var t2 = null;
  Object.defineProperty(this, "MaxLen", { enumerable: true, configurable: false, get: function() {
    return t2;
  }, set: function(e) {
    t2 = e;
  } }), Object.defineProperty(this, "maxLength", { enumerable: true, configurable: true, get: function() {
    return t2;
  }, set: function(e) {
    Number.isInteger(e) && (t2 = e);
  } }), Object.defineProperty(this, "hasAppearanceStream", { enumerable: true, configurable: true, get: function() {
    return this.V || this.DV;
  } });
}, "Nt");
H(Nt, lt);
var Lt = /* @__PURE__ */ __name(function() {
  Nt.call(this), Object.defineProperty(this, "password", { enumerable: true, configurable: true, get: function() {
    return Boolean(X(this.Ff, 14));
  }, set: function(t2) {
    true === Boolean(t2) ? this.Ff = K(this.Ff, 14) : this.Ff = Z(this.Ff, 14);
  } }), this.password = true;
}, "Lt");
H(Lt, Nt);
var At = { CheckBox: { createAppearanceStream: function() {
  return { N: { On: At.CheckBox.YesNormal }, D: { On: At.CheckBox.YesPushDown, Off: At.CheckBox.OffPushDown } };
}, YesPushDown: function(t2) {
  var e = V(t2);
  e.scope = t2.scope;
  var r = [], n2 = t2.scope.internal.getFont(t2.fontName, t2.fontStyle).id, i2 = t2.scope.__private__.encodeColorString(t2.color), a2 = tt(t2, t2.caption);
  return r.push("0.749023 g"), r.push("0 0 " + U(At.internal.getWidth(t2)) + " " + U(At.internal.getHeight(t2)) + " re"), r.push("f"), r.push("BMC"), r.push("q"), r.push("0 0 1 rg"), r.push("/" + n2 + " " + U(a2.fontSize) + " Tf " + i2), r.push("BT"), r.push(a2.text), r.push("ET"), r.push("Q"), r.push("EMC"), e.stream = r.join("\n"), e;
}, YesNormal: function(t2) {
  var e = V(t2);
  e.scope = t2.scope;
  var r = t2.scope.internal.getFont(t2.fontName, t2.fontStyle).id, n2 = t2.scope.__private__.encodeColorString(t2.color), i2 = [], a2 = At.internal.getHeight(t2), o2 = At.internal.getWidth(t2), s2 = tt(t2, t2.caption);
  return i2.push("1 g"), i2.push("0 0 " + U(o2) + " " + U(a2) + " re"), i2.push("f"), i2.push("q"), i2.push("0 0 1 rg"), i2.push("0 0 " + U(o2 - 1) + " " + U(a2 - 1) + " re"), i2.push("W"), i2.push("n"), i2.push("0 g"), i2.push("BT"), i2.push("/" + r + " " + U(s2.fontSize) + " Tf " + n2), i2.push(s2.text), i2.push("ET"), i2.push("Q"), e.stream = i2.join("\n"), e;
}, OffPushDown: function(t2) {
  var e = V(t2);
  e.scope = t2.scope;
  var r = [];
  return r.push("0.749023 g"), r.push("0 0 " + U(At.internal.getWidth(t2)) + " " + U(At.internal.getHeight(t2)) + " re"), r.push("f"), e.stream = r.join("\n"), e;
} }, RadioButton: { Circle: { createAppearanceStream: function(t2) {
  var e = { D: { Off: At.RadioButton.Circle.OffPushDown }, N: {} };
  return e.N[t2] = At.RadioButton.Circle.YesNormal, e.D[t2] = At.RadioButton.Circle.YesPushDown, e;
}, getCA: function() {
  return "l";
}, YesNormal: function(t2) {
  var e = V(t2);
  e.scope = t2.scope;
  var r = [], n2 = At.internal.getWidth(t2) <= At.internal.getHeight(t2) ? At.internal.getWidth(t2) / 4 : At.internal.getHeight(t2) / 4;
  n2 = Number((0.9 * n2).toFixed(5));
  var i2 = At.internal.Bezier_C, a2 = Number((n2 * i2).toFixed(5));
  return r.push("q"), r.push("1 0 0 1 " + z(At.internal.getWidth(t2) / 2) + " " + z(At.internal.getHeight(t2) / 2) + " cm"), r.push(n2 + " 0 m"), r.push(n2 + " " + a2 + " " + a2 + " " + n2 + " 0 " + n2 + " c"), r.push("-" + a2 + " " + n2 + " -" + n2 + " " + a2 + " -" + n2 + " 0 c"), r.push("-" + n2 + " -" + a2 + " -" + a2 + " -" + n2 + " 0 -" + n2 + " c"), r.push(a2 + " -" + n2 + " " + n2 + " -" + a2 + " " + n2 + " 0 c"), r.push("f"), r.push("Q"), e.stream = r.join("\n"), e;
}, YesPushDown: function(t2) {
  var e = V(t2);
  e.scope = t2.scope;
  var r = [], n2 = At.internal.getWidth(t2) <= At.internal.getHeight(t2) ? At.internal.getWidth(t2) / 4 : At.internal.getHeight(t2) / 4;
  n2 = Number((0.9 * n2).toFixed(5));
  var i2 = Number((2 * n2).toFixed(5)), a2 = Number((i2 * At.internal.Bezier_C).toFixed(5)), o2 = Number((n2 * At.internal.Bezier_C).toFixed(5));
  return r.push("0.749023 g"), r.push("q"), r.push("1 0 0 1 " + z(At.internal.getWidth(t2) / 2) + " " + z(At.internal.getHeight(t2) / 2) + " cm"), r.push(i2 + " 0 m"), r.push(i2 + " " + a2 + " " + a2 + " " + i2 + " 0 " + i2 + " c"), r.push("-" + a2 + " " + i2 + " -" + i2 + " " + a2 + " -" + i2 + " 0 c"), r.push("-" + i2 + " -" + a2 + " -" + a2 + " -" + i2 + " 0 -" + i2 + " c"), r.push(a2 + " -" + i2 + " " + i2 + " -" + a2 + " " + i2 + " 0 c"), r.push("f"), r.push("Q"), r.push("0 g"), r.push("q"), r.push("1 0 0 1 " + z(At.internal.getWidth(t2) / 2) + " " + z(At.internal.getHeight(t2) / 2) + " cm"), r.push(n2 + " 0 m"), r.push(n2 + " " + o2 + " " + o2 + " " + n2 + " 0 " + n2 + " c"), r.push("-" + o2 + " " + n2 + " -" + n2 + " " + o2 + " -" + n2 + " 0 c"), r.push("-" + n2 + " -" + o2 + " -" + o2 + " -" + n2 + " 0 -" + n2 + " c"), r.push(o2 + " -" + n2 + " " + n2 + " -" + o2 + " " + n2 + " 0 c"), r.push("f"), r.push("Q"), e.stream = r.join("\n"), e;
}, OffPushDown: function(t2) {
  var e = V(t2);
  e.scope = t2.scope;
  var r = [], n2 = At.internal.getWidth(t2) <= At.internal.getHeight(t2) ? At.internal.getWidth(t2) / 4 : At.internal.getHeight(t2) / 4;
  n2 = Number((0.9 * n2).toFixed(5));
  var i2 = Number((2 * n2).toFixed(5)), a2 = Number((i2 * At.internal.Bezier_C).toFixed(5));
  return r.push("0.749023 g"), r.push("q"), r.push("1 0 0 1 " + z(At.internal.getWidth(t2) / 2) + " " + z(At.internal.getHeight(t2) / 2) + " cm"), r.push(i2 + " 0 m"), r.push(i2 + " " + a2 + " " + a2 + " " + i2 + " 0 " + i2 + " c"), r.push("-" + a2 + " " + i2 + " -" + i2 + " " + a2 + " -" + i2 + " 0 c"), r.push("-" + i2 + " -" + a2 + " -" + a2 + " -" + i2 + " 0 -" + i2 + " c"), r.push(a2 + " -" + i2 + " " + i2 + " -" + a2 + " " + i2 + " 0 c"), r.push("f"), r.push("Q"), e.stream = r.join("\n"), e;
} }, Cross: { createAppearanceStream: function(t2) {
  var e = { D: { Off: At.RadioButton.Cross.OffPushDown }, N: {} };
  return e.N[t2] = At.RadioButton.Cross.YesNormal, e.D[t2] = At.RadioButton.Cross.YesPushDown, e;
}, getCA: function() {
  return "8";
}, YesNormal: function(t2) {
  var e = V(t2);
  e.scope = t2.scope;
  var r = [], n2 = At.internal.calculateCross(t2);
  return r.push("q"), r.push("1 1 " + U(At.internal.getWidth(t2) - 2) + " " + U(At.internal.getHeight(t2) - 2) + " re"), r.push("W"), r.push("n"), r.push(U(n2.x1.x) + " " + U(n2.x1.y) + " m"), r.push(U(n2.x2.x) + " " + U(n2.x2.y) + " l"), r.push(U(n2.x4.x) + " " + U(n2.x4.y) + " m"), r.push(U(n2.x3.x) + " " + U(n2.x3.y) + " l"), r.push("s"), r.push("Q"), e.stream = r.join("\n"), e;
}, YesPushDown: function(t2) {
  var e = V(t2);
  e.scope = t2.scope;
  var r = At.internal.calculateCross(t2), n2 = [];
  return n2.push("0.749023 g"), n2.push("0 0 " + U(At.internal.getWidth(t2)) + " " + U(At.internal.getHeight(t2)) + " re"), n2.push("f"), n2.push("q"), n2.push("1 1 " + U(At.internal.getWidth(t2) - 2) + " " + U(At.internal.getHeight(t2) - 2) + " re"), n2.push("W"), n2.push("n"), n2.push(U(r.x1.x) + " " + U(r.x1.y) + " m"), n2.push(U(r.x2.x) + " " + U(r.x2.y) + " l"), n2.push(U(r.x4.x) + " " + U(r.x4.y) + " m"), n2.push(U(r.x3.x) + " " + U(r.x3.y) + " l"), n2.push("s"), n2.push("Q"), e.stream = n2.join("\n"), e;
}, OffPushDown: function(t2) {
  var e = V(t2);
  e.scope = t2.scope;
  var r = [];
  return r.push("0.749023 g"), r.push("0 0 " + U(At.internal.getWidth(t2)) + " " + U(At.internal.getHeight(t2)) + " re"), r.push("f"), e.stream = r.join("\n"), e;
} } }, createDefaultAppearanceStream: function(t2) {
  var e = t2.scope.internal.getFont(t2.fontName, t2.fontStyle).id, r = t2.scope.__private__.encodeColorString(t2.color);
  return "/" + e + " " + t2.fontSize + " Tf " + r;
} };
At.internal = { Bezier_C: 0.551915024494, calculateCross: function(t2) {
  var e = At.internal.getWidth(t2), r = At.internal.getHeight(t2), n2 = Math.min(e, r);
  return { x1: { x: (e - n2) / 2, y: (r - n2) / 2 + n2 }, x2: { x: (e - n2) / 2 + n2, y: (r - n2) / 2 }, x3: { x: (e - n2) / 2, y: (r - n2) / 2 }, x4: { x: (e - n2) / 2 + n2, y: (r - n2) / 2 + n2 } };
} }, At.internal.getWidth = function(e) {
  var r = 0;
  return "object" === _typeof(e) && (r = W(e.Rect[2])), r;
}, At.internal.getHeight = function(e) {
  var r = 0;
  return "object" === _typeof(e) && (r = W(e.Rect[3])), r;
};
var xt = q.addField = function(t2) {
  if (at(this, t2), !(t2 instanceof lt))
    throw new Error("Invalid argument passed to jsPDF.addField.");
  var e;
  return (e = t2).scope.internal.acroformPlugin.printedOut && (e.scope.internal.acroformPlugin.printedOut = false, e.scope.internal.acroformPlugin.acroFormDictionaryRoot = null), e.scope.internal.acroformPlugin.acroFormDictionaryRoot.Fields.push(e), t2.page = t2.scope.internal.getCurrentPageInfo().pageNumber, this;
};
q.AcroFormChoiceField = ft, q.AcroFormListBox = dt, q.AcroFormComboBox = pt, q.AcroFormEditBox = gt, q.AcroFormButton = mt, q.AcroFormPushButton = vt, q.AcroFormRadioButton = bt, q.AcroFormCheckBox = wt, q.AcroFormTextField = Nt, q.AcroFormPasswordField = Lt, q.AcroFormAppearance = At, q.AcroForm = { ChoiceField: ft, ListBox: dt, ComboBox: pt, EditBox: gt, Button: mt, PushButton: vt, RadioButton: bt, CheckBox: wt, TextField: Nt, PasswordField: Lt, Appearance: At }, E.AcroForm = { ChoiceField: ft, ListBox: dt, ComboBox: pt, EditBox: gt, Button: mt, PushButton: vt, RadioButton: bt, CheckBox: wt, TextField: Nt, PasswordField: Lt, Appearance: At };
var St = E.AcroForm;
function _t(t2) {
  return t2.reduce(function(t3, e, r) {
    return t3[e] = r, t3;
  }, {});
}
__name(_t, "_t");
!function(e) {
  e.__addimage__ = {};
  var r = "UNKNOWN", n2 = { PNG: [[137, 80, 78, 71]], TIFF: [[77, 77, 0, 42], [73, 73, 42, 0]], JPEG: [[255, 216, 255, 224, void 0, void 0, 74, 70, 73, 70, 0], [255, 216, 255, 225, void 0, void 0, 69, 120, 105, 102, 0, 0], [255, 216, 255, 219], [255, 216, 255, 238]], JPEG2000: [[0, 0, 0, 12, 106, 80, 32, 32]], GIF87a: [[71, 73, 70, 56, 55, 97]], GIF89a: [[71, 73, 70, 56, 57, 97]], WEBP: [[82, 73, 70, 70, void 0, void 0, void 0, void 0, 87, 69, 66, 80]], BMP: [[66, 77], [66, 65], [67, 73], [67, 80], [73, 67], [80, 84]] }, i2 = e.__addimage__.getImageFileTypeByImageData = function(t2, e2) {
    var i3, a3, o3, s3, c3, u2 = r;
    if ("RGBA" === (e2 = e2 || r) || void 0 !== t2.data && t2.data instanceof Uint8ClampedArray && "height" in t2 && "width" in t2)
      return "RGBA";
    if (x2(t2))
      for (c3 in n2)
        for (o3 = n2[c3], i3 = 0; i3 < o3.length; i3 += 1) {
          for (s3 = true, a3 = 0; a3 < o3[i3].length; a3 += 1)
            if (void 0 !== o3[i3][a3] && o3[i3][a3] !== t2[a3]) {
              s3 = false;
              break;
            }
          if (true === s3) {
            u2 = c3;
            break;
          }
        }
    else
      for (c3 in n2)
        for (o3 = n2[c3], i3 = 0; i3 < o3.length; i3 += 1) {
          for (s3 = true, a3 = 0; a3 < o3[i3].length; a3 += 1)
            if (void 0 !== o3[i3][a3] && o3[i3][a3] !== t2.charCodeAt(a3)) {
              s3 = false;
              break;
            }
          if (true === s3) {
            u2 = c3;
            break;
          }
        }
    return u2 === r && e2 !== r && (u2 = e2), u2;
  }, a2 = /* @__PURE__ */ __name(function t2(e2) {
    for (var r2 = this.internal.write, n3 = this.internal.putStream, i3 = (0, this.internal.getFilters)(); -1 !== i3.indexOf("FlateEncode"); )
      i3.splice(i3.indexOf("FlateEncode"), 1);
    e2.objectId = this.internal.newObject();
    var a3 = [];
    if (a3.push({ key: "Type", value: "/XObject" }), a3.push({ key: "Subtype", value: "/Image" }), a3.push({ key: "Width", value: e2.width }), a3.push({ key: "Height", value: e2.height }), e2.colorSpace === b2.INDEXED ? a3.push({ key: "ColorSpace", value: "[/Indexed /DeviceRGB " + (e2.palette.length / 3 - 1) + " " + ("sMask" in e2 && void 0 !== e2.sMask ? e2.objectId + 2 : e2.objectId + 1) + " 0 R]" }) : (a3.push({ key: "ColorSpace", value: "/" + e2.colorSpace }), e2.colorSpace === b2.DEVICE_CMYK && a3.push({ key: "Decode", value: "[1 0 1 0 1 0 1 0]" })), a3.push({ key: "BitsPerComponent", value: e2.bitsPerComponent }), "decodeParameters" in e2 && void 0 !== e2.decodeParameters && a3.push({ key: "DecodeParms", value: "<<" + e2.decodeParameters + ">>" }), "transparency" in e2 && Array.isArray(e2.transparency)) {
      for (var o3 = "", s3 = 0, c3 = e2.transparency.length; s3 < c3; s3++)
        o3 += e2.transparency[s3] + " " + e2.transparency[s3] + " ";
      a3.push({ key: "Mask", value: "[" + o3 + "]" });
    }
    void 0 !== e2.sMask && a3.push({ key: "SMask", value: e2.objectId + 1 + " 0 R" });
    var u2 = void 0 !== e2.filter ? ["/" + e2.filter] : void 0;
    if (n3({ data: e2.data, additionalKeyValues: a3, alreadyAppliedFilters: u2, objectId: e2.objectId }), r2("endobj"), "sMask" in e2 && void 0 !== e2.sMask) {
      var h4 = "/Predictor " + e2.predictor + " /Colors 1 /BitsPerComponent " + e2.bitsPerComponent + " /Columns " + e2.width, l3 = { width: e2.width, height: e2.height, colorSpace: "DeviceGray", bitsPerComponent: e2.bitsPerComponent, decodeParameters: h4, data: e2.sMask };
      "filter" in e2 && (l3.filter = e2.filter), t2.call(this, l3);
    }
    if (e2.colorSpace === b2.INDEXED) {
      var f3 = this.internal.newObject();
      n3({ data: _2(new Uint8Array(e2.palette)), objectId: f3 }), r2("endobj");
    }
  }, "t"), o2 = /* @__PURE__ */ __name(function() {
    var t2 = this.internal.collections.addImage_images;
    for (var e2 in t2)
      a2.call(this, t2[e2]);
  }, "o"), s2 = /* @__PURE__ */ __name(function() {
    var t2, e2 = this.internal.collections.addImage_images, r2 = this.internal.write;
    for (var n3 in e2)
      r2("/I" + (t2 = e2[n3]).index, t2.objectId, "0", "R");
  }, "s"), c2 = /* @__PURE__ */ __name(function() {
    this.internal.collections.addImage_images || (this.internal.collections.addImage_images = {}, this.internal.events.subscribe("putResources", o2), this.internal.events.subscribe("putXobjectDict", s2));
  }, "c"), h3 = /* @__PURE__ */ __name(function() {
    var t2 = this.internal.collections.addImage_images;
    return c2.call(this), t2;
  }, "h"), l2 = /* @__PURE__ */ __name(function() {
    return Object.keys(this.internal.collections.addImage_images).length;
  }, "l"), f2 = /* @__PURE__ */ __name(function(t2) {
    return "function" == typeof e["process" + t2.toUpperCase()];
  }, "f"), d2 = /* @__PURE__ */ __name(function(e2) {
    return "object" === _typeof(e2) && 1 === e2.nodeType;
  }, "d"), p2 = /* @__PURE__ */ __name(function(t2, r2) {
    if ("IMG" === t2.nodeName && t2.hasAttribute("src")) {
      var n3 = "" + t2.getAttribute("src");
      if (0 === n3.indexOf("data:image/"))
        return u(unescape(n3).split("base64,").pop());
      var i3 = e.loadFile(n3, true);
      if (void 0 !== i3)
        return i3;
    }
    if ("CANVAS" === t2.nodeName) {
      if (0 === t2.width || 0 === t2.height)
        throw new Error("Given canvas must have data. Canvas width: " + t2.width + ", height: " + t2.height);
      var a3;
      switch (r2) {
        case "PNG":
          a3 = "image/png";
          break;
        case "WEBP":
          a3 = "image/webp";
          break;
        case "JPEG":
        case "JPG":
        default:
          a3 = "image/jpeg";
      }
      return u(t2.toDataURL(a3, 1).split("base64,").pop());
    }
  }, "p"), g2 = /* @__PURE__ */ __name(function(t2) {
    var e2 = this.internal.collections.addImage_images;
    if (e2) {
      for (var r2 in e2)
        if (t2 === e2[r2].alias)
          return e2[r2];
    }
  }, "g"), m2 = /* @__PURE__ */ __name(function(t2, e2, r2) {
    return t2 || e2 || (t2 = -96, e2 = -96), t2 < 0 && (t2 = -1 * r2.width * 72 / t2 / this.internal.scaleFactor), e2 < 0 && (e2 = -1 * r2.height * 72 / e2 / this.internal.scaleFactor), 0 === t2 && (t2 = e2 * r2.width / r2.height), 0 === e2 && (e2 = t2 * r2.height / r2.width), [t2, e2];
  }, "m"), v2 = /* @__PURE__ */ __name(function(t2, e2, r2, n3, i3, a3) {
    var o3 = m2.call(this, r2, n3, i3), s3 = this.internal.getCoordinateString, c3 = this.internal.getVerticalCoordinateString, u2 = h3.call(this);
    if (r2 = o3[0], n3 = o3[1], u2[i3.index] = i3, a3) {
      a3 *= Math.PI / 180;
      var l3 = Math.cos(a3), f3 = Math.sin(a3), d3 = /* @__PURE__ */ __name(function(t3) {
        return t3.toFixed(4);
      }, "d"), p3 = [d3(l3), d3(f3), d3(-1 * f3), d3(l3), 0, 0, "cm"];
    }
    this.internal.write("q"), a3 ? (this.internal.write([1, "0", "0", 1, s3(t2), c3(e2 + n3), "cm"].join(" ")), this.internal.write(p3.join(" ")), this.internal.write([s3(r2), "0", "0", s3(n3), "0", "0", "cm"].join(" "))) : this.internal.write([s3(r2), "0", "0", s3(n3), s3(t2), c3(e2 + n3), "cm"].join(" ")), this.isAdvancedAPI() && this.internal.write([1, 0, 0, -1, 0, 0, "cm"].join(" ")), this.internal.write("/I" + i3.index + " Do"), this.internal.write("Q");
  }, "v"), b2 = e.color_spaces = { DEVICE_RGB: "DeviceRGB", DEVICE_GRAY: "DeviceGray", DEVICE_CMYK: "DeviceCMYK", CAL_GREY: "CalGray", CAL_RGB: "CalRGB", LAB: "Lab", ICC_BASED: "ICCBased", INDEXED: "Indexed", PATTERN: "Pattern", SEPARATION: "Separation", DEVICE_N: "DeviceN" };
  e.decode = { DCT_DECODE: "DCTDecode", FLATE_DECODE: "FlateDecode", LZW_DECODE: "LZWDecode", JPX_DECODE: "JPXDecode", JBIG2_DECODE: "JBIG2Decode", ASCII85_DECODE: "ASCII85Decode", ASCII_HEX_DECODE: "ASCIIHexDecode", RUN_LENGTH_DECODE: "RunLengthDecode", CCITT_FAX_DECODE: "CCITTFaxDecode" };
  var y2 = e.image_compression = { NONE: "NONE", FAST: "FAST", MEDIUM: "MEDIUM", SLOW: "SLOW" }, w2 = e.__addimage__.sHashCode = function(t2) {
    var e2, r2, n3 = 0;
    if ("string" == typeof t2)
      for (r2 = t2.length, e2 = 0; e2 < r2; e2++)
        n3 = (n3 << 5) - n3 + t2.charCodeAt(e2), n3 |= 0;
    else if (x2(t2))
      for (r2 = t2.byteLength / 2, e2 = 0; e2 < r2; e2++)
        n3 = (n3 << 5) - n3 + t2[e2], n3 |= 0;
    return n3;
  }, N2 = e.__addimage__.validateStringAsBase64 = function(t2) {
    (t2 = t2 || "").toString().trim();
    var e2 = true;
    return 0 === t2.length && (e2 = false), t2.length % 4 != 0 && (e2 = false), false === /^[A-Za-z0-9+/]+$/.test(t2.substr(0, t2.length - 2)) && (e2 = false), false === /^[A-Za-z0-9/][A-Za-z0-9+/]|[A-Za-z0-9+/]=|==$/.test(t2.substr(-2)) && (e2 = false), e2;
  }, L2 = e.__addimage__.extractImageFromDataUrl = function(t2) {
    var e2 = (t2 = t2 || "").split("base64,"), r2 = null;
    if (2 === e2.length) {
      var n3 = /^data:(\w*\/\w*);*(charset=(?!charset=)[\w=-]*)*;*$/.exec(e2[0]);
      Array.isArray(n3) && (r2 = { mimeType: n3[1], charset: n3[2], data: e2[1] });
    }
    return r2;
  }, A2 = e.__addimage__.supportsArrayBuffer = function() {
    return "undefined" != typeof ArrayBuffer && "undefined" != typeof Uint8Array;
  };
  e.__addimage__.isArrayBuffer = function(t2) {
    return A2() && t2 instanceof ArrayBuffer;
  };
  var x2 = e.__addimage__.isArrayBufferView = function(t2) {
    return A2() && "undefined" != typeof Uint32Array && (t2 instanceof Int8Array || t2 instanceof Uint8Array || "undefined" != typeof Uint8ClampedArray && t2 instanceof Uint8ClampedArray || t2 instanceof Int16Array || t2 instanceof Uint16Array || t2 instanceof Int32Array || t2 instanceof Uint32Array || t2 instanceof Float32Array || t2 instanceof Float64Array);
  }, S2 = e.__addimage__.binaryStringToUint8Array = function(t2) {
    for (var e2 = t2.length, r2 = new Uint8Array(e2), n3 = 0; n3 < e2; n3++)
      r2[n3] = t2.charCodeAt(n3);
    return r2;
  }, _2 = e.__addimage__.arrayBufferToBinaryString = function(t2) {
    for (var e2 = "", r2 = x2(t2) ? t2 : new Uint8Array(t2), n3 = 0; n3 < r2.length; n3 += 8192)
      e2 += String.fromCharCode.apply(null, r2.subarray(n3, n3 + 8192));
    return e2;
  };
  e.addImage = function() {
    var e2, n3, i3, a3, o3, s3, u2, h4, l3;
    if ("number" == typeof arguments[1] ? (n3 = r, i3 = arguments[1], a3 = arguments[2], o3 = arguments[3], s3 = arguments[4], u2 = arguments[5], h4 = arguments[6], l3 = arguments[7]) : (n3 = arguments[1], i3 = arguments[2], a3 = arguments[3], o3 = arguments[4], s3 = arguments[5], u2 = arguments[6], h4 = arguments[7], l3 = arguments[8]), "object" === _typeof(e2 = arguments[0]) && !d2(e2) && "imageData" in e2) {
      var f3 = e2;
      e2 = f3.imageData, n3 = f3.format || n3 || r, i3 = f3.x || i3 || 0, a3 = f3.y || a3 || 0, o3 = f3.w || f3.width || o3, s3 = f3.h || f3.height || s3, u2 = f3.alias || u2, h4 = f3.compression || h4, l3 = f3.rotation || f3.angle || l3;
    }
    var p3 = this.internal.getFilters();
    if (void 0 === h4 && -1 !== p3.indexOf("FlateEncode") && (h4 = "SLOW"), isNaN(i3) || isNaN(a3))
      throw new Error("Invalid coordinates passed to jsPDF.addImage");
    c2.call(this);
    var g3 = P2.call(this, e2, n3, u2, h4);
    return v2.call(this, i3, a3, o3, s3, g3, l3), this;
  };
  var P2 = /* @__PURE__ */ __name(function(t2, n3, a3, o3) {
    var s3, c3, u2;
    if ("string" == typeof t2 && i2(t2) === r) {
      t2 = unescape(t2);
      var h4 = k2(t2, false);
      ("" !== h4 || void 0 !== (h4 = e.loadFile(t2, true))) && (t2 = h4);
    }
    if (d2(t2) && (t2 = p2(t2, n3)), n3 = i2(t2, n3), !f2(n3))
      throw new Error("addImage does not support files of type '" + n3 + "', please ensure that a plugin for '" + n3 + "' support is added.");
    if ((null == (u2 = a3) || 0 === u2.length) && (a3 = function(t3) {
      return "string" == typeof t3 || x2(t3) ? w2(t3) : x2(t3.data) ? w2(t3.data) : null;
    }(t2)), (s3 = g2.call(this, a3)) || (A2() && (t2 instanceof Uint8Array || "RGBA" === n3 || (c3 = t2, t2 = S2(t2))), s3 = this["process" + n3.toUpperCase()](t2, l2.call(this), a3, function(t3) {
      return t3 && "string" == typeof t3 && (t3 = t3.toUpperCase()), t3 in e.image_compression ? t3 : y2.NONE;
    }(o3), c3)), !s3)
      throw new Error("An unknown error occurred whilst processing the image.");
    return s3;
  }, "P"), k2 = e.__addimage__.convertBase64ToBinaryString = function(t2, e2) {
    var r2;
    e2 = "boolean" != typeof e2 || e2;
    var n3, i3 = "";
    if ("string" == typeof t2) {
      n3 = null !== (r2 = L2(t2)) ? r2.data : t2;
      try {
        i3 = u(n3);
      } catch (t3) {
        if (e2)
          throw N2(n3) ? new Error("atob-Error in jsPDF.convertBase64ToBinaryString " + t3.message) : new Error("Supplied Data is not a valid base64-String jsPDF.convertBase64ToBinaryString ");
      }
    }
    return i3;
  };
  e.getImageProperties = function(t2) {
    var n3, a3, o3 = "";
    if (d2(t2) && (t2 = p2(t2)), "string" == typeof t2 && i2(t2) === r && ("" === (o3 = k2(t2, false)) && (o3 = e.loadFile(t2) || ""), t2 = o3), a3 = i2(t2), !f2(a3))
      throw new Error("addImage does not support files of type '" + a3 + "', please ensure that a plugin for '" + a3 + "' support is added.");
    if (!A2() || t2 instanceof Uint8Array || (t2 = S2(t2)), !(n3 = this["process" + a3.toUpperCase()](t2)))
      throw new Error("An unknown error occurred whilst processing the image");
    return n3.fileType = a3, n3;
  };
}(E.API), /**
 * @license
 * Copyright (c) 2014 Steven Spungin (TwelveTone LLC)  steven@twelvetone.tv
 *
 * Licensed under the MIT License.
 * http://opensource.org/licenses/mit-license
 */
function(t2) {
  var e = /* @__PURE__ */ __name(function(t3) {
    if (void 0 !== t3 && "" != t3)
      return true;
  }, "e");
  E.API.events.push(["addPage", function(t3) {
    this.internal.getPageInfo(t3.pageNumber).pageContext.annotations = [];
  }]), t2.events.push(["putPage", function(t3) {
    for (var r, n2, i2, a2 = this.internal.getCoordinateString, o2 = this.internal.getVerticalCoordinateString, s2 = this.internal.getPageInfoByObjId(t3.objId), c2 = t3.pageContext.annotations, u2 = false, h3 = 0; h3 < c2.length && !u2; h3++)
      switch ((r = c2[h3]).type) {
        case "link":
          (e(r.options.url) || e(r.options.pageNumber)) && (u2 = true);
          break;
        case "reference":
        case "text":
        case "freetext":
          u2 = true;
      }
    if (0 != u2) {
      this.internal.write("/Annots [");
      for (var l2 = 0; l2 < c2.length; l2++) {
        r = c2[l2];
        var f2 = this.internal.pdfEscape, d2 = this.internal.getEncryptor(t3.objId);
        switch (r.type) {
          case "reference":
            this.internal.write(" " + r.object.objId + " 0 R ");
            break;
          case "text":
            var p2 = this.internal.newAdditionalObject(), g2 = this.internal.newAdditionalObject(), m2 = this.internal.getEncryptor(p2.objId), v2 = r.title || "Note";
            i2 = "<</Type /Annot /Subtype /Text " + (n2 = "/Rect [" + a2(r.bounds.x) + " " + o2(r.bounds.y + r.bounds.h) + " " + a2(r.bounds.x + r.bounds.w) + " " + o2(r.bounds.y) + "] ") + "/Contents (" + f2(m2(r.contents)) + ")", i2 += " /Popup " + g2.objId + " 0 R", i2 += " /P " + s2.objId + " 0 R", i2 += " /T (" + f2(m2(v2)) + ") >>", p2.content = i2;
            var b2 = p2.objId + " 0 R";
            i2 = "<</Type /Annot /Subtype /Popup " + (n2 = "/Rect [" + a2(r.bounds.x + 30) + " " + o2(r.bounds.y + r.bounds.h) + " " + a2(r.bounds.x + r.bounds.w + 30) + " " + o2(r.bounds.y) + "] ") + " /Parent " + b2, r.open && (i2 += " /Open true"), i2 += " >>", g2.content = i2, this.internal.write(p2.objId, "0 R", g2.objId, "0 R");
            break;
          case "freetext":
            n2 = "/Rect [" + a2(r.bounds.x) + " " + o2(r.bounds.y) + " " + a2(r.bounds.x + r.bounds.w) + " " + o2(r.bounds.y + r.bounds.h) + "] ";
            var y2 = r.color || "#000000";
            i2 = "<</Type /Annot /Subtype /FreeText " + n2 + "/Contents (" + f2(d2(r.contents)) + ")", i2 += " /DS(font: Helvetica,sans-serif 12.0pt; text-align:left; color:#" + y2 + ")", i2 += " /Border [0 0 0]", i2 += " >>", this.internal.write(i2);
            break;
          case "link":
            if (r.options.name) {
              var w2 = this.annotations._nameMap[r.options.name];
              r.options.pageNumber = w2.page, r.options.top = w2.y;
            } else
              r.options.top || (r.options.top = 0);
            if (n2 = "/Rect [" + r.finalBounds.x + " " + r.finalBounds.y + " " + r.finalBounds.w + " " + r.finalBounds.h + "] ", i2 = "", r.options.url)
              i2 = "<</Type /Annot /Subtype /Link " + n2 + "/Border [0 0 0] /A <</S /URI /URI (" + f2(d2(r.options.url)) + ") >>";
            else if (r.options.pageNumber) {
              switch (i2 = "<</Type /Annot /Subtype /Link " + n2 + "/Border [0 0 0] /Dest [" + this.internal.getPageInfo(r.options.pageNumber).objId + " 0 R", r.options.magFactor = r.options.magFactor || "XYZ", r.options.magFactor) {
                case "Fit":
                  i2 += " /Fit]";
                  break;
                case "FitH":
                  i2 += " /FitH " + r.options.top + "]";
                  break;
                case "FitV":
                  r.options.left = r.options.left || 0, i2 += " /FitV " + r.options.left + "]";
                  break;
                case "XYZ":
                default:
                  var N2 = o2(r.options.top);
                  r.options.left = r.options.left || 0, void 0 === r.options.zoom && (r.options.zoom = 0), i2 += " /XYZ " + r.options.left + " " + N2 + " " + r.options.zoom + "]";
              }
            }
            "" != i2 && (i2 += " >>", this.internal.write(i2));
        }
      }
      this.internal.write("]");
    }
  }]), t2.createAnnotation = function(t3) {
    var e2 = this.internal.getCurrentPageInfo();
    switch (t3.type) {
      case "link":
        this.link(t3.bounds.x, t3.bounds.y, t3.bounds.w, t3.bounds.h, t3);
        break;
      case "text":
      case "freetext":
        e2.pageContext.annotations.push(t3);
    }
  }, t2.link = function(t3, e2, r, n2, i2) {
    var a2 = this.internal.getCurrentPageInfo(), o2 = this.internal.getCoordinateString, s2 = this.internal.getVerticalCoordinateString;
    a2.pageContext.annotations.push({ finalBounds: { x: o2(t3), y: s2(e2), w: o2(t3 + r), h: s2(e2 + n2) }, options: i2, type: "link" });
  }, t2.textWithLink = function(t3, e2, r, n2) {
    var i2, a2, o2 = this.getTextWidth(t3), s2 = this.internal.getLineHeight() / this.internal.scaleFactor;
    if (void 0 !== n2.maxWidth) {
      a2 = n2.maxWidth;
      var c2 = this.splitTextToSize(t3, a2).length;
      i2 = Math.ceil(s2 * c2);
    } else
      a2 = o2, i2 = s2;
    return this.text(t3, e2, r, n2), r += 0.2 * s2, "center" === n2.align && (e2 -= o2 / 2), "right" === n2.align && (e2 -= o2), this.link(e2, r - s2, a2, i2, n2), o2;
  }, t2.getTextWidth = function(t3) {
    var e2 = this.internal.getFontSize();
    return this.getStringUnitWidth(t3) * e2 / this.internal.scaleFactor;
  };
}(E.API), /**
 * @license
 * Copyright (c) 2017 Aras Abbasi
 *
 * Licensed under the MIT License.
 * http://opensource.org/licenses/mit-license
 */
function(t2) {
  var e = { 1569: [65152], 1570: [65153, 65154], 1571: [65155, 65156], 1572: [65157, 65158], 1573: [65159, 65160], 1574: [65161, 65162, 65163, 65164], 1575: [65165, 65166], 1576: [65167, 65168, 65169, 65170], 1577: [65171, 65172], 1578: [65173, 65174, 65175, 65176], 1579: [65177, 65178, 65179, 65180], 1580: [65181, 65182, 65183, 65184], 1581: [65185, 65186, 65187, 65188], 1582: [65189, 65190, 65191, 65192], 1583: [65193, 65194], 1584: [65195, 65196], 1585: [65197, 65198], 1586: [65199, 65200], 1587: [65201, 65202, 65203, 65204], 1588: [65205, 65206, 65207, 65208], 1589: [65209, 65210, 65211, 65212], 1590: [65213, 65214, 65215, 65216], 1591: [65217, 65218, 65219, 65220], 1592: [65221, 65222, 65223, 65224], 1593: [65225, 65226, 65227, 65228], 1594: [65229, 65230, 65231, 65232], 1601: [65233, 65234, 65235, 65236], 1602: [65237, 65238, 65239, 65240], 1603: [65241, 65242, 65243, 65244], 1604: [65245, 65246, 65247, 65248], 1605: [65249, 65250, 65251, 65252], 1606: [65253, 65254, 65255, 65256], 1607: [65257, 65258, 65259, 65260], 1608: [65261, 65262], 1609: [65263, 65264, 64488, 64489], 1610: [65265, 65266, 65267, 65268], 1649: [64336, 64337], 1655: [64477], 1657: [64358, 64359, 64360, 64361], 1658: [64350, 64351, 64352, 64353], 1659: [64338, 64339, 64340, 64341], 1662: [64342, 64343, 64344, 64345], 1663: [64354, 64355, 64356, 64357], 1664: [64346, 64347, 64348, 64349], 1667: [64374, 64375, 64376, 64377], 1668: [64370, 64371, 64372, 64373], 1670: [64378, 64379, 64380, 64381], 1671: [64382, 64383, 64384, 64385], 1672: [64392, 64393], 1676: [64388, 64389], 1677: [64386, 64387], 1678: [64390, 64391], 1681: [64396, 64397], 1688: [64394, 64395], 1700: [64362, 64363, 64364, 64365], 1702: [64366, 64367, 64368, 64369], 1705: [64398, 64399, 64400, 64401], 1709: [64467, 64468, 64469, 64470], 1711: [64402, 64403, 64404, 64405], 1713: [64410, 64411, 64412, 64413], 1715: [64406, 64407, 64408, 64409], 1722: [64414, 64415], 1723: [64416, 64417, 64418, 64419], 1726: [64426, 64427, 64428, 64429], 1728: [64420, 64421], 1729: [64422, 64423, 64424, 64425], 1733: [64480, 64481], 1734: [64473, 64474], 1735: [64471, 64472], 1736: [64475, 64476], 1737: [64482, 64483], 1739: [64478, 64479], 1740: [64508, 64509, 64510, 64511], 1744: [64484, 64485, 64486, 64487], 1746: [64430, 64431], 1747: [64432, 64433] }, r = { 65247: { 65154: 65269, 65156: 65271, 65160: 65273, 65166: 65275 }, 65248: { 65154: 65270, 65156: 65272, 65160: 65274, 65166: 65276 }, 65165: { 65247: { 65248: { 65258: 65010 } } }, 1617: { 1612: 64606, 1613: 64607, 1614: 64608, 1615: 64609, 1616: 64610 } }, n2 = { 1612: 64606, 1613: 64607, 1614: 64608, 1615: 64609, 1616: 64610 }, i2 = [1570, 1571, 1573, 1575];
  t2.__arabicParser__ = {};
  var a2 = t2.__arabicParser__.isInArabicSubstitutionA = function(t3) {
    return void 0 !== e[t3.charCodeAt(0)];
  }, o2 = t2.__arabicParser__.isArabicLetter = function(t3) {
    return "string" == typeof t3 && /^[\u0600-\u06FF\u0750-\u077F\u08A0-\u08FF\uFB50-\uFDFF\uFE70-\uFEFF]+$/.test(t3);
  }, s2 = t2.__arabicParser__.isArabicEndLetter = function(t3) {
    return o2(t3) && a2(t3) && e[t3.charCodeAt(0)].length <= 2;
  }, c2 = t2.__arabicParser__.isArabicAlfLetter = function(t3) {
    return o2(t3) && i2.indexOf(t3.charCodeAt(0)) >= 0;
  };
  t2.__arabicParser__.arabicLetterHasIsolatedForm = function(t3) {
    return o2(t3) && a2(t3) && e[t3.charCodeAt(0)].length >= 1;
  };
  var u2 = t2.__arabicParser__.arabicLetterHasFinalForm = function(t3) {
    return o2(t3) && a2(t3) && e[t3.charCodeAt(0)].length >= 2;
  };
  t2.__arabicParser__.arabicLetterHasInitialForm = function(t3) {
    return o2(t3) && a2(t3) && e[t3.charCodeAt(0)].length >= 3;
  };
  var h3 = t2.__arabicParser__.arabicLetterHasMedialForm = function(t3) {
    return o2(t3) && a2(t3) && 4 == e[t3.charCodeAt(0)].length;
  }, l2 = t2.__arabicParser__.resolveLigatures = function(t3) {
    var e2 = 0, n3 = r, i3 = "", a3 = 0;
    for (e2 = 0; e2 < t3.length; e2 += 1)
      void 0 !== n3[t3.charCodeAt(e2)] ? (a3++, "number" == typeof (n3 = n3[t3.charCodeAt(e2)]) && (i3 += String.fromCharCode(n3), n3 = r, a3 = 0), e2 === t3.length - 1 && (n3 = r, i3 += t3.charAt(e2 - (a3 - 1)), e2 -= a3 - 1, a3 = 0)) : (n3 = r, i3 += t3.charAt(e2 - a3), e2 -= a3, a3 = 0);
    return i3;
  };
  t2.__arabicParser__.isArabicDiacritic = function(t3) {
    return void 0 !== t3 && void 0 !== n2[t3.charCodeAt(0)];
  };
  var f2 = t2.__arabicParser__.getCorrectForm = function(t3, e2, r2) {
    return o2(t3) ? false === a2(t3) ? -1 : !u2(t3) || !o2(e2) && !o2(r2) || !o2(r2) && s2(e2) || s2(t3) && !o2(e2) || s2(t3) && c2(e2) || s2(t3) && s2(e2) ? 0 : h3(t3) && o2(e2) && !s2(e2) && o2(r2) && u2(r2) ? 3 : s2(t3) || !o2(r2) ? 1 : 2 : -1;
  }, d2 = /* @__PURE__ */ __name(function(t3) {
    var r2 = 0, n3 = 0, i3 = 0, a3 = "", s3 = "", c3 = "", u3 = (t3 = t3 || "").split("\\s+"), h4 = [];
    for (r2 = 0; r2 < u3.length; r2 += 1) {
      for (h4.push(""), n3 = 0; n3 < u3[r2].length; n3 += 1)
        a3 = u3[r2][n3], s3 = u3[r2][n3 - 1], c3 = u3[r2][n3 + 1], o2(a3) ? (i3 = f2(a3, s3, c3), h4[r2] += -1 !== i3 ? String.fromCharCode(e[a3.charCodeAt(0)][i3]) : a3) : h4[r2] += a3;
      h4[r2] = l2(h4[r2]);
    }
    return h4.join(" ");
  }, "d"), p2 = t2.__arabicParser__.processArabic = t2.processArabic = function() {
    var t3, e2 = "string" == typeof arguments[0] ? arguments[0] : arguments[0].text, r2 = [];
    if (Array.isArray(e2)) {
      var n3 = 0;
      for (r2 = [], n3 = 0; n3 < e2.length; n3 += 1)
        Array.isArray(e2[n3]) ? r2.push([d2(e2[n3][0]), e2[n3][1], e2[n3][2]]) : r2.push([d2(e2[n3])]);
      t3 = r2;
    } else
      t3 = d2(e2);
    return "string" == typeof arguments[0] ? t3 : (arguments[0].text = t3, arguments[0]);
  };
  t2.events.push(["preProcessText", p2]);
}(E.API), E.API.autoPrint = function(t2) {
  var e;
  switch ((t2 = t2 || {}).variant = t2.variant || "non-conform", t2.variant) {
    case "javascript":
      this.addJS("print({});");
      break;
    case "non-conform":
    default:
      this.internal.events.subscribe("postPutResources", function() {
        e = this.internal.newObject(), this.internal.out("<<"), this.internal.out("/S /Named"), this.internal.out("/Type /Action"), this.internal.out("/N /Print"), this.internal.out(">>"), this.internal.out("endobj");
      }), this.internal.events.subscribe("putCatalog", function() {
        this.internal.out("/OpenAction " + e + " 0 R");
      });
  }
  return this;
}, /**
 * @license
 * Copyright (c) 2014 Steven Spungin (TwelveTone LLC)  steven@twelvetone.tv
 *
 * Licensed under the MIT License.
 * http://opensource.org/licenses/mit-license
 */
function(t2) {
  var e = /* @__PURE__ */ __name(function() {
    var t3 = void 0;
    Object.defineProperty(this, "pdf", { get: function() {
      return t3;
    }, set: function(e3) {
      t3 = e3;
    } });
    var e2 = 150;
    Object.defineProperty(this, "width", { get: function() {
      return e2;
    }, set: function(t4) {
      e2 = isNaN(t4) || false === Number.isInteger(t4) || t4 < 0 ? 150 : t4, this.getContext("2d").pageWrapXEnabled && (this.getContext("2d").pageWrapX = e2 + 1);
    } });
    var r = 300;
    Object.defineProperty(this, "height", { get: function() {
      return r;
    }, set: function(t4) {
      r = isNaN(t4) || false === Number.isInteger(t4) || t4 < 0 ? 300 : t4, this.getContext("2d").pageWrapYEnabled && (this.getContext("2d").pageWrapY = r + 1);
    } });
    var n2 = [];
    Object.defineProperty(this, "childNodes", { get: function() {
      return n2;
    }, set: function(t4) {
      n2 = t4;
    } });
    var i2 = {};
    Object.defineProperty(this, "style", { get: function() {
      return i2;
    }, set: function(t4) {
      i2 = t4;
    } }), Object.defineProperty(this, "parentNode", {});
  }, "e");
  e.prototype.getContext = function(t3, e2) {
    var r;
    if ("2d" !== (t3 = t3 || "2d"))
      return null;
    for (r in e2)
      this.pdf.context2d.hasOwnProperty(r) && (this.pdf.context2d[r] = e2[r]);
    return this.pdf.context2d._canvas = this, this.pdf.context2d;
  }, e.prototype.toDataURL = function() {
    throw new Error("toDataURL is not implemented.");
  }, t2.events.push(["initialized", function() {
    this.canvas = new e(), this.canvas.pdf = this;
  }]);
}(E.API), function(e) {
  var r = { left: 0, top: 0, bottom: 0, right: 0 }, n2 = false, i2 = /* @__PURE__ */ __name(function() {
    void 0 === this.internal.__cell__ && (this.internal.__cell__ = {}, this.internal.__cell__.padding = 3, this.internal.__cell__.headerFunction = void 0, this.internal.__cell__.margins = Object.assign({}, r), this.internal.__cell__.margins.width = this.getPageWidth(), a2.call(this));
  }, "i"), a2 = /* @__PURE__ */ __name(function() {
    this.internal.__cell__.lastCell = new o2(), this.internal.__cell__.pages = 1;
  }, "a"), o2 = /* @__PURE__ */ __name(function() {
    var t2 = arguments[0];
    Object.defineProperty(this, "x", { enumerable: true, get: function() {
      return t2;
    }, set: function(e3) {
      t2 = e3;
    } });
    var e2 = arguments[1];
    Object.defineProperty(this, "y", { enumerable: true, get: function() {
      return e2;
    }, set: function(t3) {
      e2 = t3;
    } });
    var r2 = arguments[2];
    Object.defineProperty(this, "width", { enumerable: true, get: function() {
      return r2;
    }, set: function(t3) {
      r2 = t3;
    } });
    var n3 = arguments[3];
    Object.defineProperty(this, "height", { enumerable: true, get: function() {
      return n3;
    }, set: function(t3) {
      n3 = t3;
    } });
    var i3 = arguments[4];
    Object.defineProperty(this, "text", { enumerable: true, get: function() {
      return i3;
    }, set: function(t3) {
      i3 = t3;
    } });
    var a3 = arguments[5];
    Object.defineProperty(this, "lineNumber", { enumerable: true, get: function() {
      return a3;
    }, set: function(t3) {
      a3 = t3;
    } });
    var o3 = arguments[6];
    return Object.defineProperty(this, "align", { enumerable: true, get: function() {
      return o3;
    }, set: function(t3) {
      o3 = t3;
    } }), this;
  }, "o");
  o2.prototype.clone = function() {
    return new o2(this.x, this.y, this.width, this.height, this.text, this.lineNumber, this.align);
  }, o2.prototype.toArray = function() {
    return [this.x, this.y, this.width, this.height, this.text, this.lineNumber, this.align];
  }, e.setHeaderFunction = function(t2) {
    return i2.call(this), this.internal.__cell__.headerFunction = "function" == typeof t2 ? t2 : void 0, this;
  }, e.getTextDimensions = function(t2, e2) {
    i2.call(this);
    var r2 = (e2 = e2 || {}).fontSize || this.getFontSize(), n3 = e2.font || this.getFont(), a3 = e2.scaleFactor || this.internal.scaleFactor, o3 = 0, s3 = 0, c3 = 0, u2 = this;
    if (!Array.isArray(t2) && "string" != typeof t2) {
      if ("number" != typeof t2)
        throw new Error("getTextDimensions expects text-parameter to be of type String or type Number or an Array of Strings.");
      t2 = String(t2);
    }
    var h3 = e2.maxWidth;
    h3 > 0 ? "string" == typeof t2 ? t2 = this.splitTextToSize(t2, h3) : "[object Array]" === Object.prototype.toString.call(t2) && (t2 = t2.reduce(function(t3, e3) {
      return t3.concat(u2.splitTextToSize(e3, h3));
    }, [])) : t2 = Array.isArray(t2) ? t2 : [t2];
    for (var l2 = 0; l2 < t2.length; l2++)
      o3 < (c3 = this.getStringUnitWidth(t2[l2], { font: n3 }) * r2) && (o3 = c3);
    return 0 !== o3 && (s3 = t2.length), { w: o3 /= a3, h: Math.max((s3 * r2 * this.getLineHeightFactor() - r2 * (this.getLineHeightFactor() - 1)) / a3, 0) };
  }, e.cellAddPage = function() {
    i2.call(this), this.addPage();
    var t2 = this.internal.__cell__.margins || r;
    return this.internal.__cell__.lastCell = new o2(t2.left, t2.top, void 0, void 0), this.internal.__cell__.pages += 1, this;
  };
  var s2 = e.cell = function() {
    var t2;
    t2 = arguments[0] instanceof o2 ? arguments[0] : new o2(arguments[0], arguments[1], arguments[2], arguments[3], arguments[4], arguments[5]), i2.call(this);
    var e2 = this.internal.__cell__.lastCell, a3 = this.internal.__cell__.padding, s3 = this.internal.__cell__.margins || r, c3 = this.internal.__cell__.tableHeaderRow, u2 = this.internal.__cell__.printHeaders;
    return void 0 !== e2.lineNumber && (e2.lineNumber === t2.lineNumber ? (t2.x = (e2.x || 0) + (e2.width || 0), t2.y = e2.y || 0) : e2.y + e2.height + t2.height + s3.bottom > this.getPageHeight() ? (this.cellAddPage(), t2.y = s3.top, u2 && c3 && (this.printHeaderRow(t2.lineNumber, true), t2.y += c3[0].height)) : t2.y = e2.y + e2.height || t2.y), void 0 !== t2.text[0] && (this.rect(t2.x, t2.y, t2.width, t2.height, true === n2 ? "FD" : void 0), "right" === t2.align ? this.text(t2.text, t2.x + t2.width - a3, t2.y + a3, { align: "right", baseline: "top" }) : "center" === t2.align ? this.text(t2.text, t2.x + t2.width / 2, t2.y + a3, { align: "center", baseline: "top", maxWidth: t2.width - a3 - a3 }) : this.text(t2.text, t2.x + a3, t2.y + a3, { align: "left", baseline: "top", maxWidth: t2.width - a3 - a3 })), this.internal.__cell__.lastCell = t2, this;
  };
  e.table = function(e2, n3, u2, h3, l2) {
    if (i2.call(this), !u2)
      throw new Error("No data for PDF table.");
    var f2, d2, p2, g2, m2 = [], v2 = [], b2 = [], y2 = {}, w2 = {}, N2 = [], L2 = [], A2 = (l2 = l2 || {}).autoSize || false, x2 = false !== l2.printHeaders, S2 = l2.css && void 0 !== l2.css["font-size"] ? 16 * l2.css["font-size"] : l2.fontSize || 12, _2 = l2.margins || Object.assign({ width: this.getPageWidth() }, r), P2 = "number" == typeof l2.padding ? l2.padding : 3, k2 = l2.headerBackgroundColor || "#c8c8c8", I2 = l2.headerTextColor || "#000";
    if (a2.call(this), this.internal.__cell__.printHeaders = x2, this.internal.__cell__.margins = _2, this.internal.__cell__.table_font_size = S2, this.internal.__cell__.padding = P2, this.internal.__cell__.headerBackgroundColor = k2, this.internal.__cell__.headerTextColor = I2, this.setFontSize(S2), null == h3)
      v2 = m2 = Object.keys(u2[0]), b2 = m2.map(function() {
        return "left";
      });
    else if (Array.isArray(h3) && "object" === _typeof(h3[0]))
      for (m2 = h3.map(function(t2) {
        return t2.name;
      }), v2 = h3.map(function(t2) {
        return t2.prompt || t2.name || "";
      }), b2 = h3.map(function(t2) {
        return t2.align || "left";
      }), f2 = 0; f2 < h3.length; f2 += 1)
        w2[h3[f2].name] = h3[f2].width * (19.049976 / 25.4);
    else
      Array.isArray(h3) && "string" == typeof h3[0] && (v2 = m2 = h3, b2 = m2.map(function() {
        return "left";
      }));
    if (A2 || Array.isArray(h3) && "string" == typeof h3[0])
      for (f2 = 0; f2 < m2.length; f2 += 1) {
        for (y2[g2 = m2[f2]] = u2.map(function(t2) {
          return t2[g2];
        }), this.setFont(void 0, "bold"), N2.push(this.getTextDimensions(v2[f2], { fontSize: this.internal.__cell__.table_font_size, scaleFactor: this.internal.scaleFactor }).w), d2 = y2[g2], this.setFont(void 0, "normal"), p2 = 0; p2 < d2.length; p2 += 1)
          N2.push(this.getTextDimensions(d2[p2], { fontSize: this.internal.__cell__.table_font_size, scaleFactor: this.internal.scaleFactor }).w);
        w2[g2] = Math.max.apply(null, N2) + P2 + P2, N2 = [];
      }
    if (x2) {
      var F2 = {};
      for (f2 = 0; f2 < m2.length; f2 += 1)
        F2[m2[f2]] = {}, F2[m2[f2]].text = v2[f2], F2[m2[f2]].align = b2[f2];
      var C2 = c2.call(this, F2, w2);
      L2 = m2.map(function(t2) {
        return new o2(e2, n3, w2[t2], C2, F2[t2].text, void 0, F2[t2].align);
      }), this.setTableHeaderRow(L2), this.printHeaderRow(1, false);
    }
    var j2 = h3.reduce(function(t2, e3) {
      return t2[e3.name] = e3.align, t2;
    }, {});
    for (f2 = 0; f2 < u2.length; f2 += 1) {
      "rowStart" in l2 && l2.rowStart instanceof Function && l2.rowStart({ row: f2, data: u2[f2] }, this);
      var O2 = c2.call(this, u2[f2], w2);
      for (p2 = 0; p2 < m2.length; p2 += 1) {
        var B2 = u2[f2][m2[p2]];
        "cellStart" in l2 && l2.cellStart instanceof Function && l2.cellStart({ row: f2, col: p2, data: B2 }, this), s2.call(this, new o2(e2, n3, w2[m2[p2]], O2, B2, f2 + 2, j2[m2[p2]]));
      }
    }
    return this.internal.__cell__.table_x = e2, this.internal.__cell__.table_y = n3, this;
  };
  var c2 = /* @__PURE__ */ __name(function(t2, e2) {
    var r2 = this.internal.__cell__.padding, n3 = this.internal.__cell__.table_font_size, i3 = this.internal.scaleFactor;
    return Object.keys(t2).map(function(n4) {
      var i4 = t2[n4];
      return this.splitTextToSize(i4.hasOwnProperty("text") ? i4.text : i4, e2[n4] - r2 - r2);
    }, this).map(function(t3) {
      return this.getLineHeightFactor() * t3.length * n3 / i3 + r2 + r2;
    }, this).reduce(function(t3, e3) {
      return Math.max(t3, e3);
    }, 0);
  }, "c");
  e.setTableHeaderRow = function(t2) {
    i2.call(this), this.internal.__cell__.tableHeaderRow = t2;
  }, e.printHeaderRow = function(t2, e2) {
    if (i2.call(this), !this.internal.__cell__.tableHeaderRow)
      throw new Error("Property tableHeaderRow does not exist.");
    var r2;
    if (n2 = true, "function" == typeof this.internal.__cell__.headerFunction) {
      var a3 = this.internal.__cell__.headerFunction(this, this.internal.__cell__.pages);
      this.internal.__cell__.lastCell = new o2(a3[0], a3[1], a3[2], a3[3], void 0, -1);
    }
    this.setFont(void 0, "bold");
    for (var c3 = [], u2 = 0; u2 < this.internal.__cell__.tableHeaderRow.length; u2 += 1) {
      r2 = this.internal.__cell__.tableHeaderRow[u2].clone(), e2 && (r2.y = this.internal.__cell__.margins.top || 0, c3.push(r2)), r2.lineNumber = t2;
      var h3 = this.getTextColor();
      this.setTextColor(this.internal.__cell__.headerTextColor), this.setFillColor(this.internal.__cell__.headerBackgroundColor), s2.call(this, r2), this.setTextColor(h3);
    }
    c3.length > 0 && this.setTableHeaderRow(c3), this.setFont(void 0, "normal"), n2 = false;
  };
}(E.API);
var Pt = { italic: ["italic", "oblique", "normal"], oblique: ["oblique", "italic", "normal"], normal: ["normal", "oblique", "italic"] }, kt = ["ultra-condensed", "extra-condensed", "condensed", "semi-condensed", "normal", "semi-expanded", "expanded", "extra-expanded", "ultra-expanded"], It = _t(kt), Ft = [100, 200, 300, 400, 500, 600, 700, 800, 900], Ct = _t(Ft);
function jt(t2) {
  var e = t2.family.replace(/"|'/g, "").toLowerCase(), r = function(t3) {
    return Pt[t3 = t3 || "normal"] ? t3 : "normal";
  }(t2.style), n2 = function(t3) {
    if (!t3)
      return 400;
    if ("number" == typeof t3)
      return t3 >= 100 && t3 <= 900 && t3 % 100 == 0 ? t3 : 400;
    if (/^\d00$/.test(t3))
      return parseInt(t3);
    switch (t3) {
      case "bold":
        return 700;
      case "normal":
      default:
        return 400;
    }
  }(t2.weight), i2 = function(t3) {
    return "number" == typeof It[t3 = t3 || "normal"] ? t3 : "normal";
  }(t2.stretch);
  return { family: e, style: r, weight: n2, stretch: i2, src: t2.src || [], ref: t2.ref || { name: e, style: [i2, r, n2].join(" ") } };
}
__name(jt, "jt");
function Ot(t2, e, r, n2) {
  var i2;
  for (i2 = r; i2 >= 0 && i2 < e.length; i2 += n2)
    if (t2[e[i2]])
      return t2[e[i2]];
  for (i2 = r; i2 >= 0 && i2 < e.length; i2 -= n2)
    if (t2[e[i2]])
      return t2[e[i2]];
}
__name(Ot, "Ot");
var Bt = { "sans-serif": "helvetica", fixed: "courier", monospace: "courier", terminal: "courier", cursive: "times", fantasy: "times", serif: "times" }, Mt = { caption: "times", icon: "times", menu: "times", "message-box": "times", "small-caption": "times", "status-bar": "times" };
function Et(t2) {
  return [t2.stretch, t2.style, t2.weight, t2.family].join(" ");
}
__name(Et, "Et");
function qt(t2, e, r) {
  for (var n2 = (r = r || {}).defaultFontFamily || "times", i2 = Object.assign({}, Bt, r.genericFontFamilies || {}), a2 = null, o2 = null, s2 = 0; s2 < e.length; ++s2)
    if (i2[(a2 = jt(e[s2])).family] && (a2.family = i2[a2.family]), t2.hasOwnProperty(a2.family)) {
      o2 = t2[a2.family];
      break;
    }
  if (!(o2 = o2 || t2[n2]))
    throw new Error("Could not find a font-family for the rule '" + Et(a2) + "' and default family '" + n2 + "'.");
  if (o2 = function(t3, e2) {
    if (e2[t3])
      return e2[t3];
    var r2 = It[t3], n3 = r2 <= It.normal ? -1 : 1, i3 = Ot(e2, kt, r2, n3);
    if (!i3)
      throw new Error("Could not find a matching font-stretch value for " + t3);
    return i3;
  }(a2.stretch, o2), o2 = function(t3, e2) {
    if (e2[t3])
      return e2[t3];
    for (var r2 = Pt[t3], n3 = 0; n3 < r2.length; ++n3)
      if (e2[r2[n3]])
        return e2[r2[n3]];
    throw new Error("Could not find a matching font-style for " + t3);
  }(a2.style, o2), !(o2 = function(t3, e2) {
    if (e2[t3])
      return e2[t3];
    if (400 === t3 && e2[500])
      return e2[500];
    if (500 === t3 && e2[400])
      return e2[400];
    var r2 = Ct[t3], n3 = Ot(e2, Ft, r2, t3 < 400 ? -1 : 1);
    if (!n3)
      throw new Error("Could not find a matching font-weight for value " + t3);
    return n3;
  }(a2.weight, o2)))
    throw new Error("Failed to resolve a font for the rule '" + Et(a2) + "'.");
  return o2;
}
__name(qt, "qt");
function Dt(t2) {
  return t2.trimLeft();
}
__name(Dt, "Dt");
function Rt(t2, e) {
  for (var r = 0; r < t2.length; ) {
    if (t2.charAt(r) === e)
      return [t2.substring(0, r), t2.substring(r + 1)];
    r += 1;
  }
  return null;
}
__name(Rt, "Rt");
function Tt(t2) {
  var e = t2.match(/^(-[a-z_]|[a-z_])[a-z0-9_-]*/i);
  return null === e ? null : [e[0], t2.substring(e[0].length)];
}
__name(Tt, "Tt");
var Ut, zt, Ht, Wt = ["times"];
!function(e) {
  var r, n2, i2, o2, s2, c2, u2, h3, l2, d2 = /* @__PURE__ */ __name(function(t2) {
    return t2 = t2 || {}, this.isStrokeTransparent = t2.isStrokeTransparent || false, this.strokeOpacity = t2.strokeOpacity || 1, this.strokeStyle = t2.strokeStyle || "#000000", this.fillStyle = t2.fillStyle || "#000000", this.isFillTransparent = t2.isFillTransparent || false, this.fillOpacity = t2.fillOpacity || 1, this.font = t2.font || "10px sans-serif", this.textBaseline = t2.textBaseline || "alphabetic", this.textAlign = t2.textAlign || "left", this.lineWidth = t2.lineWidth || 1, this.lineJoin = t2.lineJoin || "miter", this.lineCap = t2.lineCap || "butt", this.path = t2.path || [], this.transform = void 0 !== t2.transform ? t2.transform.clone() : new h3(), this.globalCompositeOperation = t2.globalCompositeOperation || "normal", this.globalAlpha = t2.globalAlpha || 1, this.clip_path = t2.clip_path || [], this.currentPoint = t2.currentPoint || new c2(), this.miterLimit = t2.miterLimit || 10, this.lastPoint = t2.lastPoint || new c2(), this.lineDashOffset = t2.lineDashOffset || 0, this.lineDash = t2.lineDash || [], this.margin = t2.margin || [0, 0, 0, 0], this.prevPageLastElemOffset = t2.prevPageLastElemOffset || 0, this.ignoreClearRect = "boolean" != typeof t2.ignoreClearRect || t2.ignoreClearRect, this;
  }, "d");
  e.events.push(["initialized", function() {
    this.context2d = new p2(this), r = this.internal.f2, n2 = this.internal.getCoordinateString, i2 = this.internal.getVerticalCoordinateString, o2 = this.internal.getHorizontalCoordinate, s2 = this.internal.getVerticalCoordinate, c2 = this.internal.Point, u2 = this.internal.Rectangle, h3 = this.internal.Matrix, l2 = new d2();
  }]);
  var p2 = /* @__PURE__ */ __name(function(t2) {
    Object.defineProperty(this, "canvas", { get: function() {
      return { parentNode: false, style: false };
    } });
    var e2 = t2;
    Object.defineProperty(this, "pdf", { get: function() {
      return e2;
    } });
    var r2 = false;
    Object.defineProperty(this, "pageWrapXEnabled", { get: function() {
      return r2;
    }, set: function(t3) {
      r2 = Boolean(t3);
    } });
    var n3 = false;
    Object.defineProperty(this, "pageWrapYEnabled", { get: function() {
      return n3;
    }, set: function(t3) {
      n3 = Boolean(t3);
    } });
    var i3 = 0;
    Object.defineProperty(this, "posX", { get: function() {
      return i3;
    }, set: function(t3) {
      isNaN(t3) || (i3 = t3);
    } });
    var a2 = 0;
    Object.defineProperty(this, "posY", { get: function() {
      return a2;
    }, set: function(t3) {
      isNaN(t3) || (a2 = t3);
    } }), Object.defineProperty(this, "margin", { get: function() {
      return l2.margin;
    }, set: function(t3) {
      var e3;
      "number" == typeof t3 ? e3 = [t3, t3, t3, t3] : ((e3 = new Array(4))[0] = t3[0], e3[1] = t3.length >= 2 ? t3[1] : e3[0], e3[2] = t3.length >= 3 ? t3[2] : e3[0], e3[3] = t3.length >= 4 ? t3[3] : e3[1]), l2.margin = e3;
    } });
    var o3 = false;
    Object.defineProperty(this, "autoPaging", { get: function() {
      return o3;
    }, set: function(t3) {
      o3 = t3;
    } });
    var s3 = 0;
    Object.defineProperty(this, "lastBreak", { get: function() {
      return s3;
    }, set: function(t3) {
      s3 = t3;
    } });
    var c3 = [];
    Object.defineProperty(this, "pageBreaks", { get: function() {
      return c3;
    }, set: function(t3) {
      c3 = t3;
    } }), Object.defineProperty(this, "ctx", { get: function() {
      return l2;
    }, set: function(t3) {
      t3 instanceof d2 && (l2 = t3);
    } }), Object.defineProperty(this, "path", { get: function() {
      return l2.path;
    }, set: function(t3) {
      l2.path = t3;
    } });
    var u3 = [];
    Object.defineProperty(this, "ctxStack", { get: function() {
      return u3;
    }, set: function(t3) {
      u3 = t3;
    } }), Object.defineProperty(this, "fillStyle", { get: function() {
      return this.ctx.fillStyle;
    }, set: function(t3) {
      var e3;
      e3 = g2(t3), this.ctx.fillStyle = e3.style, this.ctx.isFillTransparent = 0 === e3.a, this.ctx.fillOpacity = e3.a, this.pdf.setFillColor(e3.r, e3.g, e3.b, { a: e3.a }), this.pdf.setTextColor(e3.r, e3.g, e3.b, { a: e3.a });
    } }), Object.defineProperty(this, "strokeStyle", { get: function() {
      return this.ctx.strokeStyle;
    }, set: function(t3) {
      var e3 = g2(t3);
      this.ctx.strokeStyle = e3.style, this.ctx.isStrokeTransparent = 0 === e3.a, this.ctx.strokeOpacity = e3.a, 0 === e3.a ? this.pdf.setDrawColor(255, 255, 255) : (e3.a, this.pdf.setDrawColor(e3.r, e3.g, e3.b));
    } }), Object.defineProperty(this, "lineCap", { get: function() {
      return this.ctx.lineCap;
    }, set: function(t3) {
      -1 !== ["butt", "round", "square"].indexOf(t3) && (this.ctx.lineCap = t3, this.pdf.setLineCap(t3));
    } }), Object.defineProperty(this, "lineWidth", { get: function() {
      return this.ctx.lineWidth;
    }, set: function(t3) {
      isNaN(t3) || (this.ctx.lineWidth = t3, this.pdf.setLineWidth(t3));
    } }), Object.defineProperty(this, "lineJoin", { get: function() {
      return this.ctx.lineJoin;
    }, set: function(t3) {
      -1 !== ["bevel", "round", "miter"].indexOf(t3) && (this.ctx.lineJoin = t3, this.pdf.setLineJoin(t3));
    } }), Object.defineProperty(this, "miterLimit", { get: function() {
      return this.ctx.miterLimit;
    }, set: function(t3) {
      isNaN(t3) || (this.ctx.miterLimit = t3, this.pdf.setMiterLimit(t3));
    } }), Object.defineProperty(this, "textBaseline", { get: function() {
      return this.ctx.textBaseline;
    }, set: function(t3) {
      this.ctx.textBaseline = t3;
    } }), Object.defineProperty(this, "textAlign", { get: function() {
      return this.ctx.textAlign;
    }, set: function(t3) {
      -1 !== ["right", "end", "center", "left", "start"].indexOf(t3) && (this.ctx.textAlign = t3);
    } });
    var h4 = null;
    function f2(t3, e3) {
      if (null === h4) {
        var r3 = function(t4) {
          var e4 = [];
          return Object.keys(t4).forEach(function(r4) {
            t4[r4].forEach(function(t5) {
              var n4 = null;
              switch (t5) {
                case "bold":
                  n4 = { family: r4, weight: "bold" };
                  break;
                case "italic":
                  n4 = { family: r4, style: "italic" };
                  break;
                case "bolditalic":
                  n4 = { family: r4, weight: "bold", style: "italic" };
                  break;
                case "":
                case "normal":
                  n4 = { family: r4 };
              }
              null !== n4 && (n4.ref = { name: r4, style: t5 }, e4.push(n4));
            });
          }), e4;
        }(t3.getFontList());
        h4 = function(t4) {
          for (var e4 = {}, r4 = 0; r4 < t4.length; ++r4) {
            var n4 = jt(t4[r4]), i4 = n4.family, a3 = n4.stretch, o4 = n4.style, s4 = n4.weight;
            e4[i4] = e4[i4] || {}, e4[i4][a3] = e4[i4][a3] || {}, e4[i4][a3][o4] = e4[i4][a3][o4] || {}, e4[i4][a3][o4][s4] = n4;
          }
          return e4;
        }(r3.concat(e3));
      }
      return h4;
    }
    __name(f2, "f");
    var p3 = null;
    Object.defineProperty(this, "fontFaces", { get: function() {
      return p3;
    }, set: function(t3) {
      h4 = null, p3 = t3;
    } }), Object.defineProperty(this, "font", { get: function() {
      return this.ctx.font;
    }, set: function(t3) {
      var e3;
      if (this.ctx.font = t3, null !== (e3 = /^\s*(?=(?:(?:[-a-z]+\s*){0,2}(italic|oblique))?)(?=(?:(?:[-a-z]+\s*){0,2}(small-caps))?)(?=(?:(?:[-a-z]+\s*){0,2}(bold(?:er)?|lighter|[1-9]00))?)(?:(?:normal|\1|\2|\3)\s*){0,3}((?:xx?-)?(?:small|large)|medium|smaller|larger|[.\d]+(?:\%|in|[cem]m|ex|p[ctx]))(?:\s*\/\s*(normal|[.\d]+(?:\%|in|[cem]m|ex|p[ctx])))?\s*([-_,\"\'\sa-z]+?)\s*$/i.exec(t3))) {
        var r3 = e3[1], n4 = (e3[2], e3[3]), i4 = e3[4], a3 = (e3[5], e3[6]), o4 = /^([.\d]+)((?:%|in|[cem]m|ex|p[ctx]))$/i.exec(i4)[2];
        i4 = "px" === o4 ? Math.floor(parseFloat(i4) * this.pdf.internal.scaleFactor) : "em" === o4 ? Math.floor(parseFloat(i4) * this.pdf.getFontSize()) : Math.floor(parseFloat(i4) * this.pdf.internal.scaleFactor), this.pdf.setFontSize(i4);
        var s4 = function(t4) {
          var e4, r4, n5 = [], i5 = t4.trim();
          if ("" === i5)
            return Wt;
          if (i5 in Mt)
            return [Mt[i5]];
          for (; "" !== i5; ) {
            switch (r4 = null, e4 = (i5 = Dt(i5)).charAt(0)) {
              case '"':
              case "'":
                r4 = Rt(i5.substring(1), e4);
                break;
              default:
                r4 = Tt(i5);
            }
            if (null === r4)
              return Wt;
            if (n5.push(r4[0]), "" !== (i5 = Dt(r4[1])) && "," !== i5.charAt(0))
              return Wt;
            i5 = i5.replace(/^,/, "");
          }
          return n5;
        }(a3);
        if (this.fontFaces) {
          var c4 = qt(f2(this.pdf, this.fontFaces), s4.map(function(t4) {
            return { family: t4, stretch: "normal", weight: n4, style: r3 };
          }));
          this.pdf.setFont(c4.ref.name, c4.ref.style);
        } else {
          var u4 = "";
          ("bold" === n4 || parseInt(n4, 10) >= 700 || "bold" === r3) && (u4 = "bold"), "italic" === r3 && (u4 += "italic"), 0 === u4.length && (u4 = "normal");
          for (var h5 = "", l3 = { arial: "Helvetica", Arial: "Helvetica", verdana: "Helvetica", Verdana: "Helvetica", helvetica: "Helvetica", Helvetica: "Helvetica", "sans-serif": "Helvetica", fixed: "Courier", monospace: "Courier", terminal: "Courier", cursive: "Times", fantasy: "Times", serif: "Times" }, d3 = 0; d3 < s4.length; d3++) {
            if (void 0 !== this.pdf.internal.getFont(s4[d3], u4, { noFallback: true, disableWarning: true })) {
              h5 = s4[d3];
              break;
            }
            if ("bolditalic" === u4 && void 0 !== this.pdf.internal.getFont(s4[d3], "bold", { noFallback: true, disableWarning: true }))
              h5 = s4[d3], u4 = "bold";
            else if (void 0 !== this.pdf.internal.getFont(s4[d3], "normal", { noFallback: true, disableWarning: true })) {
              h5 = s4[d3], u4 = "normal";
              break;
            }
          }
          if ("" === h5) {
            for (var p4 = 0; p4 < s4.length; p4++)
              if (l3[s4[p4]]) {
                h5 = l3[s4[p4]];
                break;
              }
          }
          h5 = "" === h5 ? "Times" : h5, this.pdf.setFont(h5, u4);
        }
      }
    } }), Object.defineProperty(this, "globalCompositeOperation", { get: function() {
      return this.ctx.globalCompositeOperation;
    }, set: function(t3) {
      this.ctx.globalCompositeOperation = t3;
    } }), Object.defineProperty(this, "globalAlpha", { get: function() {
      return this.ctx.globalAlpha;
    }, set: function(t3) {
      this.ctx.globalAlpha = t3;
    } }), Object.defineProperty(this, "lineDashOffset", { get: function() {
      return this.ctx.lineDashOffset;
    }, set: function(t3) {
      this.ctx.lineDashOffset = t3, T2.call(this);
    } }), Object.defineProperty(this, "lineDash", { get: function() {
      return this.ctx.lineDash;
    }, set: function(t3) {
      this.ctx.lineDash = t3, T2.call(this);
    } }), Object.defineProperty(this, "ignoreClearRect", { get: function() {
      return this.ctx.ignoreClearRect;
    }, set: function(t3) {
      this.ctx.ignoreClearRect = Boolean(t3);
    } });
  }, "p");
  p2.prototype.setLineDash = function(t2) {
    this.lineDash = t2;
  }, p2.prototype.getLineDash = function() {
    return this.lineDash.length % 2 ? this.lineDash.concat(this.lineDash) : this.lineDash.slice();
  }, p2.prototype.fill = function() {
    A2.call(this, "fill", false);
  }, p2.prototype.stroke = function() {
    A2.call(this, "stroke", false);
  }, p2.prototype.beginPath = function() {
    this.path = [{ type: "begin" }];
  }, p2.prototype.moveTo = function(t2, e2) {
    if (isNaN(t2) || isNaN(e2))
      throw a.error("jsPDF.context2d.moveTo: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.moveTo");
    var r2 = this.ctx.transform.applyToPoint(new c2(t2, e2));
    this.path.push({ type: "mt", x: r2.x, y: r2.y }), this.ctx.lastPoint = new c2(t2, e2);
  }, p2.prototype.closePath = function() {
    var e2 = new c2(0, 0), r2 = 0;
    for (r2 = this.path.length - 1; -1 !== r2; r2--)
      if ("begin" === this.path[r2].type && "object" === _typeof(this.path[r2 + 1]) && "number" == typeof this.path[r2 + 1].x) {
        e2 = new c2(this.path[r2 + 1].x, this.path[r2 + 1].y);
        break;
      }
    this.path.push({ type: "close" }), this.ctx.lastPoint = new c2(e2.x, e2.y);
  }, p2.prototype.lineTo = function(t2, e2) {
    if (isNaN(t2) || isNaN(e2))
      throw a.error("jsPDF.context2d.lineTo: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.lineTo");
    var r2 = this.ctx.transform.applyToPoint(new c2(t2, e2));
    this.path.push({ type: "lt", x: r2.x, y: r2.y }), this.ctx.lastPoint = new c2(r2.x, r2.y);
  }, p2.prototype.clip = function() {
    this.ctx.clip_path = JSON.parse(JSON.stringify(this.path)), A2.call(this, null, true);
  }, p2.prototype.quadraticCurveTo = function(t2, e2, r2, n3) {
    if (isNaN(r2) || isNaN(n3) || isNaN(t2) || isNaN(e2))
      throw a.error("jsPDF.context2d.quadraticCurveTo: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.quadraticCurveTo");
    var i3 = this.ctx.transform.applyToPoint(new c2(r2, n3)), o3 = this.ctx.transform.applyToPoint(new c2(t2, e2));
    this.path.push({ type: "qct", x1: o3.x, y1: o3.y, x: i3.x, y: i3.y }), this.ctx.lastPoint = new c2(i3.x, i3.y);
  }, p2.prototype.bezierCurveTo = function(t2, e2, r2, n3, i3, o3) {
    if (isNaN(i3) || isNaN(o3) || isNaN(t2) || isNaN(e2) || isNaN(r2) || isNaN(n3))
      throw a.error("jsPDF.context2d.bezierCurveTo: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.bezierCurveTo");
    var s3 = this.ctx.transform.applyToPoint(new c2(i3, o3)), u3 = this.ctx.transform.applyToPoint(new c2(t2, e2)), h4 = this.ctx.transform.applyToPoint(new c2(r2, n3));
    this.path.push({ type: "bct", x1: u3.x, y1: u3.y, x2: h4.x, y2: h4.y, x: s3.x, y: s3.y }), this.ctx.lastPoint = new c2(s3.x, s3.y);
  }, p2.prototype.arc = function(t2, e2, r2, n3, i3, o3) {
    if (isNaN(t2) || isNaN(e2) || isNaN(r2) || isNaN(n3) || isNaN(i3))
      throw a.error("jsPDF.context2d.arc: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.arc");
    if (o3 = Boolean(o3), !this.ctx.transform.isIdentity) {
      var s3 = this.ctx.transform.applyToPoint(new c2(t2, e2));
      t2 = s3.x, e2 = s3.y;
      var u3 = this.ctx.transform.applyToPoint(new c2(0, r2)), h4 = this.ctx.transform.applyToPoint(new c2(0, 0));
      r2 = Math.sqrt(Math.pow(u3.x - h4.x, 2) + Math.pow(u3.y - h4.y, 2));
    }
    Math.abs(i3 - n3) >= 2 * Math.PI && (n3 = 0, i3 = 2 * Math.PI), this.path.push({ type: "arc", x: t2, y: e2, radius: r2, startAngle: n3, endAngle: i3, counterclockwise: o3 });
  }, p2.prototype.arcTo = function(t2, e2, r2, n3, i3) {
    throw new Error("arcTo not implemented.");
  }, p2.prototype.rect = function(t2, e2, r2, n3) {
    if (isNaN(t2) || isNaN(e2) || isNaN(r2) || isNaN(n3))
      throw a.error("jsPDF.context2d.rect: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.rect");
    this.moveTo(t2, e2), this.lineTo(t2 + r2, e2), this.lineTo(t2 + r2, e2 + n3), this.lineTo(t2, e2 + n3), this.lineTo(t2, e2), this.lineTo(t2 + r2, e2), this.lineTo(t2, e2);
  }, p2.prototype.fillRect = function(t2, e2, r2, n3) {
    if (isNaN(t2) || isNaN(e2) || isNaN(r2) || isNaN(n3))
      throw a.error("jsPDF.context2d.fillRect: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.fillRect");
    if (!m2.call(this)) {
      var i3 = {};
      "butt" !== this.lineCap && (i3.lineCap = this.lineCap, this.lineCap = "butt"), "miter" !== this.lineJoin && (i3.lineJoin = this.lineJoin, this.lineJoin = "miter"), this.beginPath(), this.rect(t2, e2, r2, n3), this.fill(), i3.hasOwnProperty("lineCap") && (this.lineCap = i3.lineCap), i3.hasOwnProperty("lineJoin") && (this.lineJoin = i3.lineJoin);
    }
  }, p2.prototype.strokeRect = function(t2, e2, r2, n3) {
    if (isNaN(t2) || isNaN(e2) || isNaN(r2) || isNaN(n3))
      throw a.error("jsPDF.context2d.strokeRect: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.strokeRect");
    v2.call(this) || (this.beginPath(), this.rect(t2, e2, r2, n3), this.stroke());
  }, p2.prototype.clearRect = function(t2, e2, r2, n3) {
    if (isNaN(t2) || isNaN(e2) || isNaN(r2) || isNaN(n3))
      throw a.error("jsPDF.context2d.clearRect: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.clearRect");
    this.ignoreClearRect || (this.fillStyle = "#ffffff", this.fillRect(t2, e2, r2, n3));
  }, p2.prototype.save = function(t2) {
    t2 = "boolean" != typeof t2 || t2;
    for (var e2 = this.pdf.internal.getCurrentPageInfo().pageNumber, r2 = 0; r2 < this.pdf.internal.getNumberOfPages(); r2++)
      this.pdf.setPage(r2 + 1), this.pdf.internal.out("q");
    if (this.pdf.setPage(e2), t2) {
      this.ctx.fontSize = this.pdf.internal.getFontSize();
      var n3 = new d2(this.ctx);
      this.ctxStack.push(this.ctx), this.ctx = n3;
    }
  }, p2.prototype.restore = function(t2) {
    t2 = "boolean" != typeof t2 || t2;
    for (var e2 = this.pdf.internal.getCurrentPageInfo().pageNumber, r2 = 0; r2 < this.pdf.internal.getNumberOfPages(); r2++)
      this.pdf.setPage(r2 + 1), this.pdf.internal.out("Q");
    this.pdf.setPage(e2), t2 && 0 !== this.ctxStack.length && (this.ctx = this.ctxStack.pop(), this.fillStyle = this.ctx.fillStyle, this.strokeStyle = this.ctx.strokeStyle, this.font = this.ctx.font, this.lineCap = this.ctx.lineCap, this.lineWidth = this.ctx.lineWidth, this.lineJoin = this.ctx.lineJoin, this.lineDash = this.ctx.lineDash, this.lineDashOffset = this.ctx.lineDashOffset);
  }, p2.prototype.toDataURL = function() {
    throw new Error("toDataUrl not implemented.");
  };
  var g2 = /* @__PURE__ */ __name(function(t2) {
    var e2, r2, n3, i3;
    if (true === t2.isCanvasGradient && (t2 = t2.getColor()), !t2)
      return { r: 0, g: 0, b: 0, a: 0, style: t2 };
    if (/transparent|rgba\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*,\s*0+\s*\)/.test(t2))
      e2 = 0, r2 = 0, n3 = 0, i3 = 0;
    else {
      var a2 = /rgb\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*\)/.exec(t2);
      if (null !== a2)
        e2 = parseInt(a2[1]), r2 = parseInt(a2[2]), n3 = parseInt(a2[3]), i3 = 1;
      else if (null !== (a2 = /rgba\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*,\s*([\d.]+)\s*\)/.exec(t2)))
        e2 = parseInt(a2[1]), r2 = parseInt(a2[2]), n3 = parseInt(a2[3]), i3 = parseFloat(a2[4]);
      else {
        if (i3 = 1, "string" == typeof t2 && "#" !== t2.charAt(0)) {
          var o3 = new f(t2);
          t2 = o3.ok ? o3.toHex() : "#000000";
        }
        4 === t2.length ? (e2 = t2.substring(1, 2), e2 += e2, r2 = t2.substring(2, 3), r2 += r2, n3 = t2.substring(3, 4), n3 += n3) : (e2 = t2.substring(1, 3), r2 = t2.substring(3, 5), n3 = t2.substring(5, 7)), e2 = parseInt(e2, 16), r2 = parseInt(r2, 16), n3 = parseInt(n3, 16);
      }
    }
    return { r: e2, g: r2, b: n3, a: i3, style: t2 };
  }, "g"), m2 = /* @__PURE__ */ __name(function() {
    return this.ctx.isFillTransparent || 0 == this.globalAlpha;
  }, "m"), v2 = /* @__PURE__ */ __name(function() {
    return Boolean(this.ctx.isStrokeTransparent || 0 == this.globalAlpha);
  }, "v");
  p2.prototype.fillText = function(t2, e2, r2, n3) {
    if (isNaN(e2) || isNaN(r2) || "string" != typeof t2)
      throw a.error("jsPDF.context2d.fillText: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.fillText");
    if (n3 = isNaN(n3) ? void 0 : n3, !m2.call(this)) {
      var i3 = q2(this.ctx.transform.rotation), o3 = this.ctx.transform.scaleX;
      C2.call(this, { text: t2, x: e2, y: r2, scale: o3, angle: i3, align: this.textAlign, maxWidth: n3 });
    }
  }, p2.prototype.strokeText = function(t2, e2, r2, n3) {
    if (isNaN(e2) || isNaN(r2) || "string" != typeof t2)
      throw a.error("jsPDF.context2d.strokeText: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.strokeText");
    if (!v2.call(this)) {
      n3 = isNaN(n3) ? void 0 : n3;
      var i3 = q2(this.ctx.transform.rotation), o3 = this.ctx.transform.scaleX;
      C2.call(this, { text: t2, x: e2, y: r2, scale: o3, renderingMode: "stroke", angle: i3, align: this.textAlign, maxWidth: n3 });
    }
  }, p2.prototype.measureText = function(t2) {
    if ("string" != typeof t2)
      throw a.error("jsPDF.context2d.measureText: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.measureText");
    var e2 = this.pdf, r2 = this.pdf.internal.scaleFactor, n3 = e2.internal.getFontSize(), i3 = e2.getStringUnitWidth(t2) * n3 / e2.internal.scaleFactor, o3 = /* @__PURE__ */ __name(function(t3) {
      var e3 = (t3 = t3 || {}).width || 0;
      return Object.defineProperty(this, "width", { get: function() {
        return e3;
      } }), this;
    }, "o");
    return new o3({ width: i3 *= Math.round(96 * r2 / 72 * 1e4) / 1e4 });
  }, p2.prototype.scale = function(t2, e2) {
    if (isNaN(t2) || isNaN(e2))
      throw a.error("jsPDF.context2d.scale: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.scale");
    var r2 = new h3(t2, 0, 0, e2, 0, 0);
    this.ctx.transform = this.ctx.transform.multiply(r2);
  }, p2.prototype.rotate = function(t2) {
    if (isNaN(t2))
      throw a.error("jsPDF.context2d.rotate: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.rotate");
    var e2 = new h3(Math.cos(t2), Math.sin(t2), -Math.sin(t2), Math.cos(t2), 0, 0);
    this.ctx.transform = this.ctx.transform.multiply(e2);
  }, p2.prototype.translate = function(t2, e2) {
    if (isNaN(t2) || isNaN(e2))
      throw a.error("jsPDF.context2d.translate: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.translate");
    var r2 = new h3(1, 0, 0, 1, t2, e2);
    this.ctx.transform = this.ctx.transform.multiply(r2);
  }, p2.prototype.transform = function(t2, e2, r2, n3, i3, o3) {
    if (isNaN(t2) || isNaN(e2) || isNaN(r2) || isNaN(n3) || isNaN(i3) || isNaN(o3))
      throw a.error("jsPDF.context2d.transform: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.transform");
    var s3 = new h3(t2, e2, r2, n3, i3, o3);
    this.ctx.transform = this.ctx.transform.multiply(s3);
  }, p2.prototype.setTransform = function(t2, e2, r2, n3, i3, a2) {
    t2 = isNaN(t2) ? 1 : t2, e2 = isNaN(e2) ? 0 : e2, r2 = isNaN(r2) ? 0 : r2, n3 = isNaN(n3) ? 1 : n3, i3 = isNaN(i3) ? 0 : i3, a2 = isNaN(a2) ? 0 : a2, this.ctx.transform = new h3(t2, e2, r2, n3, i3, a2);
  };
  var b2 = /* @__PURE__ */ __name(function() {
    return this.margin[0] > 0 || this.margin[1] > 0 || this.margin[2] > 0 || this.margin[3] > 0;
  }, "b");
  p2.prototype.drawImage = function(t2, e2, r2, n3, i3, a2, o3, s3, c3) {
    var l3 = this.pdf.getImageProperties(t2), f2 = 1, d3 = 1, p3 = 1, g3 = 1;
    void 0 !== n3 && void 0 !== s3 && (p3 = s3 / n3, g3 = c3 / i3, f2 = l3.width / n3 * s3 / n3, d3 = l3.height / i3 * c3 / i3), void 0 === a2 && (a2 = e2, o3 = r2, e2 = 0, r2 = 0), void 0 !== n3 && void 0 === s3 && (s3 = n3, c3 = i3), void 0 === n3 && void 0 === s3 && (s3 = l3.width, c3 = l3.height);
    for (var m3, v3 = this.ctx.transform.decompose(), w3 = q2(v3.rotate.shx), A3 = new h3(), S3 = (A3 = (A3 = (A3 = A3.multiply(v3.translate)).multiply(v3.skew)).multiply(v3.scale)).applyToRectangle(new u2(a2 - e2 * p3, o3 - r2 * g3, n3 * f2, i3 * d3)), _3 = y2.call(this, S3), P3 = [], k3 = 0; k3 < _3.length; k3 += 1)
      -1 === P3.indexOf(_3[k3]) && P3.push(_3[k3]);
    if (L2(P3), this.autoPaging)
      for (var I3 = P3[0], F3 = P3[P3.length - 1], C3 = I3; C3 < F3 + 1; C3++) {
        this.pdf.setPage(C3);
        var j3 = this.pdf.internal.pageSize.width - this.margin[3] - this.margin[1], O3 = 1 === C3 ? this.posY + this.margin[0] : this.margin[0], B3 = this.pdf.internal.pageSize.height - this.posY - this.margin[0] - this.margin[2], M3 = this.pdf.internal.pageSize.height - this.margin[0] - this.margin[2], E3 = 1 === C3 ? 0 : B3 + (C3 - 2) * M3;
        if (0 !== this.ctx.clip_path.length) {
          var D3 = this.path;
          m3 = JSON.parse(JSON.stringify(this.ctx.clip_path)), this.path = N2(m3, this.posX + this.margin[3], -E3 + O3 + this.ctx.prevPageLastElemOffset), x2.call(this, "fill", true), this.path = D3;
        }
        var R3 = JSON.parse(JSON.stringify(S3));
        R3 = N2([R3], this.posX + this.margin[3], -E3 + O3 + this.ctx.prevPageLastElemOffset)[0];
        var T3 = (C3 > I3 || C3 < F3) && b2.call(this);
        T3 && (this.pdf.saveGraphicsState(), this.pdf.rect(this.margin[3], this.margin[0], j3, M3, null).clip().discardPath()), this.pdf.addImage(t2, "JPEG", R3.x, R3.y, R3.w, R3.h, null, null, w3), T3 && this.pdf.restoreGraphicsState();
      }
    else
      this.pdf.addImage(t2, "JPEG", S3.x, S3.y, S3.w, S3.h, null, null, w3);
  };
  var y2 = /* @__PURE__ */ __name(function(t2, e2, r2) {
    var n3 = [];
    e2 = e2 || this.pdf.internal.pageSize.width, r2 = r2 || this.pdf.internal.pageSize.height - this.margin[0] - this.margin[2];
    var i3 = this.posY + this.ctx.prevPageLastElemOffset;
    switch (t2.type) {
      default:
      case "mt":
      case "lt":
        n3.push(Math.floor((t2.y + i3) / r2) + 1);
        break;
      case "arc":
        n3.push(Math.floor((t2.y + i3 - t2.radius) / r2) + 1), n3.push(Math.floor((t2.y + i3 + t2.radius) / r2) + 1);
        break;
      case "qct":
        var a2 = D2(this.ctx.lastPoint.x, this.ctx.lastPoint.y, t2.x1, t2.y1, t2.x, t2.y);
        n3.push(Math.floor((a2.y + i3) / r2) + 1), n3.push(Math.floor((a2.y + a2.h + i3) / r2) + 1);
        break;
      case "bct":
        var o3 = R2(this.ctx.lastPoint.x, this.ctx.lastPoint.y, t2.x1, t2.y1, t2.x2, t2.y2, t2.x, t2.y);
        n3.push(Math.floor((o3.y + i3) / r2) + 1), n3.push(Math.floor((o3.y + o3.h + i3) / r2) + 1);
        break;
      case "rect":
        n3.push(Math.floor((t2.y + i3) / r2) + 1), n3.push(Math.floor((t2.y + t2.h + i3) / r2) + 1);
    }
    for (var s3 = 0; s3 < n3.length; s3 += 1)
      for (; this.pdf.internal.getNumberOfPages() < n3[s3]; )
        w2.call(this);
    return n3;
  }, "y"), w2 = /* @__PURE__ */ __name(function() {
    var t2 = this.fillStyle, e2 = this.strokeStyle, r2 = this.font, n3 = this.lineCap, i3 = this.lineWidth, a2 = this.lineJoin;
    this.pdf.addPage(), this.fillStyle = t2, this.strokeStyle = e2, this.font = r2, this.lineCap = n3, this.lineWidth = i3, this.lineJoin = a2;
  }, "w"), N2 = /* @__PURE__ */ __name(function(t2, e2, r2) {
    for (var n3 = 0; n3 < t2.length; n3++)
      switch (t2[n3].type) {
        case "bct":
          t2[n3].x2 += e2, t2[n3].y2 += r2;
        case "qct":
          t2[n3].x1 += e2, t2[n3].y1 += r2;
        case "mt":
        case "lt":
        case "arc":
        default:
          t2[n3].x += e2, t2[n3].y += r2;
      }
    return t2;
  }, "N"), L2 = /* @__PURE__ */ __name(function(t2) {
    return t2.sort(function(t3, e2) {
      return t3 - e2;
    });
  }, "L"), A2 = /* @__PURE__ */ __name(function(t2, e2) {
    for (var r2, n3, i3 = this.fillStyle, a2 = this.strokeStyle, o3 = this.lineCap, s3 = this.lineWidth, c3 = Math.abs(s3 * this.ctx.transform.scaleX), u3 = this.lineJoin, h4 = JSON.parse(JSON.stringify(this.path)), l3 = JSON.parse(JSON.stringify(this.path)), f2 = [], d3 = 0; d3 < l3.length; d3++)
      if (void 0 !== l3[d3].x)
        for (var p3 = y2.call(this, l3[d3]), g3 = 0; g3 < p3.length; g3 += 1)
          -1 === f2.indexOf(p3[g3]) && f2.push(p3[g3]);
    for (var m3 = 0; m3 < f2.length; m3++)
      for (; this.pdf.internal.getNumberOfPages() < f2[m3]; )
        w2.call(this);
    if (L2(f2), this.autoPaging)
      for (var v3 = f2[0], A3 = f2[f2.length - 1], S3 = v3; S3 < A3 + 1; S3++) {
        this.pdf.setPage(S3), this.fillStyle = i3, this.strokeStyle = a2, this.lineCap = o3, this.lineWidth = c3, this.lineJoin = u3;
        var _3 = this.pdf.internal.pageSize.width - this.margin[3] - this.margin[1], P3 = 1 === S3 ? this.posY + this.margin[0] : this.margin[0], k3 = this.pdf.internal.pageSize.height - this.posY - this.margin[0] - this.margin[2], I3 = this.pdf.internal.pageSize.height - this.margin[0] - this.margin[2], F3 = 1 === S3 ? 0 : k3 + (S3 - 2) * I3;
        if (0 !== this.ctx.clip_path.length) {
          var C3 = this.path;
          r2 = JSON.parse(JSON.stringify(this.ctx.clip_path)), this.path = N2(r2, this.posX + this.margin[3], -F3 + P3 + this.ctx.prevPageLastElemOffset), x2.call(this, t2, true), this.path = C3;
        }
        if (n3 = JSON.parse(JSON.stringify(h4)), this.path = N2(n3, this.posX + this.margin[3], -F3 + P3 + this.ctx.prevPageLastElemOffset), false === e2 || 0 === S3) {
          var j3 = (S3 > v3 || S3 < A3) && b2.call(this);
          j3 && (this.pdf.saveGraphicsState(), this.pdf.rect(this.margin[3], this.margin[0], _3, I3, null).clip().discardPath()), x2.call(this, t2, e2), j3 && this.pdf.restoreGraphicsState();
        }
        this.lineWidth = s3;
      }
    else
      this.lineWidth = c3, x2.call(this, t2, e2), this.lineWidth = s3;
    this.path = h4;
  }, "A"), x2 = /* @__PURE__ */ __name(function(t2, e2) {
    if (("stroke" !== t2 || e2 || !v2.call(this)) && ("stroke" === t2 || e2 || !m2.call(this))) {
      for (var r2, n3, i3 = [], a2 = this.path, o3 = 0; o3 < a2.length; o3++) {
        var s3 = a2[o3];
        switch (s3.type) {
          case "begin":
            i3.push({ begin: true });
            break;
          case "close":
            i3.push({ close: true });
            break;
          case "mt":
            i3.push({ start: s3, deltas: [], abs: [] });
            break;
          case "lt":
            var c3 = i3.length;
            if (a2[o3 - 1] && !isNaN(a2[o3 - 1].x) && (r2 = [s3.x - a2[o3 - 1].x, s3.y - a2[o3 - 1].y], c3 > 0)) {
              for (; c3 >= 0; c3--)
                if (true !== i3[c3 - 1].close && true !== i3[c3 - 1].begin) {
                  i3[c3 - 1].deltas.push(r2), i3[c3 - 1].abs.push(s3);
                  break;
                }
            }
            break;
          case "bct":
            r2 = [s3.x1 - a2[o3 - 1].x, s3.y1 - a2[o3 - 1].y, s3.x2 - a2[o3 - 1].x, s3.y2 - a2[o3 - 1].y, s3.x - a2[o3 - 1].x, s3.y - a2[o3 - 1].y], i3[i3.length - 1].deltas.push(r2);
            break;
          case "qct":
            var u3 = a2[o3 - 1].x + 2 / 3 * (s3.x1 - a2[o3 - 1].x), h4 = a2[o3 - 1].y + 2 / 3 * (s3.y1 - a2[o3 - 1].y), l3 = s3.x + 2 / 3 * (s3.x1 - s3.x), f2 = s3.y + 2 / 3 * (s3.y1 - s3.y), d3 = s3.x, p3 = s3.y;
            r2 = [u3 - a2[o3 - 1].x, h4 - a2[o3 - 1].y, l3 - a2[o3 - 1].x, f2 - a2[o3 - 1].y, d3 - a2[o3 - 1].x, p3 - a2[o3 - 1].y], i3[i3.length - 1].deltas.push(r2);
            break;
          case "arc":
            i3.push({ deltas: [], abs: [], arc: true }), Array.isArray(i3[i3.length - 1].abs) && i3[i3.length - 1].abs.push(s3);
        }
      }
      n3 = e2 ? null : "stroke" === t2 ? "stroke" : "fill";
      for (var g3 = false, b3 = 0; b3 < i3.length; b3++)
        if (i3[b3].arc)
          for (var y3 = i3[b3].abs, w3 = 0; w3 < y3.length; w3++) {
            var N3 = y3[w3];
            "arc" === N3.type ? P2.call(this, N3.x, N3.y, N3.radius, N3.startAngle, N3.endAngle, N3.counterclockwise, void 0, e2, !g3) : j2.call(this, N3.x, N3.y), g3 = true;
          }
        else if (true === i3[b3].close)
          this.pdf.internal.out("h"), g3 = false;
        else if (true !== i3[b3].begin) {
          var L3 = i3[b3].start.x, A3 = i3[b3].start.y;
          O2.call(this, i3[b3].deltas, L3, A3), g3 = true;
        }
      n3 && k2.call(this, n3), e2 && I2.call(this);
    }
  }, "x"), S2 = /* @__PURE__ */ __name(function(t2) {
    var e2 = this.pdf.internal.getFontSize() / this.pdf.internal.scaleFactor, r2 = e2 * (this.pdf.internal.getLineHeightFactor() - 1);
    switch (this.ctx.textBaseline) {
      case "bottom":
        return t2 - r2;
      case "top":
        return t2 + e2 - r2;
      case "hanging":
        return t2 + e2 - 2 * r2;
      case "middle":
        return t2 + e2 / 2 - r2;
      case "ideographic":
        return t2;
      case "alphabetic":
      default:
        return t2;
    }
  }, "S"), _2 = /* @__PURE__ */ __name(function(t2) {
    return t2 + this.pdf.internal.getFontSize() / this.pdf.internal.scaleFactor * (this.pdf.internal.getLineHeightFactor() - 1);
  }, "_");
  p2.prototype.createLinearGradient = function() {
    var t2 = /* @__PURE__ */ __name(function() {
    }, "t");
    return t2.colorStops = [], t2.addColorStop = function(t3, e2) {
      this.colorStops.push([t3, e2]);
    }, t2.getColor = function() {
      return 0 === this.colorStops.length ? "#000000" : this.colorStops[0][1];
    }, t2.isCanvasGradient = true, t2;
  }, p2.prototype.createPattern = function() {
    return this.createLinearGradient();
  }, p2.prototype.createRadialGradient = function() {
    return this.createLinearGradient();
  };
  var P2 = /* @__PURE__ */ __name(function(t2, e2, r2, n3, i3, a2, o3, s3, c3) {
    for (var u3 = M2.call(this, r2, n3, i3, a2), h4 = 0; h4 < u3.length; h4++) {
      var l3 = u3[h4];
      0 === h4 && (c3 ? F2.call(this, l3.x1 + t2, l3.y1 + e2) : j2.call(this, l3.x1 + t2, l3.y1 + e2)), B2.call(this, t2, e2, l3.x2, l3.y2, l3.x3, l3.y3, l3.x4, l3.y4);
    }
    s3 ? I2.call(this) : k2.call(this, o3);
  }, "P"), k2 = /* @__PURE__ */ __name(function(t2) {
    switch (t2) {
      case "stroke":
        this.pdf.internal.out("S");
        break;
      case "fill":
        this.pdf.internal.out("f");
    }
  }, "k"), I2 = /* @__PURE__ */ __name(function() {
    this.pdf.clip(), this.pdf.discardPath();
  }, "I"), F2 = /* @__PURE__ */ __name(function(t2, e2) {
    this.pdf.internal.out(n2(t2) + " " + i2(e2) + " m");
  }, "F"), C2 = /* @__PURE__ */ __name(function(t2) {
    var e2;
    switch (t2.align) {
      case "right":
      case "end":
        e2 = "right";
        break;
      case "center":
        e2 = "center";
        break;
      case "left":
      case "start":
      default:
        e2 = "left";
    }
    var r2 = this.pdf.getTextDimensions(t2.text), n3 = S2.call(this, t2.y), i3 = _2.call(this, n3) - r2.h, a2 = this.ctx.transform.applyToPoint(new c2(t2.x, n3)), o3 = this.ctx.transform.decompose(), s3 = new h3();
    s3 = (s3 = (s3 = s3.multiply(o3.translate)).multiply(o3.skew)).multiply(o3.scale);
    for (var l3, f2, d3, p3 = this.ctx.transform.applyToRectangle(new u2(t2.x, n3, r2.w, r2.h)), g3 = s3.applyToRectangle(new u2(t2.x, i3, r2.w, r2.h)), m3 = y2.call(this, g3), v3 = [], w3 = 0; w3 < m3.length; w3 += 1)
      -1 === v3.indexOf(m3[w3]) && v3.push(m3[w3]);
    if (L2(v3), this.autoPaging)
      for (var A3 = v3[0], P3 = v3[v3.length - 1], k3 = A3; k3 < P3 + 1; k3++) {
        this.pdf.setPage(k3);
        var I3 = 1 === k3 ? this.posY + this.margin[0] : this.margin[0], F3 = this.pdf.internal.pageSize.height - this.posY - this.margin[0] - this.margin[2], C3 = this.pdf.internal.pageSize.height - this.margin[2], j3 = C3 - this.margin[0], O3 = this.pdf.internal.pageSize.width - this.margin[1], B3 = O3 - this.margin[3], M3 = 1 === k3 ? 0 : F3 + (k3 - 2) * j3;
        if (0 !== this.ctx.clip_path.length) {
          var E3 = this.path;
          l3 = JSON.parse(JSON.stringify(this.ctx.clip_path)), this.path = N2(l3, this.posX + this.margin[3], -1 * M3 + I3), x2.call(this, "fill", true), this.path = E3;
        }
        var q3 = N2([JSON.parse(JSON.stringify(g3))], this.posX + this.margin[3], -M3 + I3 + this.ctx.prevPageLastElemOffset)[0];
        t2.scale >= 0.01 && (f2 = this.pdf.internal.getFontSize(), this.pdf.setFontSize(f2 * t2.scale), d3 = this.lineWidth, this.lineWidth = d3 * t2.scale);
        var D3 = "text" !== this.autoPaging;
        if (D3 || q3.y + q3.h <= C3) {
          if (D3 || q3.y >= I3 && q3.x <= O3) {
            var R3 = D3 ? t2.text : this.pdf.splitTextToSize(t2.text, t2.maxWidth || O3 - q3.x)[0], T3 = N2([JSON.parse(JSON.stringify(p3))], this.posX + this.margin[3], -M3 + I3 + this.ctx.prevPageLastElemOffset)[0], U2 = D3 && (k3 > A3 || k3 < P3) && b2.call(this);
            U2 && (this.pdf.saveGraphicsState(), this.pdf.rect(this.margin[3], this.margin[0], B3, j3, null).clip().discardPath()), this.pdf.text(R3, T3.x, T3.y, { angle: t2.angle, align: e2, renderingMode: t2.renderingMode }), U2 && this.pdf.restoreGraphicsState();
          }
        } else
          q3.y < C3 && (this.ctx.prevPageLastElemOffset += C3 - q3.y);
        t2.scale >= 0.01 && (this.pdf.setFontSize(f2), this.lineWidth = d3);
      }
    else
      t2.scale >= 0.01 && (f2 = this.pdf.internal.getFontSize(), this.pdf.setFontSize(f2 * t2.scale), d3 = this.lineWidth, this.lineWidth = d3 * t2.scale), this.pdf.text(t2.text, a2.x + this.posX, a2.y + this.posY, { angle: t2.angle, align: e2, renderingMode: t2.renderingMode, maxWidth: t2.maxWidth }), t2.scale >= 0.01 && (this.pdf.setFontSize(f2), this.lineWidth = d3);
  }, "C"), j2 = /* @__PURE__ */ __name(function(t2, e2, r2, a2) {
    r2 = r2 || 0, a2 = a2 || 0, this.pdf.internal.out(n2(t2 + r2) + " " + i2(e2 + a2) + " l");
  }, "j"), O2 = /* @__PURE__ */ __name(function(t2, e2, r2) {
    return this.pdf.lines(t2, e2, r2, null, null);
  }, "O"), B2 = /* @__PURE__ */ __name(function(t2, e2, n3, i3, a2, c3, u3, h4) {
    this.pdf.internal.out([r(o2(n3 + t2)), r(s2(i3 + e2)), r(o2(a2 + t2)), r(s2(c3 + e2)), r(o2(u3 + t2)), r(s2(h4 + e2)), "c"].join(" "));
  }, "B"), M2 = /* @__PURE__ */ __name(function(t2, e2, r2, n3) {
    for (var i3 = 2 * Math.PI, a2 = Math.PI / 2; e2 > r2; )
      e2 -= i3;
    var o3 = Math.abs(r2 - e2);
    o3 < i3 && n3 && (o3 = i3 - o3);
    for (var s3 = [], c3 = n3 ? -1 : 1, u3 = e2; o3 > 1e-5; ) {
      var h4 = u3 + c3 * Math.min(o3, a2);
      s3.push(E2.call(this, t2, u3, h4)), o3 -= Math.abs(h4 - u3), u3 = h4;
    }
    return s3;
  }, "M"), E2 = /* @__PURE__ */ __name(function(t2, e2, r2) {
    var n3 = (r2 - e2) / 2, i3 = t2 * Math.cos(n3), a2 = t2 * Math.sin(n3), o3 = i3, s3 = -a2, c3 = o3 * o3 + s3 * s3, u3 = c3 + o3 * i3 + s3 * a2, h4 = 4 / 3 * (Math.sqrt(2 * c3 * u3) - u3) / (o3 * a2 - s3 * i3), l3 = o3 - h4 * s3, f2 = s3 + h4 * o3, d3 = l3, p3 = -f2, g3 = n3 + e2, m3 = Math.cos(g3), v3 = Math.sin(g3);
    return { x1: t2 * Math.cos(e2), y1: t2 * Math.sin(e2), x2: l3 * m3 - f2 * v3, y2: l3 * v3 + f2 * m3, x3: d3 * m3 - p3 * v3, y3: d3 * v3 + p3 * m3, x4: t2 * Math.cos(r2), y4: t2 * Math.sin(r2) };
  }, "E"), q2 = /* @__PURE__ */ __name(function(t2) {
    return 180 * t2 / Math.PI;
  }, "q"), D2 = /* @__PURE__ */ __name(function(t2, e2, r2, n3, i3, a2) {
    var o3 = t2 + 0.5 * (r2 - t2), s3 = e2 + 0.5 * (n3 - e2), c3 = i3 + 0.5 * (r2 - i3), h4 = a2 + 0.5 * (n3 - a2), l3 = Math.min(t2, i3, o3, c3), f2 = Math.max(t2, i3, o3, c3), d3 = Math.min(e2, a2, s3, h4), p3 = Math.max(e2, a2, s3, h4);
    return new u2(l3, d3, f2 - l3, p3 - d3);
  }, "D"), R2 = /* @__PURE__ */ __name(function(t2, e2, r2, n3, i3, a2, o3, s3) {
    var c3, h4, l3, f2, d3, p3, g3, m3, v3, b3, y3, w3, N3, L3, A3 = r2 - t2, x3 = n3 - e2, S3 = i3 - r2, _3 = a2 - n3, P3 = o3 - i3, k3 = s3 - a2;
    for (h4 = 0; h4 < 41; h4++)
      v3 = (g3 = (l3 = t2 + (c3 = h4 / 40) * A3) + c3 * ((d3 = r2 + c3 * S3) - l3)) + c3 * (d3 + c3 * (i3 + c3 * P3 - d3) - g3), b3 = (m3 = (f2 = e2 + c3 * x3) + c3 * ((p3 = n3 + c3 * _3) - f2)) + c3 * (p3 + c3 * (a2 + c3 * k3 - p3) - m3), 0 == h4 ? (y3 = v3, w3 = b3, N3 = v3, L3 = b3) : (y3 = Math.min(y3, v3), w3 = Math.min(w3, b3), N3 = Math.max(N3, v3), L3 = Math.max(L3, b3));
    return new u2(Math.round(y3), Math.round(w3), Math.round(N3 - y3), Math.round(L3 - w3));
  }, "R"), T2 = /* @__PURE__ */ __name(function() {
    if (this.prevLineDash || this.ctx.lineDash.length || this.ctx.lineDashOffset) {
      var t2, e2, r2 = (t2 = this.ctx.lineDash, e2 = this.ctx.lineDashOffset, JSON.stringify({ lineDash: t2, lineDashOffset: e2 }));
      this.prevLineDash !== r2 && (this.pdf.setLineDash(this.ctx.lineDash, this.ctx.lineDashOffset), this.prevLineDash = r2);
    }
  }, "T");
}(E.API), /**
 * @license
 * jsPDF filters PlugIn
 * Copyright (c) 2014 Aras Abbasi
 *
 * Licensed under the MIT License.
 * http://opensource.org/licenses/mit-license
 */
function(t2) {
  var r = /* @__PURE__ */ __name(function(t3) {
    var e, r2, n3, i3, a3, o2, s2, c2, u2, h3;
    for (r2 = [], n3 = 0, i3 = (t3 += e = "\0\0\0\0".slice(t3.length % 4 || 4)).length; i3 > n3; n3 += 4)
      0 !== (a3 = (t3.charCodeAt(n3) << 24) + (t3.charCodeAt(n3 + 1) << 16) + (t3.charCodeAt(n3 + 2) << 8) + t3.charCodeAt(n3 + 3)) ? (o2 = (a3 = ((a3 = ((a3 = ((a3 = (a3 - (h3 = a3 % 85)) / 85) - (u2 = a3 % 85)) / 85) - (c2 = a3 % 85)) / 85) - (s2 = a3 % 85)) / 85) % 85, r2.push(o2 + 33, s2 + 33, c2 + 33, u2 + 33, h3 + 33)) : r2.push(122);
    return function(t4, e2) {
      for (var r3 = e2; r3 > 0; r3--)
        t4.pop();
    }(r2, e.length), String.fromCharCode.apply(String, r2) + "~>";
  }, "r"), n2 = /* @__PURE__ */ __name(function(t3) {
    var e, r2, n3, i3, a3, o2 = String, s2 = "length", c2 = 255, u2 = "charCodeAt", h3 = "slice", l2 = "replace";
    for (t3[h3](-2), t3 = t3[h3](0, -2)[l2](/\s/g, "")[l2]("z", "!!!!!"), n3 = [], i3 = 0, a3 = (t3 += e = "uuuuu"[h3](t3[s2] % 5 || 5))[s2]; a3 > i3; i3 += 5)
      r2 = 52200625 * (t3[u2](i3) - 33) + 614125 * (t3[u2](i3 + 1) - 33) + 7225 * (t3[u2](i3 + 2) - 33) + 85 * (t3[u2](i3 + 3) - 33) + (t3[u2](i3 + 4) - 33), n3.push(c2 & r2 >> 24, c2 & r2 >> 16, c2 & r2 >> 8, c2 & r2);
    return function(t4, e2) {
      for (var r3 = e2; r3 > 0; r3--)
        t4.pop();
    }(n3, e[s2]), o2.fromCharCode.apply(o2, n3);
  }, "n"), i2 = /* @__PURE__ */ __name(function(t3) {
    var e = new RegExp(/^([0-9A-Fa-f]{2})+$/);
    if (-1 !== (t3 = t3.replace(/\s/g, "")).indexOf(">") && (t3 = t3.substr(0, t3.indexOf(">"))), t3.length % 2 && (t3 += "0"), false === e.test(t3))
      return "";
    for (var r2 = "", n3 = 0; n3 < t3.length; n3 += 2)
      r2 += String.fromCharCode("0x" + (t3[n3] + t3[n3 + 1]));
    return r2;
  }, "i"), a2 = /* @__PURE__ */ __name(function(t3) {
    for (var r2 = new Uint8Array(t3.length), n3 = t3.length; n3--; )
      r2[n3] = t3.charCodeAt(n3);
    return t3 = (r2 = zlibSync(r2)).reduce(function(t4, e) {
      return t4 + String.fromCharCode(e);
    }, "");
  }, "a");
  t2.processDataByFilters = function(t3, e) {
    var o2 = 0, s2 = t3 || "", c2 = [];
    for ("string" == typeof (e = e || []) && (e = [e]), o2 = 0; o2 < e.length; o2 += 1)
      switch (e[o2]) {
        case "ASCII85Decode":
        case "/ASCII85Decode":
          s2 = n2(s2), c2.push("/ASCII85Encode");
          break;
        case "ASCII85Encode":
        case "/ASCII85Encode":
          s2 = r(s2), c2.push("/ASCII85Decode");
          break;
        case "ASCIIHexDecode":
        case "/ASCIIHexDecode":
          s2 = i2(s2), c2.push("/ASCIIHexEncode");
          break;
        case "ASCIIHexEncode":
        case "/ASCIIHexEncode":
          s2 = s2.split("").map(function(t4) {
            return ("0" + t4.charCodeAt().toString(16)).slice(-2);
          }).join("") + ">", c2.push("/ASCIIHexDecode");
          break;
        case "FlateEncode":
        case "/FlateEncode":
          s2 = a2(s2), c2.push("/FlateDecode");
          break;
        default:
          throw new Error('The filter: "' + e[o2] + '" is not implemented');
      }
    return { data: s2, reverseChain: c2.reverse().join(" ") };
  };
}(E.API), /**
 * @license
 * jsPDF fileloading PlugIn
 * Copyright (c) 2018 Aras Abbasi (aras.abbasi@gmail.com)
 *
 * Licensed under the MIT License.
 * http://opensource.org/licenses/mit-license
 */
function(t2) {
  t2.loadFile = function(t3, e, r) {
    return function(t4, e2, r2) {
      e2 = false !== e2, r2 = "function" == typeof r2 ? r2 : function() {
      };
      var n2 = void 0;
      try {
        n2 = function(t5, e3, r3) {
          var n3 = new XMLHttpRequest(), i2 = 0, a2 = /* @__PURE__ */ __name(function(t6) {
            var e4 = t6.length, r4 = [], n4 = String.fromCharCode;
            for (i2 = 0; i2 < e4; i2 += 1)
              r4.push(n4(255 & t6.charCodeAt(i2)));
            return r4.join("");
          }, "a");
          if (n3.open("GET", t5, !e3), n3.overrideMimeType("text/plain; charset=x-user-defined"), false === e3 && (n3.onload = function() {
            200 === n3.status ? r3(a2(this.responseText)) : r3(void 0);
          }), n3.send(null), e3 && 200 === n3.status)
            return a2(n3.responseText);
        }(t4, e2, r2);
      } catch (t5) {
      }
      return n2;
    }(t3, e, r);
  }, t2.loadImageFile = t2.loadFile;
}(E.API), function(e) {
  function r() {
    return (n.html2canvas ? Promise.resolve(n.html2canvas) : __vitePreload(() => import("./html2canvas.esm-553cc70b.js"), true ? [] : void 0)).catch(function(t2) {
      return Promise.reject(new Error("Could not load html2canvas: " + t2));
    }).then(function(t2) {
      return t2.default ? t2.default : t2;
    });
  }
  __name(r, "r");
  function i2() {
    return (n.DOMPurify ? Promise.resolve(n.DOMPurify) : __vitePreload(() => import("./purify.es-c8479f61.js"), true ? [] : void 0)).catch(function(t2) {
      return Promise.reject(new Error("Could not load dompurify: " + t2));
    }).then(function(t2) {
      return t2.default ? t2.default : t2;
    });
  }
  __name(i2, "i");
  var a2 = /* @__PURE__ */ __name(function(e2) {
    var r2 = _typeof(e2);
    return "undefined" === r2 ? "undefined" : "string" === r2 || e2 instanceof String ? "string" : "number" === r2 || e2 instanceof Number ? "number" : "function" === r2 || e2 instanceof Function ? "function" : e2 && e2.constructor === Array ? "array" : e2 && 1 === e2.nodeType ? "element" : "object" === r2 ? "object" : "unknown";
  }, "a"), o2 = /* @__PURE__ */ __name(function(t2, e2) {
    var r2 = document.createElement(t2);
    for (var n2 in e2.className && (r2.className = e2.className), e2.innerHTML && e2.dompurify && (r2.innerHTML = e2.dompurify.sanitize(e2.innerHTML)), e2.style)
      r2.style[n2] = e2.style[n2];
    return r2;
  }, "o"), s2 = /* @__PURE__ */ __name(function t2(e2) {
    var r2 = Object.assign(t2.convert(Promise.resolve()), JSON.parse(JSON.stringify(t2.template))), n2 = t2.convert(Promise.resolve(), r2);
    return n2 = (n2 = n2.setProgress(1, t2, 1, [t2])).set(e2);
  }, "t");
  (s2.prototype = Object.create(Promise.prototype)).constructor = s2, s2.convert = function(t2, e2) {
    return t2.__proto__ = e2 || s2.prototype, t2;
  }, s2.template = { prop: { src: null, container: null, overlay: null, canvas: null, img: null, pdf: null, pageSize: null, callback: function() {
  } }, progress: { val: 0, state: null, n: 0, stack: [] }, opt: { filename: "file.pdf", margin: [0, 0, 0, 0], enableLinks: true, x: 0, y: 0, html2canvas: {}, jsPDF: {}, backgroundColor: "transparent" } }, s2.prototype.from = function(t2, e2) {
    return this.then(function() {
      switch (e2 = e2 || function(t3) {
        switch (a2(t3)) {
          case "string":
            return "string";
          case "element":
            return "canvas" === t3.nodeName.toLowerCase() ? "canvas" : "element";
          default:
            return "unknown";
        }
      }(t2)) {
        case "string":
          return this.then(i2).then(function(e3) {
            return this.set({ src: o2("div", { innerHTML: t2, dompurify: e3 }) });
          });
        case "element":
          return this.set({ src: t2 });
        case "canvas":
          return this.set({ canvas: t2 });
        case "img":
          return this.set({ img: t2 });
        default:
          return this.error("Unknown source type.");
      }
    });
  }, s2.prototype.to = function(t2) {
    switch (t2) {
      case "container":
        return this.toContainer();
      case "canvas":
        return this.toCanvas();
      case "img":
        return this.toImg();
      case "pdf":
        return this.toPdf();
      default:
        return this.error("Invalid target.");
    }
  }, s2.prototype.toContainer = function() {
    return this.thenList([function() {
      return this.prop.src || this.error("Cannot duplicate - no source HTML.");
    }, function() {
      return this.prop.pageSize || this.setPageSize();
    }]).then(function() {
      var t2 = { position: "relative", display: "inline-block", width: ("number" != typeof this.opt.width || isNaN(this.opt.width) || "number" != typeof this.opt.windowWidth || isNaN(this.opt.windowWidth) ? Math.max(this.prop.src.clientWidth, this.prop.src.scrollWidth, this.prop.src.offsetWidth) : this.opt.windowWidth) + "px", left: 0, right: 0, top: 0, margin: "auto", backgroundColor: this.opt.backgroundColor }, e2 = (/* @__PURE__ */ __name(function t3(e3, r2) {
        for (var n2 = 3 === e3.nodeType ? document.createTextNode(e3.nodeValue) : e3.cloneNode(false), i3 = e3.firstChild; i3; i3 = i3.nextSibling)
          true !== r2 && 1 === i3.nodeType && "SCRIPT" === i3.nodeName || n2.appendChild(t3(i3, r2));
        return 1 === e3.nodeType && ("CANVAS" === e3.nodeName ? (n2.width = e3.width, n2.height = e3.height, n2.getContext("2d").drawImage(e3, 0, 0)) : "TEXTAREA" !== e3.nodeName && "SELECT" !== e3.nodeName || (n2.value = e3.value), n2.addEventListener("load", function() {
          n2.scrollTop = e3.scrollTop, n2.scrollLeft = e3.scrollLeft;
        }, true)), n2;
      }, "t"))(this.prop.src, this.opt.html2canvas.javascriptEnabled);
      "BODY" === e2.tagName && (t2.height = Math.max(document.body.scrollHeight, document.body.offsetHeight, document.documentElement.clientHeight, document.documentElement.scrollHeight, document.documentElement.offsetHeight) + "px"), this.prop.overlay = o2("div", { className: "html2pdf__overlay", style: { position: "fixed", overflow: "hidden", zIndex: 1e3, left: "-100000px", right: 0, bottom: 0, top: 0 } }), this.prop.container = o2("div", { className: "html2pdf__container", style: t2 }), this.prop.container.appendChild(e2), this.prop.container.firstChild.appendChild(o2("div", { style: { clear: "both", border: "0 none transparent", margin: 0, padding: 0, height: 0 } })), this.prop.container.style.float = "none", this.prop.overlay.appendChild(this.prop.container), document.body.appendChild(this.prop.overlay), this.prop.container.firstChild.style.position = "relative", this.prop.container.height = Math.max(this.prop.container.firstChild.clientHeight, this.prop.container.firstChild.scrollHeight, this.prop.container.firstChild.offsetHeight) + "px";
    });
  }, s2.prototype.toCanvas = function() {
    var t2 = [function() {
      return document.body.contains(this.prop.container) || this.toContainer();
    }];
    return this.thenList(t2).then(r).then(function(t3) {
      var e2 = Object.assign({}, this.opt.html2canvas);
      return delete e2.onrendered, t3(this.prop.container, e2);
    }).then(function(t3) {
      (this.opt.html2canvas.onrendered || function() {
      })(t3), this.prop.canvas = t3, document.body.removeChild(this.prop.overlay);
    });
  }, s2.prototype.toContext2d = function() {
    var t2 = [function() {
      return document.body.contains(this.prop.container) || this.toContainer();
    }];
    return this.thenList(t2).then(r).then(function(t3) {
      var e2 = this.opt.jsPDF, r2 = this.opt.fontFaces, n2 = "number" != typeof this.opt.width || isNaN(this.opt.width) || "number" != typeof this.opt.windowWidth || isNaN(this.opt.windowWidth) ? 1 : this.opt.width / this.opt.windowWidth, i3 = Object.assign({ async: true, allowTaint: true, scale: n2, scrollX: this.opt.scrollX || 0, scrollY: this.opt.scrollY || 0, backgroundColor: "#ffffff", imageTimeout: 15e3, logging: true, proxy: null, removeContainer: true, foreignObjectRendering: false, useCORS: false }, this.opt.html2canvas);
      if (delete i3.onrendered, e2.context2d.autoPaging = void 0 === this.opt.autoPaging || this.opt.autoPaging, e2.context2d.posX = this.opt.x, e2.context2d.posY = this.opt.y, e2.context2d.margin = this.opt.margin, e2.context2d.fontFaces = r2, r2)
        for (var a3 = 0; a3 < r2.length; ++a3) {
          var o3 = r2[a3], s3 = o3.src.find(function(t4) {
            return "truetype" === t4.format;
          });
          s3 && e2.addFont(s3.url, o3.ref.name, o3.ref.style);
        }
      return i3.windowHeight = i3.windowHeight || 0, i3.windowHeight = 0 == i3.windowHeight ? Math.max(this.prop.container.clientHeight, this.prop.container.scrollHeight, this.prop.container.offsetHeight) : i3.windowHeight, e2.context2d.save(true), t3(this.prop.container, i3);
    }).then(function(t3) {
      this.opt.jsPDF.context2d.restore(true), (this.opt.html2canvas.onrendered || function() {
      })(t3), this.prop.canvas = t3, document.body.removeChild(this.prop.overlay);
    });
  }, s2.prototype.toImg = function() {
    return this.thenList([function() {
      return this.prop.canvas || this.toCanvas();
    }]).then(function() {
      var t2 = this.prop.canvas.toDataURL("image/" + this.opt.image.type, this.opt.image.quality);
      this.prop.img = document.createElement("img"), this.prop.img.src = t2;
    });
  }, s2.prototype.toPdf = function() {
    return this.thenList([function() {
      return this.toContext2d();
    }]).then(function() {
      this.prop.pdf = this.prop.pdf || this.opt.jsPDF;
    });
  }, s2.prototype.output = function(t2, e2, r2) {
    return "img" === (r2 = r2 || "pdf").toLowerCase() || "image" === r2.toLowerCase() ? this.outputImg(t2, e2) : this.outputPdf(t2, e2);
  }, s2.prototype.outputPdf = function(t2, e2) {
    return this.thenList([function() {
      return this.prop.pdf || this.toPdf();
    }]).then(function() {
      return this.prop.pdf.output(t2, e2);
    });
  }, s2.prototype.outputImg = function(t2) {
    return this.thenList([function() {
      return this.prop.img || this.toImg();
    }]).then(function() {
      switch (t2) {
        case void 0:
        case "img":
          return this.prop.img;
        case "datauristring":
        case "dataurlstring":
          return this.prop.img.src;
        case "datauri":
        case "dataurl":
          return document.location.href = this.prop.img.src;
        default:
          throw 'Image output type "' + t2 + '" is not supported.';
      }
    });
  }, s2.prototype.save = function(t2) {
    return this.thenList([function() {
      return this.prop.pdf || this.toPdf();
    }]).set(t2 ? { filename: t2 } : null).then(function() {
      this.prop.pdf.save(this.opt.filename);
    });
  }, s2.prototype.doCallback = function() {
    return this.thenList([function() {
      return this.prop.pdf || this.toPdf();
    }]).then(function() {
      this.prop.callback(this.prop.pdf);
    });
  }, s2.prototype.set = function(t2) {
    if ("object" !== a2(t2))
      return this;
    var e2 = Object.keys(t2 || {}).map(function(e3) {
      if (e3 in s2.template.prop)
        return function() {
          this.prop[e3] = t2[e3];
        };
      switch (e3) {
        case "margin":
          return this.setMargin.bind(this, t2.margin);
        case "jsPDF":
          return function() {
            return this.opt.jsPDF = t2.jsPDF, this.setPageSize();
          };
        case "pageSize":
          return this.setPageSize.bind(this, t2.pageSize);
        default:
          return function() {
            this.opt[e3] = t2[e3];
          };
      }
    }, this);
    return this.then(function() {
      return this.thenList(e2);
    });
  }, s2.prototype.get = function(t2, e2) {
    return this.then(function() {
      var r2 = t2 in s2.template.prop ? this.prop[t2] : this.opt[t2];
      return e2 ? e2(r2) : r2;
    });
  }, s2.prototype.setMargin = function(t2) {
    return this.then(function() {
      switch (a2(t2)) {
        case "number":
          t2 = [t2, t2, t2, t2];
        case "array":
          if (2 === t2.length && (t2 = [t2[0], t2[1], t2[0], t2[1]]), 4 === t2.length)
            break;
        default:
          return this.error("Invalid margin array.");
      }
      this.opt.margin = t2;
    }).then(this.setPageSize);
  }, s2.prototype.setPageSize = function(t2) {
    function e2(t3, e3) {
      return Math.floor(t3 * e3 / 72 * 96);
    }
    __name(e2, "e");
    return this.then(function() {
      (t2 = t2 || E.getPageSize(this.opt.jsPDF)).hasOwnProperty("inner") || (t2.inner = { width: t2.width - this.opt.margin[1] - this.opt.margin[3], height: t2.height - this.opt.margin[0] - this.opt.margin[2] }, t2.inner.px = { width: e2(t2.inner.width, t2.k), height: e2(t2.inner.height, t2.k) }, t2.inner.ratio = t2.inner.height / t2.inner.width), this.prop.pageSize = t2;
    });
  }, s2.prototype.setProgress = function(t2, e2, r2, n2) {
    return null != t2 && (this.progress.val = t2), null != e2 && (this.progress.state = e2), null != r2 && (this.progress.n = r2), null != n2 && (this.progress.stack = n2), this.progress.ratio = this.progress.val / this.progress.state, this;
  }, s2.prototype.updateProgress = function(t2, e2, r2, n2) {
    return this.setProgress(t2 ? this.progress.val + t2 : null, e2 || null, r2 ? this.progress.n + r2 : null, n2 ? this.progress.stack.concat(n2) : null);
  }, s2.prototype.then = function(t2, e2) {
    var r2 = this;
    return this.thenCore(t2, e2, function(t3, e3) {
      return r2.updateProgress(null, null, 1, [t3]), Promise.prototype.then.call(this, function(e4) {
        return r2.updateProgress(null, t3), e4;
      }).then(t3, e3).then(function(t4) {
        return r2.updateProgress(1), t4;
      });
    });
  }, s2.prototype.thenCore = function(t2, e2, r2) {
    r2 = r2 || Promise.prototype.then;
    t2 && (t2 = t2.bind(this)), e2 && (e2 = e2.bind(this));
    var n2 = -1 !== Promise.toString().indexOf("[native code]") && "Promise" === Promise.name ? this : s2.convert(Object.assign({}, this), Promise.prototype), i3 = r2.call(n2, t2, e2);
    return s2.convert(i3, this.__proto__);
  }, s2.prototype.thenExternal = function(t2, e2) {
    return Promise.prototype.then.call(this, t2, e2);
  }, s2.prototype.thenList = function(t2) {
    var e2 = this;
    return t2.forEach(function(t3) {
      e2 = e2.thenCore(t3);
    }), e2;
  }, s2.prototype.catch = function(t2) {
    t2 && (t2 = t2.bind(this));
    var e2 = Promise.prototype.catch.call(this, t2);
    return s2.convert(e2, this);
  }, s2.prototype.catchExternal = function(t2) {
    return Promise.prototype.catch.call(this, t2);
  }, s2.prototype.error = function(t2) {
    return this.then(function() {
      throw new Error(t2);
    });
  }, s2.prototype.using = s2.prototype.set, s2.prototype.saveAs = s2.prototype.save, s2.prototype.export = s2.prototype.output, s2.prototype.run = s2.prototype.then, E.getPageSize = function(e2, r2, n2) {
    if ("object" === _typeof(e2)) {
      var i3 = e2;
      e2 = i3.orientation, r2 = i3.unit || r2, n2 = i3.format || n2;
    }
    r2 = r2 || "mm", n2 = n2 || "a4", e2 = ("" + (e2 || "P")).toLowerCase();
    var a3, o3 = ("" + n2).toLowerCase(), s3 = { a0: [2383.94, 3370.39], a1: [1683.78, 2383.94], a2: [1190.55, 1683.78], a3: [841.89, 1190.55], a4: [595.28, 841.89], a5: [419.53, 595.28], a6: [297.64, 419.53], a7: [209.76, 297.64], a8: [147.4, 209.76], a9: [104.88, 147.4], a10: [73.7, 104.88], b0: [2834.65, 4008.19], b1: [2004.09, 2834.65], b2: [1417.32, 2004.09], b3: [1000.63, 1417.32], b4: [708.66, 1000.63], b5: [498.9, 708.66], b6: [354.33, 498.9], b7: [249.45, 354.33], b8: [175.75, 249.45], b9: [124.72, 175.75], b10: [87.87, 124.72], c0: [2599.37, 3676.54], c1: [1836.85, 2599.37], c2: [1298.27, 1836.85], c3: [918.43, 1298.27], c4: [649.13, 918.43], c5: [459.21, 649.13], c6: [323.15, 459.21], c7: [229.61, 323.15], c8: [161.57, 229.61], c9: [113.39, 161.57], c10: [79.37, 113.39], dl: [311.81, 623.62], letter: [612, 792], "government-letter": [576, 756], legal: [612, 1008], "junior-legal": [576, 360], ledger: [1224, 792], tabloid: [792, 1224], "credit-card": [153, 243] };
    switch (r2) {
      case "pt":
        a3 = 1;
        break;
      case "mm":
        a3 = 72 / 25.4;
        break;
      case "cm":
        a3 = 72 / 2.54;
        break;
      case "in":
        a3 = 72;
        break;
      case "px":
        a3 = 0.75;
        break;
      case "pc":
      case "em":
        a3 = 12;
        break;
      case "ex":
        a3 = 6;
        break;
      default:
        throw "Invalid unit: " + r2;
    }
    var c2, u2 = 0, h3 = 0;
    if (s3.hasOwnProperty(o3))
      u2 = s3[o3][1] / a3, h3 = s3[o3][0] / a3;
    else
      try {
        u2 = n2[1], h3 = n2[0];
      } catch (t2) {
        throw new Error("Invalid format: " + n2);
      }
    if ("p" === e2 || "portrait" === e2)
      e2 = "p", h3 > u2 && (c2 = h3, h3 = u2, u2 = c2);
    else {
      if ("l" !== e2 && "landscape" !== e2)
        throw "Invalid orientation: " + e2;
      e2 = "l", u2 > h3 && (c2 = h3, h3 = u2, u2 = c2);
    }
    return { width: h3, height: u2, unit: r2, k: a3, orientation: e2 };
  }, e.html = function(t2, e2) {
    (e2 = e2 || {}).callback = e2.callback || function() {
    }, e2.html2canvas = e2.html2canvas || {}, e2.html2canvas.canvas = e2.html2canvas.canvas || this.canvas, e2.jsPDF = e2.jsPDF || this, e2.fontFaces = e2.fontFaces ? e2.fontFaces.map(jt) : null;
    var r2 = new s2(e2);
    return e2.worker ? r2 : r2.from(t2).doCallback();
  };
}(E.API), E.API.addJS = function(t2) {
  return Ht = t2, this.internal.events.subscribe("postPutResources", function() {
    Ut = this.internal.newObject(), this.internal.out("<<"), this.internal.out("/Names [(EmbeddedJS) " + (Ut + 1) + " 0 R]"), this.internal.out(">>"), this.internal.out("endobj"), zt = this.internal.newObject(), this.internal.out("<<"), this.internal.out("/S /JavaScript"), this.internal.out("/JS (" + Ht + ")"), this.internal.out(">>"), this.internal.out("endobj");
  }), this.internal.events.subscribe("putCatalog", function() {
    void 0 !== Ut && void 0 !== zt && this.internal.out("/Names <</JavaScript " + Ut + " 0 R>>");
  }), this;
}, /**
 * @license
 * Copyright (c) 2014 Steven Spungin (TwelveTone LLC)  steven@twelvetone.tv
 *
 * Licensed under the MIT License.
 * http://opensource.org/licenses/mit-license
 */
function(t2) {
  var e;
  t2.events.push(["postPutResources", function() {
    var t3 = this, r = /^(\d+) 0 obj$/;
    if (this.outline.root.children.length > 0)
      for (var n2 = t3.outline.render().split(/\r\n/), i2 = 0; i2 < n2.length; i2++) {
        var a2 = n2[i2], o2 = r.exec(a2);
        if (null != o2) {
          var s2 = o2[1];
          t3.internal.newObjectDeferredBegin(s2, false);
        }
        t3.internal.write(a2);
      }
    if (this.outline.createNamedDestinations) {
      var c2 = this.internal.pages.length, u2 = [];
      for (i2 = 0; i2 < c2; i2++) {
        var h3 = t3.internal.newObject();
        u2.push(h3);
        var l2 = t3.internal.getPageInfo(i2 + 1);
        t3.internal.write("<< /D[" + l2.objId + " 0 R /XYZ null null null]>> endobj");
      }
      var f2 = t3.internal.newObject();
      t3.internal.write("<< /Names [ ");
      for (i2 = 0; i2 < u2.length; i2++)
        t3.internal.write("(page_" + (i2 + 1) + ")" + u2[i2] + " 0 R");
      t3.internal.write(" ] >>", "endobj"), e = t3.internal.newObject(), t3.internal.write("<< /Dests " + f2 + " 0 R"), t3.internal.write(">>", "endobj");
    }
  }]), t2.events.push(["putCatalog", function() {
    this.outline.root.children.length > 0 && (this.internal.write("/Outlines", this.outline.makeRef(this.outline.root)), this.outline.createNamedDestinations && this.internal.write("/Names " + e + " 0 R"));
  }]), t2.events.push(["initialized", function() {
    var t3 = this;
    t3.outline = { createNamedDestinations: false, root: { children: [] } }, t3.outline.add = function(t4, e2, r) {
      var n2 = { title: e2, options: r, children: [] };
      return null == t4 && (t4 = this.root), t4.children.push(n2), n2;
    }, t3.outline.render = function() {
      return this.ctx = {}, this.ctx.val = "", this.ctx.pdf = t3, this.genIds_r(this.root), this.renderRoot(this.root), this.renderItems(this.root), this.ctx.val;
    }, t3.outline.genIds_r = function(e2) {
      e2.id = t3.internal.newObjectDeferred();
      for (var r = 0; r < e2.children.length; r++)
        this.genIds_r(e2.children[r]);
    }, t3.outline.renderRoot = function(t4) {
      this.objStart(t4), this.line("/Type /Outlines"), t4.children.length > 0 && (this.line("/First " + this.makeRef(t4.children[0])), this.line("/Last " + this.makeRef(t4.children[t4.children.length - 1]))), this.line("/Count " + this.count_r({ count: 0 }, t4)), this.objEnd();
    }, t3.outline.renderItems = function(e2) {
      for (var r = this.ctx.pdf.internal.getVerticalCoordinateString, n2 = 0; n2 < e2.children.length; n2++) {
        var i2 = e2.children[n2];
        this.objStart(i2), this.line("/Title " + this.makeString(i2.title)), this.line("/Parent " + this.makeRef(e2)), n2 > 0 && this.line("/Prev " + this.makeRef(e2.children[n2 - 1])), n2 < e2.children.length - 1 && this.line("/Next " + this.makeRef(e2.children[n2 + 1])), i2.children.length > 0 && (this.line("/First " + this.makeRef(i2.children[0])), this.line("/Last " + this.makeRef(i2.children[i2.children.length - 1])));
        var a2 = this.count = this.count_r({ count: 0 }, i2);
        if (a2 > 0 && this.line("/Count " + a2), i2.options && i2.options.pageNumber) {
          var o2 = t3.internal.getPageInfo(i2.options.pageNumber);
          this.line("/Dest [" + o2.objId + " 0 R /XYZ 0 " + r(0) + " 0]");
        }
        this.objEnd();
      }
      for (var s2 = 0; s2 < e2.children.length; s2++)
        this.renderItems(e2.children[s2]);
    }, t3.outline.line = function(t4) {
      this.ctx.val += t4 + "\r\n";
    }, t3.outline.makeRef = function(t4) {
      return t4.id + " 0 R";
    }, t3.outline.makeString = function(e2) {
      return "(" + t3.internal.pdfEscape(e2) + ")";
    }, t3.outline.objStart = function(t4) {
      this.ctx.val += "\r\n" + t4.id + " 0 obj\r\n<<\r\n";
    }, t3.outline.objEnd = function() {
      this.ctx.val += ">> \r\nendobj\r\n";
    }, t3.outline.count_r = function(t4, e2) {
      for (var r = 0; r < e2.children.length; r++)
        t4.count++, this.count_r(t4, e2.children[r]);
      return t4.count;
    };
  }]);
}(E.API), /**
 * @license
 *
 * Licensed under the MIT License.
 * http://opensource.org/licenses/mit-license
 */
function(t2) {
  var e = [192, 193, 194, 195, 196, 197, 198, 199];
  t2.processJPEG = function(t3, r, n2, i2, a2, o2) {
    var s2, c2 = this.decode.DCT_DECODE, u2 = null;
    if ("string" == typeof t3 || this.__addimage__.isArrayBuffer(t3) || this.__addimage__.isArrayBufferView(t3)) {
      switch (t3 = a2 || t3, t3 = this.__addimage__.isArrayBuffer(t3) ? new Uint8Array(t3) : t3, (s2 = function(t4) {
        for (var r2, n3 = 256 * t4.charCodeAt(4) + t4.charCodeAt(5), i3 = t4.length, a3 = { width: 0, height: 0, numcomponents: 1 }, o3 = 4; o3 < i3; o3 += 2) {
          if (o3 += n3, -1 !== e.indexOf(t4.charCodeAt(o3 + 1))) {
            r2 = 256 * t4.charCodeAt(o3 + 5) + t4.charCodeAt(o3 + 6), a3 = { width: 256 * t4.charCodeAt(o3 + 7) + t4.charCodeAt(o3 + 8), height: r2, numcomponents: t4.charCodeAt(o3 + 9) };
            break;
          }
          n3 = 256 * t4.charCodeAt(o3 + 2) + t4.charCodeAt(o3 + 3);
        }
        return a3;
      }(t3 = this.__addimage__.isArrayBufferView(t3) ? this.__addimage__.arrayBufferToBinaryString(t3) : t3)).numcomponents) {
        case 1:
          o2 = this.color_spaces.DEVICE_GRAY;
          break;
        case 4:
          o2 = this.color_spaces.DEVICE_CMYK;
          break;
        case 3:
          o2 = this.color_spaces.DEVICE_RGB;
      }
      u2 = { data: t3, width: s2.width, height: s2.height, colorSpace: o2, bitsPerComponent: 8, filter: c2, index: r, alias: n2 };
    }
    return u2;
  };
}(E.API);
var Vt, Gt, Yt, Jt, Xt, Kt = function() {
  var t2, e, i2;
  function a2(t3) {
    var e2, r, n2, i3, a3, o3, s2, c2, u2, h3, l2, f2, d2, p2;
    for (this.data = t3, this.pos = 8, this.palette = [], this.imgData = [], this.transparency = {}, this.animation = null, this.text = {}, o3 = null; ; ) {
      switch (e2 = this.readUInt32(), u2 = (function() {
        var t4, e3;
        for (e3 = [], t4 = 0; t4 < 4; ++t4)
          e3.push(String.fromCharCode(this.data[this.pos++]));
        return e3;
      }).call(this).join("")) {
        case "IHDR":
          this.width = this.readUInt32(), this.height = this.readUInt32(), this.bits = this.data[this.pos++], this.colorType = this.data[this.pos++], this.compressionMethod = this.data[this.pos++], this.filterMethod = this.data[this.pos++], this.interlaceMethod = this.data[this.pos++];
          break;
        case "acTL":
          this.animation = { numFrames: this.readUInt32(), numPlays: this.readUInt32() || 1 / 0, frames: [] };
          break;
        case "PLTE":
          this.palette = this.read(e2);
          break;
        case "fcTL":
          o3 && this.animation.frames.push(o3), this.pos += 4, o3 = { width: this.readUInt32(), height: this.readUInt32(), xOffset: this.readUInt32(), yOffset: this.readUInt32() }, a3 = this.readUInt16(), i3 = this.readUInt16() || 100, o3.delay = 1e3 * a3 / i3, o3.disposeOp = this.data[this.pos++], o3.blendOp = this.data[this.pos++], o3.data = [];
          break;
        case "IDAT":
        case "fdAT":
          for ("fdAT" === u2 && (this.pos += 4, e2 -= 4), t3 = (null != o3 ? o3.data : void 0) || this.imgData, f2 = 0; 0 <= e2 ? f2 < e2 : f2 > e2; 0 <= e2 ? ++f2 : --f2)
            t3.push(this.data[this.pos++]);
          break;
        case "tRNS":
          switch (this.transparency = {}, this.colorType) {
            case 3:
              if (n2 = this.palette.length / 3, this.transparency.indexed = this.read(e2), this.transparency.indexed.length > n2)
                throw new Error("More transparent colors than palette size");
              if ((h3 = n2 - this.transparency.indexed.length) > 0)
                for (d2 = 0; 0 <= h3 ? d2 < h3 : d2 > h3; 0 <= h3 ? ++d2 : --d2)
                  this.transparency.indexed.push(255);
              break;
            case 0:
              this.transparency.grayscale = this.read(e2)[0];
              break;
            case 2:
              this.transparency.rgb = this.read(e2);
          }
          break;
        case "tEXt":
          s2 = (l2 = this.read(e2)).indexOf(0), c2 = String.fromCharCode.apply(String, l2.slice(0, s2)), this.text[c2] = String.fromCharCode.apply(String, l2.slice(s2 + 1));
          break;
        case "IEND":
          return o3 && this.animation.frames.push(o3), this.colors = (function() {
            switch (this.colorType) {
              case 0:
              case 3:
              case 4:
                return 1;
              case 2:
              case 6:
                return 3;
            }
          }).call(this), this.hasAlphaChannel = 4 === (p2 = this.colorType) || 6 === p2, r = this.colors + (this.hasAlphaChannel ? 1 : 0), this.pixelBitlength = this.bits * r, this.colorSpace = (function() {
            switch (this.colors) {
              case 1:
                return "DeviceGray";
              case 3:
                return "DeviceRGB";
            }
          }).call(this), void (this.imgData = new Uint8Array(this.imgData));
        default:
          this.pos += e2;
      }
      if (this.pos += 4, this.pos > this.data.length)
        throw new Error("Incomplete or corrupt PNG file");
    }
  }
  __name(a2, "a");
  a2.prototype.read = function(t3) {
    var e2, r;
    for (r = [], e2 = 0; 0 <= t3 ? e2 < t3 : e2 > t3; 0 <= t3 ? ++e2 : --e2)
      r.push(this.data[this.pos++]);
    return r;
  }, a2.prototype.readUInt32 = function() {
    return this.data[this.pos++] << 24 | this.data[this.pos++] << 16 | this.data[this.pos++] << 8 | this.data[this.pos++];
  }, a2.prototype.readUInt16 = function() {
    return this.data[this.pos++] << 8 | this.data[this.pos++];
  }, a2.prototype.decodePixels = function(t3) {
    var e2 = this.pixelBitlength / 8, n2 = new Uint8Array(this.width * this.height * e2), i3 = 0, a3 = this;
    if (null == t3 && (t3 = this.imgData), 0 === t3.length)
      return new Uint8Array(0);
    function o3(r, o4, s2, c2) {
      var u2, h3, l2, f2, d2, p2, g2, m2, v2, b2, y2, w2, N2, L2, A2, x2, S2, _2, P2, k2, I2, F2 = Math.ceil((a3.width - r) / s2), C2 = Math.ceil((a3.height - o4) / c2), j2 = a3.width == F2 && a3.height == C2;
      for (L2 = e2 * F2, w2 = j2 ? n2 : new Uint8Array(L2 * C2), p2 = t3.length, N2 = 0, h3 = 0; N2 < C2 && i3 < p2; ) {
        switch (t3[i3++]) {
          case 0:
            for (f2 = S2 = 0; S2 < L2; f2 = S2 += 1)
              w2[h3++] = t3[i3++];
            break;
          case 1:
            for (f2 = _2 = 0; _2 < L2; f2 = _2 += 1)
              u2 = t3[i3++], d2 = f2 < e2 ? 0 : w2[h3 - e2], w2[h3++] = (u2 + d2) % 256;
            break;
          case 2:
            for (f2 = P2 = 0; P2 < L2; f2 = P2 += 1)
              u2 = t3[i3++], l2 = (f2 - f2 % e2) / e2, A2 = N2 && w2[(N2 - 1) * L2 + l2 * e2 + f2 % e2], w2[h3++] = (A2 + u2) % 256;
            break;
          case 3:
            for (f2 = k2 = 0; k2 < L2; f2 = k2 += 1)
              u2 = t3[i3++], l2 = (f2 - f2 % e2) / e2, d2 = f2 < e2 ? 0 : w2[h3 - e2], A2 = N2 && w2[(N2 - 1) * L2 + l2 * e2 + f2 % e2], w2[h3++] = (u2 + Math.floor((d2 + A2) / 2)) % 256;
            break;
          case 4:
            for (f2 = I2 = 0; I2 < L2; f2 = I2 += 1)
              u2 = t3[i3++], l2 = (f2 - f2 % e2) / e2, d2 = f2 < e2 ? 0 : w2[h3 - e2], 0 === N2 ? A2 = x2 = 0 : (A2 = w2[(N2 - 1) * L2 + l2 * e2 + f2 % e2], x2 = l2 && w2[(N2 - 1) * L2 + (l2 - 1) * e2 + f2 % e2]), g2 = d2 + A2 - x2, m2 = Math.abs(g2 - d2), b2 = Math.abs(g2 - A2), y2 = Math.abs(g2 - x2), v2 = m2 <= b2 && m2 <= y2 ? d2 : b2 <= y2 ? A2 : x2, w2[h3++] = (u2 + v2) % 256;
            break;
          default:
            throw new Error("Invalid filter algorithm: " + t3[i3 - 1]);
        }
        if (!j2) {
          var O2 = ((o4 + N2 * c2) * a3.width + r) * e2, B2 = N2 * L2;
          for (f2 = 0; f2 < F2; f2 += 1) {
            for (var M2 = 0; M2 < e2; M2 += 1)
              n2[O2++] = w2[B2++];
            O2 += (s2 - 1) * e2;
          }
        }
        N2++;
      }
    }
    __name(o3, "o");
    return t3 = unzlibSync(t3), 1 == a3.interlaceMethod ? (o3(0, 0, 8, 8), o3(4, 0, 8, 8), o3(0, 4, 4, 8), o3(2, 0, 4, 4), o3(0, 2, 2, 4), o3(1, 0, 2, 2), o3(0, 1, 1, 2)) : o3(0, 0, 1, 1), n2;
  }, a2.prototype.decodePalette = function() {
    var t3, e2, r, n2, i3, a3, o3, s2, c2;
    for (r = this.palette, a3 = this.transparency.indexed || [], i3 = new Uint8Array((a3.length || 0) + r.length), n2 = 0, t3 = 0, e2 = o3 = 0, s2 = r.length; o3 < s2; e2 = o3 += 3)
      i3[n2++] = r[e2], i3[n2++] = r[e2 + 1], i3[n2++] = r[e2 + 2], i3[n2++] = null != (c2 = a3[t3++]) ? c2 : 255;
    return i3;
  }, a2.prototype.copyToImageData = function(t3, e2) {
    var r, n2, i3, a3, o3, s2, c2, u2, h3, l2, f2;
    if (n2 = this.colors, h3 = null, r = this.hasAlphaChannel, this.palette.length && (h3 = null != (f2 = this._decodedPalette) ? f2 : this._decodedPalette = this.decodePalette(), n2 = 4, r = true), u2 = (i3 = t3.data || t3).length, o3 = h3 || e2, a3 = s2 = 0, 1 === n2)
      for (; a3 < u2; )
        c2 = h3 ? 4 * e2[a3 / 4] : s2, l2 = o3[c2++], i3[a3++] = l2, i3[a3++] = l2, i3[a3++] = l2, i3[a3++] = r ? o3[c2++] : 255, s2 = c2;
    else
      for (; a3 < u2; )
        c2 = h3 ? 4 * e2[a3 / 4] : s2, i3[a3++] = o3[c2++], i3[a3++] = o3[c2++], i3[a3++] = o3[c2++], i3[a3++] = r ? o3[c2++] : 255, s2 = c2;
  }, a2.prototype.decode = function() {
    var t3;
    return t3 = new Uint8Array(this.width * this.height * 4), this.copyToImageData(t3, this.decodePixels()), t3;
  };
  var o2 = /* @__PURE__ */ __name(function() {
    if ("[object Window]" === Object.prototype.toString.call(n)) {
      try {
        e = n.document.createElement("canvas"), i2 = e.getContext("2d");
      } catch (t3) {
        return false;
      }
      return true;
    }
    return false;
  }, "o");
  return o2(), t2 = /* @__PURE__ */ __name(function(t3) {
    var r;
    if (true === o2())
      return i2.width = t3.width, i2.height = t3.height, i2.clearRect(0, 0, t3.width, t3.height), i2.putImageData(t3, 0, 0), (r = new Image()).src = e.toDataURL(), r;
    throw new Error("This method requires a Browser with Canvas-capability.");
  }, "t"), a2.prototype.decodeFrames = function(e2) {
    var r, n2, i3, a3, o3, s2, c2, u2;
    if (this.animation) {
      for (u2 = [], n2 = o3 = 0, s2 = (c2 = this.animation.frames).length; o3 < s2; n2 = ++o3)
        r = c2[n2], i3 = e2.createImageData(r.width, r.height), a3 = this.decodePixels(new Uint8Array(r.data)), this.copyToImageData(i3, a3), r.imageData = i3, u2.push(r.image = t2(i3));
      return u2;
    }
  }, a2.prototype.renderFrame = function(t3, e2) {
    var r, n2, i3;
    return r = (n2 = this.animation.frames)[e2], i3 = n2[e2 - 1], 0 === e2 && t3.clearRect(0, 0, this.width, this.height), 1 === (null != i3 ? i3.disposeOp : void 0) ? t3.clearRect(i3.xOffset, i3.yOffset, i3.width, i3.height) : 2 === (null != i3 ? i3.disposeOp : void 0) && t3.putImageData(i3.imageData, i3.xOffset, i3.yOffset), 0 === r.blendOp && t3.clearRect(r.xOffset, r.yOffset, r.width, r.height), t3.drawImage(r.image, r.xOffset, r.yOffset);
  }, a2.prototype.animate = function(t3) {
    var e2, r, n2, i3, a3, o3, s2 = this;
    return r = 0, o3 = this.animation, i3 = o3.numFrames, n2 = o3.frames, a3 = o3.numPlays, (e2 = /* @__PURE__ */ __name(function() {
      var o4, c2;
      if (o4 = r++ % i3, c2 = n2[o4], s2.renderFrame(t3, o4), i3 > 1 && r / i3 < a3)
        return s2.animation._timeout = setTimeout(e2, c2.delay);
    }, "e"))();
  }, a2.prototype.stopAnimation = function() {
    var t3;
    return clearTimeout(null != (t3 = this.animation) ? t3._timeout : void 0);
  }, a2.prototype.render = function(t3) {
    var e2, r;
    return t3._png && t3._png.stopAnimation(), t3._png = this, t3.width = this.width, t3.height = this.height, e2 = t3.getContext("2d"), this.animation ? (this.decodeFrames(e2), this.animate(e2)) : (r = e2.createImageData(this.width, this.height), this.copyToImageData(r, this.decodePixels()), e2.putImageData(r, 0, 0));
  }, a2;
}();
/**
 * @license
 *
 * Copyright (c) 2014 James Robb, https://github.com/jamesbrobb
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
 * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 * ====================================================================
 */
/**
 * @license
 * (c) Dean McNamee <dean@gmail.com>, 2013.
 *
 * https://github.com/deanm/omggif
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to
 * deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
 * sell copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 *
 * omggif is a JavaScript implementation of a GIF 89a encoder and decoder,
 * including animation and compression.  It does not rely on any specific
 * underlying system, so should run in the browser, Node, or Plask.
 */
function Zt(t2) {
  var e = 0;
  if (71 !== t2[e++] || 73 !== t2[e++] || 70 !== t2[e++] || 56 !== t2[e++] || 56 != (t2[e++] + 1 & 253) || 97 !== t2[e++])
    throw new Error("Invalid GIF 87a/89a header.");
  var r = t2[e++] | t2[e++] << 8, n2 = t2[e++] | t2[e++] << 8, i2 = t2[e++], a2 = i2 >> 7, o2 = 1 << (7 & i2) + 1;
  t2[e++];
  t2[e++];
  var s2 = null, c2 = null;
  a2 && (s2 = e, c2 = o2, e += 3 * o2);
  var u2 = true, h3 = [], l2 = 0, f2 = null, d2 = 0, p2 = null;
  for (this.width = r, this.height = n2; u2 && e < t2.length; )
    switch (t2[e++]) {
      case 33:
        switch (t2[e++]) {
          case 255:
            if (11 !== t2[e] || 78 == t2[e + 1] && 69 == t2[e + 2] && 84 == t2[e + 3] && 83 == t2[e + 4] && 67 == t2[e + 5] && 65 == t2[e + 6] && 80 == t2[e + 7] && 69 == t2[e + 8] && 50 == t2[e + 9] && 46 == t2[e + 10] && 48 == t2[e + 11] && 3 == t2[e + 12] && 1 == t2[e + 13] && 0 == t2[e + 16])
              e += 14, p2 = t2[e++] | t2[e++] << 8, e++;
            else
              for (e += 12; ; ) {
                if (!((P2 = t2[e++]) >= 0))
                  throw Error("Invalid block size");
                if (0 === P2)
                  break;
                e += P2;
              }
            break;
          case 249:
            if (4 !== t2[e++] || 0 !== t2[e + 4])
              throw new Error("Invalid graphics extension block.");
            var g2 = t2[e++];
            l2 = t2[e++] | t2[e++] << 8, f2 = t2[e++], 0 == (1 & g2) && (f2 = null), d2 = g2 >> 2 & 7, e++;
            break;
          case 254:
            for (; ; ) {
              if (!((P2 = t2[e++]) >= 0))
                throw Error("Invalid block size");
              if (0 === P2)
                break;
              e += P2;
            }
            break;
          default:
            throw new Error("Unknown graphic control label: 0x" + t2[e - 1].toString(16));
        }
        break;
      case 44:
        var m2 = t2[e++] | t2[e++] << 8, v2 = t2[e++] | t2[e++] << 8, b2 = t2[e++] | t2[e++] << 8, y2 = t2[e++] | t2[e++] << 8, w2 = t2[e++], N2 = w2 >> 6 & 1, L2 = 1 << (7 & w2) + 1, A2 = s2, x2 = c2, S2 = false;
        if (w2 >> 7) {
          S2 = true;
          A2 = e, x2 = L2, e += 3 * L2;
        }
        var _2 = e;
        for (e++; ; ) {
          var P2;
          if (!((P2 = t2[e++]) >= 0))
            throw Error("Invalid block size");
          if (0 === P2)
            break;
          e += P2;
        }
        h3.push({ x: m2, y: v2, width: b2, height: y2, has_local_palette: S2, palette_offset: A2, palette_size: x2, data_offset: _2, data_length: e - _2, transparent_index: f2, interlaced: !!N2, delay: l2, disposal: d2 });
        break;
      case 59:
        u2 = false;
        break;
      default:
        throw new Error("Unknown gif block: 0x" + t2[e - 1].toString(16));
    }
  this.numFrames = function() {
    return h3.length;
  }, this.loopCount = function() {
    return p2;
  }, this.frameInfo = function(t3) {
    if (t3 < 0 || t3 >= h3.length)
      throw new Error("Frame index out of range.");
    return h3[t3];
  }, this.decodeAndBlitFrameBGRA = function(e2, n3) {
    var i3 = this.frameInfo(e2), a3 = i3.width * i3.height, o3 = new Uint8Array(a3);
    $t(t2, i3.data_offset, o3, a3);
    var s3 = i3.palette_offset, c3 = i3.transparent_index;
    null === c3 && (c3 = 256);
    var u3 = i3.width, h4 = r - u3, l3 = u3, f3 = 4 * (i3.y * r + i3.x), d3 = 4 * ((i3.y + i3.height) * r + i3.x), p3 = f3, g3 = 4 * h4;
    true === i3.interlaced && (g3 += 4 * r * 7);
    for (var m3 = 8, v3 = 0, b3 = o3.length; v3 < b3; ++v3) {
      var y3 = o3[v3];
      if (0 === l3 && (l3 = u3, (p3 += g3) >= d3 && (g3 = 4 * h4 + 4 * r * (m3 - 1), p3 = f3 + (u3 + h4) * (m3 << 1), m3 >>= 1)), y3 === c3)
        p3 += 4;
      else {
        var w3 = t2[s3 + 3 * y3], N3 = t2[s3 + 3 * y3 + 1], L3 = t2[s3 + 3 * y3 + 2];
        n3[p3++] = L3, n3[p3++] = N3, n3[p3++] = w3, n3[p3++] = 255;
      }
      --l3;
    }
  }, this.decodeAndBlitFrameRGBA = function(e2, n3) {
    var i3 = this.frameInfo(e2), a3 = i3.width * i3.height, o3 = new Uint8Array(a3);
    $t(t2, i3.data_offset, o3, a3);
    var s3 = i3.palette_offset, c3 = i3.transparent_index;
    null === c3 && (c3 = 256);
    var u3 = i3.width, h4 = r - u3, l3 = u3, f3 = 4 * (i3.y * r + i3.x), d3 = 4 * ((i3.y + i3.height) * r + i3.x), p3 = f3, g3 = 4 * h4;
    true === i3.interlaced && (g3 += 4 * r * 7);
    for (var m3 = 8, v3 = 0, b3 = o3.length; v3 < b3; ++v3) {
      var y3 = o3[v3];
      if (0 === l3 && (l3 = u3, (p3 += g3) >= d3 && (g3 = 4 * h4 + 4 * r * (m3 - 1), p3 = f3 + (u3 + h4) * (m3 << 1), m3 >>= 1)), y3 === c3)
        p3 += 4;
      else {
        var w3 = t2[s3 + 3 * y3], N3 = t2[s3 + 3 * y3 + 1], L3 = t2[s3 + 3 * y3 + 2];
        n3[p3++] = w3, n3[p3++] = N3, n3[p3++] = L3, n3[p3++] = 255;
      }
      --l3;
    }
  };
}
__name(Zt, "Zt");
function $t(t2, e, r, n2) {
  for (var i2 = t2[e++], o2 = 1 << i2, s2 = o2 + 1, c2 = s2 + 1, u2 = i2 + 1, h3 = (1 << u2) - 1, l2 = 0, f2 = 0, d2 = 0, p2 = t2[e++], g2 = new Int32Array(4096), m2 = null; ; ) {
    for (; l2 < 16 && 0 !== p2; )
      f2 |= t2[e++] << l2, l2 += 8, 1 === p2 ? p2 = t2[e++] : --p2;
    if (l2 < u2)
      break;
    var v2 = f2 & h3;
    if (f2 >>= u2, l2 -= u2, v2 !== o2) {
      if (v2 === s2)
        break;
      for (var b2 = v2 < c2 ? v2 : m2, y2 = 0, w2 = b2; w2 > o2; )
        w2 = g2[w2] >> 8, ++y2;
      var N2 = w2;
      if (d2 + y2 + (b2 !== v2 ? 1 : 0) > n2)
        return void a.log("Warning, gif stream longer than expected.");
      r[d2++] = N2;
      var L2 = d2 += y2;
      for (b2 !== v2 && (r[d2++] = N2), w2 = b2; y2--; )
        w2 = g2[w2], r[--L2] = 255 & w2, w2 >>= 8;
      null !== m2 && c2 < 4096 && (g2[c2++] = m2 << 8 | N2, c2 >= h3 + 1 && u2 < 12 && (++u2, h3 = h3 << 1 | 1)), m2 = v2;
    } else
      c2 = s2 + 1, h3 = (1 << (u2 = i2 + 1)) - 1, m2 = null;
  }
  return d2 !== n2 && a.log("Warning, gif stream shorter than expected."), r;
}
__name($t, "$t");
/**
 * @license
  Copyright (c) 2008, Adobe Systems Incorporated
  All rights reserved.

  Redistribution and use in source and binary forms, with or without 
  modification, are permitted provided that the following conditions are
  met:

  * Redistributions of source code must retain the above copyright notice, 
    this list of conditions and the following disclaimer.
  
  * Redistributions in binary form must reproduce the above copyright
    notice, this list of conditions and the following disclaimer in the 
    documentation and/or other materials provided with the distribution.
  
  * Neither the name of Adobe Systems Incorporated nor the names of its 
    contributors may be used to endorse or promote products derived from 
    this software without specific prior written permission.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
  IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR 
  CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
function Qt(t2) {
  var e, r, n2, i2, a2, o2 = Math.floor, s2 = new Array(64), c2 = new Array(64), u2 = new Array(64), h3 = new Array(64), l2 = new Array(65535), f2 = new Array(65535), d2 = new Array(64), p2 = new Array(64), g2 = [], m2 = 0, v2 = 7, b2 = new Array(64), y2 = new Array(64), w2 = new Array(64), N2 = new Array(256), L2 = new Array(2048), A2 = [0, 1, 5, 6, 14, 15, 27, 28, 2, 4, 7, 13, 16, 26, 29, 42, 3, 8, 12, 17, 25, 30, 41, 43, 9, 11, 18, 24, 31, 40, 44, 53, 10, 19, 23, 32, 39, 45, 52, 54, 20, 22, 33, 38, 46, 51, 55, 60, 21, 34, 37, 47, 50, 56, 59, 61, 35, 36, 48, 49, 57, 58, 62, 63], x2 = [0, 0, 1, 5, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0], S2 = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11], _2 = [0, 0, 2, 1, 3, 3, 2, 4, 3, 5, 5, 4, 4, 0, 0, 1, 125], P2 = [1, 2, 3, 0, 4, 17, 5, 18, 33, 49, 65, 6, 19, 81, 97, 7, 34, 113, 20, 50, 129, 145, 161, 8, 35, 66, 177, 193, 21, 82, 209, 240, 36, 51, 98, 114, 130, 9, 10, 22, 23, 24, 25, 26, 37, 38, 39, 40, 41, 42, 52, 53, 54, 55, 56, 57, 58, 67, 68, 69, 70, 71, 72, 73, 74, 83, 84, 85, 86, 87, 88, 89, 90, 99, 100, 101, 102, 103, 104, 105, 106, 115, 116, 117, 118, 119, 120, 121, 122, 131, 132, 133, 134, 135, 136, 137, 138, 146, 147, 148, 149, 150, 151, 152, 153, 154, 162, 163, 164, 165, 166, 167, 168, 169, 170, 178, 179, 180, 181, 182, 183, 184, 185, 186, 194, 195, 196, 197, 198, 199, 200, 201, 202, 210, 211, 212, 213, 214, 215, 216, 217, 218, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250], k2 = [0, 0, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0], I2 = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11], F2 = [0, 0, 2, 1, 2, 4, 4, 3, 4, 7, 5, 4, 4, 0, 1, 2, 119], C2 = [0, 1, 2, 3, 17, 4, 5, 33, 49, 6, 18, 65, 81, 7, 97, 113, 19, 34, 50, 129, 8, 20, 66, 145, 161, 177, 193, 9, 35, 51, 82, 240, 21, 98, 114, 209, 10, 22, 36, 52, 225, 37, 241, 23, 24, 25, 26, 38, 39, 40, 41, 42, 53, 54, 55, 56, 57, 58, 67, 68, 69, 70, 71, 72, 73, 74, 83, 84, 85, 86, 87, 88, 89, 90, 99, 100, 101, 102, 103, 104, 105, 106, 115, 116, 117, 118, 119, 120, 121, 122, 130, 131, 132, 133, 134, 135, 136, 137, 138, 146, 147, 148, 149, 150, 151, 152, 153, 154, 162, 163, 164, 165, 166, 167, 168, 169, 170, 178, 179, 180, 181, 182, 183, 184, 185, 186, 194, 195, 196, 197, 198, 199, 200, 201, 202, 210, 211, 212, 213, 214, 215, 216, 217, 218, 226, 227, 228, 229, 230, 231, 232, 233, 234, 242, 243, 244, 245, 246, 247, 248, 249, 250];
  function j2(t3, e2) {
    for (var r2 = 0, n3 = 0, i3 = new Array(), a3 = 1; a3 <= 16; a3++) {
      for (var o3 = 1; o3 <= t3[a3]; o3++)
        i3[e2[n3]] = [], i3[e2[n3]][0] = r2, i3[e2[n3]][1] = a3, n3++, r2++;
      r2 *= 2;
    }
    return i3;
  }
  __name(j2, "j");
  function O2(t3) {
    for (var e2 = t3[0], r2 = t3[1] - 1; r2 >= 0; )
      e2 & 1 << r2 && (m2 |= 1 << v2), r2--, --v2 < 0 && (255 == m2 ? (B2(255), B2(0)) : B2(m2), v2 = 7, m2 = 0);
  }
  __name(O2, "O");
  function B2(t3) {
    g2.push(t3);
  }
  __name(B2, "B");
  function M2(t3) {
    B2(t3 >> 8 & 255), B2(255 & t3);
  }
  __name(M2, "M");
  function E2(t3, e2, r2, n3, i3) {
    for (var a3, o3 = i3[0], s3 = i3[240], c3 = function(t4, e3) {
      var r3, n4, i4, a4, o4, s4, c4, u4, h5, l3, f3 = 0;
      for (h5 = 0; h5 < 8; ++h5) {
        r3 = t4[f3], n4 = t4[f3 + 1], i4 = t4[f3 + 2], a4 = t4[f3 + 3], o4 = t4[f3 + 4], s4 = t4[f3 + 5], c4 = t4[f3 + 6];
        var p3 = r3 + (u4 = t4[f3 + 7]), g4 = r3 - u4, m4 = n4 + c4, v4 = n4 - c4, b4 = i4 + s4, y4 = i4 - s4, w4 = a4 + o4, N3 = a4 - o4, L3 = p3 + w4, A3 = p3 - w4, x3 = m4 + b4, S3 = m4 - b4;
        t4[f3] = L3 + x3, t4[f3 + 4] = L3 - x3;
        var _3 = 0.707106781 * (S3 + A3);
        t4[f3 + 2] = A3 + _3, t4[f3 + 6] = A3 - _3;
        var P3 = 0.382683433 * ((L3 = N3 + y4) - (S3 = v4 + g4)), k3 = 0.5411961 * L3 + P3, I3 = 1.306562965 * S3 + P3, F3 = 0.707106781 * (x3 = y4 + v4), C3 = g4 + F3, j3 = g4 - F3;
        t4[f3 + 5] = j3 + k3, t4[f3 + 3] = j3 - k3, t4[f3 + 1] = C3 + I3, t4[f3 + 7] = C3 - I3, f3 += 8;
      }
      for (f3 = 0, h5 = 0; h5 < 8; ++h5) {
        r3 = t4[f3], n4 = t4[f3 + 8], i4 = t4[f3 + 16], a4 = t4[f3 + 24], o4 = t4[f3 + 32], s4 = t4[f3 + 40], c4 = t4[f3 + 48];
        var O3 = r3 + (u4 = t4[f3 + 56]), B3 = r3 - u4, M3 = n4 + c4, E3 = n4 - c4, q3 = i4 + s4, D2 = i4 - s4, R2 = a4 + o4, T2 = a4 - o4, U2 = O3 + R2, z2 = O3 - R2, H2 = M3 + q3, W2 = M3 - q3;
        t4[f3] = U2 + H2, t4[f3 + 32] = U2 - H2;
        var V2 = 0.707106781 * (W2 + z2);
        t4[f3 + 16] = z2 + V2, t4[f3 + 48] = z2 - V2;
        var G2 = 0.382683433 * ((U2 = T2 + D2) - (W2 = E3 + B3)), Y2 = 0.5411961 * U2 + G2, J2 = 1.306562965 * W2 + G2, X2 = 0.707106781 * (H2 = D2 + E3), K2 = B3 + X2, Z2 = B3 - X2;
        t4[f3 + 40] = Z2 + Y2, t4[f3 + 24] = Z2 - Y2, t4[f3 + 8] = K2 + J2, t4[f3 + 56] = K2 - J2, f3++;
      }
      for (h5 = 0; h5 < 64; ++h5)
        l3 = t4[h5] * e3[h5], d2[h5] = l3 > 0 ? l3 + 0.5 | 0 : l3 - 0.5 | 0;
      return d2;
    }(t3, e2), u3 = 0; u3 < 64; ++u3)
      p2[A2[u3]] = c3[u3];
    var h4 = p2[0] - r2;
    r2 = p2[0], 0 == h4 ? O2(n3[0]) : (O2(n3[f2[a3 = 32767 + h4]]), O2(l2[a3]));
    for (var g3 = 63; g3 > 0 && 0 == p2[g3]; )
      g3--;
    if (0 == g3)
      return O2(o3), r2;
    for (var m3, v3 = 1; v3 <= g3; ) {
      for (var b3 = v3; 0 == p2[v3] && v3 <= g3; )
        ++v3;
      var y3 = v3 - b3;
      if (y3 >= 16) {
        m3 = y3 >> 4;
        for (var w3 = 1; w3 <= m3; ++w3)
          O2(s3);
        y3 &= 15;
      }
      a3 = 32767 + p2[v3], O2(i3[(y3 << 4) + f2[a3]]), O2(l2[a3]), v3++;
    }
    return 63 != g3 && O2(o3), r2;
  }
  __name(E2, "E");
  function q2(t3) {
    (t3 = Math.min(Math.max(t3, 1), 100), a2 != t3) && (!function(t4) {
      for (var e2 = [16, 11, 10, 16, 24, 40, 51, 61, 12, 12, 14, 19, 26, 58, 60, 55, 14, 13, 16, 24, 40, 57, 69, 56, 14, 17, 22, 29, 51, 87, 80, 62, 18, 22, 37, 56, 68, 109, 103, 77, 24, 35, 55, 64, 81, 104, 113, 92, 49, 64, 78, 87, 103, 121, 120, 101, 72, 92, 95, 98, 112, 100, 103, 99], r2 = 0; r2 < 64; r2++) {
        var n3 = o2((e2[r2] * t4 + 50) / 100);
        n3 = Math.min(Math.max(n3, 1), 255), s2[A2[r2]] = n3;
      }
      for (var i3 = [17, 18, 24, 47, 99, 99, 99, 99, 18, 21, 26, 66, 99, 99, 99, 99, 24, 26, 56, 99, 99, 99, 99, 99, 47, 66, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99], a3 = 0; a3 < 64; a3++) {
        var l3 = o2((i3[a3] * t4 + 50) / 100);
        l3 = Math.min(Math.max(l3, 1), 255), c2[A2[a3]] = l3;
      }
      for (var f3 = [1, 1.387039845, 1.306562965, 1.175875602, 1, 0.785694958, 0.5411961, 0.275899379], d3 = 0, p3 = 0; p3 < 8; p3++)
        for (var g3 = 0; g3 < 8; g3++)
          u2[d3] = 1 / (s2[A2[d3]] * f3[p3] * f3[g3] * 8), h3[d3] = 1 / (c2[A2[d3]] * f3[p3] * f3[g3] * 8), d3++;
    }(t3 < 50 ? Math.floor(5e3 / t3) : Math.floor(200 - 2 * t3)), a2 = t3);
  }
  __name(q2, "q");
  this.encode = function(t3, a3) {
    a3 && q2(a3), g2 = new Array(), m2 = 0, v2 = 7, M2(65496), M2(65504), M2(16), B2(74), B2(70), B2(73), B2(70), B2(0), B2(1), B2(1), B2(0), M2(1), M2(1), B2(0), B2(0), function() {
      M2(65499), M2(132), B2(0);
      for (var t4 = 0; t4 < 64; t4++)
        B2(s2[t4]);
      B2(1);
      for (var e2 = 0; e2 < 64; e2++)
        B2(c2[e2]);
    }(), function(t4, e2) {
      M2(65472), M2(17), B2(8), M2(e2), M2(t4), B2(3), B2(1), B2(17), B2(0), B2(2), B2(17), B2(1), B2(3), B2(17), B2(1);
    }(t3.width, t3.height), function() {
      M2(65476), M2(418), B2(0);
      for (var t4 = 0; t4 < 16; t4++)
        B2(x2[t4 + 1]);
      for (var e2 = 0; e2 <= 11; e2++)
        B2(S2[e2]);
      B2(16);
      for (var r2 = 0; r2 < 16; r2++)
        B2(_2[r2 + 1]);
      for (var n3 = 0; n3 <= 161; n3++)
        B2(P2[n3]);
      B2(1);
      for (var i3 = 0; i3 < 16; i3++)
        B2(k2[i3 + 1]);
      for (var a4 = 0; a4 <= 11; a4++)
        B2(I2[a4]);
      B2(17);
      for (var o4 = 0; o4 < 16; o4++)
        B2(F2[o4 + 1]);
      for (var s3 = 0; s3 <= 161; s3++)
        B2(C2[s3]);
    }(), M2(65498), M2(12), B2(3), B2(1), B2(0), B2(2), B2(17), B2(3), B2(17), B2(0), B2(63), B2(0);
    var o3 = 0, l3 = 0, f3 = 0;
    m2 = 0, v2 = 7, this.encode.displayName = "_encode_";
    for (var d3, p3, N3, A3, j3, D2, R2, T2, U2, z2 = t3.data, H2 = t3.width, W2 = t3.height, V2 = 4 * H2, G2 = 0; G2 < W2; ) {
      for (d3 = 0; d3 < V2; ) {
        for (j3 = V2 * G2 + d3, R2 = -1, T2 = 0, U2 = 0; U2 < 64; U2++)
          D2 = j3 + (T2 = U2 >> 3) * V2 + (R2 = 4 * (7 & U2)), G2 + T2 >= W2 && (D2 -= V2 * (G2 + 1 + T2 - W2)), d3 + R2 >= V2 && (D2 -= d3 + R2 - V2 + 4), p3 = z2[D2++], N3 = z2[D2++], A3 = z2[D2++], b2[U2] = (L2[p3] + L2[N3 + 256 >> 0] + L2[A3 + 512 >> 0] >> 16) - 128, y2[U2] = (L2[p3 + 768 >> 0] + L2[N3 + 1024 >> 0] + L2[A3 + 1280 >> 0] >> 16) - 128, w2[U2] = (L2[p3 + 1280 >> 0] + L2[N3 + 1536 >> 0] + L2[A3 + 1792 >> 0] >> 16) - 128;
        o3 = E2(b2, u2, o3, e, n2), l3 = E2(y2, h3, l3, r, i2), f3 = E2(w2, h3, f3, r, i2), d3 += 32;
      }
      G2 += 8;
    }
    if (v2 >= 0) {
      var Y2 = [];
      Y2[1] = v2 + 1, Y2[0] = (1 << v2 + 1) - 1, O2(Y2);
    }
    return M2(65497), new Uint8Array(g2);
  }, t2 = t2 || 50, function() {
    for (var t3 = String.fromCharCode, e2 = 0; e2 < 256; e2++)
      N2[e2] = t3(e2);
  }(), e = j2(x2, S2), r = j2(k2, I2), n2 = j2(_2, P2), i2 = j2(F2, C2), function() {
    for (var t3 = 1, e2 = 2, r2 = 1; r2 <= 15; r2++) {
      for (var n3 = t3; n3 < e2; n3++)
        f2[32767 + n3] = r2, l2[32767 + n3] = [], l2[32767 + n3][1] = r2, l2[32767 + n3][0] = n3;
      for (var i3 = -(e2 - 1); i3 <= -t3; i3++)
        f2[32767 + i3] = r2, l2[32767 + i3] = [], l2[32767 + i3][1] = r2, l2[32767 + i3][0] = e2 - 1 + i3;
      t3 <<= 1, e2 <<= 1;
    }
  }(), function() {
    for (var t3 = 0; t3 < 256; t3++)
      L2[t3] = 19595 * t3, L2[t3 + 256 >> 0] = 38470 * t3, L2[t3 + 512 >> 0] = 7471 * t3 + 32768, L2[t3 + 768 >> 0] = -11059 * t3, L2[t3 + 1024 >> 0] = -21709 * t3, L2[t3 + 1280 >> 0] = 32768 * t3 + 8421375, L2[t3 + 1536 >> 0] = -27439 * t3, L2[t3 + 1792 >> 0] = -5329 * t3;
  }(), q2(t2);
}
__name(Qt, "Qt");
/**
 * @license
 * Copyright (c) 2017 Aras Abbasi
 *
 * Licensed under the MIT License.
 * http://opensource.org/licenses/mit-license
 */
function te(t2, e) {
  if (this.pos = 0, this.buffer = t2, this.datav = new DataView(t2.buffer), this.is_with_alpha = !!e, this.bottom_up = true, this.flag = String.fromCharCode(this.buffer[0]) + String.fromCharCode(this.buffer[1]), this.pos += 2, -1 === ["BM", "BA", "CI", "CP", "IC", "PT"].indexOf(this.flag))
    throw new Error("Invalid BMP File");
  this.parseHeader(), this.parseBGR();
}
__name(te, "te");
function ee(t2) {
  function e(t3) {
    if (!t3)
      throw Error("assert :P");
  }
  __name(e, "e");
  function r(t3, e2, r2) {
    for (var n3 = 0; 4 > n3; n3++)
      if (t3[e2 + n3] != r2.charCodeAt(n3))
        return true;
    return false;
  }
  __name(r, "r");
  function n2(t3, e2, r2, n3, i3) {
    for (var a3 = 0; a3 < i3; a3++)
      t3[e2 + a3] = r2[n3 + a3];
  }
  __name(n2, "n");
  function i2(t3, e2, r2, n3) {
    for (var i3 = 0; i3 < n3; i3++)
      t3[e2 + i3] = r2;
  }
  __name(i2, "i");
  function a2(t3) {
    return new Int32Array(t3);
  }
  __name(a2, "a");
  function o2(t3, e2) {
    for (var r2 = [], n3 = 0; n3 < t3; n3++)
      r2.push(new e2());
    return r2;
  }
  __name(o2, "o");
  function s2(t3, e2) {
    var r2 = [];
    return (/* @__PURE__ */ __name(function t4(r3, n3, i3) {
      for (var a3 = i3[n3], o3 = 0; o3 < a3 && (r3.push(i3.length > n3 + 1 ? [] : new e2()), !(i3.length < n3 + 1)); o3++)
        t4(r3[o3], n3 + 1, i3);
    }, "t"))(r2, 0, t3), r2;
  }
  __name(s2, "s");
  var c2 = /* @__PURE__ */ __name(function() {
    var t3 = this;
    function c3(t4, e2) {
      for (var r2 = 1 << e2 - 1 >>> 0; t4 & r2; )
        r2 >>>= 1;
      return r2 ? (t4 & r2 - 1) + r2 : t4;
    }
    __name(c3, "c");
    function u3(t4, r2, n3, i3, a3) {
      e(!(i3 % n3));
      do {
        t4[r2 + (i3 -= n3)] = a3;
      } while (0 < i3);
    }
    __name(u3, "u");
    function h4(t4, r2, n3, i3, o3) {
      if (e(2328 >= o3), 512 >= o3)
        var s3 = a2(512);
      else if (null == (s3 = a2(o3)))
        return 0;
      return function(t5, r3, n4, i4, o4, s4) {
        var h5, f4, d4 = r3, p4 = 1 << n4, g4 = a2(16), m4 = a2(16);
        for (e(0 != o4), e(null != i4), e(null != t5), e(0 < n4), f4 = 0; f4 < o4; ++f4) {
          if (15 < i4[f4])
            return 0;
          ++g4[i4[f4]];
        }
        if (g4[0] == o4)
          return 0;
        for (m4[1] = 0, h5 = 1; 15 > h5; ++h5) {
          if (g4[h5] > 1 << h5)
            return 0;
          m4[h5 + 1] = m4[h5] + g4[h5];
        }
        for (f4 = 0; f4 < o4; ++f4)
          h5 = i4[f4], 0 < i4[f4] && (s4[m4[h5]++] = f4);
        if (1 == m4[15])
          return (i4 = new l3()).g = 0, i4.value = s4[0], u3(t5, d4, 1, p4, i4), p4;
        var v4, b4 = -1, y4 = p4 - 1, w4 = 0, N4 = 1, L4 = 1, A4 = 1 << n4;
        for (f4 = 0, h5 = 1, o4 = 2; h5 <= n4; ++h5, o4 <<= 1) {
          if (N4 += L4 <<= 1, 0 > (L4 -= g4[h5]))
            return 0;
          for (; 0 < g4[h5]; --g4[h5])
            (i4 = new l3()).g = h5, i4.value = s4[f4++], u3(t5, d4 + w4, o4, A4, i4), w4 = c3(w4, h5);
        }
        for (h5 = n4 + 1, o4 = 2; 15 >= h5; ++h5, o4 <<= 1) {
          if (N4 += L4 <<= 1, 0 > (L4 -= g4[h5]))
            return 0;
          for (; 0 < g4[h5]; --g4[h5]) {
            if (i4 = new l3(), (w4 & y4) != b4) {
              for (d4 += A4, v4 = 1 << (b4 = h5) - n4; 15 > b4 && !(0 >= (v4 -= g4[b4])); )
                ++b4, v4 <<= 1;
              p4 += A4 = 1 << (v4 = b4 - n4), t5[r3 + (b4 = w4 & y4)].g = v4 + n4, t5[r3 + b4].value = d4 - r3 - b4;
            }
            i4.g = h5 - n4, i4.value = s4[f4++], u3(t5, d4 + (w4 >> n4), o4, A4, i4), w4 = c3(w4, h5);
          }
        }
        return N4 != 2 * m4[15] - 1 ? 0 : p4;
      }(t4, r2, n3, i3, o3, s3);
    }
    __name(h4, "h");
    function l3() {
      this.value = this.g = 0;
    }
    __name(l3, "l");
    function f3() {
      this.value = this.g = 0;
    }
    __name(f3, "f");
    function d3() {
      this.G = o2(5, l3), this.H = a2(5), this.jc = this.Qb = this.qb = this.nd = 0, this.pd = o2(Dr, f3);
    }
    __name(d3, "d");
    function p3(t4, r2, n3, i3) {
      e(null != t4), e(null != r2), e(2147483648 > i3), t4.Ca = 254, t4.I = 0, t4.b = -8, t4.Ka = 0, t4.oa = r2, t4.pa = n3, t4.Jd = r2, t4.Yc = n3 + i3, t4.Zc = 4 <= i3 ? n3 + i3 - 4 + 1 : n3, _2(t4);
    }
    __name(p3, "p");
    function g3(t4, e2) {
      for (var r2 = 0; 0 < e2--; )
        r2 |= k2(t4, 128) << e2;
      return r2;
    }
    __name(g3, "g");
    function m3(t4, e2) {
      var r2 = g3(t4, e2);
      return P2(t4) ? -r2 : r2;
    }
    __name(m3, "m");
    function v3(t4, r2, n3, i3) {
      var a3, o3 = 0;
      for (e(null != t4), e(null != r2), e(4294967288 > i3), t4.Sb = i3, t4.Ra = 0, t4.u = 0, t4.h = 0, 4 < i3 && (i3 = 4), a3 = 0; a3 < i3; ++a3)
        o3 += r2[n3 + a3] << 8 * a3;
      t4.Ra = o3, t4.bb = i3, t4.oa = r2, t4.pa = n3;
    }
    __name(v3, "v");
    function b3(t4) {
      for (; 8 <= t4.u && t4.bb < t4.Sb; )
        t4.Ra >>>= 8, t4.Ra += t4.oa[t4.pa + t4.bb] << Ur - 8 >>> 0, ++t4.bb, t4.u -= 8;
      A3(t4) && (t4.h = 1, t4.u = 0);
    }
    __name(b3, "b");
    function y3(t4, r2) {
      if (e(0 <= r2), !t4.h && r2 <= Tr) {
        var n3 = L3(t4) & Rr[r2];
        return t4.u += r2, b3(t4), n3;
      }
      return t4.h = 1, t4.u = 0;
    }
    __name(y3, "y");
    function w3() {
      this.b = this.Ca = this.I = 0, this.oa = [], this.pa = 0, this.Jd = [], this.Yc = 0, this.Zc = [], this.Ka = 0;
    }
    __name(w3, "w");
    function N3() {
      this.Ra = 0, this.oa = [], this.h = this.u = this.bb = this.Sb = this.pa = 0;
    }
    __name(N3, "N");
    function L3(t4) {
      return t4.Ra >>> (t4.u & Ur - 1) >>> 0;
    }
    __name(L3, "L");
    function A3(t4) {
      return e(t4.bb <= t4.Sb), t4.h || t4.bb == t4.Sb && t4.u > Ur;
    }
    __name(A3, "A");
    function x2(t4, e2) {
      t4.u = e2, t4.h = A3(t4);
    }
    __name(x2, "x");
    function S2(t4) {
      t4.u >= zr && (e(t4.u >= zr), b3(t4));
    }
    __name(S2, "S");
    function _2(t4) {
      e(null != t4 && null != t4.oa), t4.pa < t4.Zc ? (t4.I = (t4.oa[t4.pa++] | t4.I << 8) >>> 0, t4.b += 8) : (e(null != t4 && null != t4.oa), t4.pa < t4.Yc ? (t4.b += 8, t4.I = t4.oa[t4.pa++] | t4.I << 8) : t4.Ka ? t4.b = 0 : (t4.I <<= 8, t4.b += 8, t4.Ka = 1));
    }
    __name(_2, "_");
    function P2(t4) {
      return g3(t4, 1);
    }
    __name(P2, "P");
    function k2(t4, e2) {
      var r2 = t4.Ca;
      0 > t4.b && _2(t4);
      var n3 = t4.b, i3 = r2 * e2 >>> 8, a3 = (t4.I >>> n3 > i3) + 0;
      for (a3 ? (r2 -= i3, t4.I -= i3 + 1 << n3 >>> 0) : r2 = i3 + 1, n3 = r2, i3 = 0; 256 <= n3; )
        i3 += 8, n3 >>= 8;
      return n3 = 7 ^ i3 + Hr[n3], t4.b -= n3, t4.Ca = (r2 << n3) - 1, a3;
    }
    __name(k2, "k");
    function I2(t4, e2, r2) {
      t4[e2 + 0] = r2 >> 24 & 255, t4[e2 + 1] = r2 >> 16 & 255, t4[e2 + 2] = r2 >> 8 & 255, t4[e2 + 3] = r2 >> 0 & 255;
    }
    __name(I2, "I");
    function F2(t4, e2) {
      return t4[e2 + 0] << 0 | t4[e2 + 1] << 8;
    }
    __name(F2, "F");
    function C2(t4, e2) {
      return F2(t4, e2) | t4[e2 + 2] << 16;
    }
    __name(C2, "C");
    function j2(t4, e2) {
      return F2(t4, e2) | F2(t4, e2 + 2) << 16;
    }
    __name(j2, "j");
    function O2(t4, r2) {
      var n3 = 1 << r2;
      return e(null != t4), e(0 < r2), t4.X = a2(n3), null == t4.X ? 0 : (t4.Mb = 32 - r2, t4.Xa = r2, 1);
    }
    __name(O2, "O");
    function B2(t4, r2) {
      e(null != t4), e(null != r2), e(t4.Xa == r2.Xa), n2(r2.X, 0, t4.X, 0, 1 << r2.Xa);
    }
    __name(B2, "B");
    function M2() {
      this.X = [], this.Xa = this.Mb = 0;
    }
    __name(M2, "M");
    function E2(t4, r2, n3, i3) {
      e(null != n3), e(null != i3);
      var a3 = n3[0], o3 = i3[0];
      return 0 == a3 && (a3 = (t4 * o3 + r2 / 2) / r2), 0 == o3 && (o3 = (r2 * a3 + t4 / 2) / t4), 0 >= a3 || 0 >= o3 ? 0 : (n3[0] = a3, i3[0] = o3, 1);
    }
    __name(E2, "E");
    function q2(t4, e2) {
      return t4 + (1 << e2) - 1 >>> e2;
    }
    __name(q2, "q");
    function D2(t4, e2) {
      return ((4278255360 & t4) + (4278255360 & e2) >>> 0 & 4278255360) + ((16711935 & t4) + (16711935 & e2) >>> 0 & 16711935) >>> 0;
    }
    __name(D2, "D");
    function R2(e2, r2) {
      t3[r2] = function(r3, n3, i3, a3, o3, s3, c4) {
        var u4;
        for (u4 = 0; u4 < o3; ++u4) {
          var h5 = t3[e2](s3[c4 + u4 - 1], i3, a3 + u4);
          s3[c4 + u4] = D2(r3[n3 + u4], h5);
        }
      };
    }
    __name(R2, "R");
    function T2() {
      this.ud = this.hd = this.jd = 0;
    }
    __name(T2, "T");
    function U2(t4, e2) {
      return ((4278124286 & (t4 ^ e2)) >>> 1) + (t4 & e2) >>> 0;
    }
    __name(U2, "U");
    function z2(t4) {
      return 0 <= t4 && 256 > t4 ? t4 : 0 > t4 ? 0 : 255 < t4 ? 255 : void 0;
    }
    __name(z2, "z");
    function H2(t4, e2) {
      return z2(t4 + (t4 - e2 + 0.5 >> 1));
    }
    __name(H2, "H");
    function W2(t4, e2, r2) {
      return Math.abs(e2 - r2) - Math.abs(t4 - r2);
    }
    __name(W2, "W");
    function V2(t4, e2, r2, n3, i3, a3, o3) {
      for (n3 = a3[o3 - 1], r2 = 0; r2 < i3; ++r2)
        a3[o3 + r2] = n3 = D2(t4[e2 + r2], n3);
    }
    __name(V2, "V");
    function G2(t4, e2, r2, n3, i3) {
      var a3;
      for (a3 = 0; a3 < r2; ++a3) {
        var o3 = t4[e2 + a3], s3 = o3 >> 8 & 255, c4 = 16711935 & (c4 = (c4 = 16711935 & o3) + ((s3 << 16) + s3));
        n3[i3 + a3] = (4278255360 & o3) + c4 >>> 0;
      }
    }
    __name(G2, "G");
    function Y2(t4, e2) {
      e2.jd = t4 >> 0 & 255, e2.hd = t4 >> 8 & 255, e2.ud = t4 >> 16 & 255;
    }
    __name(Y2, "Y");
    function J2(t4, e2, r2, n3, i3, a3) {
      var o3;
      for (o3 = 0; o3 < n3; ++o3) {
        var s3 = e2[r2 + o3], c4 = s3 >>> 8, u4 = s3, h5 = 255 & (h5 = (h5 = s3 >>> 16) + ((t4.jd << 24 >> 24) * (c4 << 24 >> 24) >>> 5));
        u4 = 255 & (u4 = (u4 = u4 + ((t4.hd << 24 >> 24) * (c4 << 24 >> 24) >>> 5)) + ((t4.ud << 24 >> 24) * (h5 << 24 >> 24) >>> 5));
        i3[a3 + o3] = (4278255360 & s3) + (h5 << 16) + u4;
      }
    }
    __name(J2, "J");
    function X2(e2, r2, n3, i3, a3) {
      t3[r2] = function(t4, e3, r3, n4, o3, s3, c4, u4, h5) {
        for (n4 = c4; n4 < u4; ++n4)
          for (c4 = 0; c4 < h5; ++c4)
            o3[s3++] = a3(r3[i3(t4[e3++])]);
      }, t3[e2] = function(e3, r3, o3, s3, c4, u4, h5) {
        var l4 = 8 >> e3.b, f4 = e3.Ea, d4 = e3.K[0], p4 = e3.w;
        if (8 > l4)
          for (e3 = (1 << e3.b) - 1, p4 = (1 << l4) - 1; r3 < o3; ++r3) {
            var g4, m4 = 0;
            for (g4 = 0; g4 < f4; ++g4)
              g4 & e3 || (m4 = i3(s3[c4++])), u4[h5++] = a3(d4[m4 & p4]), m4 >>= l4;
          }
        else
          t3["VP8LMapColor" + n3](s3, c4, d4, p4, u4, h5, r3, o3, f4);
      };
    }
    __name(X2, "X");
    function K2(t4, e2, r2, n3, i3) {
      for (r2 = e2 + r2; e2 < r2; ) {
        var a3 = t4[e2++];
        n3[i3++] = a3 >> 16 & 255, n3[i3++] = a3 >> 8 & 255, n3[i3++] = a3 >> 0 & 255;
      }
    }
    __name(K2, "K");
    function Z2(t4, e2, r2, n3, i3) {
      for (r2 = e2 + r2; e2 < r2; ) {
        var a3 = t4[e2++];
        n3[i3++] = a3 >> 16 & 255, n3[i3++] = a3 >> 8 & 255, n3[i3++] = a3 >> 0 & 255, n3[i3++] = a3 >> 24 & 255;
      }
    }
    __name(Z2, "Z");
    function $2(t4, e2, r2, n3, i3) {
      for (r2 = e2 + r2; e2 < r2; ) {
        var a3 = (o3 = t4[e2++]) >> 16 & 240 | o3 >> 12 & 15, o3 = o3 >> 0 & 240 | o3 >> 28 & 15;
        n3[i3++] = a3, n3[i3++] = o3;
      }
    }
    __name($2, "$");
    function Q2(t4, e2, r2, n3, i3) {
      for (r2 = e2 + r2; e2 < r2; ) {
        var a3 = (o3 = t4[e2++]) >> 16 & 248 | o3 >> 13 & 7, o3 = o3 >> 5 & 224 | o3 >> 3 & 31;
        n3[i3++] = a3, n3[i3++] = o3;
      }
    }
    __name(Q2, "Q");
    function tt2(t4, e2, r2, n3, i3) {
      for (r2 = e2 + r2; e2 < r2; ) {
        var a3 = t4[e2++];
        n3[i3++] = a3 >> 0 & 255, n3[i3++] = a3 >> 8 & 255, n3[i3++] = a3 >> 16 & 255;
      }
    }
    __name(tt2, "tt");
    function et2(t4, e2, r2, i3, a3, o3) {
      if (0 == o3)
        for (r2 = e2 + r2; e2 < r2; )
          I2(i3, ((o3 = t4[e2++])[0] >> 24 | o3[1] >> 8 & 65280 | o3[2] << 8 & 16711680 | o3[3] << 24) >>> 0), a3 += 32;
      else
        n2(i3, a3, t4, e2, r2);
    }
    __name(et2, "et");
    function rt2(e2, r2) {
      t3[r2][0] = t3[e2 + "0"], t3[r2][1] = t3[e2 + "1"], t3[r2][2] = t3[e2 + "2"], t3[r2][3] = t3[e2 + "3"], t3[r2][4] = t3[e2 + "4"], t3[r2][5] = t3[e2 + "5"], t3[r2][6] = t3[e2 + "6"], t3[r2][7] = t3[e2 + "7"], t3[r2][8] = t3[e2 + "8"], t3[r2][9] = t3[e2 + "9"], t3[r2][10] = t3[e2 + "10"], t3[r2][11] = t3[e2 + "11"], t3[r2][12] = t3[e2 + "12"], t3[r2][13] = t3[e2 + "13"], t3[r2][14] = t3[e2 + "0"], t3[r2][15] = t3[e2 + "0"];
    }
    __name(rt2, "rt");
    function nt2(t4) {
      return t4 == Hn || t4 == Wn || t4 == Vn || t4 == Gn;
    }
    __name(nt2, "nt");
    function it2() {
      this.eb = [], this.size = this.A = this.fb = 0;
    }
    __name(it2, "it");
    function at2() {
      this.y = [], this.f = [], this.ea = [], this.F = [], this.Tc = this.Ed = this.Cd = this.Fd = this.lb = this.Db = this.Ab = this.fa = this.J = this.W = this.N = this.O = 0;
    }
    __name(at2, "at");
    function ot2() {
      this.Rd = this.height = this.width = this.S = 0, this.f = {}, this.f.RGBA = new it2(), this.f.kb = new at2(), this.sd = null;
    }
    __name(ot2, "ot");
    function st2() {
      this.width = [0], this.height = [0], this.Pd = [0], this.Qd = [0], this.format = [0];
    }
    __name(st2, "st");
    function ct2() {
      this.Id = this.fd = this.Md = this.hb = this.ib = this.da = this.bd = this.cd = this.j = this.v = this.Da = this.Sd = this.ob = 0;
    }
    __name(ct2, "ct");
    function ut2(t4) {
      return alert("todo:WebPSamplerProcessPlane"), t4.T;
    }
    __name(ut2, "ut");
    function ht2(t4, e2) {
      var r2 = t4.T, i3 = e2.ba.f.RGBA, a3 = i3.eb, o3 = i3.fb + t4.ka * i3.A, s3 = vi[e2.ba.S], c4 = t4.y, u4 = t4.O, h5 = t4.f, l4 = t4.N, f4 = t4.ea, d4 = t4.W, p4 = e2.cc, g4 = e2.dc, m4 = e2.Mc, v4 = e2.Nc, b4 = t4.ka, y4 = t4.ka + t4.T, w4 = t4.U, N4 = w4 + 1 >> 1;
      for (0 == b4 ? s3(c4, u4, null, null, h5, l4, f4, d4, h5, l4, f4, d4, a3, o3, null, null, w4) : (s3(e2.ec, e2.fc, c4, u4, p4, g4, m4, v4, h5, l4, f4, d4, a3, o3 - i3.A, a3, o3, w4), ++r2); b4 + 2 < y4; b4 += 2)
        p4 = h5, g4 = l4, m4 = f4, v4 = d4, l4 += t4.Rc, d4 += t4.Rc, o3 += 2 * i3.A, s3(c4, (u4 += 2 * t4.fa) - t4.fa, c4, u4, p4, g4, m4, v4, h5, l4, f4, d4, a3, o3 - i3.A, a3, o3, w4);
      return u4 += t4.fa, t4.j + y4 < t4.o ? (n2(e2.ec, e2.fc, c4, u4, w4), n2(e2.cc, e2.dc, h5, l4, N4), n2(e2.Mc, e2.Nc, f4, d4, N4), r2--) : 1 & y4 || s3(c4, u4, null, null, h5, l4, f4, d4, h5, l4, f4, d4, a3, o3 + i3.A, null, null, w4), r2;
    }
    __name(ht2, "ht");
    function lt2(t4, r2, n3) {
      var i3 = t4.F, a3 = [t4.J];
      if (null != i3) {
        var o3 = t4.U, s3 = r2.ba.S, c4 = s3 == Tn || s3 == Vn;
        r2 = r2.ba.f.RGBA;
        var u4 = [0], h5 = t4.ka;
        u4[0] = t4.T, t4.Kb && (0 == h5 ? --u4[0] : (--h5, a3[0] -= t4.width), t4.j + t4.ka + t4.T == t4.o && (u4[0] = t4.o - t4.j - h5));
        var l4 = r2.eb;
        h5 = r2.fb + h5 * r2.A;
        t4 = Sn(i3, a3[0], t4.width, o3, u4, l4, h5 + (c4 ? 0 : 3), r2.A), e(n3 == u4), t4 && nt2(s3) && An(l4, h5, c4, o3, u4, r2.A);
      }
      return 0;
    }
    __name(lt2, "lt");
    function ft2(t4) {
      var e2 = t4.ma, r2 = e2.ba.S, n3 = 11 > r2, i3 = r2 == qn || r2 == Rn || r2 == Tn || r2 == Un || 12 == r2 || nt2(r2);
      if (e2.memory = null, e2.Ib = null, e2.Jb = null, e2.Nd = null, !Mr(e2.Oa, t4, i3 ? 11 : 12))
        return 0;
      if (i3 && nt2(r2) && br(), t4.da)
        alert("todo:use_scaling");
      else {
        if (n3) {
          if (e2.Ib = ut2, t4.Kb) {
            if (r2 = t4.U + 1 >> 1, e2.memory = a2(t4.U + 2 * r2), null == e2.memory)
              return 0;
            e2.ec = e2.memory, e2.fc = 0, e2.cc = e2.ec, e2.dc = e2.fc + t4.U, e2.Mc = e2.cc, e2.Nc = e2.dc + r2, e2.Ib = ht2, br();
          }
        } else
          alert("todo:EmitYUV");
        i3 && (e2.Jb = lt2, n3 && mr());
      }
      if (n3 && !Ci) {
        for (t4 = 0; 256 > t4; ++t4)
          ji[t4] = 89858 * (t4 - 128) + _i >> Si, Mi[t4] = -22014 * (t4 - 128) + _i, Bi[t4] = -45773 * (t4 - 128), Oi[t4] = 113618 * (t4 - 128) + _i >> Si;
        for (t4 = Pi; t4 < ki; ++t4)
          e2 = 76283 * (t4 - 16) + _i >> Si, Ei[t4 - Pi] = Vt2(e2, 255), qi[t4 - Pi] = Vt2(e2 + 8 >> 4, 15);
        Ci = 1;
      }
      return 1;
    }
    __name(ft2, "ft");
    function dt2(t4) {
      var r2 = t4.ma, n3 = t4.U, i3 = t4.T;
      return e(!(1 & t4.ka)), 0 >= n3 || 0 >= i3 ? 0 : (n3 = r2.Ib(t4, r2), null != r2.Jb && r2.Jb(t4, r2, n3), r2.Dc += n3, 1);
    }
    __name(dt2, "dt");
    function pt2(t4) {
      t4.ma.memory = null;
    }
    __name(pt2, "pt");
    function gt2(t4, e2, r2, n3) {
      return 47 != y3(t4, 8) ? 0 : (e2[0] = y3(t4, 14) + 1, r2[0] = y3(t4, 14) + 1, n3[0] = y3(t4, 1), 0 != y3(t4, 3) ? 0 : !t4.h);
    }
    __name(gt2, "gt");
    function mt2(t4, e2) {
      if (4 > t4)
        return t4 + 1;
      var r2 = t4 - 2 >> 1;
      return (2 + (1 & t4) << r2) + y3(e2, r2) + 1;
    }
    __name(mt2, "mt");
    function vt2(t4, e2) {
      return 120 < e2 ? e2 - 120 : 1 <= (r2 = ((r2 = $n[e2 - 1]) >> 4) * t4 + (8 - (15 & r2))) ? r2 : 1;
      var r2;
    }
    __name(vt2, "vt");
    function bt2(t4, e2, r2) {
      var n3 = L3(r2), i3 = t4[e2 += 255 & n3].g - 8;
      return 0 < i3 && (x2(r2, r2.u + 8), n3 = L3(r2), e2 += t4[e2].value, e2 += n3 & (1 << i3) - 1), x2(r2, r2.u + t4[e2].g), t4[e2].value;
    }
    __name(bt2, "bt");
    function yt2(t4, r2, n3) {
      return n3.g += t4.g, n3.value += t4.value << r2 >>> 0, e(8 >= n3.g), t4.g;
    }
    __name(yt2, "yt");
    function wt2(t4, r2, n3) {
      var i3 = t4.xc;
      return e((r2 = 0 == i3 ? 0 : t4.vc[t4.md * (n3 >> i3) + (r2 >> i3)]) < t4.Wb), t4.Ya[r2];
    }
    __name(wt2, "wt");
    function Nt2(t4, r2, i3, a3) {
      var o3 = t4.ab, s3 = t4.c * r2, c4 = t4.C;
      r2 = c4 + r2;
      var u4 = i3, h5 = a3;
      for (a3 = t4.Ta, i3 = t4.Ua; 0 < o3--; ) {
        var l4 = t4.gc[o3], f4 = c4, d4 = r2, p4 = u4, g4 = h5, m4 = (h5 = a3, u4 = i3, l4.Ea);
        switch (e(f4 < d4), e(d4 <= l4.nc), l4.hc) {
          case 2:
            Gr(p4, g4, (d4 - f4) * m4, h5, u4);
            break;
          case 0:
            var v4 = f4, b4 = d4, y4 = h5, w4 = u4, N4 = (_3 = l4).Ea;
            0 == v4 && (Wr(p4, g4, null, null, 1, y4, w4), V2(p4, g4 + 1, 0, 0, N4 - 1, y4, w4 + 1), g4 += N4, w4 += N4, ++v4);
            for (var L4 = 1 << _3.b, A4 = L4 - 1, x3 = q2(N4, _3.b), S3 = _3.K, _3 = _3.w + (v4 >> _3.b) * x3; v4 < b4; ) {
              var P3 = S3, k3 = _3, I3 = 1;
              for (Vr(p4, g4, y4, w4 - N4, 1, y4, w4); I3 < N4; ) {
                var F3 = (I3 & ~A4) + L4;
                F3 > N4 && (F3 = N4), (0, Zr[P3[k3++] >> 8 & 15])(p4, g4 + +I3, y4, w4 + I3 - N4, F3 - I3, y4, w4 + I3), I3 = F3;
              }
              g4 += N4, w4 += N4, ++v4 & A4 || (_3 += x3);
            }
            d4 != l4.nc && n2(h5, u4 - m4, h5, u4 + (d4 - f4 - 1) * m4, m4);
            break;
          case 1:
            for (m4 = p4, b4 = g4, N4 = (p4 = l4.Ea) - (w4 = p4 & ~(y4 = (g4 = 1 << l4.b) - 1)), v4 = q2(p4, l4.b), L4 = l4.K, l4 = l4.w + (f4 >> l4.b) * v4; f4 < d4; ) {
              for (A4 = L4, x3 = l4, S3 = new T2(), _3 = b4 + w4, P3 = b4 + p4; b4 < _3; )
                Y2(A4[x3++], S3), $r(S3, m4, b4, g4, h5, u4), b4 += g4, u4 += g4;
              b4 < P3 && (Y2(A4[x3++], S3), $r(S3, m4, b4, N4, h5, u4), b4 += N4, u4 += N4), ++f4 & y4 || (l4 += v4);
            }
            break;
          case 3:
            if (p4 == h5 && g4 == u4 && 0 < l4.b) {
              for (b4 = h5, p4 = m4 = u4 + (d4 - f4) * m4 - (w4 = (d4 - f4) * q2(l4.Ea, l4.b)), g4 = h5, y4 = u4, v4 = [], w4 = (N4 = w4) - 1; 0 <= w4; --w4)
                v4[w4] = g4[y4 + w4];
              for (w4 = N4 - 1; 0 <= w4; --w4)
                b4[p4 + w4] = v4[w4];
              Yr(l4, f4, d4, h5, m4, h5, u4);
            } else
              Yr(l4, f4, d4, p4, g4, h5, u4);
        }
        u4 = a3, h5 = i3;
      }
      h5 != i3 && n2(a3, i3, u4, h5, s3);
    }
    __name(Nt2, "Nt");
    function Lt2(t4, r2) {
      var n3 = t4.V, i3 = t4.Ba + t4.c * t4.C, a3 = r2 - t4.C;
      if (e(r2 <= t4.l.o), e(16 >= a3), 0 < a3) {
        var o3 = t4.l, s3 = t4.Ta, c4 = t4.Ua, u4 = o3.width;
        if (Nt2(t4, a3, n3, i3), a3 = c4 = [c4], e((n3 = t4.C) < (i3 = r2)), e(o3.v < o3.va), i3 > o3.o && (i3 = o3.o), n3 < o3.j) {
          var h5 = o3.j - n3;
          n3 = o3.j;
          a3[0] += h5 * u4;
        }
        if (n3 >= i3 ? n3 = 0 : (a3[0] += 4 * o3.v, o3.ka = n3 - o3.j, o3.U = o3.va - o3.v, o3.T = i3 - n3, n3 = 1), n3) {
          if (c4 = c4[0], 11 > (n3 = t4.ca).S) {
            var l4 = n3.f.RGBA, f4 = (i3 = n3.S, a3 = o3.U, o3 = o3.T, h5 = l4.eb, l4.A), d4 = o3;
            for (l4 = l4.fb + t4.Ma * l4.A; 0 < d4--; ) {
              var p4 = s3, g4 = c4, m4 = a3, v4 = h5, b4 = l4;
              switch (i3) {
                case En:
                  Qr(p4, g4, m4, v4, b4);
                  break;
                case qn:
                  tn(p4, g4, m4, v4, b4);
                  break;
                case Hn:
                  tn(p4, g4, m4, v4, b4), An(v4, b4, 0, m4, 1, 0);
                  break;
                case Dn:
                  nn(p4, g4, m4, v4, b4);
                  break;
                case Rn:
                  et2(p4, g4, m4, v4, b4, 1);
                  break;
                case Wn:
                  et2(p4, g4, m4, v4, b4, 1), An(v4, b4, 0, m4, 1, 0);
                  break;
                case Tn:
                  et2(p4, g4, m4, v4, b4, 0);
                  break;
                case Vn:
                  et2(p4, g4, m4, v4, b4, 0), An(v4, b4, 1, m4, 1, 0);
                  break;
                case Un:
                  en(p4, g4, m4, v4, b4);
                  break;
                case Gn:
                  en(p4, g4, m4, v4, b4), xn(v4, b4, m4, 1, 0);
                  break;
                case zn:
                  rn(p4, g4, m4, v4, b4);
                  break;
                default:
                  e(0);
              }
              c4 += u4, l4 += f4;
            }
            t4.Ma += o3;
          } else
            alert("todo:EmitRescaledRowsYUVA");
          e(t4.Ma <= n3.height);
        }
      }
      t4.C = r2, e(t4.C <= t4.i);
    }
    __name(Lt2, "Lt");
    function At2(t4) {
      var e2;
      if (0 < t4.ua)
        return 0;
      for (e2 = 0; e2 < t4.Wb; ++e2) {
        var r2 = t4.Ya[e2].G, n3 = t4.Ya[e2].H;
        if (0 < r2[1][n3[1] + 0].g || 0 < r2[2][n3[2] + 0].g || 0 < r2[3][n3[3] + 0].g)
          return 0;
      }
      return 1;
    }
    __name(At2, "At");
    function xt2(t4, r2, n3, i3, a3, o3) {
      if (0 != t4.Z) {
        var s3 = t4.qd, c4 = t4.rd;
        for (e(null != mi[t4.Z]); r2 < n3; ++r2)
          mi[t4.Z](s3, c4, i3, a3, i3, a3, o3), s3 = i3, c4 = a3, a3 += o3;
        t4.qd = s3, t4.rd = c4;
      }
    }
    __name(xt2, "xt");
    function St2(t4, r2) {
      var n3 = t4.l.ma, i3 = 0 == n3.Z || 1 == n3.Z ? t4.l.j : t4.C;
      i3 = t4.C < i3 ? i3 : t4.C;
      if (e(r2 <= t4.l.o), r2 > i3) {
        var a3 = t4.l.width, o3 = n3.ca, s3 = n3.tb + a3 * i3, c4 = t4.V, u4 = t4.Ba + t4.c * i3, h5 = t4.gc;
        e(1 == t4.ab), e(3 == h5[0].hc), Xr(h5[0], i3, r2, c4, u4, o3, s3), xt2(n3, i3, r2, o3, s3, a3);
      }
      t4.C = t4.Ma = r2;
    }
    __name(St2, "St");
    function _t2(t4, r2, n3, i3, a3, o3, s3) {
      var c4 = t4.$ / i3, u4 = t4.$ % i3, h5 = t4.m, l4 = t4.s, f4 = n3 + t4.$, d4 = f4;
      a3 = n3 + i3 * a3;
      var p4 = n3 + i3 * o3, g4 = 280 + l4.ua, m4 = t4.Pb ? c4 : 16777216, v4 = 0 < l4.ua ? l4.Wa : null, b4 = l4.wc, y4 = f4 < p4 ? wt2(l4, u4, c4) : null;
      e(t4.C < o3), e(p4 <= a3);
      var w4 = false;
      t:
        for (; ; ) {
          for (; w4 || f4 < p4; ) {
            var N4 = 0;
            if (c4 >= m4) {
              var _3 = f4 - n3;
              e((m4 = t4).Pb), m4.wd = m4.m, m4.xd = _3, 0 < m4.s.ua && B2(m4.s.Wa, m4.s.vb), m4 = c4 + ti;
            }
            if (u4 & b4 || (y4 = wt2(l4, u4, c4)), e(null != y4), y4.Qb && (r2[f4] = y4.qb, w4 = true), !w4)
              if (S2(h5), y4.jc) {
                N4 = h5, _3 = r2;
                var P3 = f4, k3 = y4.pd[L3(N4) & Dr - 1];
                e(y4.jc), 256 > k3.g ? (x2(N4, N4.u + k3.g), _3[P3] = k3.value, N4 = 0) : (x2(N4, N4.u + k3.g - 256), e(256 <= k3.value), N4 = k3.value), 0 == N4 && (w4 = true);
              } else
                N4 = bt2(y4.G[0], y4.H[0], h5);
            if (h5.h)
              break;
            if (w4 || 256 > N4) {
              if (!w4)
                if (y4.nd)
                  r2[f4] = (y4.qb | N4 << 8) >>> 0;
                else {
                  if (S2(h5), w4 = bt2(y4.G[1], y4.H[1], h5), S2(h5), _3 = bt2(y4.G[2], y4.H[2], h5), P3 = bt2(y4.G[3], y4.H[3], h5), h5.h)
                    break;
                  r2[f4] = (P3 << 24 | w4 << 16 | N4 << 8 | _3) >>> 0;
                }
              if (w4 = false, ++f4, ++u4 >= i3 && (u4 = 0, ++c4, null != s3 && c4 <= o3 && !(c4 % 16) && s3(t4, c4), null != v4))
                for (; d4 < f4; )
                  N4 = r2[d4++], v4.X[(506832829 * N4 & 4294967295) >>> v4.Mb] = N4;
            } else if (280 > N4) {
              if (N4 = mt2(N4 - 256, h5), _3 = bt2(y4.G[4], y4.H[4], h5), S2(h5), _3 = vt2(i3, _3 = mt2(_3, h5)), h5.h)
                break;
              if (f4 - n3 < _3 || a3 - f4 < N4)
                break t;
              for (P3 = 0; P3 < N4; ++P3)
                r2[f4 + P3] = r2[f4 + P3 - _3];
              for (f4 += N4, u4 += N4; u4 >= i3; )
                u4 -= i3, ++c4, null != s3 && c4 <= o3 && !(c4 % 16) && s3(t4, c4);
              if (e(f4 <= a3), u4 & b4 && (y4 = wt2(l4, u4, c4)), null != v4)
                for (; d4 < f4; )
                  N4 = r2[d4++], v4.X[(506832829 * N4 & 4294967295) >>> v4.Mb] = N4;
            } else {
              if (!(N4 < g4))
                break t;
              for (w4 = N4 - 280, e(null != v4); d4 < f4; )
                N4 = r2[d4++], v4.X[(506832829 * N4 & 4294967295) >>> v4.Mb] = N4;
              N4 = f4, e(!(w4 >>> (_3 = v4).Xa)), r2[N4] = _3.X[w4], w4 = true;
            }
            w4 || e(h5.h == A3(h5));
          }
          if (t4.Pb && h5.h && f4 < a3)
            e(t4.m.h), t4.a = 5, t4.m = t4.wd, t4.$ = t4.xd, 0 < t4.s.ua && B2(t4.s.vb, t4.s.Wa);
          else {
            if (h5.h)
              break t;
            null != s3 && s3(t4, c4 > o3 ? o3 : c4), t4.a = 0, t4.$ = f4 - n3;
          }
          return 1;
        }
      return t4.a = 3, 0;
    }
    __name(_t2, "_t");
    function Pt2(t4) {
      e(null != t4), t4.vc = null, t4.yc = null, t4.Ya = null;
      var r2 = t4.Wa;
      null != r2 && (r2.X = null), t4.vb = null, e(null != t4);
    }
    __name(Pt2, "Pt");
    function kt2() {
      var e2 = new or();
      return null == e2 ? null : (e2.a = 0, e2.xb = gi, rt2("Predictor", "VP8LPredictors"), rt2("Predictor", "VP8LPredictors_C"), rt2("PredictorAdd", "VP8LPredictorsAdd"), rt2("PredictorAdd", "VP8LPredictorsAdd_C"), Gr = G2, $r = J2, Qr = K2, tn = Z2, en = $2, rn = Q2, nn = tt2, t3.VP8LMapColor32b = Jr, t3.VP8LMapColor8b = Kr, e2);
    }
    __name(kt2, "kt");
    function It2(t4, r2, n3, s3, c4) {
      var u4 = 1, f4 = [t4], p4 = [r2], g4 = s3.m, m4 = s3.s, v4 = null, b4 = 0;
      t:
        for (; ; ) {
          if (n3)
            for (; u4 && y3(g4, 1); ) {
              var w4 = f4, N4 = p4, A4 = s3, _3 = 1, P3 = A4.m, k3 = A4.gc[A4.ab], I3 = y3(P3, 2);
              if (A4.Oc & 1 << I3)
                u4 = 0;
              else {
                switch (A4.Oc |= 1 << I3, k3.hc = I3, k3.Ea = w4[0], k3.nc = N4[0], k3.K = [null], ++A4.ab, e(4 >= A4.ab), I3) {
                  case 0:
                  case 1:
                    k3.b = y3(P3, 3) + 2, _3 = It2(q2(k3.Ea, k3.b), q2(k3.nc, k3.b), 0, A4, k3.K), k3.K = k3.K[0];
                    break;
                  case 3:
                    var F3, C3 = y3(P3, 8) + 1, j3 = 16 < C3 ? 0 : 4 < C3 ? 1 : 2 < C3 ? 2 : 3;
                    if (w4[0] = q2(k3.Ea, j3), k3.b = j3, F3 = _3 = It2(C3, 1, 0, A4, k3.K)) {
                      var B3, M3 = C3, E3 = k3, R3 = 1 << (8 >> E3.b), T3 = a2(R3);
                      if (null == T3)
                        F3 = 0;
                      else {
                        var U3 = E3.K[0], z3 = E3.w;
                        for (T3[0] = E3.K[0][0], B3 = 1; B3 < 1 * M3; ++B3)
                          T3[B3] = D2(U3[z3 + B3], T3[B3 - 1]);
                        for (; B3 < 4 * R3; ++B3)
                          T3[B3] = 0;
                        E3.K[0] = null, E3.K[0] = T3, F3 = 1;
                      }
                    }
                    _3 = F3;
                    break;
                  case 2:
                    break;
                  default:
                    e(0);
                }
                u4 = _3;
              }
            }
          if (f4 = f4[0], p4 = p4[0], u4 && y3(g4, 1) && !(u4 = 1 <= (b4 = y3(g4, 4)) && 11 >= b4)) {
            s3.a = 3;
            break t;
          }
          var H3;
          if (H3 = u4)
            e: {
              var W3, V3, G3, Y3 = s3, J3 = f4, X3 = p4, K3 = b4, Z3 = n3, $3 = Y3.m, Q3 = Y3.s, tt3 = [null], et3 = 1, rt3 = 0, nt3 = Qn[K3];
              r:
                for (; ; ) {
                  if (Z3 && y3($3, 1)) {
                    var it3 = y3($3, 3) + 2, at3 = q2(J3, it3), ot3 = q2(X3, it3), st3 = at3 * ot3;
                    if (!It2(at3, ot3, 0, Y3, tt3))
                      break r;
                    for (tt3 = tt3[0], Q3.xc = it3, W3 = 0; W3 < st3; ++W3) {
                      var ct3 = tt3[W3] >> 8 & 65535;
                      tt3[W3] = ct3, ct3 >= et3 && (et3 = ct3 + 1);
                    }
                  }
                  if ($3.h)
                    break r;
                  for (V3 = 0; 5 > V3; ++V3) {
                    var ut3 = Xn[V3];
                    !V3 && 0 < K3 && (ut3 += 1 << K3), rt3 < ut3 && (rt3 = ut3);
                  }
                  var ht3 = o2(et3 * nt3, l3), lt3 = et3, ft3 = o2(lt3, d3);
                  if (null == ft3)
                    var dt3 = null;
                  else
                    e(65536 >= lt3), dt3 = ft3;
                  var pt3 = a2(rt3);
                  if (null == dt3 || null == pt3 || null == ht3) {
                    Y3.a = 1;
                    break r;
                  }
                  var gt3 = ht3;
                  for (W3 = G3 = 0; W3 < et3; ++W3) {
                    var mt3 = dt3[W3], vt3 = mt3.G, bt3 = mt3.H, wt3 = 0, Nt3 = 1, Lt3 = 0;
                    for (V3 = 0; 5 > V3; ++V3) {
                      ut3 = Xn[V3], vt3[V3] = gt3, bt3[V3] = G3, !V3 && 0 < K3 && (ut3 += 1 << K3);
                      n: {
                        var At3, xt3 = ut3, St3 = Y3, kt3 = pt3, Ft3 = gt3, Ct3 = G3, jt3 = 0, Ot3 = St3.m, Bt3 = y3(Ot3, 1);
                        if (i2(kt3, 0, 0, xt3), Bt3) {
                          var Mt3 = y3(Ot3, 1) + 1, Et3 = y3(Ot3, 1), qt3 = y3(Ot3, 0 == Et3 ? 1 : 8);
                          kt3[qt3] = 1, 2 == Mt3 && (kt3[qt3 = y3(Ot3, 8)] = 1);
                          var Dt3 = 1;
                        } else {
                          var Rt3 = a2(19), Tt3 = y3(Ot3, 4) + 4;
                          if (19 < Tt3) {
                            St3.a = 3;
                            var Ut3 = 0;
                            break n;
                          }
                          for (At3 = 0; At3 < Tt3; ++At3)
                            Rt3[Zn[At3]] = y3(Ot3, 3);
                          var zt3 = void 0, Ht3 = void 0, Wt3 = St3, Vt3 = Rt3, Gt3 = xt3, Yt3 = kt3, Jt3 = 0, Xt3 = Wt3.m, Kt3 = 8, Zt3 = o2(128, l3);
                          i:
                            for (; h4(Zt3, 0, 7, Vt3, 19); ) {
                              if (y3(Xt3, 1)) {
                                var $t3 = 2 + 2 * y3(Xt3, 3);
                                if ((zt3 = 2 + y3(Xt3, $t3)) > Gt3)
                                  break i;
                              } else
                                zt3 = Gt3;
                              for (Ht3 = 0; Ht3 < Gt3 && zt3--; ) {
                                S2(Xt3);
                                var Qt3 = Zt3[0 + (127 & L3(Xt3))];
                                x2(Xt3, Xt3.u + Qt3.g);
                                var te3 = Qt3.value;
                                if (16 > te3)
                                  Yt3[Ht3++] = te3, 0 != te3 && (Kt3 = te3);
                                else {
                                  var ee3 = 16 == te3, re3 = te3 - 16, ne3 = Jn[re3], ie3 = y3(Xt3, Yn[re3]) + ne3;
                                  if (Ht3 + ie3 > Gt3)
                                    break i;
                                  for (var ae3 = ee3 ? Kt3 : 0; 0 < ie3--; )
                                    Yt3[Ht3++] = ae3;
                                }
                              }
                              Jt3 = 1;
                              break i;
                            }
                          Jt3 || (Wt3.a = 3), Dt3 = Jt3;
                        }
                        (Dt3 = Dt3 && !Ot3.h) && (jt3 = h4(Ft3, Ct3, 8, kt3, xt3)), Dt3 && 0 != jt3 ? Ut3 = jt3 : (St3.a = 3, Ut3 = 0);
                      }
                      if (0 == Ut3)
                        break r;
                      if (Nt3 && 1 == Kn[V3] && (Nt3 = 0 == gt3[G3].g), wt3 += gt3[G3].g, G3 += Ut3, 3 >= V3) {
                        var oe3, se3 = pt3[0];
                        for (oe3 = 1; oe3 < ut3; ++oe3)
                          pt3[oe3] > se3 && (se3 = pt3[oe3]);
                        Lt3 += se3;
                      }
                    }
                    if (mt3.nd = Nt3, mt3.Qb = 0, Nt3 && (mt3.qb = (vt3[3][bt3[3] + 0].value << 24 | vt3[1][bt3[1] + 0].value << 16 | vt3[2][bt3[2] + 0].value) >>> 0, 0 == wt3 && 256 > vt3[0][bt3[0] + 0].value && (mt3.Qb = 1, mt3.qb += vt3[0][bt3[0] + 0].value << 8)), mt3.jc = !mt3.Qb && 6 > Lt3, mt3.jc) {
                      var ce3, ue3 = mt3;
                      for (ce3 = 0; ce3 < Dr; ++ce3) {
                        var he3 = ce3, le3 = ue3.pd[he3], fe3 = ue3.G[0][ue3.H[0] + he3];
                        256 <= fe3.value ? (le3.g = fe3.g + 256, le3.value = fe3.value) : (le3.g = 0, le3.value = 0, he3 >>= yt2(fe3, 8, le3), he3 >>= yt2(ue3.G[1][ue3.H[1] + he3], 16, le3), he3 >>= yt2(ue3.G[2][ue3.H[2] + he3], 0, le3), yt2(ue3.G[3][ue3.H[3] + he3], 24, le3));
                      }
                    }
                  }
                  Q3.vc = tt3, Q3.Wb = et3, Q3.Ya = dt3, Q3.yc = ht3, H3 = 1;
                  break e;
                }
              H3 = 0;
            }
          if (!(u4 = H3)) {
            s3.a = 3;
            break t;
          }
          if (0 < b4) {
            if (m4.ua = 1 << b4, !O2(m4.Wa, b4)) {
              s3.a = 1, u4 = 0;
              break t;
            }
          } else
            m4.ua = 0;
          var de3 = s3, pe3 = f4, ge3 = p4, me3 = de3.s, ve3 = me3.xc;
          if (de3.c = pe3, de3.i = ge3, me3.md = q2(pe3, ve3), me3.wc = 0 == ve3 ? -1 : (1 << ve3) - 1, n3) {
            s3.xb = pi;
            break t;
          }
          if (null == (v4 = a2(f4 * p4))) {
            s3.a = 1, u4 = 0;
            break t;
          }
          u4 = (u4 = _t2(s3, v4, 0, f4, p4, p4, null)) && !g4.h;
          break t;
        }
      return u4 ? (null != c4 ? c4[0] = v4 : (e(null == v4), e(n3)), s3.$ = 0, n3 || Pt2(m4)) : Pt2(m4), u4;
    }
    __name(It2, "It");
    function Ft2(t4, r2) {
      var n3 = t4.c * t4.i, i3 = n3 + r2 + 16 * r2;
      return e(t4.c <= r2), t4.V = a2(i3), null == t4.V ? (t4.Ta = null, t4.Ua = 0, t4.a = 1, 0) : (t4.Ta = t4.V, t4.Ua = t4.Ba + n3 + r2, 1);
    }
    __name(Ft2, "Ft");
    function Ct2(t4, r2) {
      var n3 = t4.C, i3 = r2 - n3, a3 = t4.V, o3 = t4.Ba + t4.c * n3;
      for (e(r2 <= t4.l.o); 0 < i3; ) {
        var s3 = 16 < i3 ? 16 : i3, c4 = t4.l.ma, u4 = t4.l.width, h5 = u4 * s3, l4 = c4.ca, f4 = c4.tb + u4 * n3, d4 = t4.Ta, p4 = t4.Ua;
        Nt2(t4, s3, a3, o3), _n(d4, p4, l4, f4, h5), xt2(c4, n3, n3 + s3, l4, f4, u4), i3 -= s3, a3 += s3 * t4.c, n3 += s3;
      }
      e(n3 == r2), t4.C = t4.Ma = r2;
    }
    __name(Ct2, "Ct");
    function jt2() {
      this.ub = this.yd = this.td = this.Rb = 0;
    }
    __name(jt2, "jt");
    function Ot2() {
      this.Kd = this.Ld = this.Ud = this.Td = this.i = this.c = 0;
    }
    __name(Ot2, "Ot");
    function Bt2() {
      this.Fb = this.Bb = this.Cb = 0, this.Zb = a2(4), this.Lb = a2(4);
    }
    __name(Bt2, "Bt");
    function Mt2() {
      this.Yb = function() {
        var t4 = [];
        return (/* @__PURE__ */ __name(function t5(e2, r2, n3) {
          for (var i3 = n3[r2], a3 = 0; a3 < i3 && (e2.push(n3.length > r2 + 1 ? [] : 0), !(n3.length < r2 + 1)); a3++)
            t5(e2[a3], r2 + 1, n3);
        }, "t"))(t4, 0, [3, 11]), t4;
      }();
    }
    __name(Mt2, "Mt");
    function Et2() {
      this.jb = a2(3), this.Wc = s2([4, 8], Mt2), this.Xc = s2([4, 17], Mt2);
    }
    __name(Et2, "Et");
    function qt2() {
      this.Pc = this.wb = this.Tb = this.zd = 0, this.vd = new a2(4), this.od = new a2(4);
    }
    __name(qt2, "qt");
    function Dt2() {
      this.ld = this.La = this.dd = this.tc = 0;
    }
    __name(Dt2, "Dt");
    function Rt2() {
      this.Na = this.la = 0;
    }
    __name(Rt2, "Rt");
    function Tt2() {
      this.Sc = [0, 0], this.Eb = [0, 0], this.Qc = [0, 0], this.ia = this.lc = 0;
    }
    __name(Tt2, "Tt");
    function Ut2() {
      this.ad = a2(384), this.Za = 0, this.Ob = a2(16), this.$b = this.Ad = this.ia = this.Gc = this.Hc = this.Dd = 0;
    }
    __name(Ut2, "Ut");
    function zt2() {
      this.uc = this.M = this.Nb = 0, this.wa = Array(new Dt2()), this.Y = 0, this.ya = Array(new Ut2()), this.aa = 0, this.l = new Gt2();
    }
    __name(zt2, "zt");
    function Ht2() {
      this.y = a2(16), this.f = a2(8), this.ea = a2(8);
    }
    __name(Ht2, "Ht");
    function Wt2() {
      this.cb = this.a = 0, this.sc = "", this.m = new w3(), this.Od = new jt2(), this.Kc = new Ot2(), this.ed = new qt2(), this.Qa = new Bt2(), this.Ic = this.$c = this.Aa = 0, this.D = new zt2(), this.Xb = this.Va = this.Hb = this.zb = this.yb = this.Ub = this.za = 0, this.Jc = o2(8, w3), this.ia = 0, this.pb = o2(4, Tt2), this.Pa = new Et2(), this.Bd = this.kc = 0, this.Ac = [], this.Bc = 0, this.zc = [0, 0, 0, 0], this.Gd = Array(new Ht2()), this.Hd = 0, this.rb = Array(new Rt2()), this.sb = 0, this.wa = Array(new Dt2()), this.Y = 0, this.oc = [], this.pc = 0, this.sa = [], this.ta = 0, this.qa = [], this.ra = 0, this.Ha = [], this.B = this.R = this.Ia = 0, this.Ec = [], this.M = this.ja = this.Vb = this.Fc = 0, this.ya = Array(new Ut2()), this.L = this.aa = 0, this.gd = s2([4, 2], Dt2), this.ga = null, this.Fa = [], this.Cc = this.qc = this.P = 0, this.Gb = [], this.Uc = 0, this.mb = [], this.nb = 0, this.rc = [], this.Ga = this.Vc = 0;
    }
    __name(Wt2, "Wt");
    function Vt2(t4, e2) {
      return 0 > t4 ? 0 : t4 > e2 ? e2 : t4;
    }
    __name(Vt2, "Vt");
    function Gt2() {
      this.T = this.U = this.ka = this.height = this.width = 0, this.y = [], this.f = [], this.ea = [], this.Rc = this.fa = this.W = this.N = this.O = 0, this.ma = "void", this.put = "VP8IoPutHook", this.ac = "VP8IoSetupHook", this.bc = "VP8IoTeardownHook", this.ha = this.Kb = 0, this.data = [], this.hb = this.ib = this.da = this.o = this.j = this.va = this.v = this.Da = this.ob = this.w = 0, this.F = [], this.J = 0;
    }
    __name(Gt2, "Gt");
    function Yt2() {
      var t4 = new Wt2();
      return null != t4 && (t4.a = 0, t4.sc = "OK", t4.cb = 0, t4.Xb = 0, ni || (ni = Zt2)), t4;
    }
    __name(Yt2, "Yt");
    function Jt2(t4, e2, r2) {
      return 0 == t4.a && (t4.a = e2, t4.sc = r2, t4.cb = 0), 0;
    }
    __name(Jt2, "Jt");
    function Xt2(t4, e2, r2) {
      return 3 <= r2 && 157 == t4[e2 + 0] && 1 == t4[e2 + 1] && 42 == t4[e2 + 2];
    }
    __name(Xt2, "Xt");
    function Kt2(t4, r2) {
      if (null == t4)
        return 0;
      if (t4.a = 0, t4.sc = "OK", null == r2)
        return Jt2(t4, 2, "null VP8Io passed to VP8GetHeaders()");
      var n3 = r2.data, a3 = r2.w, o3 = r2.ha;
      if (4 > o3)
        return Jt2(t4, 7, "Truncated header.");
      var s3 = n3[a3 + 0] | n3[a3 + 1] << 8 | n3[a3 + 2] << 16, c4 = t4.Od;
      if (c4.Rb = !(1 & s3), c4.td = s3 >> 1 & 7, c4.yd = s3 >> 4 & 1, c4.ub = s3 >> 5, 3 < c4.td)
        return Jt2(t4, 3, "Incorrect keyframe parameters.");
      if (!c4.yd)
        return Jt2(t4, 4, "Frame not displayable.");
      a3 += 3, o3 -= 3;
      var u4 = t4.Kc;
      if (c4.Rb) {
        if (7 > o3)
          return Jt2(t4, 7, "cannot parse picture header");
        if (!Xt2(n3, a3, o3))
          return Jt2(t4, 3, "Bad code word");
        u4.c = 16383 & (n3[a3 + 4] << 8 | n3[a3 + 3]), u4.Td = n3[a3 + 4] >> 6, u4.i = 16383 & (n3[a3 + 6] << 8 | n3[a3 + 5]), u4.Ud = n3[a3 + 6] >> 6, a3 += 7, o3 -= 7, t4.za = u4.c + 15 >> 4, t4.Ub = u4.i + 15 >> 4, r2.width = u4.c, r2.height = u4.i, r2.Da = 0, r2.j = 0, r2.v = 0, r2.va = r2.width, r2.o = r2.height, r2.da = 0, r2.ib = r2.width, r2.hb = r2.height, r2.U = r2.width, r2.T = r2.height, i2((s3 = t4.Pa).jb, 0, 255, s3.jb.length), e(null != (s3 = t4.Qa)), s3.Cb = 0, s3.Bb = 0, s3.Fb = 1, i2(s3.Zb, 0, 0, s3.Zb.length), i2(s3.Lb, 0, 0, s3.Lb);
      }
      if (c4.ub > o3)
        return Jt2(t4, 7, "bad partition length");
      p3(s3 = t4.m, n3, a3, c4.ub), a3 += c4.ub, o3 -= c4.ub, c4.Rb && (u4.Ld = P2(s3), u4.Kd = P2(s3)), u4 = t4.Qa;
      var h5, l4 = t4.Pa;
      if (e(null != s3), e(null != u4), u4.Cb = P2(s3), u4.Cb) {
        if (u4.Bb = P2(s3), P2(s3)) {
          for (u4.Fb = P2(s3), h5 = 0; 4 > h5; ++h5)
            u4.Zb[h5] = P2(s3) ? m3(s3, 7) : 0;
          for (h5 = 0; 4 > h5; ++h5)
            u4.Lb[h5] = P2(s3) ? m3(s3, 6) : 0;
        }
        if (u4.Bb)
          for (h5 = 0; 3 > h5; ++h5)
            l4.jb[h5] = P2(s3) ? g3(s3, 8) : 255;
      } else
        u4.Bb = 0;
      if (s3.Ka)
        return Jt2(t4, 3, "cannot parse segment header");
      if ((u4 = t4.ed).zd = P2(s3), u4.Tb = g3(s3, 6), u4.wb = g3(s3, 3), u4.Pc = P2(s3), u4.Pc && P2(s3)) {
        for (l4 = 0; 4 > l4; ++l4)
          P2(s3) && (u4.vd[l4] = m3(s3, 6));
        for (l4 = 0; 4 > l4; ++l4)
          P2(s3) && (u4.od[l4] = m3(s3, 6));
      }
      if (t4.L = 0 == u4.Tb ? 0 : u4.zd ? 1 : 2, s3.Ka)
        return Jt2(t4, 3, "cannot parse filter header");
      var f4 = o3;
      if (o3 = h5 = a3, a3 = h5 + f4, u4 = f4, t4.Xb = (1 << g3(t4.m, 2)) - 1, f4 < 3 * (l4 = t4.Xb))
        n3 = 7;
      else {
        for (h5 += 3 * l4, u4 -= 3 * l4, f4 = 0; f4 < l4; ++f4) {
          var d4 = n3[o3 + 0] | n3[o3 + 1] << 8 | n3[o3 + 2] << 16;
          d4 > u4 && (d4 = u4), p3(t4.Jc[+f4], n3, h5, d4), h5 += d4, u4 -= d4, o3 += 3;
        }
        p3(t4.Jc[+l4], n3, h5, u4), n3 = h5 < a3 ? 0 : 5;
      }
      if (0 != n3)
        return Jt2(t4, n3, "cannot parse partitions");
      for (n3 = g3(h5 = t4.m, 7), o3 = P2(h5) ? m3(h5, 4) : 0, a3 = P2(h5) ? m3(h5, 4) : 0, u4 = P2(h5) ? m3(h5, 4) : 0, l4 = P2(h5) ? m3(h5, 4) : 0, h5 = P2(h5) ? m3(h5, 4) : 0, f4 = t4.Qa, d4 = 0; 4 > d4; ++d4) {
        if (f4.Cb) {
          var v4 = f4.Zb[d4];
          f4.Fb || (v4 += n3);
        } else {
          if (0 < d4) {
            t4.pb[d4] = t4.pb[0];
            continue;
          }
          v4 = n3;
        }
        var b4 = t4.pb[d4];
        b4.Sc[0] = ei[Vt2(v4 + o3, 127)], b4.Sc[1] = ri[Vt2(v4 + 0, 127)], b4.Eb[0] = 2 * ei[Vt2(v4 + a3, 127)], b4.Eb[1] = 101581 * ri[Vt2(v4 + u4, 127)] >> 16, 8 > b4.Eb[1] && (b4.Eb[1] = 8), b4.Qc[0] = ei[Vt2(v4 + l4, 117)], b4.Qc[1] = ri[Vt2(v4 + h5, 127)], b4.lc = v4 + h5;
      }
      if (!c4.Rb)
        return Jt2(t4, 4, "Not a key frame.");
      for (P2(s3), c4 = t4.Pa, n3 = 0; 4 > n3; ++n3) {
        for (o3 = 0; 8 > o3; ++o3)
          for (a3 = 0; 3 > a3; ++a3)
            for (u4 = 0; 11 > u4; ++u4)
              l4 = k2(s3, ui[n3][o3][a3][u4]) ? g3(s3, 8) : si[n3][o3][a3][u4], c4.Wc[n3][o3].Yb[a3][u4] = l4;
        for (o3 = 0; 17 > o3; ++o3)
          c4.Xc[n3][o3] = c4.Wc[n3][hi[o3]];
      }
      return t4.kc = P2(s3), t4.kc && (t4.Bd = g3(s3, 8)), t4.cb = 1;
    }
    __name(Kt2, "Kt");
    function Zt2(t4, e2, r2, n3, i3, a3, o3) {
      var s3 = e2[i3].Yb[r2];
      for (r2 = 0; 16 > i3; ++i3) {
        if (!k2(t4, s3[r2 + 0]))
          return i3;
        for (; !k2(t4, s3[r2 + 1]); )
          if (s3 = e2[++i3].Yb[0], r2 = 0, 16 == i3)
            return 16;
        var c4 = e2[i3 + 1].Yb;
        if (k2(t4, s3[r2 + 2])) {
          var u4 = t4, h5 = 0;
          if (k2(u4, (f4 = s3)[(l4 = r2) + 3]))
            if (k2(u4, f4[l4 + 6])) {
              for (s3 = 0, l4 = 2 * (h5 = k2(u4, f4[l4 + 8])) + (f4 = k2(u4, f4[l4 + 9 + h5])), h5 = 0, f4 = ii[l4]; f4[s3]; ++s3)
                h5 += h5 + k2(u4, f4[s3]);
              h5 += 3 + (8 << l4);
            } else
              k2(u4, f4[l4 + 7]) ? (h5 = 7 + 2 * k2(u4, 165), h5 += k2(u4, 145)) : h5 = 5 + k2(u4, 159);
          else
            h5 = k2(u4, f4[l4 + 4]) ? 3 + k2(u4, f4[l4 + 5]) : 2;
          s3 = c4[2];
        } else
          h5 = 1, s3 = c4[1];
        c4 = o3 + ai[i3], 0 > (u4 = t4).b && _2(u4);
        var l4, f4 = u4.b, d4 = (l4 = u4.Ca >> 1) - (u4.I >> f4) >> 31;
        --u4.b, u4.Ca += d4, u4.Ca |= 1, u4.I -= (l4 + 1 & d4) << f4, a3[c4] = ((h5 ^ d4) - d4) * n3[(0 < i3) + 0];
      }
      return 16;
    }
    __name(Zt2, "Zt");
    function $t2(t4) {
      var e2 = t4.rb[t4.sb - 1];
      e2.la = 0, e2.Na = 0, i2(t4.zc, 0, 0, t4.zc.length), t4.ja = 0;
    }
    __name($t2, "$t");
    function Qt2(t4, r2) {
      if (null == t4)
        return 0;
      if (null == r2)
        return Jt2(t4, 2, "NULL VP8Io parameter in VP8Decode().");
      if (!t4.cb && !Kt2(t4, r2))
        return 0;
      if (e(t4.cb), null == r2.ac || r2.ac(r2)) {
        r2.ob && (t4.L = 0);
        var s3 = Ri[t4.L];
        if (2 == t4.L ? (t4.yb = 0, t4.zb = 0) : (t4.yb = r2.v - s3 >> 4, t4.zb = r2.j - s3 >> 4, 0 > t4.yb && (t4.yb = 0), 0 > t4.zb && (t4.zb = 0)), t4.Va = r2.o + 15 + s3 >> 4, t4.Hb = r2.va + 15 + s3 >> 4, t4.Hb > t4.za && (t4.Hb = t4.za), t4.Va > t4.Ub && (t4.Va = t4.Ub), 0 < t4.L) {
          var c4 = t4.ed;
          for (s3 = 0; 4 > s3; ++s3) {
            var u4;
            if (t4.Qa.Cb) {
              var h5 = t4.Qa.Lb[s3];
              t4.Qa.Fb || (h5 += c4.Tb);
            } else
              h5 = c4.Tb;
            for (u4 = 0; 1 >= u4; ++u4) {
              var l4 = t4.gd[s3][u4], f4 = h5;
              if (c4.Pc && (f4 += c4.vd[0], u4 && (f4 += c4.od[0])), 0 < (f4 = 0 > f4 ? 0 : 63 < f4 ? 63 : f4)) {
                var d4 = f4;
                0 < c4.wb && ((d4 = 4 < c4.wb ? d4 >> 2 : d4 >> 1) > 9 - c4.wb && (d4 = 9 - c4.wb)), 1 > d4 && (d4 = 1), l4.dd = d4, l4.tc = 2 * f4 + d4, l4.ld = 40 <= f4 ? 2 : 15 <= f4 ? 1 : 0;
              } else
                l4.tc = 0;
              l4.La = u4;
            }
          }
        }
        s3 = 0;
      } else
        Jt2(t4, 6, "Frame setup failed"), s3 = t4.a;
      if (s3 = 0 == s3) {
        if (s3) {
          t4.$c = 0, 0 < t4.Aa || (t4.Ic = Ui);
          t: {
            s3 = t4.Ic;
            c4 = 4 * (d4 = t4.za);
            var p4 = 32 * d4, g4 = d4 + 1, m4 = 0 < t4.L ? d4 * (0 < t4.Aa ? 2 : 1) : 0, v4 = (2 == t4.Aa ? 2 : 1) * d4;
            if ((l4 = c4 + 832 + (u4 = 3 * (16 * s3 + Ri[t4.L]) / 2 * p4) + (h5 = null != t4.Fa && 0 < t4.Fa.length ? t4.Kc.c * t4.Kc.i : 0)) != l4)
              s3 = 0;
            else {
              if (l4 > t4.Vb) {
                if (t4.Vb = 0, t4.Ec = a2(l4), t4.Fc = 0, null == t4.Ec) {
                  s3 = Jt2(t4, 1, "no memory during frame initialization.");
                  break t;
                }
                t4.Vb = l4;
              }
              l4 = t4.Ec, f4 = t4.Fc, t4.Ac = l4, t4.Bc = f4, f4 += c4, t4.Gd = o2(p4, Ht2), t4.Hd = 0, t4.rb = o2(g4 + 1, Rt2), t4.sb = 1, t4.wa = m4 ? o2(m4, Dt2) : null, t4.Y = 0, t4.D.Nb = 0, t4.D.wa = t4.wa, t4.D.Y = t4.Y, 0 < t4.Aa && (t4.D.Y += d4), e(true), t4.oc = l4, t4.pc = f4, f4 += 832, t4.ya = o2(v4, Ut2), t4.aa = 0, t4.D.ya = t4.ya, t4.D.aa = t4.aa, 2 == t4.Aa && (t4.D.aa += d4), t4.R = 16 * d4, t4.B = 8 * d4, d4 = (p4 = Ri[t4.L]) * t4.R, p4 = p4 / 2 * t4.B, t4.sa = l4, t4.ta = f4 + d4, t4.qa = t4.sa, t4.ra = t4.ta + 16 * s3 * t4.R + p4, t4.Ha = t4.qa, t4.Ia = t4.ra + 8 * s3 * t4.B + p4, t4.$c = 0, f4 += u4, t4.mb = h5 ? l4 : null, t4.nb = h5 ? f4 : null, e(f4 + h5 <= t4.Fc + t4.Vb), $t2(t4), i2(t4.Ac, t4.Bc, 0, c4), s3 = 1;
            }
          }
          if (s3) {
            if (r2.ka = 0, r2.y = t4.sa, r2.O = t4.ta, r2.f = t4.qa, r2.N = t4.ra, r2.ea = t4.Ha, r2.Vd = t4.Ia, r2.fa = t4.R, r2.Rc = t4.B, r2.F = null, r2.J = 0, !Cn) {
              for (s3 = -255; 255 >= s3; ++s3)
                Pn[255 + s3] = 0 > s3 ? -s3 : s3;
              for (s3 = -1020; 1020 >= s3; ++s3)
                kn[1020 + s3] = -128 > s3 ? -128 : 127 < s3 ? 127 : s3;
              for (s3 = -112; 112 >= s3; ++s3)
                In[112 + s3] = -16 > s3 ? -16 : 15 < s3 ? 15 : s3;
              for (s3 = -255; 510 >= s3; ++s3)
                Fn[255 + s3] = 0 > s3 ? 0 : 255 < s3 ? 255 : s3;
              Cn = 1;
            }
            an = ue2, on = ae2, cn = oe2, un = se2, hn = ce2, sn = ie2, ln2 = Je, fn = Xe, dn = $e, pn = Qe, gn = Ke, mn = Ze, vn = tr, bn = er, yn = ze, wn = He, Nn = We, Ln = Ve, fi[0] = xe, fi[1] = le2, fi[2] = Le2, fi[3] = Ae, fi[4] = Se, fi[5] = Pe, fi[6] = _e, fi[7] = ke, fi[8] = Fe, fi[9] = Ie, li[0] = ve2, li[1] = de2, li[2] = pe2, li[3] = ge2, li[4] = be2, li[5] = ye2, li[6] = we2, di[0] = Be, di[1] = fe2, di[2] = Ce, di[3] = je, di[4] = Ee, di[5] = Me, di[6] = qe, s3 = 1;
          } else
            s3 = 0;
        }
        s3 && (s3 = function(t5, r3) {
          for (t5.M = 0; t5.M < t5.Va; ++t5.M) {
            var o3, s4 = t5.Jc[t5.M & t5.Xb], c5 = t5.m, u5 = t5;
            for (o3 = 0; o3 < u5.za; ++o3) {
              var h6 = c5, l5 = u5, f5 = l5.Ac, d5 = l5.Bc + 4 * o3, p5 = l5.zc, g5 = l5.ya[l5.aa + o3];
              if (l5.Qa.Bb ? g5.$b = k2(h6, l5.Pa.jb[0]) ? 2 + k2(h6, l5.Pa.jb[2]) : k2(h6, l5.Pa.jb[1]) : g5.$b = 0, l5.kc && (g5.Ad = k2(h6, l5.Bd)), g5.Za = !k2(h6, 145) + 0, g5.Za) {
                var m5 = g5.Ob, v5 = 0;
                for (l5 = 0; 4 > l5; ++l5) {
                  var b4, y4 = p5[0 + l5];
                  for (b4 = 0; 4 > b4; ++b4) {
                    y4 = ci[f5[d5 + b4]][y4];
                    for (var w4 = oi[k2(h6, y4[0])]; 0 < w4; )
                      w4 = oi[2 * w4 + k2(h6, y4[w4])];
                    y4 = -w4, f5[d5 + b4] = y4;
                  }
                  n2(m5, v5, f5, d5, 4), v5 += 4, p5[0 + l5] = y4;
                }
              } else
                y4 = k2(h6, 156) ? k2(h6, 128) ? 1 : 3 : k2(h6, 163) ? 2 : 0, g5.Ob[0] = y4, i2(f5, d5, y4, 4), i2(p5, 0, y4, 4);
              g5.Dd = k2(h6, 142) ? k2(h6, 114) ? k2(h6, 183) ? 1 : 3 : 2 : 0;
            }
            if (u5.m.Ka)
              return Jt2(t5, 7, "Premature end-of-partition0 encountered.");
            for (; t5.ja < t5.za; ++t5.ja) {
              if (u5 = s4, h6 = (c5 = t5).rb[c5.sb - 1], f5 = c5.rb[c5.sb + c5.ja], o3 = c5.ya[c5.aa + c5.ja], d5 = c5.kc ? o3.Ad : 0)
                h6.la = f5.la = 0, o3.Za || (h6.Na = f5.Na = 0), o3.Hc = 0, o3.Gc = 0, o3.ia = 0;
              else {
                var N4, L4;
                h6 = f5, f5 = u5, d5 = c5.Pa.Xc, p5 = c5.ya[c5.aa + c5.ja], g5 = c5.pb[p5.$b];
                if (l5 = p5.ad, m5 = 0, v5 = c5.rb[c5.sb - 1], y4 = b4 = 0, i2(l5, m5, 0, 384), p5.Za)
                  var A4 = 0, x3 = d5[3];
                else {
                  w4 = a2(16);
                  var S3 = h6.Na + v5.Na;
                  if (S3 = ni(f5, d5[1], S3, g5.Eb, 0, w4, 0), h6.Na = v5.Na = (0 < S3) + 0, 1 < S3)
                    an(w4, 0, l5, m5);
                  else {
                    var _3 = w4[0] + 3 >> 3;
                    for (w4 = 0; 256 > w4; w4 += 16)
                      l5[m5 + w4] = _3;
                  }
                  A4 = 1, x3 = d5[0];
                }
                var P3 = 15 & h6.la, I3 = 15 & v5.la;
                for (w4 = 0; 4 > w4; ++w4) {
                  var F3 = 1 & I3;
                  for (_3 = L4 = 0; 4 > _3; ++_3)
                    P3 = P3 >> 1 | (F3 = (S3 = ni(f5, x3, S3 = F3 + (1 & P3), g5.Sc, A4, l5, m5)) > A4) << 7, L4 = L4 << 2 | (3 < S3 ? 3 : 1 < S3 ? 2 : 0 != l5[m5 + 0]), m5 += 16;
                  P3 >>= 4, I3 = I3 >> 1 | F3 << 7, b4 = (b4 << 8 | L4) >>> 0;
                }
                for (x3 = P3, A4 = I3 >> 4, N4 = 0; 4 > N4; N4 += 2) {
                  for (L4 = 0, P3 = h6.la >> 4 + N4, I3 = v5.la >> 4 + N4, w4 = 0; 2 > w4; ++w4) {
                    for (F3 = 1 & I3, _3 = 0; 2 > _3; ++_3)
                      S3 = F3 + (1 & P3), P3 = P3 >> 1 | (F3 = 0 < (S3 = ni(f5, d5[2], S3, g5.Qc, 0, l5, m5))) << 3, L4 = L4 << 2 | (3 < S3 ? 3 : 1 < S3 ? 2 : 0 != l5[m5 + 0]), m5 += 16;
                    P3 >>= 2, I3 = I3 >> 1 | F3 << 5;
                  }
                  y4 |= L4 << 4 * N4, x3 |= P3 << 4 << N4, A4 |= (240 & I3) << N4;
                }
                h6.la = x3, v5.la = A4, p5.Hc = b4, p5.Gc = y4, p5.ia = 43690 & y4 ? 0 : g5.ia, d5 = !(b4 | y4);
              }
              if (0 < c5.L && (c5.wa[c5.Y + c5.ja] = c5.gd[o3.$b][o3.Za], c5.wa[c5.Y + c5.ja].La |= !d5), u5.Ka)
                return Jt2(t5, 7, "Premature end-of-file encountered.");
            }
            if ($t2(t5), c5 = r3, u5 = 1, o3 = (s4 = t5).D, h6 = 0 < s4.L && s4.M >= s4.zb && s4.M <= s4.Va, 0 == s4.Aa)
              t: {
                if (o3.M = s4.M, o3.uc = h6, Or(s4, o3), u5 = 1, o3 = (L4 = s4.D).Nb, h6 = (y4 = Ri[s4.L]) * s4.R, f5 = y4 / 2 * s4.B, w4 = 16 * o3 * s4.R, _3 = 8 * o3 * s4.B, d5 = s4.sa, p5 = s4.ta - h6 + w4, g5 = s4.qa, l5 = s4.ra - f5 + _3, m5 = s4.Ha, v5 = s4.Ia - f5 + _3, I3 = 0 == (P3 = L4.M), b4 = P3 >= s4.Va - 1, 2 == s4.Aa && Or(s4, L4), L4.uc)
                  for (F3 = (S3 = s4).D.M, e(S3.D.uc), L4 = S3.yb; L4 < S3.Hb; ++L4) {
                    A4 = L4, x3 = F3;
                    var C3 = (j3 = (U3 = S3).D).Nb;
                    N4 = U3.R;
                    var j3 = j3.wa[j3.Y + A4], O3 = U3.sa, B3 = U3.ta + 16 * C3 * N4 + 16 * A4, M3 = j3.dd, E3 = j3.tc;
                    if (0 != E3)
                      if (e(3 <= E3), 1 == U3.L)
                        0 < A4 && wn(O3, B3, N4, E3 + 4), j3.La && Ln(O3, B3, N4, E3), 0 < x3 && yn(O3, B3, N4, E3 + 4), j3.La && Nn(O3, B3, N4, E3);
                      else {
                        var q3 = U3.B, D3 = U3.qa, R3 = U3.ra + 8 * C3 * q3 + 8 * A4, T3 = U3.Ha, U3 = U3.Ia + 8 * C3 * q3 + 8 * A4;
                        C3 = j3.ld;
                        0 < A4 && (fn(O3, B3, N4, E3 + 4, M3, C3), pn(D3, R3, T3, U3, q3, E3 + 4, M3, C3)), j3.La && (mn(O3, B3, N4, E3, M3, C3), bn(D3, R3, T3, U3, q3, E3, M3, C3)), 0 < x3 && (ln2(O3, B3, N4, E3 + 4, M3, C3), dn(D3, R3, T3, U3, q3, E3 + 4, M3, C3)), j3.La && (gn(O3, B3, N4, E3, M3, C3), vn(D3, R3, T3, U3, q3, E3, M3, C3));
                      }
                  }
                if (s4.ia && alert("todo:DitherRow"), null != c5.put) {
                  if (L4 = 16 * P3, P3 = 16 * (P3 + 1), I3 ? (c5.y = s4.sa, c5.O = s4.ta + w4, c5.f = s4.qa, c5.N = s4.ra + _3, c5.ea = s4.Ha, c5.W = s4.Ia + _3) : (L4 -= y4, c5.y = d5, c5.O = p5, c5.f = g5, c5.N = l5, c5.ea = m5, c5.W = v5), b4 || (P3 -= y4), P3 > c5.o && (P3 = c5.o), c5.F = null, c5.J = null, null != s4.Fa && 0 < s4.Fa.length && L4 < P3 && (c5.J = lr(s4, c5, L4, P3 - L4), c5.F = s4.mb, null == c5.F && 0 == c5.F.length)) {
                    u5 = Jt2(s4, 3, "Could not decode alpha data.");
                    break t;
                  }
                  L4 < c5.j && (y4 = c5.j - L4, L4 = c5.j, e(!(1 & y4)), c5.O += s4.R * y4, c5.N += s4.B * (y4 >> 1), c5.W += s4.B * (y4 >> 1), null != c5.F && (c5.J += c5.width * y4)), L4 < P3 && (c5.O += c5.v, c5.N += c5.v >> 1, c5.W += c5.v >> 1, null != c5.F && (c5.J += c5.v), c5.ka = L4 - c5.j, c5.U = c5.va - c5.v, c5.T = P3 - L4, u5 = c5.put(c5));
                }
                o3 + 1 != s4.Ic || b4 || (n2(s4.sa, s4.ta - h6, d5, p5 + 16 * s4.R, h6), n2(s4.qa, s4.ra - f5, g5, l5 + 8 * s4.B, f5), n2(s4.Ha, s4.Ia - f5, m5, v5 + 8 * s4.B, f5));
              }
            if (!u5)
              return Jt2(t5, 6, "Output aborted.");
          }
          return 1;
        }(t4, r2)), null != r2.bc && r2.bc(r2), s3 &= 1;
      }
      return s3 ? (t4.cb = 0, s3) : 0;
    }
    __name(Qt2, "Qt");
    function te2(t4, e2, r2, n3, i3) {
      i3 = t4[e2 + r2 + 32 * n3] + (i3 >> 3), t4[e2 + r2 + 32 * n3] = -256 & i3 ? 0 > i3 ? 0 : 255 : i3;
    }
    __name(te2, "te");
    function ee2(t4, e2, r2, n3, i3, a3) {
      te2(t4, e2, 0, r2, n3 + i3), te2(t4, e2, 1, r2, n3 + a3), te2(t4, e2, 2, r2, n3 - a3), te2(t4, e2, 3, r2, n3 - i3);
    }
    __name(ee2, "ee");
    function re2(t4) {
      return (20091 * t4 >> 16) + t4;
    }
    __name(re2, "re");
    function ne2(t4, e2, r2, n3) {
      var i3, o3 = 0, s3 = a2(16);
      for (i3 = 0; 4 > i3; ++i3) {
        var c4 = t4[e2 + 0] + t4[e2 + 8], u4 = t4[e2 + 0] - t4[e2 + 8], h5 = (35468 * t4[e2 + 4] >> 16) - re2(t4[e2 + 12]), l4 = re2(t4[e2 + 4]) + (35468 * t4[e2 + 12] >> 16);
        s3[o3 + 0] = c4 + l4, s3[o3 + 1] = u4 + h5, s3[o3 + 2] = u4 - h5, s3[o3 + 3] = c4 - l4, o3 += 4, e2++;
      }
      for (i3 = o3 = 0; 4 > i3; ++i3)
        c4 = (t4 = s3[o3 + 0] + 4) + s3[o3 + 8], u4 = t4 - s3[o3 + 8], h5 = (35468 * s3[o3 + 4] >> 16) - re2(s3[o3 + 12]), te2(r2, n3, 0, 0, c4 + (l4 = re2(s3[o3 + 4]) + (35468 * s3[o3 + 12] >> 16))), te2(r2, n3, 1, 0, u4 + h5), te2(r2, n3, 2, 0, u4 - h5), te2(r2, n3, 3, 0, c4 - l4), o3++, n3 += 32;
    }
    __name(ne2, "ne");
    function ie2(t4, e2, r2, n3) {
      var i3 = t4[e2 + 0] + 4, a3 = 35468 * t4[e2 + 4] >> 16, o3 = re2(t4[e2 + 4]), s3 = 35468 * t4[e2 + 1] >> 16;
      ee2(r2, n3, 0, i3 + o3, t4 = re2(t4[e2 + 1]), s3), ee2(r2, n3, 1, i3 + a3, t4, s3), ee2(r2, n3, 2, i3 - a3, t4, s3), ee2(r2, n3, 3, i3 - o3, t4, s3);
    }
    __name(ie2, "ie");
    function ae2(t4, e2, r2, n3, i3) {
      ne2(t4, e2, r2, n3), i3 && ne2(t4, e2 + 16, r2, n3 + 4);
    }
    __name(ae2, "ae");
    function oe2(t4, e2, r2, n3) {
      on(t4, e2 + 0, r2, n3, 1), on(t4, e2 + 32, r2, n3 + 128, 1);
    }
    __name(oe2, "oe");
    function se2(t4, e2, r2, n3) {
      var i3;
      for (t4 = t4[e2 + 0] + 4, i3 = 0; 4 > i3; ++i3)
        for (e2 = 0; 4 > e2; ++e2)
          te2(r2, n3, e2, i3, t4);
    }
    __name(se2, "se");
    function ce2(t4, e2, r2, n3) {
      t4[e2 + 0] && un(t4, e2 + 0, r2, n3), t4[e2 + 16] && un(t4, e2 + 16, r2, n3 + 4), t4[e2 + 32] && un(t4, e2 + 32, r2, n3 + 128), t4[e2 + 48] && un(t4, e2 + 48, r2, n3 + 128 + 4);
    }
    __name(ce2, "ce");
    function ue2(t4, e2, r2, n3) {
      var i3, o3 = a2(16);
      for (i3 = 0; 4 > i3; ++i3) {
        var s3 = t4[e2 + 0 + i3] + t4[e2 + 12 + i3], c4 = t4[e2 + 4 + i3] + t4[e2 + 8 + i3], u4 = t4[e2 + 4 + i3] - t4[e2 + 8 + i3], h5 = t4[e2 + 0 + i3] - t4[e2 + 12 + i3];
        o3[0 + i3] = s3 + c4, o3[8 + i3] = s3 - c4, o3[4 + i3] = h5 + u4, o3[12 + i3] = h5 - u4;
      }
      for (i3 = 0; 4 > i3; ++i3)
        s3 = (t4 = o3[0 + 4 * i3] + 3) + o3[3 + 4 * i3], c4 = o3[1 + 4 * i3] + o3[2 + 4 * i3], u4 = o3[1 + 4 * i3] - o3[2 + 4 * i3], h5 = t4 - o3[3 + 4 * i3], r2[n3 + 0] = s3 + c4 >> 3, r2[n3 + 16] = h5 + u4 >> 3, r2[n3 + 32] = s3 - c4 >> 3, r2[n3 + 48] = h5 - u4 >> 3, n3 += 64;
    }
    __name(ue2, "ue");
    function he2(t4, e2, r2) {
      var n3, i3 = e2 - 32, a3 = Bn, o3 = 255 - t4[i3 - 1];
      for (n3 = 0; n3 < r2; ++n3) {
        var s3, c4 = a3, u4 = o3 + t4[e2 - 1];
        for (s3 = 0; s3 < r2; ++s3)
          t4[e2 + s3] = c4[u4 + t4[i3 + s3]];
        e2 += 32;
      }
    }
    __name(he2, "he");
    function le2(t4, e2) {
      he2(t4, e2, 4);
    }
    __name(le2, "le");
    function fe2(t4, e2) {
      he2(t4, e2, 8);
    }
    __name(fe2, "fe");
    function de2(t4, e2) {
      he2(t4, e2, 16);
    }
    __name(de2, "de");
    function pe2(t4, e2) {
      var r2;
      for (r2 = 0; 16 > r2; ++r2)
        n2(t4, e2 + 32 * r2, t4, e2 - 32, 16);
    }
    __name(pe2, "pe");
    function ge2(t4, e2) {
      var r2;
      for (r2 = 16; 0 < r2; --r2)
        i2(t4, e2, t4[e2 - 1], 16), e2 += 32;
    }
    __name(ge2, "ge");
    function me2(t4, e2, r2) {
      var n3;
      for (n3 = 0; 16 > n3; ++n3)
        i2(e2, r2 + 32 * n3, t4, 16);
    }
    __name(me2, "me");
    function ve2(t4, e2) {
      var r2, n3 = 16;
      for (r2 = 0; 16 > r2; ++r2)
        n3 += t4[e2 - 1 + 32 * r2] + t4[e2 + r2 - 32];
      me2(n3 >> 5, t4, e2);
    }
    __name(ve2, "ve");
    function be2(t4, e2) {
      var r2, n3 = 8;
      for (r2 = 0; 16 > r2; ++r2)
        n3 += t4[e2 - 1 + 32 * r2];
      me2(n3 >> 4, t4, e2);
    }
    __name(be2, "be");
    function ye2(t4, e2) {
      var r2, n3 = 8;
      for (r2 = 0; 16 > r2; ++r2)
        n3 += t4[e2 + r2 - 32];
      me2(n3 >> 4, t4, e2);
    }
    __name(ye2, "ye");
    function we2(t4, e2) {
      me2(128, t4, e2);
    }
    __name(we2, "we");
    function Ne2(t4, e2, r2) {
      return t4 + 2 * e2 + r2 + 2 >> 2;
    }
    __name(Ne2, "Ne");
    function Le2(t4, e2) {
      var r2, i3 = e2 - 32;
      i3 = new Uint8Array([Ne2(t4[i3 - 1], t4[i3 + 0], t4[i3 + 1]), Ne2(t4[i3 + 0], t4[i3 + 1], t4[i3 + 2]), Ne2(t4[i3 + 1], t4[i3 + 2], t4[i3 + 3]), Ne2(t4[i3 + 2], t4[i3 + 3], t4[i3 + 4])]);
      for (r2 = 0; 4 > r2; ++r2)
        n2(t4, e2 + 32 * r2, i3, 0, i3.length);
    }
    __name(Le2, "Le");
    function Ae(t4, e2) {
      var r2 = t4[e2 - 1], n3 = t4[e2 - 1 + 32], i3 = t4[e2 - 1 + 64], a3 = t4[e2 - 1 + 96];
      I2(t4, e2 + 0, 16843009 * Ne2(t4[e2 - 1 - 32], r2, n3)), I2(t4, e2 + 32, 16843009 * Ne2(r2, n3, i3)), I2(t4, e2 + 64, 16843009 * Ne2(n3, i3, a3)), I2(t4, e2 + 96, 16843009 * Ne2(i3, a3, a3));
    }
    __name(Ae, "Ae");
    function xe(t4, e2) {
      var r2, n3 = 4;
      for (r2 = 0; 4 > r2; ++r2)
        n3 += t4[e2 + r2 - 32] + t4[e2 - 1 + 32 * r2];
      for (n3 >>= 3, r2 = 0; 4 > r2; ++r2)
        i2(t4, e2 + 32 * r2, n3, 4);
    }
    __name(xe, "xe");
    function Se(t4, e2) {
      var r2 = t4[e2 - 1 + 0], n3 = t4[e2 - 1 + 32], i3 = t4[e2 - 1 + 64], a3 = t4[e2 - 1 - 32], o3 = t4[e2 + 0 - 32], s3 = t4[e2 + 1 - 32], c4 = t4[e2 + 2 - 32], u4 = t4[e2 + 3 - 32];
      t4[e2 + 0 + 96] = Ne2(n3, i3, t4[e2 - 1 + 96]), t4[e2 + 1 + 96] = t4[e2 + 0 + 64] = Ne2(r2, n3, i3), t4[e2 + 2 + 96] = t4[e2 + 1 + 64] = t4[e2 + 0 + 32] = Ne2(a3, r2, n3), t4[e2 + 3 + 96] = t4[e2 + 2 + 64] = t4[e2 + 1 + 32] = t4[e2 + 0 + 0] = Ne2(o3, a3, r2), t4[e2 + 3 + 64] = t4[e2 + 2 + 32] = t4[e2 + 1 + 0] = Ne2(s3, o3, a3), t4[e2 + 3 + 32] = t4[e2 + 2 + 0] = Ne2(c4, s3, o3), t4[e2 + 3 + 0] = Ne2(u4, c4, s3);
    }
    __name(Se, "Se");
    function _e(t4, e2) {
      var r2 = t4[e2 + 1 - 32], n3 = t4[e2 + 2 - 32], i3 = t4[e2 + 3 - 32], a3 = t4[e2 + 4 - 32], o3 = t4[e2 + 5 - 32], s3 = t4[e2 + 6 - 32], c4 = t4[e2 + 7 - 32];
      t4[e2 + 0 + 0] = Ne2(t4[e2 + 0 - 32], r2, n3), t4[e2 + 1 + 0] = t4[e2 + 0 + 32] = Ne2(r2, n3, i3), t4[e2 + 2 + 0] = t4[e2 + 1 + 32] = t4[e2 + 0 + 64] = Ne2(n3, i3, a3), t4[e2 + 3 + 0] = t4[e2 + 2 + 32] = t4[e2 + 1 + 64] = t4[e2 + 0 + 96] = Ne2(i3, a3, o3), t4[e2 + 3 + 32] = t4[e2 + 2 + 64] = t4[e2 + 1 + 96] = Ne2(a3, o3, s3), t4[e2 + 3 + 64] = t4[e2 + 2 + 96] = Ne2(o3, s3, c4), t4[e2 + 3 + 96] = Ne2(s3, c4, c4);
    }
    __name(_e, "_e");
    function Pe(t4, e2) {
      var r2 = t4[e2 - 1 + 0], n3 = t4[e2 - 1 + 32], i3 = t4[e2 - 1 + 64], a3 = t4[e2 - 1 - 32], o3 = t4[e2 + 0 - 32], s3 = t4[e2 + 1 - 32], c4 = t4[e2 + 2 - 32], u4 = t4[e2 + 3 - 32];
      t4[e2 + 0 + 0] = t4[e2 + 1 + 64] = a3 + o3 + 1 >> 1, t4[e2 + 1 + 0] = t4[e2 + 2 + 64] = o3 + s3 + 1 >> 1, t4[e2 + 2 + 0] = t4[e2 + 3 + 64] = s3 + c4 + 1 >> 1, t4[e2 + 3 + 0] = c4 + u4 + 1 >> 1, t4[e2 + 0 + 96] = Ne2(i3, n3, r2), t4[e2 + 0 + 64] = Ne2(n3, r2, a3), t4[e2 + 0 + 32] = t4[e2 + 1 + 96] = Ne2(r2, a3, o3), t4[e2 + 1 + 32] = t4[e2 + 2 + 96] = Ne2(a3, o3, s3), t4[e2 + 2 + 32] = t4[e2 + 3 + 96] = Ne2(o3, s3, c4), t4[e2 + 3 + 32] = Ne2(s3, c4, u4);
    }
    __name(Pe, "Pe");
    function ke(t4, e2) {
      var r2 = t4[e2 + 0 - 32], n3 = t4[e2 + 1 - 32], i3 = t4[e2 + 2 - 32], a3 = t4[e2 + 3 - 32], o3 = t4[e2 + 4 - 32], s3 = t4[e2 + 5 - 32], c4 = t4[e2 + 6 - 32], u4 = t4[e2 + 7 - 32];
      t4[e2 + 0 + 0] = r2 + n3 + 1 >> 1, t4[e2 + 1 + 0] = t4[e2 + 0 + 64] = n3 + i3 + 1 >> 1, t4[e2 + 2 + 0] = t4[e2 + 1 + 64] = i3 + a3 + 1 >> 1, t4[e2 + 3 + 0] = t4[e2 + 2 + 64] = a3 + o3 + 1 >> 1, t4[e2 + 0 + 32] = Ne2(r2, n3, i3), t4[e2 + 1 + 32] = t4[e2 + 0 + 96] = Ne2(n3, i3, a3), t4[e2 + 2 + 32] = t4[e2 + 1 + 96] = Ne2(i3, a3, o3), t4[e2 + 3 + 32] = t4[e2 + 2 + 96] = Ne2(a3, o3, s3), t4[e2 + 3 + 64] = Ne2(o3, s3, c4), t4[e2 + 3 + 96] = Ne2(s3, c4, u4);
    }
    __name(ke, "ke");
    function Ie(t4, e2) {
      var r2 = t4[e2 - 1 + 0], n3 = t4[e2 - 1 + 32], i3 = t4[e2 - 1 + 64], a3 = t4[e2 - 1 + 96];
      t4[e2 + 0 + 0] = r2 + n3 + 1 >> 1, t4[e2 + 2 + 0] = t4[e2 + 0 + 32] = n3 + i3 + 1 >> 1, t4[e2 + 2 + 32] = t4[e2 + 0 + 64] = i3 + a3 + 1 >> 1, t4[e2 + 1 + 0] = Ne2(r2, n3, i3), t4[e2 + 3 + 0] = t4[e2 + 1 + 32] = Ne2(n3, i3, a3), t4[e2 + 3 + 32] = t4[e2 + 1 + 64] = Ne2(i3, a3, a3), t4[e2 + 3 + 64] = t4[e2 + 2 + 64] = t4[e2 + 0 + 96] = t4[e2 + 1 + 96] = t4[e2 + 2 + 96] = t4[e2 + 3 + 96] = a3;
    }
    __name(Ie, "Ie");
    function Fe(t4, e2) {
      var r2 = t4[e2 - 1 + 0], n3 = t4[e2 - 1 + 32], i3 = t4[e2 - 1 + 64], a3 = t4[e2 - 1 + 96], o3 = t4[e2 - 1 - 32], s3 = t4[e2 + 0 - 32], c4 = t4[e2 + 1 - 32], u4 = t4[e2 + 2 - 32];
      t4[e2 + 0 + 0] = t4[e2 + 2 + 32] = r2 + o3 + 1 >> 1, t4[e2 + 0 + 32] = t4[e2 + 2 + 64] = n3 + r2 + 1 >> 1, t4[e2 + 0 + 64] = t4[e2 + 2 + 96] = i3 + n3 + 1 >> 1, t4[e2 + 0 + 96] = a3 + i3 + 1 >> 1, t4[e2 + 3 + 0] = Ne2(s3, c4, u4), t4[e2 + 2 + 0] = Ne2(o3, s3, c4), t4[e2 + 1 + 0] = t4[e2 + 3 + 32] = Ne2(r2, o3, s3), t4[e2 + 1 + 32] = t4[e2 + 3 + 64] = Ne2(n3, r2, o3), t4[e2 + 1 + 64] = t4[e2 + 3 + 96] = Ne2(i3, n3, r2), t4[e2 + 1 + 96] = Ne2(a3, i3, n3);
    }
    __name(Fe, "Fe");
    function Ce(t4, e2) {
      var r2;
      for (r2 = 0; 8 > r2; ++r2)
        n2(t4, e2 + 32 * r2, t4, e2 - 32, 8);
    }
    __name(Ce, "Ce");
    function je(t4, e2) {
      var r2;
      for (r2 = 0; 8 > r2; ++r2)
        i2(t4, e2, t4[e2 - 1], 8), e2 += 32;
    }
    __name(je, "je");
    function Oe(t4, e2, r2) {
      var n3;
      for (n3 = 0; 8 > n3; ++n3)
        i2(e2, r2 + 32 * n3, t4, 8);
    }
    __name(Oe, "Oe");
    function Be(t4, e2) {
      var r2, n3 = 8;
      for (r2 = 0; 8 > r2; ++r2)
        n3 += t4[e2 + r2 - 32] + t4[e2 - 1 + 32 * r2];
      Oe(n3 >> 4, t4, e2);
    }
    __name(Be, "Be");
    function Me(t4, e2) {
      var r2, n3 = 4;
      for (r2 = 0; 8 > r2; ++r2)
        n3 += t4[e2 + r2 - 32];
      Oe(n3 >> 3, t4, e2);
    }
    __name(Me, "Me");
    function Ee(t4, e2) {
      var r2, n3 = 4;
      for (r2 = 0; 8 > r2; ++r2)
        n3 += t4[e2 - 1 + 32 * r2];
      Oe(n3 >> 3, t4, e2);
    }
    __name(Ee, "Ee");
    function qe(t4, e2) {
      Oe(128, t4, e2);
    }
    __name(qe, "qe");
    function De(t4, e2, r2) {
      var n3 = t4[e2 - r2], i3 = t4[e2 + 0], a3 = 3 * (i3 - n3) + jn[1020 + t4[e2 - 2 * r2] - t4[e2 + r2]], o3 = On[112 + (a3 + 4 >> 3)];
      t4[e2 - r2] = Bn[255 + n3 + On[112 + (a3 + 3 >> 3)]], t4[e2 + 0] = Bn[255 + i3 - o3];
    }
    __name(De, "De");
    function Re(t4, e2, r2, n3) {
      var i3 = t4[e2 + 0], a3 = t4[e2 + r2];
      return Mn[255 + t4[e2 - 2 * r2] - t4[e2 - r2]] > n3 || Mn[255 + a3 - i3] > n3;
    }
    __name(Re, "Re");
    function Te(t4, e2, r2, n3) {
      return 4 * Mn[255 + t4[e2 - r2] - t4[e2 + 0]] + Mn[255 + t4[e2 - 2 * r2] - t4[e2 + r2]] <= n3;
    }
    __name(Te, "Te");
    function Ue(t4, e2, r2, n3, i3) {
      var a3 = t4[e2 - 3 * r2], o3 = t4[e2 - 2 * r2], s3 = t4[e2 - r2], c4 = t4[e2 + 0], u4 = t4[e2 + r2], h5 = t4[e2 + 2 * r2], l4 = t4[e2 + 3 * r2];
      return 4 * Mn[255 + s3 - c4] + Mn[255 + o3 - u4] > n3 ? 0 : Mn[255 + t4[e2 - 4 * r2] - a3] <= i3 && Mn[255 + a3 - o3] <= i3 && Mn[255 + o3 - s3] <= i3 && Mn[255 + l4 - h5] <= i3 && Mn[255 + h5 - u4] <= i3 && Mn[255 + u4 - c4] <= i3;
    }
    __name(Ue, "Ue");
    function ze(t4, e2, r2, n3) {
      var i3 = 2 * n3 + 1;
      for (n3 = 0; 16 > n3; ++n3)
        Te(t4, e2 + n3, r2, i3) && De(t4, e2 + n3, r2);
    }
    __name(ze, "ze");
    function He(t4, e2, r2, n3) {
      var i3 = 2 * n3 + 1;
      for (n3 = 0; 16 > n3; ++n3)
        Te(t4, e2 + n3 * r2, 1, i3) && De(t4, e2 + n3 * r2, 1);
    }
    __name(He, "He");
    function We(t4, e2, r2, n3) {
      var i3;
      for (i3 = 3; 0 < i3; --i3)
        ze(t4, e2 += 4 * r2, r2, n3);
    }
    __name(We, "We");
    function Ve(t4, e2, r2, n3) {
      var i3;
      for (i3 = 3; 0 < i3; --i3)
        He(t4, e2 += 4, r2, n3);
    }
    __name(Ve, "Ve");
    function Ge(t4, e2, r2, n3, i3, a3, o3, s3) {
      for (a3 = 2 * a3 + 1; 0 < i3--; ) {
        if (Ue(t4, e2, r2, a3, o3))
          if (Re(t4, e2, r2, s3))
            De(t4, e2, r2);
          else {
            var c4 = t4, u4 = e2, h5 = r2, l4 = c4[u4 - 2 * h5], f4 = c4[u4 - h5], d4 = c4[u4 + 0], p4 = c4[u4 + h5], g4 = c4[u4 + 2 * h5], m4 = 27 * (b4 = jn[1020 + 3 * (d4 - f4) + jn[1020 + l4 - p4]]) + 63 >> 7, v4 = 18 * b4 + 63 >> 7, b4 = 9 * b4 + 63 >> 7;
            c4[u4 - 3 * h5] = Bn[255 + c4[u4 - 3 * h5] + b4], c4[u4 - 2 * h5] = Bn[255 + l4 + v4], c4[u4 - h5] = Bn[255 + f4 + m4], c4[u4 + 0] = Bn[255 + d4 - m4], c4[u4 + h5] = Bn[255 + p4 - v4], c4[u4 + 2 * h5] = Bn[255 + g4 - b4];
          }
        e2 += n3;
      }
    }
    __name(Ge, "Ge");
    function Ye(t4, e2, r2, n3, i3, a3, o3, s3) {
      for (a3 = 2 * a3 + 1; 0 < i3--; ) {
        if (Ue(t4, e2, r2, a3, o3))
          if (Re(t4, e2, r2, s3))
            De(t4, e2, r2);
          else {
            var c4 = t4, u4 = e2, h5 = r2, l4 = c4[u4 - h5], f4 = c4[u4 + 0], d4 = c4[u4 + h5], p4 = On[112 + ((g4 = 3 * (f4 - l4)) + 4 >> 3)], g4 = On[112 + (g4 + 3 >> 3)], m4 = p4 + 1 >> 1;
            c4[u4 - 2 * h5] = Bn[255 + c4[u4 - 2 * h5] + m4], c4[u4 - h5] = Bn[255 + l4 + g4], c4[u4 + 0] = Bn[255 + f4 - p4], c4[u4 + h5] = Bn[255 + d4 - m4];
          }
        e2 += n3;
      }
    }
    __name(Ye, "Ye");
    function Je(t4, e2, r2, n3, i3, a3) {
      Ge(t4, e2, r2, 1, 16, n3, i3, a3);
    }
    __name(Je, "Je");
    function Xe(t4, e2, r2, n3, i3, a3) {
      Ge(t4, e2, 1, r2, 16, n3, i3, a3);
    }
    __name(Xe, "Xe");
    function Ke(t4, e2, r2, n3, i3, a3) {
      var o3;
      for (o3 = 3; 0 < o3; --o3)
        Ye(t4, e2 += 4 * r2, r2, 1, 16, n3, i3, a3);
    }
    __name(Ke, "Ke");
    function Ze(t4, e2, r2, n3, i3, a3) {
      var o3;
      for (o3 = 3; 0 < o3; --o3)
        Ye(t4, e2 += 4, 1, r2, 16, n3, i3, a3);
    }
    __name(Ze, "Ze");
    function $e(t4, e2, r2, n3, i3, a3, o3, s3) {
      Ge(t4, e2, i3, 1, 8, a3, o3, s3), Ge(r2, n3, i3, 1, 8, a3, o3, s3);
    }
    __name($e, "$e");
    function Qe(t4, e2, r2, n3, i3, a3, o3, s3) {
      Ge(t4, e2, 1, i3, 8, a3, o3, s3), Ge(r2, n3, 1, i3, 8, a3, o3, s3);
    }
    __name(Qe, "Qe");
    function tr(t4, e2, r2, n3, i3, a3, o3, s3) {
      Ye(t4, e2 + 4 * i3, i3, 1, 8, a3, o3, s3), Ye(r2, n3 + 4 * i3, i3, 1, 8, a3, o3, s3);
    }
    __name(tr, "tr");
    function er(t4, e2, r2, n3, i3, a3, o3, s3) {
      Ye(t4, e2 + 4, 1, i3, 8, a3, o3, s3), Ye(r2, n3 + 4, 1, i3, 8, a3, o3, s3);
    }
    __name(er, "er");
    function rr() {
      this.ba = new ot2(), this.ec = [], this.cc = [], this.Mc = [], this.Dc = this.Nc = this.dc = this.fc = 0, this.Oa = new ct2(), this.memory = 0, this.Ib = "OutputFunc", this.Jb = "OutputAlphaFunc", this.Nd = "OutputRowFunc";
    }
    __name(rr, "rr");
    function nr() {
      this.data = [], this.offset = this.kd = this.ha = this.w = 0, this.na = [], this.xa = this.gb = this.Ja = this.Sa = this.P = 0;
    }
    __name(nr, "nr");
    function ir() {
      this.nc = this.Ea = this.b = this.hc = 0, this.K = [], this.w = 0;
    }
    __name(ir, "ir");
    function ar() {
      this.ua = 0, this.Wa = new M2(), this.vb = new M2(), this.md = this.xc = this.wc = 0, this.vc = [], this.Wb = 0, this.Ya = new d3(), this.yc = new l3();
    }
    __name(ar, "ar");
    function or() {
      this.xb = this.a = 0, this.l = new Gt2(), this.ca = new ot2(), this.V = [], this.Ba = 0, this.Ta = [], this.Ua = 0, this.m = new N3(), this.Pb = 0, this.wd = new N3(), this.Ma = this.$ = this.C = this.i = this.c = this.xd = 0, this.s = new ar(), this.ab = 0, this.gc = o2(4, ir), this.Oc = 0;
    }
    __name(or, "or");
    function sr() {
      this.Lc = this.Z = this.$a = this.i = this.c = 0, this.l = new Gt2(), this.ic = 0, this.ca = [], this.tb = 0, this.qd = null, this.rd = 0;
    }
    __name(sr, "sr");
    function cr(t4, e2, r2, n3, i3, a3, o3) {
      for (t4 = null == t4 ? 0 : t4[e2 + 0], e2 = 0; e2 < o3; ++e2)
        i3[a3 + e2] = t4 + r2[n3 + e2] & 255, t4 = i3[a3 + e2];
    }
    __name(cr, "cr");
    function ur(t4, e2, r2, n3, i3, a3, o3) {
      var s3;
      if (null == t4)
        cr(null, null, r2, n3, i3, a3, o3);
      else
        for (s3 = 0; s3 < o3; ++s3)
          i3[a3 + s3] = t4[e2 + s3] + r2[n3 + s3] & 255;
    }
    __name(ur, "ur");
    function hr(t4, e2, r2, n3, i3, a3, o3) {
      if (null == t4)
        cr(null, null, r2, n3, i3, a3, o3);
      else {
        var s3, c4 = t4[e2 + 0], u4 = c4, h5 = c4;
        for (s3 = 0; s3 < o3; ++s3)
          u4 = h5 + (c4 = t4[e2 + s3]) - u4, h5 = r2[n3 + s3] + (-256 & u4 ? 0 > u4 ? 0 : 255 : u4) & 255, u4 = c4, i3[a3 + s3] = h5;
      }
    }
    __name(hr, "hr");
    function lr(t4, r2, i3, o3) {
      var s3 = r2.width, c4 = r2.o;
      if (e(null != t4 && null != r2), 0 > i3 || 0 >= o3 || i3 + o3 > c4)
        return null;
      if (!t4.Cc) {
        if (null == t4.ga) {
          var u4;
          if (t4.ga = new sr(), (u4 = null == t4.ga) || (u4 = r2.width * r2.o, e(0 == t4.Gb.length), t4.Gb = a2(u4), t4.Uc = 0, null == t4.Gb ? u4 = 0 : (t4.mb = t4.Gb, t4.nb = t4.Uc, t4.rc = null, u4 = 1), u4 = !u4), !u4) {
            u4 = t4.ga;
            var h5 = t4.Fa, l4 = t4.P, f4 = t4.qc, d4 = t4.mb, p4 = t4.nb, g4 = l4 + 1, m4 = f4 - 1, b4 = u4.l;
            if (e(null != h5 && null != d4 && null != r2), mi[0] = null, mi[1] = cr, mi[2] = ur, mi[3] = hr, u4.ca = d4, u4.tb = p4, u4.c = r2.width, u4.i = r2.height, e(0 < u4.c && 0 < u4.i), 1 >= f4)
              r2 = 0;
            else if (u4.$a = h5[l4 + 0] >> 0 & 3, u4.Z = h5[l4 + 0] >> 2 & 3, u4.Lc = h5[l4 + 0] >> 4 & 3, l4 = h5[l4 + 0] >> 6 & 3, 0 > u4.$a || 1 < u4.$a || 4 <= u4.Z || 1 < u4.Lc || l4)
              r2 = 0;
            else if (b4.put = dt2, b4.ac = ft2, b4.bc = pt2, b4.ma = u4, b4.width = r2.width, b4.height = r2.height, b4.Da = r2.Da, b4.v = r2.v, b4.va = r2.va, b4.j = r2.j, b4.o = r2.o, u4.$a)
              t: {
                e(1 == u4.$a), r2 = kt2();
                e:
                  for (; ; ) {
                    if (null == r2) {
                      r2 = 0;
                      break t;
                    }
                    if (e(null != u4), u4.mc = r2, r2.c = u4.c, r2.i = u4.i, r2.l = u4.l, r2.l.ma = u4, r2.l.width = u4.c, r2.l.height = u4.i, r2.a = 0, v3(r2.m, h5, g4, m4), !It2(u4.c, u4.i, 1, r2, null))
                      break e;
                    if (1 == r2.ab && 3 == r2.gc[0].hc && At2(r2.s) ? (u4.ic = 1, h5 = r2.c * r2.i, r2.Ta = null, r2.Ua = 0, r2.V = a2(h5), r2.Ba = 0, null == r2.V ? (r2.a = 1, r2 = 0) : r2 = 1) : (u4.ic = 0, r2 = Ft2(r2, u4.c)), !r2)
                      break e;
                    r2 = 1;
                    break t;
                  }
                u4.mc = null, r2 = 0;
              }
            else
              r2 = m4 >= u4.c * u4.i;
            u4 = !r2;
          }
          if (u4)
            return null;
          1 != t4.ga.Lc ? t4.Ga = 0 : o3 = c4 - i3;
        }
        e(null != t4.ga), e(i3 + o3 <= c4);
        t: {
          if (r2 = (h5 = t4.ga).c, c4 = h5.l.o, 0 == h5.$a) {
            if (g4 = t4.rc, m4 = t4.Vc, b4 = t4.Fa, l4 = t4.P + 1 + i3 * r2, f4 = t4.mb, d4 = t4.nb + i3 * r2, e(l4 <= t4.P + t4.qc), 0 != h5.Z)
              for (e(null != mi[h5.Z]), u4 = 0; u4 < o3; ++u4)
                mi[h5.Z](g4, m4, b4, l4, f4, d4, r2), g4 = f4, m4 = d4, d4 += r2, l4 += r2;
            else
              for (u4 = 0; u4 < o3; ++u4)
                n2(f4, d4, b4, l4, r2), g4 = f4, m4 = d4, d4 += r2, l4 += r2;
            t4.rc = g4, t4.Vc = m4;
          } else {
            if (e(null != h5.mc), r2 = i3 + o3, e(null != (u4 = h5.mc)), e(r2 <= u4.i), u4.C >= r2)
              r2 = 1;
            else if (h5.ic || mr(), h5.ic) {
              h5 = u4.V, g4 = u4.Ba, m4 = u4.c;
              var y4 = u4.i, w4 = (b4 = 1, l4 = u4.$ / m4, f4 = u4.$ % m4, d4 = u4.m, p4 = u4.s, u4.$), N4 = m4 * y4, L4 = m4 * r2, x3 = p4.wc, _3 = w4 < L4 ? wt2(p4, f4, l4) : null;
              e(w4 <= N4), e(r2 <= y4), e(At2(p4));
              e:
                for (; ; ) {
                  for (; !d4.h && w4 < L4; ) {
                    if (f4 & x3 || (_3 = wt2(p4, f4, l4)), e(null != _3), S2(d4), 256 > (y4 = bt2(_3.G[0], _3.H[0], d4)))
                      h5[g4 + w4] = y4, ++w4, ++f4 >= m4 && (f4 = 0, ++l4 <= r2 && !(l4 % 16) && St2(u4, l4));
                    else {
                      if (!(280 > y4)) {
                        b4 = 0;
                        break e;
                      }
                      y4 = mt2(y4 - 256, d4);
                      var P3, k3 = bt2(_3.G[4], _3.H[4], d4);
                      if (S2(d4), !(w4 >= (k3 = vt2(m4, k3 = mt2(k3, d4))) && N4 - w4 >= y4)) {
                        b4 = 0;
                        break e;
                      }
                      for (P3 = 0; P3 < y4; ++P3)
                        h5[g4 + w4 + P3] = h5[g4 + w4 + P3 - k3];
                      for (w4 += y4, f4 += y4; f4 >= m4; )
                        f4 -= m4, ++l4 <= r2 && !(l4 % 16) && St2(u4, l4);
                      w4 < L4 && f4 & x3 && (_3 = wt2(p4, f4, l4));
                    }
                    e(d4.h == A3(d4));
                  }
                  St2(u4, l4 > r2 ? r2 : l4);
                  break e;
                }
              !b4 || d4.h && w4 < N4 ? (b4 = 0, u4.a = d4.h ? 5 : 3) : u4.$ = w4, r2 = b4;
            } else
              r2 = _t2(u4, u4.V, u4.Ba, u4.c, u4.i, r2, Ct2);
            if (!r2) {
              o3 = 0;
              break t;
            }
          }
          i3 + o3 >= c4 && (t4.Cc = 1), o3 = 1;
        }
        if (!o3)
          return null;
        if (t4.Cc && (null != (o3 = t4.ga) && (o3.mc = null), t4.ga = null, 0 < t4.Ga))
          return alert("todo:WebPDequantizeLevels"), null;
      }
      return t4.nb + i3 * s3;
    }
    __name(lr, "lr");
    function fr(t4, e2, r2, n3, i3, a3) {
      for (; 0 < i3--; ) {
        var o3, s3 = t4, c4 = e2 + (r2 ? 1 : 0), u4 = t4, h5 = e2 + (r2 ? 0 : 3);
        for (o3 = 0; o3 < n3; ++o3) {
          var l4 = u4[h5 + 4 * o3];
          255 != l4 && (l4 *= 32897, s3[c4 + 4 * o3 + 0] = s3[c4 + 4 * o3 + 0] * l4 >> 23, s3[c4 + 4 * o3 + 1] = s3[c4 + 4 * o3 + 1] * l4 >> 23, s3[c4 + 4 * o3 + 2] = s3[c4 + 4 * o3 + 2] * l4 >> 23);
        }
        e2 += a3;
      }
    }
    __name(fr, "fr");
    function dr(t4, e2, r2, n3, i3) {
      for (; 0 < n3--; ) {
        var a3;
        for (a3 = 0; a3 < r2; ++a3) {
          var o3 = t4[e2 + 2 * a3 + 0], s3 = 15 & (u4 = t4[e2 + 2 * a3 + 1]), c4 = 4369 * s3, u4 = (240 & u4 | u4 >> 4) * c4 >> 16;
          t4[e2 + 2 * a3 + 0] = (240 & o3 | o3 >> 4) * c4 >> 16 & 240 | (15 & o3 | o3 << 4) * c4 >> 16 >> 4 & 15, t4[e2 + 2 * a3 + 1] = 240 & u4 | s3;
        }
        e2 += i3;
      }
    }
    __name(dr, "dr");
    function pr(t4, e2, r2, n3, i3, a3, o3, s3) {
      var c4, u4, h5 = 255;
      for (u4 = 0; u4 < i3; ++u4) {
        for (c4 = 0; c4 < n3; ++c4) {
          var l4 = t4[e2 + c4];
          a3[o3 + 4 * c4] = l4, h5 &= l4;
        }
        e2 += r2, o3 += s3;
      }
      return 255 != h5;
    }
    __name(pr, "pr");
    function gr(t4, e2, r2, n3, i3) {
      var a3;
      for (a3 = 0; a3 < i3; ++a3)
        r2[n3 + a3] = t4[e2 + a3] >> 8;
    }
    __name(gr, "gr");
    function mr() {
      An = fr, xn = dr, Sn = pr, _n = gr;
    }
    __name(mr, "mr");
    function vr(r2, n3, i3) {
      t3[r2] = function(t4, r3, a3, o3, s3, c4, u4, h5, l4, f4, d4, p4, g4, m4, v4, b4, y4) {
        var w4, N4 = y4 - 1 >> 1, L4 = s3[c4 + 0] | u4[h5 + 0] << 16, A4 = l4[f4 + 0] | d4[p4 + 0] << 16;
        e(null != t4);
        var x3 = 3 * L4 + A4 + 131074 >> 2;
        for (n3(t4[r3 + 0], 255 & x3, x3 >> 16, g4, m4), null != a3 && (x3 = 3 * A4 + L4 + 131074 >> 2, n3(a3[o3 + 0], 255 & x3, x3 >> 16, v4, b4)), w4 = 1; w4 <= N4; ++w4) {
          var S3 = s3[c4 + w4] | u4[h5 + w4] << 16, _3 = l4[f4 + w4] | d4[p4 + w4] << 16, P3 = L4 + S3 + A4 + _3 + 524296, k3 = P3 + 2 * (S3 + A4) >> 3;
          x3 = k3 + L4 >> 1, L4 = (P3 = P3 + 2 * (L4 + _3) >> 3) + S3 >> 1, n3(t4[r3 + 2 * w4 - 1], 255 & x3, x3 >> 16, g4, m4 + (2 * w4 - 1) * i3), n3(t4[r3 + 2 * w4 - 0], 255 & L4, L4 >> 16, g4, m4 + (2 * w4 - 0) * i3), null != a3 && (x3 = P3 + A4 >> 1, L4 = k3 + _3 >> 1, n3(a3[o3 + 2 * w4 - 1], 255 & x3, x3 >> 16, v4, b4 + (2 * w4 - 1) * i3), n3(a3[o3 + 2 * w4 + 0], 255 & L4, L4 >> 16, v4, b4 + (2 * w4 + 0) * i3)), L4 = S3, A4 = _3;
        }
        1 & y4 || (x3 = 3 * L4 + A4 + 131074 >> 2, n3(t4[r3 + y4 - 1], 255 & x3, x3 >> 16, g4, m4 + (y4 - 1) * i3), null != a3 && (x3 = 3 * A4 + L4 + 131074 >> 2, n3(a3[o3 + y4 - 1], 255 & x3, x3 >> 16, v4, b4 + (y4 - 1) * i3)));
      };
    }
    __name(vr, "vr");
    function br() {
      vi[En] = bi, vi[qn] = wi, vi[Dn] = yi, vi[Rn] = Ni, vi[Tn] = Li, vi[Un] = Ai, vi[zn] = xi, vi[Hn] = wi, vi[Wn] = Ni, vi[Vn] = Li, vi[Gn] = Ai;
    }
    __name(br, "br");
    function yr(t4) {
      return t4 & ~Fi ? 0 > t4 ? 0 : 255 : t4 >> Ii;
    }
    __name(yr, "yr");
    function wr(t4, e2) {
      return yr((19077 * t4 >> 8) + (26149 * e2 >> 8) - 14234);
    }
    __name(wr, "wr");
    function Nr(t4, e2, r2) {
      return yr((19077 * t4 >> 8) - (6419 * e2 >> 8) - (13320 * r2 >> 8) + 8708);
    }
    __name(Nr, "Nr");
    function Lr(t4, e2) {
      return yr((19077 * t4 >> 8) + (33050 * e2 >> 8) - 17685);
    }
    __name(Lr, "Lr");
    function Ar(t4, e2, r2, n3, i3) {
      n3[i3 + 0] = wr(t4, r2), n3[i3 + 1] = Nr(t4, e2, r2), n3[i3 + 2] = Lr(t4, e2);
    }
    __name(Ar, "Ar");
    function xr(t4, e2, r2, n3, i3) {
      n3[i3 + 0] = Lr(t4, e2), n3[i3 + 1] = Nr(t4, e2, r2), n3[i3 + 2] = wr(t4, r2);
    }
    __name(xr, "xr");
    function Sr(t4, e2, r2, n3, i3) {
      var a3 = Nr(t4, e2, r2);
      e2 = a3 << 3 & 224 | Lr(t4, e2) >> 3, n3[i3 + 0] = 248 & wr(t4, r2) | a3 >> 5, n3[i3 + 1] = e2;
    }
    __name(Sr, "Sr");
    function _r(t4, e2, r2, n3, i3) {
      var a3 = 240 & Lr(t4, e2) | 15;
      n3[i3 + 0] = 240 & wr(t4, r2) | Nr(t4, e2, r2) >> 4, n3[i3 + 1] = a3;
    }
    __name(_r, "_r");
    function Pr(t4, e2, r2, n3, i3) {
      n3[i3 + 0] = 255, Ar(t4, e2, r2, n3, i3 + 1);
    }
    __name(Pr, "Pr");
    function kr(t4, e2, r2, n3, i3) {
      xr(t4, e2, r2, n3, i3), n3[i3 + 3] = 255;
    }
    __name(kr, "kr");
    function Ir(t4, e2, r2, n3, i3) {
      Ar(t4, e2, r2, n3, i3), n3[i3 + 3] = 255;
    }
    __name(Ir, "Ir");
    function Vt2(t4, e2) {
      return 0 > t4 ? 0 : t4 > e2 ? e2 : t4;
    }
    __name(Vt2, "Vt");
    function Fr(e2, r2, n3) {
      t3[e2] = function(t4, e3, i3, a3, o3, s3, c4, u4, h5) {
        for (var l4 = u4 + (-2 & h5) * n3; u4 != l4; )
          r2(t4[e3 + 0], i3[a3 + 0], o3[s3 + 0], c4, u4), r2(t4[e3 + 1], i3[a3 + 0], o3[s3 + 0], c4, u4 + n3), e3 += 2, ++a3, ++s3, u4 += 2 * n3;
        1 & h5 && r2(t4[e3 + 0], i3[a3 + 0], o3[s3 + 0], c4, u4);
      };
    }
    __name(Fr, "Fr");
    function Cr(t4, e2, r2) {
      return 0 == r2 ? 0 == t4 ? 0 == e2 ? 6 : 5 : 0 == e2 ? 4 : 0 : r2;
    }
    __name(Cr, "Cr");
    function jr(t4, e2, r2, n3, i3) {
      switch (t4 >>> 30) {
        case 3:
          on(e2, r2, n3, i3, 0);
          break;
        case 2:
          sn(e2, r2, n3, i3);
          break;
        case 1:
          un(e2, r2, n3, i3);
      }
    }
    __name(jr, "jr");
    function Or(t4, e2) {
      var r2, a3, o3 = e2.M, s3 = e2.Nb, c4 = t4.oc, u4 = t4.pc + 40, h5 = t4.oc, l4 = t4.pc + 584, f4 = t4.oc, d4 = t4.pc + 600;
      for (r2 = 0; 16 > r2; ++r2)
        c4[u4 + 32 * r2 - 1] = 129;
      for (r2 = 0; 8 > r2; ++r2)
        h5[l4 + 32 * r2 - 1] = 129, f4[d4 + 32 * r2 - 1] = 129;
      for (0 < o3 ? c4[u4 - 1 - 32] = h5[l4 - 1 - 32] = f4[d4 - 1 - 32] = 129 : (i2(c4, u4 - 32 - 1, 127, 21), i2(h5, l4 - 32 - 1, 127, 9), i2(f4, d4 - 32 - 1, 127, 9)), a3 = 0; a3 < t4.za; ++a3) {
        var p4 = e2.ya[e2.aa + a3];
        if (0 < a3) {
          for (r2 = -1; 16 > r2; ++r2)
            n2(c4, u4 + 32 * r2 - 4, c4, u4 + 32 * r2 + 12, 4);
          for (r2 = -1; 8 > r2; ++r2)
            n2(h5, l4 + 32 * r2 - 4, h5, l4 + 32 * r2 + 4, 4), n2(f4, d4 + 32 * r2 - 4, f4, d4 + 32 * r2 + 4, 4);
        }
        var g4 = t4.Gd, m4 = t4.Hd + a3, v4 = p4.ad, b4 = p4.Hc;
        if (0 < o3 && (n2(c4, u4 - 32, g4[m4].y, 0, 16), n2(h5, l4 - 32, g4[m4].f, 0, 8), n2(f4, d4 - 32, g4[m4].ea, 0, 8)), p4.Za) {
          var y4 = c4, w4 = u4 - 32 + 16;
          for (0 < o3 && (a3 >= t4.za - 1 ? i2(y4, w4, g4[m4].y[15], 4) : n2(y4, w4, g4[m4 + 1].y, 0, 4)), r2 = 0; 4 > r2; r2++)
            y4[w4 + 128 + r2] = y4[w4 + 256 + r2] = y4[w4 + 384 + r2] = y4[w4 + 0 + r2];
          for (r2 = 0; 16 > r2; ++r2, b4 <<= 2)
            y4 = c4, w4 = u4 + Di[r2], fi[p4.Ob[r2]](y4, w4), jr(b4, v4, 16 * +r2, y4, w4);
        } else if (y4 = Cr(a3, o3, p4.Ob[0]), li[y4](c4, u4), 0 != b4)
          for (r2 = 0; 16 > r2; ++r2, b4 <<= 2)
            jr(b4, v4, 16 * +r2, c4, u4 + Di[r2]);
        for (r2 = p4.Gc, y4 = Cr(a3, o3, p4.Dd), di[y4](h5, l4), di[y4](f4, d4), b4 = v4, y4 = h5, w4 = l4, 255 & (p4 = r2 >> 0) && (170 & p4 ? cn(b4, 256, y4, w4) : hn(b4, 256, y4, w4)), p4 = f4, b4 = d4, 255 & (r2 >>= 8) && (170 & r2 ? cn(v4, 320, p4, b4) : hn(v4, 320, p4, b4)), o3 < t4.Ub - 1 && (n2(g4[m4].y, 0, c4, u4 + 480, 16), n2(g4[m4].f, 0, h5, l4 + 224, 8), n2(g4[m4].ea, 0, f4, d4 + 224, 8)), r2 = 8 * s3 * t4.B, g4 = t4.sa, m4 = t4.ta + 16 * a3 + 16 * s3 * t4.R, v4 = t4.qa, p4 = t4.ra + 8 * a3 + r2, b4 = t4.Ha, y4 = t4.Ia + 8 * a3 + r2, r2 = 0; 16 > r2; ++r2)
          n2(g4, m4 + r2 * t4.R, c4, u4 + 32 * r2, 16);
        for (r2 = 0; 8 > r2; ++r2)
          n2(v4, p4 + r2 * t4.B, h5, l4 + 32 * r2, 8), n2(b4, y4 + r2 * t4.B, f4, d4 + 32 * r2, 8);
      }
    }
    __name(Or, "Or");
    function Br(t4, n3, i3, a3, o3, s3, c4, u4, h5) {
      var l4 = [0], f4 = [0], d4 = 0, p4 = null != h5 ? h5.kd : 0, g4 = null != h5 ? h5 : new nr();
      if (null == t4 || 12 > i3)
        return 7;
      g4.data = t4, g4.w = n3, g4.ha = i3, n3 = [n3], i3 = [i3], g4.gb = [g4.gb];
      t: {
        var m4 = n3, b4 = i3, y4 = g4.gb;
        if (e(null != t4), e(null != b4), e(null != y4), y4[0] = 0, 12 <= b4[0] && !r(t4, m4[0], "RIFF")) {
          if (r(t4, m4[0] + 8, "WEBP")) {
            y4 = 3;
            break t;
          }
          var w4 = j2(t4, m4[0] + 4);
          if (12 > w4 || 4294967286 < w4) {
            y4 = 3;
            break t;
          }
          if (p4 && w4 > b4[0] - 8) {
            y4 = 7;
            break t;
          }
          y4[0] = w4, m4[0] += 12, b4[0] -= 12;
        }
        y4 = 0;
      }
      if (0 != y4)
        return y4;
      for (w4 = 0 < g4.gb[0], i3 = i3[0]; ; ) {
        t: {
          var L4 = t4;
          b4 = n3, y4 = i3;
          var A4 = l4, x3 = f4, S3 = m4 = [0];
          if ((k3 = d4 = [d4])[0] = 0, 8 > y4[0])
            y4 = 7;
          else {
            if (!r(L4, b4[0], "VP8X")) {
              if (10 != j2(L4, b4[0] + 4)) {
                y4 = 3;
                break t;
              }
              if (18 > y4[0]) {
                y4 = 7;
                break t;
              }
              var _3 = j2(L4, b4[0] + 8), P3 = 1 + C2(L4, b4[0] + 12);
              if (2147483648 <= P3 * (L4 = 1 + C2(L4, b4[0] + 15))) {
                y4 = 3;
                break t;
              }
              null != S3 && (S3[0] = _3), null != A4 && (A4[0] = P3), null != x3 && (x3[0] = L4), b4[0] += 18, y4[0] -= 18, k3[0] = 1;
            }
            y4 = 0;
          }
        }
        if (d4 = d4[0], m4 = m4[0], 0 != y4)
          return y4;
        if (b4 = !!(2 & m4), !w4 && d4)
          return 3;
        if (null != s3 && (s3[0] = !!(16 & m4)), null != c4 && (c4[0] = b4), null != u4 && (u4[0] = 0), c4 = l4[0], m4 = f4[0], d4 && b4 && null == h5) {
          y4 = 0;
          break;
        }
        if (4 > i3) {
          y4 = 7;
          break;
        }
        if (w4 && d4 || !w4 && !d4 && !r(t4, n3[0], "ALPH")) {
          i3 = [i3], g4.na = [g4.na], g4.P = [g4.P], g4.Sa = [g4.Sa];
          t: {
            _3 = t4, y4 = n3, w4 = i3;
            var k3 = g4.gb;
            A4 = g4.na, x3 = g4.P, S3 = g4.Sa;
            P3 = 22, e(null != _3), e(null != w4), L4 = y4[0];
            var I3 = w4[0];
            for (e(null != A4), e(null != S3), A4[0] = null, x3[0] = null, S3[0] = 0; ; ) {
              if (y4[0] = L4, w4[0] = I3, 8 > I3) {
                y4 = 7;
                break t;
              }
              var F3 = j2(_3, L4 + 4);
              if (4294967286 < F3) {
                y4 = 3;
                break t;
              }
              var O3 = 8 + F3 + 1 & -2;
              if (P3 += O3, 0 < k3 && P3 > k3) {
                y4 = 3;
                break t;
              }
              if (!r(_3, L4, "VP8 ") || !r(_3, L4, "VP8L")) {
                y4 = 0;
                break t;
              }
              if (I3[0] < O3) {
                y4 = 7;
                break t;
              }
              r(_3, L4, "ALPH") || (A4[0] = _3, x3[0] = L4 + 8, S3[0] = F3), L4 += O3, I3 -= O3;
            }
          }
          if (i3 = i3[0], g4.na = g4.na[0], g4.P = g4.P[0], g4.Sa = g4.Sa[0], 0 != y4)
            break;
        }
        i3 = [i3], g4.Ja = [g4.Ja], g4.xa = [g4.xa];
        t:
          if (k3 = t4, y4 = n3, w4 = i3, A4 = g4.gb[0], x3 = g4.Ja, S3 = g4.xa, _3 = y4[0], L4 = !r(k3, _3, "VP8 "), P3 = !r(k3, _3, "VP8L"), e(null != k3), e(null != w4), e(null != x3), e(null != S3), 8 > w4[0])
            y4 = 7;
          else {
            if (L4 || P3) {
              if (k3 = j2(k3, _3 + 4), 12 <= A4 && k3 > A4 - 12) {
                y4 = 3;
                break t;
              }
              if (p4 && k3 > w4[0] - 8) {
                y4 = 7;
                break t;
              }
              x3[0] = k3, y4[0] += 8, w4[0] -= 8, S3[0] = P3;
            } else
              S3[0] = 5 <= w4[0] && 47 == k3[_3 + 0] && !(k3[_3 + 4] >> 5), x3[0] = w4[0];
            y4 = 0;
          }
        if (i3 = i3[0], g4.Ja = g4.Ja[0], g4.xa = g4.xa[0], n3 = n3[0], 0 != y4)
          break;
        if (4294967286 < g4.Ja)
          return 3;
        if (null == u4 || b4 || (u4[0] = g4.xa ? 2 : 1), c4 = [c4], m4 = [m4], g4.xa) {
          if (5 > i3) {
            y4 = 7;
            break;
          }
          u4 = c4, p4 = m4, b4 = s3, null == t4 || 5 > i3 ? t4 = 0 : 5 <= i3 && 47 == t4[n3 + 0] && !(t4[n3 + 4] >> 5) ? (w4 = [0], k3 = [0], A4 = [0], v3(x3 = new N3(), t4, n3, i3), gt2(x3, w4, k3, A4) ? (null != u4 && (u4[0] = w4[0]), null != p4 && (p4[0] = k3[0]), null != b4 && (b4[0] = A4[0]), t4 = 1) : t4 = 0) : t4 = 0;
        } else {
          if (10 > i3) {
            y4 = 7;
            break;
          }
          u4 = m4, null == t4 || 10 > i3 || !Xt2(t4, n3 + 3, i3 - 3) ? t4 = 0 : (p4 = t4[n3 + 0] | t4[n3 + 1] << 8 | t4[n3 + 2] << 16, b4 = 16383 & (t4[n3 + 7] << 8 | t4[n3 + 6]), t4 = 16383 & (t4[n3 + 9] << 8 | t4[n3 + 8]), 1 & p4 || 3 < (p4 >> 1 & 7) || !(p4 >> 4 & 1) || p4 >> 5 >= g4.Ja || !b4 || !t4 ? t4 = 0 : (c4 && (c4[0] = b4), u4 && (u4[0] = t4), t4 = 1));
        }
        if (!t4)
          return 3;
        if (c4 = c4[0], m4 = m4[0], d4 && (l4[0] != c4 || f4[0] != m4))
          return 3;
        null != h5 && (h5[0] = g4, h5.offset = n3 - h5.w, e(4294967286 > n3 - h5.w), e(h5.offset == h5.ha - i3));
        break;
      }
      return 0 == y4 || 7 == y4 && d4 && null == h5 ? (null != s3 && (s3[0] |= null != g4.na && 0 < g4.na.length), null != a3 && (a3[0] = c4), null != o3 && (o3[0] = m4), 0) : y4;
    }
    __name(Br, "Br");
    function Mr(t4, e2, r2) {
      var n3 = e2.width, i3 = e2.height, a3 = 0, o3 = 0, s3 = n3, c4 = i3;
      if (e2.Da = null != t4 && 0 < t4.Da, e2.Da && (s3 = t4.cd, c4 = t4.bd, a3 = t4.v, o3 = t4.j, 11 > r2 || (a3 &= -2, o3 &= -2), 0 > a3 || 0 > o3 || 0 >= s3 || 0 >= c4 || a3 + s3 > n3 || o3 + c4 > i3))
        return 0;
      if (e2.v = a3, e2.j = o3, e2.va = a3 + s3, e2.o = o3 + c4, e2.U = s3, e2.T = c4, e2.da = null != t4 && 0 < t4.da, e2.da) {
        if (!E2(s3, c4, r2 = [t4.ib], a3 = [t4.hb]))
          return 0;
        e2.ib = r2[0], e2.hb = a3[0];
      }
      return e2.ob = null != t4 && t4.ob, e2.Kb = null == t4 || !t4.Sd, e2.da && (e2.ob = e2.ib < 3 * n3 / 4 && e2.hb < 3 * i3 / 4, e2.Kb = 0), 1;
    }
    __name(Mr, "Mr");
    function Er(t4) {
      if (null == t4)
        return 2;
      if (11 > t4.S) {
        var e2 = t4.f.RGBA;
        e2.fb += (t4.height - 1) * e2.A, e2.A = -e2.A;
      } else
        e2 = t4.f.kb, t4 = t4.height, e2.O += (t4 - 1) * e2.fa, e2.fa = -e2.fa, e2.N += (t4 - 1 >> 1) * e2.Ab, e2.Ab = -e2.Ab, e2.W += (t4 - 1 >> 1) * e2.Db, e2.Db = -e2.Db, null != e2.F && (e2.J += (t4 - 1) * e2.lb, e2.lb = -e2.lb);
      return 0;
    }
    __name(Er, "Er");
    function qr(t4, e2, r2, n3) {
      if (null == n3 || 0 >= t4 || 0 >= e2)
        return 2;
      if (null != r2) {
        if (r2.Da) {
          var i3 = r2.cd, o3 = r2.bd, s3 = -2 & r2.v, c4 = -2 & r2.j;
          if (0 > s3 || 0 > c4 || 0 >= i3 || 0 >= o3 || s3 + i3 > t4 || c4 + o3 > e2)
            return 2;
          t4 = i3, e2 = o3;
        }
        if (r2.da) {
          if (!E2(t4, e2, i3 = [r2.ib], o3 = [r2.hb]))
            return 2;
          t4 = i3[0], e2 = o3[0];
        }
      }
      n3.width = t4, n3.height = e2;
      t: {
        var u4 = n3.width, h5 = n3.height;
        if (t4 = n3.S, 0 >= u4 || 0 >= h5 || !(t4 >= En && 13 > t4))
          t4 = 2;
        else {
          if (0 >= n3.Rd && null == n3.sd) {
            s3 = o3 = i3 = e2 = 0;
            var l4 = (c4 = u4 * zi[t4]) * h5;
            if (11 > t4 || (o3 = (h5 + 1) / 2 * (e2 = (u4 + 1) / 2), 12 == t4 && (s3 = (i3 = u4) * h5)), null == (h5 = a2(l4 + 2 * o3 + s3))) {
              t4 = 1;
              break t;
            }
            n3.sd = h5, 11 > t4 ? ((u4 = n3.f.RGBA).eb = h5, u4.fb = 0, u4.A = c4, u4.size = l4) : ((u4 = n3.f.kb).y = h5, u4.O = 0, u4.fa = c4, u4.Fd = l4, u4.f = h5, u4.N = 0 + l4, u4.Ab = e2, u4.Cd = o3, u4.ea = h5, u4.W = 0 + l4 + o3, u4.Db = e2, u4.Ed = o3, 12 == t4 && (u4.F = h5, u4.J = 0 + l4 + 2 * o3), u4.Tc = s3, u4.lb = i3);
          }
          if (e2 = 1, i3 = n3.S, o3 = n3.width, s3 = n3.height, i3 >= En && 13 > i3)
            if (11 > i3)
              t4 = n3.f.RGBA, e2 &= (c4 = Math.abs(t4.A)) * (s3 - 1) + o3 <= t4.size, e2 &= c4 >= o3 * zi[i3], e2 &= null != t4.eb;
            else {
              t4 = n3.f.kb, c4 = (o3 + 1) / 2, l4 = (s3 + 1) / 2, u4 = Math.abs(t4.fa);
              h5 = Math.abs(t4.Ab);
              var f4 = Math.abs(t4.Db), d4 = Math.abs(t4.lb), p4 = d4 * (s3 - 1) + o3;
              e2 &= u4 * (s3 - 1) + o3 <= t4.Fd, e2 &= h5 * (l4 - 1) + c4 <= t4.Cd, e2 = (e2 &= f4 * (l4 - 1) + c4 <= t4.Ed) & u4 >= o3 & h5 >= c4 & f4 >= c4, e2 &= null != t4.y, e2 &= null != t4.f, e2 &= null != t4.ea, 12 == i3 && (e2 &= d4 >= o3, e2 &= p4 <= t4.Tc, e2 &= null != t4.F);
            }
          else
            e2 = 0;
          t4 = e2 ? 0 : 2;
        }
      }
      return 0 != t4 || null != r2 && r2.fd && (t4 = Er(n3)), t4;
    }
    __name(qr, "qr");
    var Dr = 64, Rr = [0, 1, 3, 7, 15, 31, 63, 127, 255, 511, 1023, 2047, 4095, 8191, 16383, 32767, 65535, 131071, 262143, 524287, 1048575, 2097151, 4194303, 8388607, 16777215], Tr = 24, Ur = 32, zr = 8, Hr = [0, 0, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7];
    R2("Predictor0", "PredictorAdd0"), t3.Predictor0 = function() {
      return 4278190080;
    }, t3.Predictor1 = function(t4) {
      return t4;
    }, t3.Predictor2 = function(t4, e2, r2) {
      return e2[r2 + 0];
    }, t3.Predictor3 = function(t4, e2, r2) {
      return e2[r2 + 1];
    }, t3.Predictor4 = function(t4, e2, r2) {
      return e2[r2 - 1];
    }, t3.Predictor5 = function(t4, e2, r2) {
      return U2(U2(t4, e2[r2 + 1]), e2[r2 + 0]);
    }, t3.Predictor6 = function(t4, e2, r2) {
      return U2(t4, e2[r2 - 1]);
    }, t3.Predictor7 = function(t4, e2, r2) {
      return U2(t4, e2[r2 + 0]);
    }, t3.Predictor8 = function(t4, e2, r2) {
      return U2(e2[r2 - 1], e2[r2 + 0]);
    }, t3.Predictor9 = function(t4, e2, r2) {
      return U2(e2[r2 + 0], e2[r2 + 1]);
    }, t3.Predictor10 = function(t4, e2, r2) {
      return U2(U2(t4, e2[r2 - 1]), U2(e2[r2 + 0], e2[r2 + 1]));
    }, t3.Predictor11 = function(t4, e2, r2) {
      var n3 = e2[r2 + 0];
      return 0 >= W2(n3 >> 24 & 255, t4 >> 24 & 255, (e2 = e2[r2 - 1]) >> 24 & 255) + W2(n3 >> 16 & 255, t4 >> 16 & 255, e2 >> 16 & 255) + W2(n3 >> 8 & 255, t4 >> 8 & 255, e2 >> 8 & 255) + W2(255 & n3, 255 & t4, 255 & e2) ? n3 : t4;
    }, t3.Predictor12 = function(t4, e2, r2) {
      var n3 = e2[r2 + 0];
      return (z2((t4 >> 24 & 255) + (n3 >> 24 & 255) - ((e2 = e2[r2 - 1]) >> 24 & 255)) << 24 | z2((t4 >> 16 & 255) + (n3 >> 16 & 255) - (e2 >> 16 & 255)) << 16 | z2((t4 >> 8 & 255) + (n3 >> 8 & 255) - (e2 >> 8 & 255)) << 8 | z2((255 & t4) + (255 & n3) - (255 & e2))) >>> 0;
    }, t3.Predictor13 = function(t4, e2, r2) {
      var n3 = e2[r2 - 1];
      return (H2((t4 = U2(t4, e2[r2 + 0])) >> 24 & 255, n3 >> 24 & 255) << 24 | H2(t4 >> 16 & 255, n3 >> 16 & 255) << 16 | H2(t4 >> 8 & 255, n3 >> 8 & 255) << 8 | H2(t4 >> 0 & 255, n3 >> 0 & 255)) >>> 0;
    };
    var Wr = t3.PredictorAdd0;
    t3.PredictorAdd1 = V2, R2("Predictor2", "PredictorAdd2"), R2("Predictor3", "PredictorAdd3"), R2("Predictor4", "PredictorAdd4"), R2("Predictor5", "PredictorAdd5"), R2("Predictor6", "PredictorAdd6"), R2("Predictor7", "PredictorAdd7"), R2("Predictor8", "PredictorAdd8"), R2("Predictor9", "PredictorAdd9"), R2("Predictor10", "PredictorAdd10"), R2("Predictor11", "PredictorAdd11"), R2("Predictor12", "PredictorAdd12"), R2("Predictor13", "PredictorAdd13");
    var Vr = t3.PredictorAdd2;
    X2("ColorIndexInverseTransform", "MapARGB", "32b", function(t4) {
      return t4 >> 8 & 255;
    }, function(t4) {
      return t4;
    }), X2("VP8LColorIndexInverseTransformAlpha", "MapAlpha", "8b", function(t4) {
      return t4;
    }, function(t4) {
      return t4 >> 8 & 255;
    });
    var Gr, Yr = t3.ColorIndexInverseTransform, Jr = t3.MapARGB, Xr = t3.VP8LColorIndexInverseTransformAlpha, Kr = t3.MapAlpha, Zr = t3.VP8LPredictorsAdd = [];
    Zr.length = 16, (t3.VP8LPredictors = []).length = 16, (t3.VP8LPredictorsAdd_C = []).length = 16, (t3.VP8LPredictors_C = []).length = 16;
    var $r, Qr, tn, en, rn, nn, an, on, sn, cn, un, hn, ln2, fn, dn, pn, gn, mn, vn, bn, yn, wn, Nn, Ln, An, xn, Sn, _n, Pn = a2(511), kn = a2(2041), In = a2(225), Fn = a2(767), Cn = 0, jn = kn, On = In, Bn = Fn, Mn = Pn, En = 0, qn = 1, Dn = 2, Rn = 3, Tn = 4, Un = 5, zn = 6, Hn = 7, Wn = 8, Vn = 9, Gn = 10, Yn = [2, 3, 7], Jn = [3, 3, 11], Xn = [280, 256, 256, 256, 40], Kn = [0, 1, 1, 1, 0], Zn = [17, 18, 0, 1, 2, 3, 4, 5, 16, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15], $n = [24, 7, 23, 25, 40, 6, 39, 41, 22, 26, 38, 42, 56, 5, 55, 57, 21, 27, 54, 58, 37, 43, 72, 4, 71, 73, 20, 28, 53, 59, 70, 74, 36, 44, 88, 69, 75, 52, 60, 3, 87, 89, 19, 29, 86, 90, 35, 45, 68, 76, 85, 91, 51, 61, 104, 2, 103, 105, 18, 30, 102, 106, 34, 46, 84, 92, 67, 77, 101, 107, 50, 62, 120, 1, 119, 121, 83, 93, 17, 31, 100, 108, 66, 78, 118, 122, 33, 47, 117, 123, 49, 63, 99, 109, 82, 94, 0, 116, 124, 65, 79, 16, 32, 98, 110, 48, 115, 125, 81, 95, 64, 114, 126, 97, 111, 80, 113, 127, 96, 112], Qn = [2954, 2956, 2958, 2962, 2970, 2986, 3018, 3082, 3212, 3468, 3980, 5004], ti = 8, ei = [4, 5, 6, 7, 8, 9, 10, 10, 11, 12, 13, 14, 15, 16, 17, 17, 18, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 25, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 91, 93, 95, 96, 98, 100, 101, 102, 104, 106, 108, 110, 112, 114, 116, 118, 122, 124, 126, 128, 130, 132, 134, 136, 138, 140, 143, 145, 148, 151, 154, 157], ri = [4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 60, 62, 64, 66, 68, 70, 72, 74, 76, 78, 80, 82, 84, 86, 88, 90, 92, 94, 96, 98, 100, 102, 104, 106, 108, 110, 112, 114, 116, 119, 122, 125, 128, 131, 134, 137, 140, 143, 146, 149, 152, 155, 158, 161, 164, 167, 170, 173, 177, 181, 185, 189, 193, 197, 201, 205, 209, 213, 217, 221, 225, 229, 234, 239, 245, 249, 254, 259, 264, 269, 274, 279, 284], ni = null, ii = [[173, 148, 140, 0], [176, 155, 140, 135, 0], [180, 157, 141, 134, 130, 0], [254, 254, 243, 230, 196, 177, 153, 140, 133, 130, 129, 0]], ai = [0, 1, 4, 8, 5, 2, 3, 6, 9, 12, 13, 10, 7, 11, 14, 15], oi = [-0, 1, -1, 2, -2, 3, 4, 6, -3, 5, -4, -5, -6, 7, -7, 8, -8, -9], si = [[[[128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128], [128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128], [128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128]], [[253, 136, 254, 255, 228, 219, 128, 128, 128, 128, 128], [189, 129, 242, 255, 227, 213, 255, 219, 128, 128, 128], [106, 126, 227, 252, 214, 209, 255, 255, 128, 128, 128]], [[1, 98, 248, 255, 236, 226, 255, 255, 128, 128, 128], [181, 133, 238, 254, 221, 234, 255, 154, 128, 128, 128], [78, 134, 202, 247, 198, 180, 255, 219, 128, 128, 128]], [[1, 185, 249, 255, 243, 255, 128, 128, 128, 128, 128], [184, 150, 247, 255, 236, 224, 128, 128, 128, 128, 128], [77, 110, 216, 255, 236, 230, 128, 128, 128, 128, 128]], [[1, 101, 251, 255, 241, 255, 128, 128, 128, 128, 128], [170, 139, 241, 252, 236, 209, 255, 255, 128, 128, 128], [37, 116, 196, 243, 228, 255, 255, 255, 128, 128, 128]], [[1, 204, 254, 255, 245, 255, 128, 128, 128, 128, 128], [207, 160, 250, 255, 238, 128, 128, 128, 128, 128, 128], [102, 103, 231, 255, 211, 171, 128, 128, 128, 128, 128]], [[1, 152, 252, 255, 240, 255, 128, 128, 128, 128, 128], [177, 135, 243, 255, 234, 225, 128, 128, 128, 128, 128], [80, 129, 211, 255, 194, 224, 128, 128, 128, 128, 128]], [[1, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128], [246, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128], [255, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128]]], [[[198, 35, 237, 223, 193, 187, 162, 160, 145, 155, 62], [131, 45, 198, 221, 172, 176, 220, 157, 252, 221, 1], [68, 47, 146, 208, 149, 167, 221, 162, 255, 223, 128]], [[1, 149, 241, 255, 221, 224, 255, 255, 128, 128, 128], [184, 141, 234, 253, 222, 220, 255, 199, 128, 128, 128], [81, 99, 181, 242, 176, 190, 249, 202, 255, 255, 128]], [[1, 129, 232, 253, 214, 197, 242, 196, 255, 255, 128], [99, 121, 210, 250, 201, 198, 255, 202, 128, 128, 128], [23, 91, 163, 242, 170, 187, 247, 210, 255, 255, 128]], [[1, 200, 246, 255, 234, 255, 128, 128, 128, 128, 128], [109, 178, 241, 255, 231, 245, 255, 255, 128, 128, 128], [44, 130, 201, 253, 205, 192, 255, 255, 128, 128, 128]], [[1, 132, 239, 251, 219, 209, 255, 165, 128, 128, 128], [94, 136, 225, 251, 218, 190, 255, 255, 128, 128, 128], [22, 100, 174, 245, 186, 161, 255, 199, 128, 128, 128]], [[1, 182, 249, 255, 232, 235, 128, 128, 128, 128, 128], [124, 143, 241, 255, 227, 234, 128, 128, 128, 128, 128], [35, 77, 181, 251, 193, 211, 255, 205, 128, 128, 128]], [[1, 157, 247, 255, 236, 231, 255, 255, 128, 128, 128], [121, 141, 235, 255, 225, 227, 255, 255, 128, 128, 128], [45, 99, 188, 251, 195, 217, 255, 224, 128, 128, 128]], [[1, 1, 251, 255, 213, 255, 128, 128, 128, 128, 128], [203, 1, 248, 255, 255, 128, 128, 128, 128, 128, 128], [137, 1, 177, 255, 224, 255, 128, 128, 128, 128, 128]]], [[[253, 9, 248, 251, 207, 208, 255, 192, 128, 128, 128], [175, 13, 224, 243, 193, 185, 249, 198, 255, 255, 128], [73, 17, 171, 221, 161, 179, 236, 167, 255, 234, 128]], [[1, 95, 247, 253, 212, 183, 255, 255, 128, 128, 128], [239, 90, 244, 250, 211, 209, 255, 255, 128, 128, 128], [155, 77, 195, 248, 188, 195, 255, 255, 128, 128, 128]], [[1, 24, 239, 251, 218, 219, 255, 205, 128, 128, 128], [201, 51, 219, 255, 196, 186, 128, 128, 128, 128, 128], [69, 46, 190, 239, 201, 218, 255, 228, 128, 128, 128]], [[1, 191, 251, 255, 255, 128, 128, 128, 128, 128, 128], [223, 165, 249, 255, 213, 255, 128, 128, 128, 128, 128], [141, 124, 248, 255, 255, 128, 128, 128, 128, 128, 128]], [[1, 16, 248, 255, 255, 128, 128, 128, 128, 128, 128], [190, 36, 230, 255, 236, 255, 128, 128, 128, 128, 128], [149, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128]], [[1, 226, 255, 128, 128, 128, 128, 128, 128, 128, 128], [247, 192, 255, 128, 128, 128, 128, 128, 128, 128, 128], [240, 128, 255, 128, 128, 128, 128, 128, 128, 128, 128]], [[1, 134, 252, 255, 255, 128, 128, 128, 128, 128, 128], [213, 62, 250, 255, 255, 128, 128, 128, 128, 128, 128], [55, 93, 255, 128, 128, 128, 128, 128, 128, 128, 128]], [[128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128], [128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128], [128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128]]], [[[202, 24, 213, 235, 186, 191, 220, 160, 240, 175, 255], [126, 38, 182, 232, 169, 184, 228, 174, 255, 187, 128], [61, 46, 138, 219, 151, 178, 240, 170, 255, 216, 128]], [[1, 112, 230, 250, 199, 191, 247, 159, 255, 255, 128], [166, 109, 228, 252, 211, 215, 255, 174, 128, 128, 128], [39, 77, 162, 232, 172, 180, 245, 178, 255, 255, 128]], [[1, 52, 220, 246, 198, 199, 249, 220, 255, 255, 128], [124, 74, 191, 243, 183, 193, 250, 221, 255, 255, 128], [24, 71, 130, 219, 154, 170, 243, 182, 255, 255, 128]], [[1, 182, 225, 249, 219, 240, 255, 224, 128, 128, 128], [149, 150, 226, 252, 216, 205, 255, 171, 128, 128, 128], [28, 108, 170, 242, 183, 194, 254, 223, 255, 255, 128]], [[1, 81, 230, 252, 204, 203, 255, 192, 128, 128, 128], [123, 102, 209, 247, 188, 196, 255, 233, 128, 128, 128], [20, 95, 153, 243, 164, 173, 255, 203, 128, 128, 128]], [[1, 222, 248, 255, 216, 213, 128, 128, 128, 128, 128], [168, 175, 246, 252, 235, 205, 255, 255, 128, 128, 128], [47, 116, 215, 255, 211, 212, 255, 255, 128, 128, 128]], [[1, 121, 236, 253, 212, 214, 255, 255, 128, 128, 128], [141, 84, 213, 252, 201, 202, 255, 219, 128, 128, 128], [42, 80, 160, 240, 162, 185, 255, 205, 128, 128, 128]], [[1, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128], [244, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128], [238, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128]]]], ci = [[[231, 120, 48, 89, 115, 113, 120, 152, 112], [152, 179, 64, 126, 170, 118, 46, 70, 95], [175, 69, 143, 80, 85, 82, 72, 155, 103], [56, 58, 10, 171, 218, 189, 17, 13, 152], [114, 26, 17, 163, 44, 195, 21, 10, 173], [121, 24, 80, 195, 26, 62, 44, 64, 85], [144, 71, 10, 38, 171, 213, 144, 34, 26], [170, 46, 55, 19, 136, 160, 33, 206, 71], [63, 20, 8, 114, 114, 208, 12, 9, 226], [81, 40, 11, 96, 182, 84, 29, 16, 36]], [[134, 183, 89, 137, 98, 101, 106, 165, 148], [72, 187, 100, 130, 157, 111, 32, 75, 80], [66, 102, 167, 99, 74, 62, 40, 234, 128], [41, 53, 9, 178, 241, 141, 26, 8, 107], [74, 43, 26, 146, 73, 166, 49, 23, 157], [65, 38, 105, 160, 51, 52, 31, 115, 128], [104, 79, 12, 27, 217, 255, 87, 17, 7], [87, 68, 71, 44, 114, 51, 15, 186, 23], [47, 41, 14, 110, 182, 183, 21, 17, 194], [66, 45, 25, 102, 197, 189, 23, 18, 22]], [[88, 88, 147, 150, 42, 46, 45, 196, 205], [43, 97, 183, 117, 85, 38, 35, 179, 61], [39, 53, 200, 87, 26, 21, 43, 232, 171], [56, 34, 51, 104, 114, 102, 29, 93, 77], [39, 28, 85, 171, 58, 165, 90, 98, 64], [34, 22, 116, 206, 23, 34, 43, 166, 73], [107, 54, 32, 26, 51, 1, 81, 43, 31], [68, 25, 106, 22, 64, 171, 36, 225, 114], [34, 19, 21, 102, 132, 188, 16, 76, 124], [62, 18, 78, 95, 85, 57, 50, 48, 51]], [[193, 101, 35, 159, 215, 111, 89, 46, 111], [60, 148, 31, 172, 219, 228, 21, 18, 111], [112, 113, 77, 85, 179, 255, 38, 120, 114], [40, 42, 1, 196, 245, 209, 10, 25, 109], [88, 43, 29, 140, 166, 213, 37, 43, 154], [61, 63, 30, 155, 67, 45, 68, 1, 209], [100, 80, 8, 43, 154, 1, 51, 26, 71], [142, 78, 78, 16, 255, 128, 34, 197, 171], [41, 40, 5, 102, 211, 183, 4, 1, 221], [51, 50, 17, 168, 209, 192, 23, 25, 82]], [[138, 31, 36, 171, 27, 166, 38, 44, 229], [67, 87, 58, 169, 82, 115, 26, 59, 179], [63, 59, 90, 180, 59, 166, 93, 73, 154], [40, 40, 21, 116, 143, 209, 34, 39, 175], [47, 15, 16, 183, 34, 223, 49, 45, 183], [46, 17, 33, 183, 6, 98, 15, 32, 183], [57, 46, 22, 24, 128, 1, 54, 17, 37], [65, 32, 73, 115, 28, 128, 23, 128, 205], [40, 3, 9, 115, 51, 192, 18, 6, 223], [87, 37, 9, 115, 59, 77, 64, 21, 47]], [[104, 55, 44, 218, 9, 54, 53, 130, 226], [64, 90, 70, 205, 40, 41, 23, 26, 57], [54, 57, 112, 184, 5, 41, 38, 166, 213], [30, 34, 26, 133, 152, 116, 10, 32, 134], [39, 19, 53, 221, 26, 114, 32, 73, 255], [31, 9, 65, 234, 2, 15, 1, 118, 73], [75, 32, 12, 51, 192, 255, 160, 43, 51], [88, 31, 35, 67, 102, 85, 55, 186, 85], [56, 21, 23, 111, 59, 205, 45, 37, 192], [55, 38, 70, 124, 73, 102, 1, 34, 98]], [[125, 98, 42, 88, 104, 85, 117, 175, 82], [95, 84, 53, 89, 128, 100, 113, 101, 45], [75, 79, 123, 47, 51, 128, 81, 171, 1], [57, 17, 5, 71, 102, 57, 53, 41, 49], [38, 33, 13, 121, 57, 73, 26, 1, 85], [41, 10, 67, 138, 77, 110, 90, 47, 114], [115, 21, 2, 10, 102, 255, 166, 23, 6], [101, 29, 16, 10, 85, 128, 101, 196, 26], [57, 18, 10, 102, 102, 213, 34, 20, 43], [117, 20, 15, 36, 163, 128, 68, 1, 26]], [[102, 61, 71, 37, 34, 53, 31, 243, 192], [69, 60, 71, 38, 73, 119, 28, 222, 37], [68, 45, 128, 34, 1, 47, 11, 245, 171], [62, 17, 19, 70, 146, 85, 55, 62, 70], [37, 43, 37, 154, 100, 163, 85, 160, 1], [63, 9, 92, 136, 28, 64, 32, 201, 85], [75, 15, 9, 9, 64, 255, 184, 119, 16], [86, 6, 28, 5, 64, 255, 25, 248, 1], [56, 8, 17, 132, 137, 255, 55, 116, 128], [58, 15, 20, 82, 135, 57, 26, 121, 40]], [[164, 50, 31, 137, 154, 133, 25, 35, 218], [51, 103, 44, 131, 131, 123, 31, 6, 158], [86, 40, 64, 135, 148, 224, 45, 183, 128], [22, 26, 17, 131, 240, 154, 14, 1, 209], [45, 16, 21, 91, 64, 222, 7, 1, 197], [56, 21, 39, 155, 60, 138, 23, 102, 213], [83, 12, 13, 54, 192, 255, 68, 47, 28], [85, 26, 85, 85, 128, 128, 32, 146, 171], [18, 11, 7, 63, 144, 171, 4, 4, 246], [35, 27, 10, 146, 174, 171, 12, 26, 128]], [[190, 80, 35, 99, 180, 80, 126, 54, 45], [85, 126, 47, 87, 176, 51, 41, 20, 32], [101, 75, 128, 139, 118, 146, 116, 128, 85], [56, 41, 15, 176, 236, 85, 37, 9, 62], [71, 30, 17, 119, 118, 255, 17, 18, 138], [101, 38, 60, 138, 55, 70, 43, 26, 142], [146, 36, 19, 30, 171, 255, 97, 27, 20], [138, 45, 61, 62, 219, 1, 81, 188, 64], [32, 41, 20, 117, 151, 142, 20, 21, 163], [112, 19, 12, 61, 195, 128, 48, 4, 24]]], ui = [[[[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[176, 246, 255, 255, 255, 255, 255, 255, 255, 255, 255], [223, 241, 252, 255, 255, 255, 255, 255, 255, 255, 255], [249, 253, 253, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 244, 252, 255, 255, 255, 255, 255, 255, 255, 255], [234, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255], [253, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 246, 254, 255, 255, 255, 255, 255, 255, 255, 255], [239, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255], [254, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 248, 254, 255, 255, 255, 255, 255, 255, 255, 255], [251, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255], [251, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255], [254, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 254, 253, 255, 254, 255, 255, 255, 255, 255, 255], [250, 255, 254, 255, 254, 255, 255, 255, 255, 255, 255], [254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]]], [[[217, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [225, 252, 241, 253, 255, 255, 254, 255, 255, 255, 255], [234, 250, 241, 250, 253, 255, 253, 254, 255, 255, 255]], [[255, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255], [223, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255], [238, 253, 254, 254, 255, 255, 255, 255, 255, 255, 255]], [[255, 248, 254, 255, 255, 255, 255, 255, 255, 255, 255], [249, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 253, 255, 255, 255, 255, 255, 255, 255, 255, 255], [247, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255], [252, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255], [253, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 254, 253, 255, 255, 255, 255, 255, 255, 255, 255], [250, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]]], [[[186, 251, 250, 255, 255, 255, 255, 255, 255, 255, 255], [234, 251, 244, 254, 255, 255, 255, 255, 255, 255, 255], [251, 251, 243, 253, 254, 255, 254, 255, 255, 255, 255]], [[255, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255], [236, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255], [251, 253, 253, 254, 254, 255, 255, 255, 255, 255, 255]], [[255, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255], [254, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255], [254, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255], [254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]]], [[[248, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [250, 254, 252, 254, 255, 255, 255, 255, 255, 255, 255], [248, 254, 249, 253, 255, 255, 255, 255, 255, 255, 255]], [[255, 253, 253, 255, 255, 255, 255, 255, 255, 255, 255], [246, 253, 253, 255, 255, 255, 255, 255, 255, 255, 255], [252, 254, 251, 254, 254, 255, 255, 255, 255, 255, 255]], [[255, 254, 252, 255, 255, 255, 255, 255, 255, 255, 255], [248, 254, 253, 255, 255, 255, 255, 255, 255, 255, 255], [253, 255, 254, 254, 255, 255, 255, 255, 255, 255, 255]], [[255, 251, 254, 255, 255, 255, 255, 255, 255, 255, 255], [245, 251, 254, 255, 255, 255, 255, 255, 255, 255, 255], [253, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 251, 253, 255, 255, 255, 255, 255, 255, 255, 255], [252, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255], [255, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 252, 255, 255, 255, 255, 255, 255, 255, 255, 255], [249, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 253, 255, 255, 255, 255, 255, 255, 255, 255], [250, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]]]], hi = [0, 1, 2, 3, 6, 4, 5, 6, 6, 6, 6, 6, 6, 6, 6, 7, 0], li = [], fi = [], di = [], pi = 1, gi = 2, mi = [], vi = [];
    vr("UpsampleRgbLinePair", Ar, 3), vr("UpsampleBgrLinePair", xr, 3), vr("UpsampleRgbaLinePair", Ir, 4), vr("UpsampleBgraLinePair", kr, 4), vr("UpsampleArgbLinePair", Pr, 4), vr("UpsampleRgba4444LinePair", _r, 2), vr("UpsampleRgb565LinePair", Sr, 2);
    var bi = t3.UpsampleRgbLinePair, yi = t3.UpsampleBgrLinePair, wi = t3.UpsampleRgbaLinePair, Ni = t3.UpsampleBgraLinePair, Li = t3.UpsampleArgbLinePair, Ai = t3.UpsampleRgba4444LinePair, xi = t3.UpsampleRgb565LinePair, Si = 16, _i = 1 << Si - 1, Pi = -227, ki = 482, Ii = 6, Fi = (256 << Ii) - 1, Ci = 0, ji = a2(256), Oi = a2(256), Bi = a2(256), Mi = a2(256), Ei = a2(ki - Pi), qi = a2(ki - Pi);
    Fr("YuvToRgbRow", Ar, 3), Fr("YuvToBgrRow", xr, 3), Fr("YuvToRgbaRow", Ir, 4), Fr("YuvToBgraRow", kr, 4), Fr("YuvToArgbRow", Pr, 4), Fr("YuvToRgba4444Row", _r, 2), Fr("YuvToRgb565Row", Sr, 2);
    var Di = [0, 4, 8, 12, 128, 132, 136, 140, 256, 260, 264, 268, 384, 388, 392, 396], Ri = [0, 2, 8], Ti = [8, 7, 6, 4, 4, 2, 2, 2, 1, 1, 1, 1], Ui = 1;
    this.WebPDecodeRGBA = function(t4, r2, n3, i3, a3) {
      var o3 = qn, s3 = new rr(), c4 = new ot2();
      s3.ba = c4, c4.S = o3, c4.width = [c4.width], c4.height = [c4.height];
      var u4 = c4.width, h5 = c4.height, l4 = new st2();
      if (null == l4 || null == t4)
        var f4 = 2;
      else
        e(null != l4), f4 = Br(t4, r2, n3, l4.width, l4.height, l4.Pd, l4.Qd, l4.format, null);
      if (0 != f4 ? u4 = 0 : (null != u4 && (u4[0] = l4.width[0]), null != h5 && (h5[0] = l4.height[0]), u4 = 1), u4) {
        c4.width = c4.width[0], c4.height = c4.height[0], null != i3 && (i3[0] = c4.width), null != a3 && (a3[0] = c4.height);
        t: {
          if (i3 = new Gt2(), (a3 = new nr()).data = t4, a3.w = r2, a3.ha = n3, a3.kd = 1, r2 = [0], e(null != a3), (0 == (t4 = Br(a3.data, a3.w, a3.ha, null, null, null, r2, null, a3)) || 7 == t4) && r2[0] && (t4 = 4), 0 == (r2 = t4)) {
            if (e(null != s3), i3.data = a3.data, i3.w = a3.w + a3.offset, i3.ha = a3.ha - a3.offset, i3.put = dt2, i3.ac = ft2, i3.bc = pt2, i3.ma = s3, a3.xa) {
              if (null == (t4 = kt2())) {
                s3 = 1;
                break t;
              }
              if (function(t5, r3) {
                var n4 = [0], i4 = [0], a4 = [0];
                e:
                  for (; ; ) {
                    if (null == t5)
                      return 0;
                    if (null == r3)
                      return t5.a = 2, 0;
                    if (t5.l = r3, t5.a = 0, v3(t5.m, r3.data, r3.w, r3.ha), !gt2(t5.m, n4, i4, a4)) {
                      t5.a = 3;
                      break e;
                    }
                    if (t5.xb = gi, r3.width = n4[0], r3.height = i4[0], !It2(n4[0], i4[0], 1, t5, null))
                      break e;
                    return 1;
                  }
                return e(0 != t5.a), 0;
              }(t4, i3)) {
                if (i3 = 0 == (r2 = qr(i3.width, i3.height, s3.Oa, s3.ba))) {
                  e: {
                    i3 = t4;
                    r:
                      for (; ; ) {
                        if (null == i3) {
                          i3 = 0;
                          break e;
                        }
                        if (e(null != i3.s.yc), e(null != i3.s.Ya), e(0 < i3.s.Wb), e(null != (n3 = i3.l)), e(null != (a3 = n3.ma)), 0 != i3.xb) {
                          if (i3.ca = a3.ba, i3.tb = a3.tb, e(null != i3.ca), !Mr(a3.Oa, n3, Rn)) {
                            i3.a = 2;
                            break r;
                          }
                          if (!Ft2(i3, n3.width))
                            break r;
                          if (n3.da)
                            break r;
                          if ((n3.da || nt2(i3.ca.S)) && mr(), 11 > i3.ca.S || (alert("todo:WebPInitConvertARGBToYUV"), null != i3.ca.f.kb.F && mr()), i3.Pb && 0 < i3.s.ua && null == i3.s.vb.X && !O2(i3.s.vb, i3.s.Wa.Xa)) {
                            i3.a = 1;
                            break r;
                          }
                          i3.xb = 0;
                        }
                        if (!_t2(i3, i3.V, i3.Ba, i3.c, i3.i, n3.o, Lt2))
                          break r;
                        a3.Dc = i3.Ma, i3 = 1;
                        break e;
                      }
                    e(0 != i3.a), i3 = 0;
                  }
                  i3 = !i3;
                }
                i3 && (r2 = t4.a);
              } else
                r2 = t4.a;
            } else {
              if (null == (t4 = new Yt2())) {
                s3 = 1;
                break t;
              }
              if (t4.Fa = a3.na, t4.P = a3.P, t4.qc = a3.Sa, Kt2(t4, i3)) {
                if (0 == (r2 = qr(i3.width, i3.height, s3.Oa, s3.ba))) {
                  if (t4.Aa = 0, n3 = s3.Oa, e(null != (a3 = t4)), null != n3) {
                    if (0 < (u4 = 0 > (u4 = n3.Md) ? 0 : 100 < u4 ? 255 : 255 * u4 / 100)) {
                      for (h5 = l4 = 0; 4 > h5; ++h5)
                        12 > (f4 = a3.pb[h5]).lc && (f4.ia = u4 * Ti[0 > f4.lc ? 0 : f4.lc] >> 3), l4 |= f4.ia;
                      l4 && (alert("todo:VP8InitRandom"), a3.ia = 1);
                    }
                    a3.Ga = n3.Id, 100 < a3.Ga ? a3.Ga = 100 : 0 > a3.Ga && (a3.Ga = 0);
                  }
                  Qt2(t4, i3) || (r2 = t4.a);
                }
              } else
                r2 = t4.a;
            }
            0 == r2 && null != s3.Oa && s3.Oa.fd && (r2 = Er(s3.ba));
          }
          s3 = r2;
        }
        o3 = 0 != s3 ? null : 11 > o3 ? c4.f.RGBA.eb : c4.f.kb.y;
      } else
        o3 = null;
      return o3;
    };
    var zi = [3, 4, 3, 4, 4, 2, 2, 4, 4, 4, 2, 1, 1];
  }, "c");
  function u2(t3, e2) {
    for (var r2 = "", n3 = 0; n3 < 4; n3++)
      r2 += String.fromCharCode(t3[e2++]);
    return r2;
  }
  __name(u2, "u");
  function h3(t3, e2) {
    return (t3[e2 + 0] << 0 | t3[e2 + 1] << 8 | t3[e2 + 2] << 16) >>> 0;
  }
  __name(h3, "h");
  function l2(t3, e2) {
    return (t3[e2 + 0] << 0 | t3[e2 + 1] << 8 | t3[e2 + 2] << 16 | t3[e2 + 3] << 24) >>> 0;
  }
  __name(l2, "l");
  new c2();
  var f2 = [0], d2 = [0], p2 = [], g2 = new c2(), m2 = t2, v2 = function(t3, e2) {
    var r2 = {}, n3 = 0, i3 = false, a3 = 0, o3 = 0;
    if (r2.frames = [], !/** @license
       * Copyright (c) 2017 Dominik Homberger
      Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
      The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
      THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
      https://webpjs.appspot.com
      WebPRiffParser dominikhlbg@gmail.com
      */
    function(t4, e3, r3, n4) {
      for (var i4 = 0; i4 < n4; i4++)
        if (t4[e3 + i4] != r3.charCodeAt(i4))
          return true;
      return false;
    }(t3, e2, "RIFF", 4)) {
      var s3, c3;
      l2(t3, e2 += 4);
      for (e2 += 8; e2 < t3.length; ) {
        var f3 = u2(t3, e2), d3 = l2(t3, e2 += 4);
        e2 += 4;
        var p3 = d3 + (1 & d3);
        switch (f3) {
          case "VP8 ":
          case "VP8L":
            void 0 === r2.frames[n3] && (r2.frames[n3] = {});
            (v3 = r2.frames[n3]).src_off = i3 ? o3 : e2 - 8, v3.src_size = a3 + d3 + 8, n3++, i3 && (i3 = false, a3 = 0, o3 = 0);
            break;
          case "VP8X":
            (v3 = r2.header = {}).feature_flags = t3[e2];
            var g3 = e2 + 4;
            v3.canvas_width = 1 + h3(t3, g3);
            g3 += 3;
            v3.canvas_height = 1 + h3(t3, g3);
            g3 += 3;
            break;
          case "ALPH":
            i3 = true, a3 = p3 + 8, o3 = e2 - 8;
            break;
          case "ANIM":
            (v3 = r2.header).bgcolor = l2(t3, e2);
            g3 = e2 + 4;
            v3.loop_count = (s3 = t3)[(c3 = g3) + 0] << 0 | s3[c3 + 1] << 8;
            g3 += 2;
            break;
          case "ANMF":
            var m3, v3;
            (v3 = r2.frames[n3] = {}).offset_x = 2 * h3(t3, e2), e2 += 3, v3.offset_y = 2 * h3(t3, e2), e2 += 3, v3.width = 1 + h3(t3, e2), e2 += 3, v3.height = 1 + h3(t3, e2), e2 += 3, v3.duration = h3(t3, e2), e2 += 3, m3 = t3[e2++], v3.dispose = 1 & m3, v3.blend = m3 >> 1 & 1;
        }
        "ANMF" != f3 && (e2 += p3);
      }
      return r2;
    }
  }(m2, 0);
  v2.response = m2, v2.rgbaoutput = true, v2.dataurl = false;
  var b2 = v2.header ? v2.header : null, y2 = v2.frames ? v2.frames : null;
  if (b2) {
    b2.loop_counter = b2.loop_count, f2 = [b2.canvas_height], d2 = [b2.canvas_width];
    for (var w2 = 0; w2 < y2.length && 0 != y2[w2].blend; w2++)
      ;
  }
  var N2 = y2[0], L2 = g2.WebPDecodeRGBA(m2, N2.src_off, N2.src_size, d2, f2);
  N2.rgba = L2, N2.imgwidth = d2[0], N2.imgheight = f2[0];
  for (var A2 = 0; A2 < d2[0] * f2[0] * 4; A2++)
    p2[A2] = L2[A2];
  return this.width = d2, this.height = f2, this.data = p2, this;
}
__name(ee, "ee");
!function(t2) {
  var r = /* @__PURE__ */ __name(function() {
    return "function" == typeof zlibSync;
  }, "r"), n2 = /* @__PURE__ */ __name(function(r2, n3, a3, h4) {
    var l3 = 4, f3 = s2;
    switch (h4) {
      case t2.image_compression.FAST:
        l3 = 1, f3 = o2;
        break;
      case t2.image_compression.MEDIUM:
        l3 = 6, f3 = c2;
        break;
      case t2.image_compression.SLOW:
        l3 = 9, f3 = u2;
    }
    r2 = i2(r2, n3, a3, f3);
    var d2 = zlibSync(r2, { level: l3 });
    return t2.__addimage__.arrayBufferToBinaryString(d2);
  }, "n"), i2 = /* @__PURE__ */ __name(function(t3, e, r2, n3) {
    for (var i3, a3, o3, s3 = t3.length / e, c3 = new Uint8Array(t3.length + s3), u3 = l2(), h4 = 0; h4 < s3; h4 += 1) {
      if (o3 = h4 * e, i3 = t3.subarray(o3, o3 + e), n3)
        c3.set(n3(i3, r2, a3), o3 + h4);
      else {
        for (var d2, p2 = u3.length, g2 = []; d2 < p2; d2 += 1)
          g2[d2] = u3[d2](i3, r2, a3);
        var m2 = f2(g2.concat());
        c3.set(g2[m2], o3 + h4);
      }
      a3 = i3;
    }
    return c3;
  }, "i"), a2 = /* @__PURE__ */ __name(function(t3) {
    var e = Array.apply([], t3);
    return e.unshift(0), e;
  }, "a"), o2 = /* @__PURE__ */ __name(function(t3, e) {
    var r2, n3 = [], i3 = t3.length;
    n3[0] = 1;
    for (var a3 = 0; a3 < i3; a3 += 1)
      r2 = t3[a3 - e] || 0, n3[a3 + 1] = t3[a3] - r2 + 256 & 255;
    return n3;
  }, "o"), s2 = /* @__PURE__ */ __name(function(t3, e, r2) {
    var n3, i3 = [], a3 = t3.length;
    i3[0] = 2;
    for (var o3 = 0; o3 < a3; o3 += 1)
      n3 = r2 && r2[o3] || 0, i3[o3 + 1] = t3[o3] - n3 + 256 & 255;
    return i3;
  }, "s"), c2 = /* @__PURE__ */ __name(function(t3, e, r2) {
    var n3, i3, a3 = [], o3 = t3.length;
    a3[0] = 3;
    for (var s3 = 0; s3 < o3; s3 += 1)
      n3 = t3[s3 - e] || 0, i3 = r2 && r2[s3] || 0, a3[s3 + 1] = t3[s3] + 256 - (n3 + i3 >>> 1) & 255;
    return a3;
  }, "c"), u2 = /* @__PURE__ */ __name(function(t3, e, r2) {
    var n3, i3, a3, o3, s3 = [], c3 = t3.length;
    s3[0] = 4;
    for (var u3 = 0; u3 < c3; u3 += 1)
      n3 = t3[u3 - e] || 0, i3 = r2 && r2[u3] || 0, a3 = r2 && r2[u3 - e] || 0, o3 = h3(n3, i3, a3), s3[u3 + 1] = t3[u3] - o3 + 256 & 255;
    return s3;
  }, "u"), h3 = /* @__PURE__ */ __name(function(t3, e, r2) {
    if (t3 === e && e === r2)
      return t3;
    var n3 = Math.abs(e - r2), i3 = Math.abs(t3 - r2), a3 = Math.abs(t3 + e - r2 - r2);
    return n3 <= i3 && n3 <= a3 ? t3 : i3 <= a3 ? e : r2;
  }, "h"), l2 = /* @__PURE__ */ __name(function() {
    return [a2, o2, s2, c2, u2];
  }, "l"), f2 = /* @__PURE__ */ __name(function(t3) {
    var e = t3.map(function(t4) {
      return t4.reduce(function(t5, e2) {
        return t5 + Math.abs(e2);
      }, 0);
    });
    return e.indexOf(Math.min.apply(null, e));
  }, "f");
  t2.processPNG = function(e, i3, a3, o3) {
    var s3, c3, u3, h4, l3, f3, d2, p2, g2, m2, v2, b2, y2, w2, N2, L2 = this.decode.FLATE_DECODE, A2 = "";
    if (this.__addimage__.isArrayBuffer(e) && (e = new Uint8Array(e)), this.__addimage__.isArrayBufferView(e)) {
      if (e = (u3 = new Kt(e)).imgData, c3 = u3.bits, s3 = u3.colorSpace, l3 = u3.colors, -1 !== [4, 6].indexOf(u3.colorType)) {
        if (8 === u3.bits) {
          g2 = (p2 = 32 == u3.pixelBitlength ? new Uint32Array(u3.decodePixels().buffer) : 16 == u3.pixelBitlength ? new Uint16Array(u3.decodePixels().buffer) : new Uint8Array(u3.decodePixels().buffer)).length, v2 = new Uint8Array(g2 * u3.colors), m2 = new Uint8Array(g2);
          var x2, S2 = u3.pixelBitlength - u3.bits;
          for (w2 = 0, N2 = 0; w2 < g2; w2++) {
            for (y2 = p2[w2], x2 = 0; x2 < S2; )
              v2[N2++] = y2 >>> x2 & 255, x2 += u3.bits;
            m2[w2] = y2 >>> x2 & 255;
          }
        }
        if (16 === u3.bits) {
          g2 = (p2 = new Uint32Array(u3.decodePixels().buffer)).length, v2 = new Uint8Array(g2 * (32 / u3.pixelBitlength) * u3.colors), m2 = new Uint8Array(g2 * (32 / u3.pixelBitlength)), b2 = u3.colors > 1, w2 = 0, N2 = 0;
          for (var _2 = 0; w2 < g2; )
            y2 = p2[w2++], v2[N2++] = y2 >>> 0 & 255, b2 && (v2[N2++] = y2 >>> 16 & 255, y2 = p2[w2++], v2[N2++] = y2 >>> 0 & 255), m2[_2++] = y2 >>> 16 & 255;
          c3 = 8;
        }
        o3 !== t2.image_compression.NONE && r() ? (e = n2(v2, u3.width * u3.colors, u3.colors, o3), d2 = n2(m2, u3.width, 1, o3)) : (e = v2, d2 = m2, L2 = void 0);
      }
      if (3 === u3.colorType && (s3 = this.color_spaces.INDEXED, f3 = u3.palette, u3.transparency.indexed)) {
        var P2 = u3.transparency.indexed, k2 = 0;
        for (w2 = 0, g2 = P2.length; w2 < g2; ++w2)
          k2 += P2[w2];
        if ((k2 /= 255) === g2 - 1 && -1 !== P2.indexOf(0))
          h4 = [P2.indexOf(0)];
        else if (k2 !== g2) {
          for (p2 = u3.decodePixels(), m2 = new Uint8Array(p2.length), w2 = 0, g2 = p2.length; w2 < g2; w2++)
            m2[w2] = P2[p2[w2]];
          d2 = n2(m2, u3.width, 1);
        }
      }
      var I2 = function(e2) {
        var r2;
        switch (e2) {
          case t2.image_compression.FAST:
            r2 = 11;
            break;
          case t2.image_compression.MEDIUM:
            r2 = 13;
            break;
          case t2.image_compression.SLOW:
            r2 = 14;
            break;
          default:
            r2 = 12;
        }
        return r2;
      }(o3);
      return L2 === this.decode.FLATE_DECODE && (A2 = "/Predictor " + I2 + " "), A2 += "/Colors " + l3 + " /BitsPerComponent " + c3 + " /Columns " + u3.width, (this.__addimage__.isArrayBuffer(e) || this.__addimage__.isArrayBufferView(e)) && (e = this.__addimage__.arrayBufferToBinaryString(e)), (d2 && this.__addimage__.isArrayBuffer(d2) || this.__addimage__.isArrayBufferView(d2)) && (d2 = this.__addimage__.arrayBufferToBinaryString(d2)), { alias: a3, data: e, index: i3, filter: L2, decodeParameters: A2, transparency: h4, palette: f3, sMask: d2, predictor: I2, width: u3.width, height: u3.height, bitsPerComponent: c3, colorSpace: s3 };
    }
  };
}(E.API), function(t2) {
  t2.processGIF89A = function(e, r, n2, i2) {
    var a2 = new Zt(e), o2 = a2.width, s2 = a2.height, c2 = [];
    a2.decodeAndBlitFrameRGBA(0, c2);
    var u2 = { data: c2, width: o2, height: s2 }, h3 = new Qt(100).encode(u2, 100);
    return t2.processJPEG.call(this, h3, r, n2, i2);
  }, t2.processGIF87A = t2.processGIF89A;
}(E.API), te.prototype.parseHeader = function() {
  if (this.fileSize = this.datav.getUint32(this.pos, true), this.pos += 4, this.reserved = this.datav.getUint32(this.pos, true), this.pos += 4, this.offset = this.datav.getUint32(this.pos, true), this.pos += 4, this.headerSize = this.datav.getUint32(this.pos, true), this.pos += 4, this.width = this.datav.getUint32(this.pos, true), this.pos += 4, this.height = this.datav.getInt32(this.pos, true), this.pos += 4, this.planes = this.datav.getUint16(this.pos, true), this.pos += 2, this.bitPP = this.datav.getUint16(this.pos, true), this.pos += 2, this.compress = this.datav.getUint32(this.pos, true), this.pos += 4, this.rawSize = this.datav.getUint32(this.pos, true), this.pos += 4, this.hr = this.datav.getUint32(this.pos, true), this.pos += 4, this.vr = this.datav.getUint32(this.pos, true), this.pos += 4, this.colors = this.datav.getUint32(this.pos, true), this.pos += 4, this.importantColors = this.datav.getUint32(this.pos, true), this.pos += 4, 16 === this.bitPP && this.is_with_alpha && (this.bitPP = 15), this.bitPP < 15) {
    var t2 = 0 === this.colors ? 1 << this.bitPP : this.colors;
    this.palette = new Array(t2);
    for (var e = 0; e < t2; e++) {
      var r = this.datav.getUint8(this.pos++, true), n2 = this.datav.getUint8(this.pos++, true), i2 = this.datav.getUint8(this.pos++, true), a2 = this.datav.getUint8(this.pos++, true);
      this.palette[e] = { red: i2, green: n2, blue: r, quad: a2 };
    }
  }
  this.height < 0 && (this.height *= -1, this.bottom_up = false);
}, te.prototype.parseBGR = function() {
  this.pos = this.offset;
  try {
    var t2 = "bit" + this.bitPP, e = this.width * this.height * 4;
    this.data = new Uint8Array(e), this[t2]();
  } catch (t3) {
    a.log("bit decode error:" + t3);
  }
}, te.prototype.bit1 = function() {
  var t2, e = Math.ceil(this.width / 8), r = e % 4;
  for (t2 = this.height - 1; t2 >= 0; t2--) {
    for (var n2 = this.bottom_up ? t2 : this.height - 1 - t2, i2 = 0; i2 < e; i2++)
      for (var a2 = this.datav.getUint8(this.pos++, true), o2 = n2 * this.width * 4 + 8 * i2 * 4, s2 = 0; s2 < 8 && 8 * i2 + s2 < this.width; s2++) {
        var c2 = this.palette[a2 >> 7 - s2 & 1];
        this.data[o2 + 4 * s2] = c2.blue, this.data[o2 + 4 * s2 + 1] = c2.green, this.data[o2 + 4 * s2 + 2] = c2.red, this.data[o2 + 4 * s2 + 3] = 255;
      }
    0 !== r && (this.pos += 4 - r);
  }
}, te.prototype.bit4 = function() {
  for (var t2 = Math.ceil(this.width / 2), e = t2 % 4, r = this.height - 1; r >= 0; r--) {
    for (var n2 = this.bottom_up ? r : this.height - 1 - r, i2 = 0; i2 < t2; i2++) {
      var a2 = this.datav.getUint8(this.pos++, true), o2 = n2 * this.width * 4 + 2 * i2 * 4, s2 = a2 >> 4, c2 = 15 & a2, u2 = this.palette[s2];
      if (this.data[o2] = u2.blue, this.data[o2 + 1] = u2.green, this.data[o2 + 2] = u2.red, this.data[o2 + 3] = 255, 2 * i2 + 1 >= this.width)
        break;
      u2 = this.palette[c2], this.data[o2 + 4] = u2.blue, this.data[o2 + 4 + 1] = u2.green, this.data[o2 + 4 + 2] = u2.red, this.data[o2 + 4 + 3] = 255;
    }
    0 !== e && (this.pos += 4 - e);
  }
}, te.prototype.bit8 = function() {
  for (var t2 = this.width % 4, e = this.height - 1; e >= 0; e--) {
    for (var r = this.bottom_up ? e : this.height - 1 - e, n2 = 0; n2 < this.width; n2++) {
      var i2 = this.datav.getUint8(this.pos++, true), a2 = r * this.width * 4 + 4 * n2;
      if (i2 < this.palette.length) {
        var o2 = this.palette[i2];
        this.data[a2] = o2.red, this.data[a2 + 1] = o2.green, this.data[a2 + 2] = o2.blue, this.data[a2 + 3] = 255;
      } else
        this.data[a2] = 255, this.data[a2 + 1] = 255, this.data[a2 + 2] = 255, this.data[a2 + 3] = 255;
    }
    0 !== t2 && (this.pos += 4 - t2);
  }
}, te.prototype.bit15 = function() {
  for (var t2 = this.width % 3, e = parseInt("11111", 2), r = this.height - 1; r >= 0; r--) {
    for (var n2 = this.bottom_up ? r : this.height - 1 - r, i2 = 0; i2 < this.width; i2++) {
      var a2 = this.datav.getUint16(this.pos, true);
      this.pos += 2;
      var o2 = (a2 & e) / e * 255 | 0, s2 = (a2 >> 5 & e) / e * 255 | 0, c2 = (a2 >> 10 & e) / e * 255 | 0, u2 = a2 >> 15 ? 255 : 0, h3 = n2 * this.width * 4 + 4 * i2;
      this.data[h3] = c2, this.data[h3 + 1] = s2, this.data[h3 + 2] = o2, this.data[h3 + 3] = u2;
    }
    this.pos += t2;
  }
}, te.prototype.bit16 = function() {
  for (var t2 = this.width % 3, e = parseInt("11111", 2), r = parseInt("111111", 2), n2 = this.height - 1; n2 >= 0; n2--) {
    for (var i2 = this.bottom_up ? n2 : this.height - 1 - n2, a2 = 0; a2 < this.width; a2++) {
      var o2 = this.datav.getUint16(this.pos, true);
      this.pos += 2;
      var s2 = (o2 & e) / e * 255 | 0, c2 = (o2 >> 5 & r) / r * 255 | 0, u2 = (o2 >> 11) / e * 255 | 0, h3 = i2 * this.width * 4 + 4 * a2;
      this.data[h3] = u2, this.data[h3 + 1] = c2, this.data[h3 + 2] = s2, this.data[h3 + 3] = 255;
    }
    this.pos += t2;
  }
}, te.prototype.bit24 = function() {
  for (var t2 = this.height - 1; t2 >= 0; t2--) {
    for (var e = this.bottom_up ? t2 : this.height - 1 - t2, r = 0; r < this.width; r++) {
      var n2 = this.datav.getUint8(this.pos++, true), i2 = this.datav.getUint8(this.pos++, true), a2 = this.datav.getUint8(this.pos++, true), o2 = e * this.width * 4 + 4 * r;
      this.data[o2] = a2, this.data[o2 + 1] = i2, this.data[o2 + 2] = n2, this.data[o2 + 3] = 255;
    }
    this.pos += this.width % 4;
  }
}, te.prototype.bit32 = function() {
  for (var t2 = this.height - 1; t2 >= 0; t2--)
    for (var e = this.bottom_up ? t2 : this.height - 1 - t2, r = 0; r < this.width; r++) {
      var n2 = this.datav.getUint8(this.pos++, true), i2 = this.datav.getUint8(this.pos++, true), a2 = this.datav.getUint8(this.pos++, true), o2 = this.datav.getUint8(this.pos++, true), s2 = e * this.width * 4 + 4 * r;
      this.data[s2] = a2, this.data[s2 + 1] = i2, this.data[s2 + 2] = n2, this.data[s2 + 3] = o2;
    }
}, te.prototype.getData = function() {
  return this.data;
}, /**
 * @license
 * Copyright (c) 2018 Aras Abbasi
 *
 * Licensed under the MIT License.
 * http://opensource.org/licenses/mit-license
 */
function(t2) {
  t2.processBMP = function(e, r, n2, i2) {
    var a2 = new te(e, false), o2 = a2.width, s2 = a2.height, c2 = { data: a2.getData(), width: o2, height: s2 }, u2 = new Qt(100).encode(c2, 100);
    return t2.processJPEG.call(this, u2, r, n2, i2);
  };
}(E.API), ee.prototype.getData = function() {
  return this.data;
}, /**
 * @license
 * Copyright (c) 2019 Aras Abbasi
 *
 * Licensed under the MIT License.
 * http://opensource.org/licenses/mit-license
 */
function(t2) {
  t2.processWEBP = function(e, r, n2, i2) {
    var a2 = new ee(e), o2 = a2.width, s2 = a2.height, c2 = { data: a2.getData(), width: o2, height: s2 }, u2 = new Qt(100).encode(c2, 100);
    return t2.processJPEG.call(this, u2, r, n2, i2);
  };
}(E.API), E.API.processRGBA = function(t2, e, r) {
  for (var n2 = t2.data, i2 = n2.length, a2 = new Uint8Array(i2 / 4 * 3), o2 = new Uint8Array(i2 / 4), s2 = 0, c2 = 0, u2 = 0; u2 < i2; u2 += 4) {
    var h3 = n2[u2], l2 = n2[u2 + 1], f2 = n2[u2 + 2], d2 = n2[u2 + 3];
    a2[s2++] = h3, a2[s2++] = l2, a2[s2++] = f2, o2[c2++] = d2;
  }
  var p2 = this.__addimage__.arrayBufferToBinaryString(a2);
  return { alpha: this.__addimage__.arrayBufferToBinaryString(o2), data: p2, index: e, alias: r, colorSpace: "DeviceRGB", bitsPerComponent: 8, width: t2.width, height: t2.height };
}, E.API.setLanguage = function(t2) {
  return void 0 === this.internal.languageSettings && (this.internal.languageSettings = {}, this.internal.languageSettings.isSubscribed = false), void 0 !== { af: "Afrikaans", sq: "Albanian", ar: "Arabic (Standard)", "ar-DZ": "Arabic (Algeria)", "ar-BH": "Arabic (Bahrain)", "ar-EG": "Arabic (Egypt)", "ar-IQ": "Arabic (Iraq)", "ar-JO": "Arabic (Jordan)", "ar-KW": "Arabic (Kuwait)", "ar-LB": "Arabic (Lebanon)", "ar-LY": "Arabic (Libya)", "ar-MA": "Arabic (Morocco)", "ar-OM": "Arabic (Oman)", "ar-QA": "Arabic (Qatar)", "ar-SA": "Arabic (Saudi Arabia)", "ar-SY": "Arabic (Syria)", "ar-TN": "Arabic (Tunisia)", "ar-AE": "Arabic (U.A.E.)", "ar-YE": "Arabic (Yemen)", an: "Aragonese", hy: "Armenian", as: "Assamese", ast: "Asturian", az: "Azerbaijani", eu: "Basque", be: "Belarusian", bn: "Bengali", bs: "Bosnian", br: "Breton", bg: "Bulgarian", my: "Burmese", ca: "Catalan", ch: "Chamorro", ce: "Chechen", zh: "Chinese", "zh-HK": "Chinese (Hong Kong)", "zh-CN": "Chinese (PRC)", "zh-SG": "Chinese (Singapore)", "zh-TW": "Chinese (Taiwan)", cv: "Chuvash", co: "Corsican", cr: "Cree", hr: "Croatian", cs: "Czech", da: "Danish", nl: "Dutch (Standard)", "nl-BE": "Dutch (Belgian)", en: "English", "en-AU": "English (Australia)", "en-BZ": "English (Belize)", "en-CA": "English (Canada)", "en-IE": "English (Ireland)", "en-JM": "English (Jamaica)", "en-NZ": "English (New Zealand)", "en-PH": "English (Philippines)", "en-ZA": "English (South Africa)", "en-TT": "English (Trinidad & Tobago)", "en-GB": "English (United Kingdom)", "en-US": "English (United States)", "en-ZW": "English (Zimbabwe)", eo: "Esperanto", et: "Estonian", fo: "Faeroese", fj: "Fijian", fi: "Finnish", fr: "French (Standard)", "fr-BE": "French (Belgium)", "fr-CA": "French (Canada)", "fr-FR": "French (France)", "fr-LU": "French (Luxembourg)", "fr-MC": "French (Monaco)", "fr-CH": "French (Switzerland)", fy: "Frisian", fur: "Friulian", gd: "Gaelic (Scots)", "gd-IE": "Gaelic (Irish)", gl: "Galacian", ka: "Georgian", de: "German (Standard)", "de-AT": "German (Austria)", "de-DE": "German (Germany)", "de-LI": "German (Liechtenstein)", "de-LU": "German (Luxembourg)", "de-CH": "German (Switzerland)", el: "Greek", gu: "Gujurati", ht: "Haitian", he: "Hebrew", hi: "Hindi", hu: "Hungarian", is: "Icelandic", id: "Indonesian", iu: "Inuktitut", ga: "Irish", it: "Italian (Standard)", "it-CH": "Italian (Switzerland)", ja: "Japanese", kn: "Kannada", ks: "Kashmiri", kk: "Kazakh", km: "Khmer", ky: "Kirghiz", tlh: "Klingon", ko: "Korean", "ko-KP": "Korean (North Korea)", "ko-KR": "Korean (South Korea)", la: "Latin", lv: "Latvian", lt: "Lithuanian", lb: "Luxembourgish", mk: "North Macedonia", ms: "Malay", ml: "Malayalam", mt: "Maltese", mi: "Maori", mr: "Marathi", mo: "Moldavian", nv: "Navajo", ng: "Ndonga", ne: "Nepali", no: "Norwegian", nb: "Norwegian (Bokmal)", nn: "Norwegian (Nynorsk)", oc: "Occitan", or: "Oriya", om: "Oromo", fa: "Persian", "fa-IR": "Persian/Iran", pl: "Polish", pt: "Portuguese", "pt-BR": "Portuguese (Brazil)", pa: "Punjabi", "pa-IN": "Punjabi (India)", "pa-PK": "Punjabi (Pakistan)", qu: "Quechua", rm: "Rhaeto-Romanic", ro: "Romanian", "ro-MO": "Romanian (Moldavia)", ru: "Russian", "ru-MO": "Russian (Moldavia)", sz: "Sami (Lappish)", sg: "Sango", sa: "Sanskrit", sc: "Sardinian", sd: "Sindhi", si: "Singhalese", sr: "Serbian", sk: "Slovak", sl: "Slovenian", so: "Somani", sb: "Sorbian", es: "Spanish", "es-AR": "Spanish (Argentina)", "es-BO": "Spanish (Bolivia)", "es-CL": "Spanish (Chile)", "es-CO": "Spanish (Colombia)", "es-CR": "Spanish (Costa Rica)", "es-DO": "Spanish (Dominican Republic)", "es-EC": "Spanish (Ecuador)", "es-SV": "Spanish (El Salvador)", "es-GT": "Spanish (Guatemala)", "es-HN": "Spanish (Honduras)", "es-MX": "Spanish (Mexico)", "es-NI": "Spanish (Nicaragua)", "es-PA": "Spanish (Panama)", "es-PY": "Spanish (Paraguay)", "es-PE": "Spanish (Peru)", "es-PR": "Spanish (Puerto Rico)", "es-ES": "Spanish (Spain)", "es-UY": "Spanish (Uruguay)", "es-VE": "Spanish (Venezuela)", sx: "Sutu", sw: "Swahili", sv: "Swedish", "sv-FI": "Swedish (Finland)", "sv-SV": "Swedish (Sweden)", ta: "Tamil", tt: "Tatar", te: "Teluga", th: "Thai", tig: "Tigre", ts: "Tsonga", tn: "Tswana", tr: "Turkish", tk: "Turkmen", uk: "Ukrainian", hsb: "Upper Sorbian", ur: "Urdu", ve: "Venda", vi: "Vietnamese", vo: "Volapuk", wa: "Walloon", cy: "Welsh", xh: "Xhosa", ji: "Yiddish", zu: "Zulu" }[t2] && (this.internal.languageSettings.languageCode = t2, false === this.internal.languageSettings.isSubscribed && (this.internal.events.subscribe("putCatalog", function() {
    this.internal.write("/Lang (" + this.internal.languageSettings.languageCode + ")");
  }), this.internal.languageSettings.isSubscribed = true)), this;
}, Vt = E.API, Gt = Vt.getCharWidthsArray = function(e, r) {
  var n2, i2, a2 = (r = r || {}).font || this.internal.getFont(), o2 = r.fontSize || this.internal.getFontSize(), s2 = r.charSpace || this.internal.getCharSpace(), c2 = r.widths ? r.widths : a2.metadata.Unicode.widths, u2 = c2.fof ? c2.fof : 1, h3 = r.kerning ? r.kerning : a2.metadata.Unicode.kerning, l2 = h3.fof ? h3.fof : 1, f2 = false !== r.doKerning, d2 = 0, p2 = e.length, g2 = 0, m2 = c2[0] || u2, v2 = [];
  for (n2 = 0; n2 < p2; n2++)
    i2 = e.charCodeAt(n2), "function" == typeof a2.metadata.widthOfString ? v2.push((a2.metadata.widthOfGlyph(a2.metadata.characterToGlyph(i2)) + s2 * (1e3 / o2) || 0) / 1e3) : (d2 = f2 && "object" === _typeof(h3[i2]) && !isNaN(parseInt(h3[i2][g2], 10)) ? h3[i2][g2] / l2 : 0, v2.push((c2[i2] || m2) / u2 + d2)), g2 = i2;
  return v2;
}, Yt = Vt.getStringUnitWidth = function(t2, e) {
  var r = (e = e || {}).fontSize || this.internal.getFontSize(), n2 = e.font || this.internal.getFont(), i2 = e.charSpace || this.internal.getCharSpace();
  return Vt.processArabic && (t2 = Vt.processArabic(t2)), "function" == typeof n2.metadata.widthOfString ? n2.metadata.widthOfString(t2, r, i2) / r : Gt.apply(this, arguments).reduce(function(t3, e2) {
    return t3 + e2;
  }, 0);
}, Jt = /* @__PURE__ */ __name(function(t2, e, r, n2) {
  for (var i2 = [], a2 = 0, o2 = t2.length, s2 = 0; a2 !== o2 && s2 + e[a2] < r; )
    s2 += e[a2], a2++;
  i2.push(t2.slice(0, a2));
  var c2 = a2;
  for (s2 = 0; a2 !== o2; )
    s2 + e[a2] > n2 && (i2.push(t2.slice(c2, a2)), s2 = 0, c2 = a2), s2 += e[a2], a2++;
  return c2 !== a2 && i2.push(t2.slice(c2, a2)), i2;
}, "Jt"), Xt = /* @__PURE__ */ __name(function(t2, e, r) {
  r || (r = {});
  var n2, i2, a2, o2, s2, c2, u2, h3 = [], l2 = [h3], f2 = r.textIndent || 0, d2 = 0, p2 = 0, g2 = t2.split(" "), m2 = Gt.apply(this, [" ", r])[0];
  if (c2 = -1 === r.lineIndent ? g2[0].length + 2 : r.lineIndent || 0) {
    var v2 = Array(c2).join(" "), b2 = [];
    g2.map(function(t3) {
      (t3 = t3.split(/\s*\n/)).length > 1 ? b2 = b2.concat(t3.map(function(t4, e2) {
        return (e2 && t4.length ? "\n" : "") + t4;
      })) : b2.push(t3[0]);
    }), g2 = b2, c2 = Yt.apply(this, [v2, r]);
  }
  for (a2 = 0, o2 = g2.length; a2 < o2; a2++) {
    var y2 = 0;
    if (n2 = g2[a2], c2 && "\n" == n2[0] && (n2 = n2.substr(1), y2 = 1), f2 + d2 + (p2 = (i2 = Gt.apply(this, [n2, r])).reduce(function(t3, e2) {
      return t3 + e2;
    }, 0)) > e || y2) {
      if (p2 > e) {
        for (s2 = Jt.apply(this, [n2, i2, e - (f2 + d2), e]), h3.push(s2.shift()), h3 = [s2.pop()]; s2.length; )
          l2.push([s2.shift()]);
        p2 = i2.slice(n2.length - (h3[0] ? h3[0].length : 0)).reduce(function(t3, e2) {
          return t3 + e2;
        }, 0);
      } else
        h3 = [n2];
      l2.push(h3), f2 = p2 + c2, d2 = m2;
    } else
      h3.push(n2), f2 += d2 + p2, d2 = m2;
  }
  return u2 = c2 ? function(t3, e2) {
    return (e2 ? v2 : "") + t3.join(" ");
  } : function(t3) {
    return t3.join(" ");
  }, l2.map(u2);
}, "Xt"), Vt.splitTextToSize = function(t2, e, r) {
  var n2, i2 = (r = r || {}).fontSize || this.internal.getFontSize(), a2 = (function(t3) {
    if (t3.widths && t3.kerning)
      return { widths: t3.widths, kerning: t3.kerning };
    var e2 = this.internal.getFont(t3.fontName, t3.fontStyle);
    return e2.metadata.Unicode ? { widths: e2.metadata.Unicode.widths || { 0: 1 }, kerning: e2.metadata.Unicode.kerning || {} } : { font: e2.metadata, fontSize: this.internal.getFontSize(), charSpace: this.internal.getCharSpace() };
  }).call(this, r);
  n2 = Array.isArray(t2) ? t2 : String(t2).split(/\r?\n/);
  var o2 = 1 * this.internal.scaleFactor * e / i2;
  a2.textIndent = r.textIndent ? 1 * r.textIndent * this.internal.scaleFactor / i2 : 0, a2.lineIndent = r.lineIndent;
  var s2, c2, u2 = [];
  for (s2 = 0, c2 = n2.length; s2 < c2; s2++)
    u2 = u2.concat(Xt.apply(this, [n2[s2], o2, a2]));
  return u2;
}, function(e) {
  e.__fontmetrics__ = e.__fontmetrics__ || {};
  for (var r = "klmnopqrstuvwxyz", n2 = {}, i2 = {}, a2 = 0; a2 < r.length; a2++)
    n2[r[a2]] = "0123456789abcdef"[a2], i2["0123456789abcdef"[a2]] = r[a2];
  var o2 = /* @__PURE__ */ __name(function(t2) {
    return "0x" + parseInt(t2, 10).toString(16);
  }, "o"), s2 = e.__fontmetrics__.compress = function(e2) {
    var r2, n3, a3, c3, u3 = ["{"];
    for (var h4 in e2) {
      if (r2 = e2[h4], isNaN(parseInt(h4, 10)) ? n3 = "'" + h4 + "'" : (h4 = parseInt(h4, 10), n3 = (n3 = o2(h4).slice(2)).slice(0, -1) + i2[n3.slice(-1)]), "number" == typeof r2)
        r2 < 0 ? (a3 = o2(r2).slice(3), c3 = "-") : (a3 = o2(r2).slice(2), c3 = ""), a3 = c3 + a3.slice(0, -1) + i2[a3.slice(-1)];
      else {
        if ("object" !== _typeof(r2))
          throw new Error("Don't know what to do with value type " + _typeof(r2) + ".");
        a3 = s2(r2);
      }
      u3.push(n3 + a3);
    }
    return u3.push("}"), u3.join("");
  }, c2 = e.__fontmetrics__.uncompress = function(t2) {
    if ("string" != typeof t2)
      throw new Error("Invalid argument passed to uncompress.");
    for (var e2, r2, i3, a3, o3 = {}, s3 = 1, c3 = o3, u3 = [], h4 = "", l3 = "", f2 = t2.length - 1, d2 = 1; d2 < f2; d2 += 1)
      "'" == (a3 = t2[d2]) ? e2 ? (i3 = e2.join(""), e2 = void 0) : e2 = [] : e2 ? e2.push(a3) : "{" == a3 ? (u3.push([c3, i3]), c3 = {}, i3 = void 0) : "}" == a3 ? ((r2 = u3.pop())[0][r2[1]] = c3, i3 = void 0, c3 = r2[0]) : "-" == a3 ? s3 = -1 : void 0 === i3 ? n2.hasOwnProperty(a3) ? (h4 += n2[a3], i3 = parseInt(h4, 16) * s3, s3 = 1, h4 = "") : h4 += a3 : n2.hasOwnProperty(a3) ? (l3 += n2[a3], c3[i3] = parseInt(l3, 16) * s3, s3 = 1, i3 = void 0, l3 = "") : l3 += a3;
    return o3;
  }, u2 = { codePages: ["WinAnsiEncoding"], WinAnsiEncoding: c2("{19m8n201n9q201o9r201s9l201t9m201u8m201w9n201x9o201y8o202k8q202l8r202m9p202q8p20aw8k203k8t203t8v203u9v2cq8s212m9t15m8w15n9w2dw9s16k8u16l9u17s9z17x8y17y9y}") }, h3 = { Unicode: { Courier: u2, "Courier-Bold": u2, "Courier-BoldOblique": u2, "Courier-Oblique": u2, Helvetica: u2, "Helvetica-Bold": u2, "Helvetica-BoldOblique": u2, "Helvetica-Oblique": u2, "Times-Roman": u2, "Times-Bold": u2, "Times-BoldItalic": u2, "Times-Italic": u2 } }, l2 = { Unicode: { "Courier-Oblique": c2("{'widths'{k3w'fof'6o}'kerning'{'fof'-6o}}"), "Times-BoldItalic": c2("{'widths'{k3o2q4ycx2r201n3m201o6o201s2l201t2l201u2l201w3m201x3m201y3m2k1t2l2r202m2n2n3m2o3m2p5n202q6o2r1w2s2l2t2l2u3m2v3t2w1t2x2l2y1t2z1w3k3m3l3m3m3m3n3m3o3m3p3m3q3m3r3m3s3m203t2l203u2l3v2l3w3t3x3t3y3t3z3m4k5n4l4m4m4m4n4m4o4s4p4m4q4m4r4s4s4y4t2r4u3m4v4m4w3x4x5t4y4s4z4s5k3x5l4s5m4m5n3r5o3x5p4s5q4m5r5t5s4m5t3x5u3x5v2l5w1w5x2l5y3t5z3m6k2l6l3m6m3m6n2w6o3m6p2w6q2l6r3m6s3r6t1w6u1w6v3m6w1w6x4y6y3r6z3m7k3m7l3m7m2r7n2r7o1w7p3r7q2w7r4m7s3m7t2w7u2r7v2n7w1q7x2n7y3t202l3mcl4mal2ram3man3mao3map3mar3mas2lat4uau1uav3maw3way4uaz2lbk2sbl3t'fof'6obo2lbp3tbq3mbr1tbs2lbu1ybv3mbz3mck4m202k3mcm4mcn4mco4mcp4mcq5ycr4mcs4mct4mcu4mcv4mcw2r2m3rcy2rcz2rdl4sdm4sdn4sdo4sdp4sdq4sds4sdt4sdu4sdv4sdw4sdz3mek3mel3mem3men3meo3mep3meq4ser2wes2wet2weu2wev2wew1wex1wey1wez1wfl3rfm3mfn3mfo3mfp3mfq3mfr3tfs3mft3rfu3rfv3rfw3rfz2w203k6o212m6o2dw2l2cq2l3t3m3u2l17s3x19m3m}'kerning'{cl{4qu5kt5qt5rs17ss5ts}201s{201ss}201t{cks4lscmscnscoscpscls2wu2yu201ts}201x{2wu2yu}2k{201ts}2w{4qx5kx5ou5qx5rs17su5tu}2x{17su5tu5ou}2y{4qx5kx5ou5qx5rs17ss5ts}'fof'-6ofn{17sw5tw5ou5qw5rs}7t{cksclscmscnscoscps4ls}3u{17su5tu5os5qs}3v{17su5tu5os5qs}7p{17su5tu}ck{4qu5kt5qt5rs17ss5ts}4l{4qu5kt5qt5rs17ss5ts}cm{4qu5kt5qt5rs17ss5ts}cn{4qu5kt5qt5rs17ss5ts}co{4qu5kt5qt5rs17ss5ts}cp{4qu5kt5qt5rs17ss5ts}6l{4qu5ou5qw5rt17su5tu}5q{ckuclucmucnucoucpu4lu}5r{ckuclucmucnucoucpu4lu}7q{cksclscmscnscoscps4ls}6p{4qu5ou5qw5rt17sw5tw}ek{4qu5ou5qw5rt17su5tu}el{4qu5ou5qw5rt17su5tu}em{4qu5ou5qw5rt17su5tu}en{4qu5ou5qw5rt17su5tu}eo{4qu5ou5qw5rt17su5tu}ep{4qu5ou5qw5rt17su5tu}es{17ss5ts5qs4qu}et{4qu5ou5qw5rt17sw5tw}eu{4qu5ou5qw5rt17ss5ts}ev{17ss5ts5qs4qu}6z{17sw5tw5ou5qw5rs}fm{17sw5tw5ou5qw5rs}7n{201ts}fo{17sw5tw5ou5qw5rs}fp{17sw5tw5ou5qw5rs}fq{17sw5tw5ou5qw5rs}7r{cksclscmscnscoscps4ls}fs{17sw5tw5ou5qw5rs}ft{17su5tu}fu{17su5tu}fv{17su5tu}fw{17su5tu}fz{cksclscmscnscoscps4ls}}}"), "Helvetica-Bold": c2("{'widths'{k3s2q4scx1w201n3r201o6o201s1w201t1w201u1w201w3m201x3m201y3m2k1w2l2l202m2n2n3r2o3r2p5t202q6o2r1s2s2l2t2l2u2r2v3u2w1w2x2l2y1w2z1w3k3r3l3r3m3r3n3r3o3r3p3r3q3r3r3r3s3r203t2l203u2l3v2l3w3u3x3u3y3u3z3x4k6l4l4s4m4s4n4s4o4s4p4m4q3x4r4y4s4s4t1w4u3r4v4s4w3x4x5n4y4s4z4y5k4m5l4y5m4s5n4m5o3x5p4s5q4m5r5y5s4m5t4m5u3x5v2l5w1w5x2l5y3u5z3r6k2l6l3r6m3x6n3r6o3x6p3r6q2l6r3x6s3x6t1w6u1w6v3r6w1w6x5t6y3x6z3x7k3x7l3x7m2r7n3r7o2l7p3x7q3r7r4y7s3r7t3r7u3m7v2r7w1w7x2r7y3u202l3rcl4sal2lam3ran3rao3rap3rar3ras2lat4tau2pav3raw3uay4taz2lbk2sbl3u'fof'6obo2lbp3xbq3rbr1wbs2lbu2obv3rbz3xck4s202k3rcm4scn4sco4scp4scq6ocr4scs4mct4mcu4mcv4mcw1w2m2zcy1wcz1wdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3xek3rel3rem3ren3reo3rep3req5ter3res3ret3reu3rev3rew1wex1wey1wez1wfl3xfm3xfn3xfo3xfp3xfq3xfr3ufs3xft3xfu3xfv3xfw3xfz3r203k6o212m6o2dw2l2cq2l3t3r3u2l17s4m19m3r}'kerning'{cl{4qs5ku5ot5qs17sv5tv}201t{2ww4wy2yw}201w{2ks}201x{2ww4wy2yw}2k{201ts201xs}2w{7qs4qu5kw5os5qw5rs17su5tu7tsfzs}2x{5ow5qs}2y{7qs4qu5kw5os5qw5rs17su5tu7tsfzs}'fof'-6o7p{17su5tu5ot}ck{4qs5ku5ot5qs17sv5tv}4l{4qs5ku5ot5qs17sv5tv}cm{4qs5ku5ot5qs17sv5tv}cn{4qs5ku5ot5qs17sv5tv}co{4qs5ku5ot5qs17sv5tv}cp{4qs5ku5ot5qs17sv5tv}6l{17st5tt5os}17s{2kwclvcmvcnvcovcpv4lv4wwckv}5o{2kucltcmtcntcotcpt4lt4wtckt}5q{2ksclscmscnscoscps4ls4wvcks}5r{2ks4ws}5t{2kwclvcmvcnvcovcpv4lv4wwckv}eo{17st5tt5os}fu{17su5tu5ot}6p{17ss5ts}ek{17st5tt5os}el{17st5tt5os}em{17st5tt5os}en{17st5tt5os}6o{201ts}ep{17st5tt5os}es{17ss5ts}et{17ss5ts}eu{17ss5ts}ev{17ss5ts}6z{17su5tu5os5qt}fm{17su5tu5os5qt}fn{17su5tu5os5qt}fo{17su5tu5os5qt}fp{17su5tu5os5qt}fq{17su5tu5os5qt}fs{17su5tu5os5qt}ft{17su5tu5ot}7m{5os}fv{17su5tu5ot}fw{17su5tu5ot}}}"), Courier: c2("{'widths'{k3w'fof'6o}'kerning'{'fof'-6o}}"), "Courier-BoldOblique": c2("{'widths'{k3w'fof'6o}'kerning'{'fof'-6o}}"), "Times-Bold": c2("{'widths'{k3q2q5ncx2r201n3m201o6o201s2l201t2l201u2l201w3m201x3m201y3m2k1t2l2l202m2n2n3m2o3m2p6o202q6o2r1w2s2l2t2l2u3m2v3t2w1t2x2l2y1t2z1w3k3m3l3m3m3m3n3m3o3m3p3m3q3m3r3m3s3m203t2l203u2l3v2l3w3t3x3t3y3t3z3m4k5x4l4s4m4m4n4s4o4s4p4m4q3x4r4y4s4y4t2r4u3m4v4y4w4m4x5y4y4s4z4y5k3x5l4y5m4s5n3r5o4m5p4s5q4s5r6o5s4s5t4s5u4m5v2l5w1w5x2l5y3u5z3m6k2l6l3m6m3r6n2w6o3r6p2w6q2l6r3m6s3r6t1w6u2l6v3r6w1w6x5n6y3r6z3m7k3r7l3r7m2w7n2r7o2l7p3r7q3m7r4s7s3m7t3m7u2w7v2r7w1q7x2r7y3o202l3mcl4sal2lam3man3mao3map3mar3mas2lat4uau1yav3maw3tay4uaz2lbk2sbl3t'fof'6obo2lbp3rbr1tbs2lbu2lbv3mbz3mck4s202k3mcm4scn4sco4scp4scq6ocr4scs4mct4mcu4mcv4mcw2r2m3rcy2rcz2rdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3rek3mel3mem3men3meo3mep3meq4ser2wes2wet2weu2wev2wew1wex1wey1wez1wfl3rfm3mfn3mfo3mfp3mfq3mfr3tfs3mft3rfu3rfv3rfw3rfz3m203k6o212m6o2dw2l2cq2l3t3m3u2l17s4s19m3m}'kerning'{cl{4qt5ks5ot5qy5rw17sv5tv}201t{cks4lscmscnscoscpscls4wv}2k{201ts}2w{4qu5ku7mu5os5qx5ru17su5tu}2x{17su5tu5ou5qs}2y{4qv5kv7mu5ot5qz5ru17su5tu}'fof'-6o7t{cksclscmscnscoscps4ls}3u{17su5tu5os5qu}3v{17su5tu5os5qu}fu{17su5tu5ou5qu}7p{17su5tu5ou5qu}ck{4qt5ks5ot5qy5rw17sv5tv}4l{4qt5ks5ot5qy5rw17sv5tv}cm{4qt5ks5ot5qy5rw17sv5tv}cn{4qt5ks5ot5qy5rw17sv5tv}co{4qt5ks5ot5qy5rw17sv5tv}cp{4qt5ks5ot5qy5rw17sv5tv}6l{17st5tt5ou5qu}17s{ckuclucmucnucoucpu4lu4wu}5o{ckuclucmucnucoucpu4lu4wu}5q{ckzclzcmzcnzcozcpz4lz4wu}5r{ckxclxcmxcnxcoxcpx4lx4wu}5t{ckuclucmucnucoucpu4lu4wu}7q{ckuclucmucnucoucpu4lu}6p{17sw5tw5ou5qu}ek{17st5tt5qu}el{17st5tt5ou5qu}em{17st5tt5qu}en{17st5tt5qu}eo{17st5tt5qu}ep{17st5tt5ou5qu}es{17ss5ts5qu}et{17sw5tw5ou5qu}eu{17sw5tw5ou5qu}ev{17ss5ts5qu}6z{17sw5tw5ou5qu5rs}fm{17sw5tw5ou5qu5rs}fn{17sw5tw5ou5qu5rs}fo{17sw5tw5ou5qu5rs}fp{17sw5tw5ou5qu5rs}fq{17sw5tw5ou5qu5rs}7r{cktcltcmtcntcotcpt4lt5os}fs{17sw5tw5ou5qu5rs}ft{17su5tu5ou5qu}7m{5os}fv{17su5tu5ou5qu}fw{17su5tu5ou5qu}fz{cksclscmscnscoscps4ls}}}"), Symbol: c2("{'widths'{k3uaw4r19m3m2k1t2l2l202m2y2n3m2p5n202q6o3k3m2s2l2t2l2v3r2w1t3m3m2y1t2z1wbk2sbl3r'fof'6o3n3m3o3m3p3m3q3m3r3m3s3m3t3m3u1w3v1w3w3r3x3r3y3r3z2wbp3t3l3m5v2l5x2l5z3m2q4yfr3r7v3k7w1o7x3k}'kerning'{'fof'-6o}}"), Helvetica: c2("{'widths'{k3p2q4mcx1w201n3r201o6o201s1q201t1q201u1q201w2l201x2l201y2l2k1w2l1w202m2n2n3r2o3r2p5t202q6o2r1n2s2l2t2l2u2r2v3u2w1w2x2l2y1w2z1w3k3r3l3r3m3r3n3r3o3r3p3r3q3r3r3r3s3r203t2l203u2l3v1w3w3u3x3u3y3u3z3r4k6p4l4m4m4m4n4s4o4s4p4m4q3x4r4y4s4s4t1w4u3m4v4m4w3r4x5n4y4s4z4y5k4m5l4y5m4s5n4m5o3x5p4s5q4m5r5y5s4m5t4m5u3x5v1w5w1w5x1w5y2z5z3r6k2l6l3r6m3r6n3m6o3r6p3r6q1w6r3r6s3r6t1q6u1q6v3m6w1q6x5n6y3r6z3r7k3r7l3r7m2l7n3m7o1w7p3r7q3m7r4s7s3m7t3m7u3m7v2l7w1u7x2l7y3u202l3rcl4mal2lam3ran3rao3rap3rar3ras2lat4tau2pav3raw3uay4taz2lbk2sbl3u'fof'6obo2lbp3rbr1wbs2lbu2obv3rbz3xck4m202k3rcm4mcn4mco4mcp4mcq6ocr4scs4mct4mcu4mcv4mcw1w2m2ncy1wcz1wdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3xek3rel3rem3ren3reo3rep3req5ter3mes3ret3reu3rev3rew1wex1wey1wez1wfl3rfm3rfn3rfo3rfp3rfq3rfr3ufs3xft3rfu3rfv3rfw3rfz3m203k6o212m6o2dw2l2cq2l3t3r3u1w17s4m19m3r}'kerning'{5q{4wv}cl{4qs5kw5ow5qs17sv5tv}201t{2wu4w1k2yu}201x{2wu4wy2yu}17s{2ktclucmucnu4otcpu4lu4wycoucku}2w{7qs4qz5k1m17sy5ow5qx5rsfsu5ty7tufzu}2x{17sy5ty5oy5qs}2y{7qs4qz5k1m17sy5ow5qx5rsfsu5ty7tufzu}'fof'-6o7p{17sv5tv5ow}ck{4qs5kw5ow5qs17sv5tv}4l{4qs5kw5ow5qs17sv5tv}cm{4qs5kw5ow5qs17sv5tv}cn{4qs5kw5ow5qs17sv5tv}co{4qs5kw5ow5qs17sv5tv}cp{4qs5kw5ow5qs17sv5tv}6l{17sy5ty5ow}do{17st5tt}4z{17st5tt}7s{fst}dm{17st5tt}dn{17st5tt}5o{ckwclwcmwcnwcowcpw4lw4wv}dp{17st5tt}dq{17st5tt}7t{5ow}ds{17st5tt}5t{2ktclucmucnu4otcpu4lu4wycoucku}fu{17sv5tv5ow}6p{17sy5ty5ow5qs}ek{17sy5ty5ow}el{17sy5ty5ow}em{17sy5ty5ow}en{5ty}eo{17sy5ty5ow}ep{17sy5ty5ow}es{17sy5ty5qs}et{17sy5ty5ow5qs}eu{17sy5ty5ow5qs}ev{17sy5ty5ow5qs}6z{17sy5ty5ow5qs}fm{17sy5ty5ow5qs}fn{17sy5ty5ow5qs}fo{17sy5ty5ow5qs}fp{17sy5ty5qs}fq{17sy5ty5ow5qs}7r{5ow}fs{17sy5ty5ow5qs}ft{17sv5tv5ow}7m{5ow}fv{17sv5tv5ow}fw{17sv5tv5ow}}}"), "Helvetica-BoldOblique": c2("{'widths'{k3s2q4scx1w201n3r201o6o201s1w201t1w201u1w201w3m201x3m201y3m2k1w2l2l202m2n2n3r2o3r2p5t202q6o2r1s2s2l2t2l2u2r2v3u2w1w2x2l2y1w2z1w3k3r3l3r3m3r3n3r3o3r3p3r3q3r3r3r3s3r203t2l203u2l3v2l3w3u3x3u3y3u3z3x4k6l4l4s4m4s4n4s4o4s4p4m4q3x4r4y4s4s4t1w4u3r4v4s4w3x4x5n4y4s4z4y5k4m5l4y5m4s5n4m5o3x5p4s5q4m5r5y5s4m5t4m5u3x5v2l5w1w5x2l5y3u5z3r6k2l6l3r6m3x6n3r6o3x6p3r6q2l6r3x6s3x6t1w6u1w6v3r6w1w6x5t6y3x6z3x7k3x7l3x7m2r7n3r7o2l7p3x7q3r7r4y7s3r7t3r7u3m7v2r7w1w7x2r7y3u202l3rcl4sal2lam3ran3rao3rap3rar3ras2lat4tau2pav3raw3uay4taz2lbk2sbl3u'fof'6obo2lbp3xbq3rbr1wbs2lbu2obv3rbz3xck4s202k3rcm4scn4sco4scp4scq6ocr4scs4mct4mcu4mcv4mcw1w2m2zcy1wcz1wdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3xek3rel3rem3ren3reo3rep3req5ter3res3ret3reu3rev3rew1wex1wey1wez1wfl3xfm3xfn3xfo3xfp3xfq3xfr3ufs3xft3xfu3xfv3xfw3xfz3r203k6o212m6o2dw2l2cq2l3t3r3u2l17s4m19m3r}'kerning'{cl{4qs5ku5ot5qs17sv5tv}201t{2ww4wy2yw}201w{2ks}201x{2ww4wy2yw}2k{201ts201xs}2w{7qs4qu5kw5os5qw5rs17su5tu7tsfzs}2x{5ow5qs}2y{7qs4qu5kw5os5qw5rs17su5tu7tsfzs}'fof'-6o7p{17su5tu5ot}ck{4qs5ku5ot5qs17sv5tv}4l{4qs5ku5ot5qs17sv5tv}cm{4qs5ku5ot5qs17sv5tv}cn{4qs5ku5ot5qs17sv5tv}co{4qs5ku5ot5qs17sv5tv}cp{4qs5ku5ot5qs17sv5tv}6l{17st5tt5os}17s{2kwclvcmvcnvcovcpv4lv4wwckv}5o{2kucltcmtcntcotcpt4lt4wtckt}5q{2ksclscmscnscoscps4ls4wvcks}5r{2ks4ws}5t{2kwclvcmvcnvcovcpv4lv4wwckv}eo{17st5tt5os}fu{17su5tu5ot}6p{17ss5ts}ek{17st5tt5os}el{17st5tt5os}em{17st5tt5os}en{17st5tt5os}6o{201ts}ep{17st5tt5os}es{17ss5ts}et{17ss5ts}eu{17ss5ts}ev{17ss5ts}6z{17su5tu5os5qt}fm{17su5tu5os5qt}fn{17su5tu5os5qt}fo{17su5tu5os5qt}fp{17su5tu5os5qt}fq{17su5tu5os5qt}fs{17su5tu5os5qt}ft{17su5tu5ot}7m{5os}fv{17su5tu5ot}fw{17su5tu5ot}}}"), ZapfDingbats: c2("{'widths'{k4u2k1w'fof'6o}'kerning'{'fof'-6o}}"), "Courier-Bold": c2("{'widths'{k3w'fof'6o}'kerning'{'fof'-6o}}"), "Times-Italic": c2("{'widths'{k3n2q4ycx2l201n3m201o5t201s2l201t2l201u2l201w3r201x3r201y3r2k1t2l2l202m2n2n3m2o3m2p5n202q5t2r1p2s2l2t2l2u3m2v4n2w1t2x2l2y1t2z1w3k3m3l3m3m3m3n3m3o3m3p3m3q3m3r3m3s3m203t2l203u2l3v2l3w4n3x4n3y4n3z3m4k5w4l3x4m3x4n4m4o4s4p3x4q3x4r4s4s4s4t2l4u2w4v4m4w3r4x5n4y4m4z4s5k3x5l4s5m3x5n3m5o3r5p4s5q3x5r5n5s3x5t3r5u3r5v2r5w1w5x2r5y2u5z3m6k2l6l3m6m3m6n2w6o3m6p2w6q1w6r3m6s3m6t1w6u1w6v2w6w1w6x4s6y3m6z3m7k3m7l3m7m2r7n2r7o1w7p3m7q2w7r4m7s2w7t2w7u2r7v2s7w1v7x2s7y3q202l3mcl3xal2ram3man3mao3map3mar3mas2lat4wau1vav3maw4nay4waz2lbk2sbl4n'fof'6obo2lbp3mbq3obr1tbs2lbu1zbv3mbz3mck3x202k3mcm3xcn3xco3xcp3xcq5tcr4mcs3xct3xcu3xcv3xcw2l2m2ucy2lcz2ldl4mdm4sdn4sdo4sdp4sdq4sds4sdt4sdu4sdv4sdw4sdz3mek3mel3mem3men3meo3mep3meq4mer2wes2wet2weu2wev2wew1wex1wey1wez1wfl3mfm3mfn3mfo3mfp3mfq3mfr4nfs3mft3mfu3mfv3mfw3mfz2w203k6o212m6m2dw2l2cq2l3t3m3u2l17s3r19m3m}'kerning'{cl{5kt4qw}201s{201sw}201t{201tw2wy2yy6q-t}201x{2wy2yy}2k{201tw}2w{7qs4qy7rs5ky7mw5os5qx5ru17su5tu}2x{17ss5ts5os}2y{7qs4qy7rs5ky7mw5os5qx5ru17su5tu}'fof'-6o6t{17ss5ts5qs}7t{5os}3v{5qs}7p{17su5tu5qs}ck{5kt4qw}4l{5kt4qw}cm{5kt4qw}cn{5kt4qw}co{5kt4qw}cp{5kt4qw}6l{4qs5ks5ou5qw5ru17su5tu}17s{2ks}5q{ckvclvcmvcnvcovcpv4lv}5r{ckuclucmucnucoucpu4lu}5t{2ks}6p{4qs5ks5ou5qw5ru17su5tu}ek{4qs5ks5ou5qw5ru17su5tu}el{4qs5ks5ou5qw5ru17su5tu}em{4qs5ks5ou5qw5ru17su5tu}en{4qs5ks5ou5qw5ru17su5tu}eo{4qs5ks5ou5qw5ru17su5tu}ep{4qs5ks5ou5qw5ru17su5tu}es{5ks5qs4qs}et{4qs5ks5ou5qw5ru17su5tu}eu{4qs5ks5qw5ru17su5tu}ev{5ks5qs4qs}ex{17ss5ts5qs}6z{4qv5ks5ou5qw5ru17su5tu}fm{4qv5ks5ou5qw5ru17su5tu}fn{4qv5ks5ou5qw5ru17su5tu}fo{4qv5ks5ou5qw5ru17su5tu}fp{4qv5ks5ou5qw5ru17su5tu}fq{4qv5ks5ou5qw5ru17su5tu}7r{5os}fs{4qv5ks5ou5qw5ru17su5tu}ft{17su5tu5qs}fu{17su5tu5qs}fv{17su5tu5qs}fw{17su5tu5qs}}}"), "Times-Roman": c2("{'widths'{k3n2q4ycx2l201n3m201o6o201s2l201t2l201u2l201w2w201x2w201y2w2k1t2l2l202m2n2n3m2o3m2p5n202q6o2r1m2s2l2t2l2u3m2v3s2w1t2x2l2y1t2z1w3k3m3l3m3m3m3n3m3o3m3p3m3q3m3r3m3s3m203t2l203u2l3v1w3w3s3x3s3y3s3z2w4k5w4l4s4m4m4n4m4o4s4p3x4q3r4r4s4s4s4t2l4u2r4v4s4w3x4x5t4y4s4z4s5k3r5l4s5m4m5n3r5o3x5p4s5q4s5r5y5s4s5t4s5u3x5v2l5w1w5x2l5y2z5z3m6k2l6l2w6m3m6n2w6o3m6p2w6q2l6r3m6s3m6t1w6u1w6v3m6w1w6x4y6y3m6z3m7k3m7l3m7m2l7n2r7o1w7p3m7q3m7r4s7s3m7t3m7u2w7v3k7w1o7x3k7y3q202l3mcl4sal2lam3man3mao3map3mar3mas2lat4wau1vav3maw3say4waz2lbk2sbl3s'fof'6obo2lbp3mbq2xbr1tbs2lbu1zbv3mbz2wck4s202k3mcm4scn4sco4scp4scq5tcr4mcs3xct3xcu3xcv3xcw2l2m2tcy2lcz2ldl4sdm4sdn4sdo4sdp4sdq4sds4sdt4sdu4sdv4sdw4sdz3mek2wel2wem2wen2weo2wep2weq4mer2wes2wet2weu2wev2wew1wex1wey1wez1wfl3mfm3mfn3mfo3mfp3mfq3mfr3sfs3mft3mfu3mfv3mfw3mfz3m203k6o212m6m2dw2l2cq2l3t3m3u1w17s4s19m3m}'kerning'{cl{4qs5ku17sw5ou5qy5rw201ss5tw201ws}201s{201ss}201t{ckw4lwcmwcnwcowcpwclw4wu201ts}2k{201ts}2w{4qs5kw5os5qx5ru17sx5tx}2x{17sw5tw5ou5qu}2y{4qs5kw5os5qx5ru17sx5tx}'fof'-6o7t{ckuclucmucnucoucpu4lu5os5rs}3u{17su5tu5qs}3v{17su5tu5qs}7p{17sw5tw5qs}ck{4qs5ku17sw5ou5qy5rw201ss5tw201ws}4l{4qs5ku17sw5ou5qy5rw201ss5tw201ws}cm{4qs5ku17sw5ou5qy5rw201ss5tw201ws}cn{4qs5ku17sw5ou5qy5rw201ss5tw201ws}co{4qs5ku17sw5ou5qy5rw201ss5tw201ws}cp{4qs5ku17sw5ou5qy5rw201ss5tw201ws}6l{17su5tu5os5qw5rs}17s{2ktclvcmvcnvcovcpv4lv4wuckv}5o{ckwclwcmwcnwcowcpw4lw4wu}5q{ckyclycmycnycoycpy4ly4wu5ms}5r{cktcltcmtcntcotcpt4lt4ws}5t{2ktclvcmvcnvcovcpv4lv4wuckv}7q{cksclscmscnscoscps4ls}6p{17su5tu5qw5rs}ek{5qs5rs}el{17su5tu5os5qw5rs}em{17su5tu5os5qs5rs}en{17su5qs5rs}eo{5qs5rs}ep{17su5tu5os5qw5rs}es{5qs}et{17su5tu5qw5rs}eu{17su5tu5qs5rs}ev{5qs}6z{17sv5tv5os5qx5rs}fm{5os5qt5rs}fn{17sv5tv5os5qx5rs}fo{17sv5tv5os5qx5rs}fp{5os5qt5rs}fq{5os5qt5rs}7r{ckuclucmucnucoucpu4lu5os}fs{17sv5tv5os5qx5rs}ft{17ss5ts5qs}fu{17sw5tw5qs}fv{17sw5tw5qs}fw{17ss5ts5qs}fz{ckuclucmucnucoucpu4lu5os5rs}}}"), "Helvetica-Oblique": c2("{'widths'{k3p2q4mcx1w201n3r201o6o201s1q201t1q201u1q201w2l201x2l201y2l2k1w2l1w202m2n2n3r2o3r2p5t202q6o2r1n2s2l2t2l2u2r2v3u2w1w2x2l2y1w2z1w3k3r3l3r3m3r3n3r3o3r3p3r3q3r3r3r3s3r203t2l203u2l3v1w3w3u3x3u3y3u3z3r4k6p4l4m4m4m4n4s4o4s4p4m4q3x4r4y4s4s4t1w4u3m4v4m4w3r4x5n4y4s4z4y5k4m5l4y5m4s5n4m5o3x5p4s5q4m5r5y5s4m5t4m5u3x5v1w5w1w5x1w5y2z5z3r6k2l6l3r6m3r6n3m6o3r6p3r6q1w6r3r6s3r6t1q6u1q6v3m6w1q6x5n6y3r6z3r7k3r7l3r7m2l7n3m7o1w7p3r7q3m7r4s7s3m7t3m7u3m7v2l7w1u7x2l7y3u202l3rcl4mal2lam3ran3rao3rap3rar3ras2lat4tau2pav3raw3uay4taz2lbk2sbl3u'fof'6obo2lbp3rbr1wbs2lbu2obv3rbz3xck4m202k3rcm4mcn4mco4mcp4mcq6ocr4scs4mct4mcu4mcv4mcw1w2m2ncy1wcz1wdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3xek3rel3rem3ren3reo3rep3req5ter3mes3ret3reu3rev3rew1wex1wey1wez1wfl3rfm3rfn3rfo3rfp3rfq3rfr3ufs3xft3rfu3rfv3rfw3rfz3m203k6o212m6o2dw2l2cq2l3t3r3u1w17s4m19m3r}'kerning'{5q{4wv}cl{4qs5kw5ow5qs17sv5tv}201t{2wu4w1k2yu}201x{2wu4wy2yu}17s{2ktclucmucnu4otcpu4lu4wycoucku}2w{7qs4qz5k1m17sy5ow5qx5rsfsu5ty7tufzu}2x{17sy5ty5oy5qs}2y{7qs4qz5k1m17sy5ow5qx5rsfsu5ty7tufzu}'fof'-6o7p{17sv5tv5ow}ck{4qs5kw5ow5qs17sv5tv}4l{4qs5kw5ow5qs17sv5tv}cm{4qs5kw5ow5qs17sv5tv}cn{4qs5kw5ow5qs17sv5tv}co{4qs5kw5ow5qs17sv5tv}cp{4qs5kw5ow5qs17sv5tv}6l{17sy5ty5ow}do{17st5tt}4z{17st5tt}7s{fst}dm{17st5tt}dn{17st5tt}5o{ckwclwcmwcnwcowcpw4lw4wv}dp{17st5tt}dq{17st5tt}7t{5ow}ds{17st5tt}5t{2ktclucmucnu4otcpu4lu4wycoucku}fu{17sv5tv5ow}6p{17sy5ty5ow5qs}ek{17sy5ty5ow}el{17sy5ty5ow}em{17sy5ty5ow}en{5ty}eo{17sy5ty5ow}ep{17sy5ty5ow}es{17sy5ty5qs}et{17sy5ty5ow5qs}eu{17sy5ty5ow5qs}ev{17sy5ty5ow5qs}6z{17sy5ty5ow5qs}fm{17sy5ty5ow5qs}fn{17sy5ty5ow5qs}fo{17sy5ty5ow5qs}fp{17sy5ty5qs}fq{17sy5ty5ow5qs}7r{5ow}fs{17sy5ty5ow5qs}ft{17sv5tv5ow}7m{5ow}fv{17sv5tv5ow}fw{17sv5tv5ow}}}") } };
  e.events.push(["addFont", function(t2) {
    var e2 = t2.font, r2 = l2.Unicode[e2.postScriptName];
    r2 && (e2.metadata.Unicode = {}, e2.metadata.Unicode.widths = r2.widths, e2.metadata.Unicode.kerning = r2.kerning);
    var n3 = h3.Unicode[e2.postScriptName];
    n3 && (e2.metadata.Unicode.encoding = n3, e2.encoding = n3.codePages[0]);
  }]);
}(E.API), /**
 * @license
 * Licensed under the MIT License.
 * http://opensource.org/licenses/mit-license
 */
function(t2) {
  var e = /* @__PURE__ */ __name(function(t3) {
    for (var e2 = t3.length, r = new Uint8Array(e2), n2 = 0; n2 < e2; n2++)
      r[n2] = t3.charCodeAt(n2);
    return r;
  }, "e");
  t2.API.events.push(["addFont", function(r) {
    var n2 = void 0, i2 = r.font, a2 = r.instance;
    if (!i2.isStandardFont) {
      if (void 0 === a2)
        throw new Error("Font does not exist in vFS, import fonts or remove declaration doc.addFont('" + i2.postScriptName + "').");
      if ("string" != typeof (n2 = false === a2.existsFileInVFS(i2.postScriptName) ? a2.loadFile(i2.postScriptName) : a2.getFileFromVFS(i2.postScriptName)))
        throw new Error("Font is not stored as string-data in vFS, import fonts or remove declaration doc.addFont('" + i2.postScriptName + "').");
      !function(r2, n3) {
        n3 = /^\x00\x01\x00\x00/.test(n3) ? e(n3) : e(u(n3)), r2.metadata = t2.API.TTFFont.open(n3), r2.metadata.Unicode = r2.metadata.Unicode || { encoding: {}, kerning: {}, widths: [] }, r2.metadata.glyIdsUsed = [0];
      }(i2, n2);
    }
  }]);
}(E), /** @license
 * Copyright (c) 2012 Willow Systems Corporation, https://github.com/willowsystems
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
 * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 * ====================================================================
 */
function(t2) {
  function e() {
    return (n.canvg ? Promise.resolve(n.canvg) : __vitePreload(() => import("./index.es-56910255.js"), true ? ["assets/index.es-56910255.js","assets/vendor-27b9359a.js"] : void 0)).catch(function(t3) {
      return Promise.reject(new Error("Could not load canvg: " + t3));
    }).then(function(t3) {
      return t3.default ? t3.default : t3;
    });
  }
  __name(e, "e");
  E.API.addSvgAsImage = function(t3, r, n2, i2, o2, s2, c2, u2) {
    if (isNaN(r) || isNaN(n2))
      throw a.error("jsPDF.addSvgAsImage: Invalid coordinates", arguments), new Error("Invalid coordinates passed to jsPDF.addSvgAsImage");
    if (isNaN(i2) || isNaN(o2))
      throw a.error("jsPDF.addSvgAsImage: Invalid measurements", arguments), new Error("Invalid measurements (width and/or height) passed to jsPDF.addSvgAsImage");
    var h3 = document.createElement("canvas");
    h3.width = i2, h3.height = o2;
    var l2 = h3.getContext("2d");
    l2.fillStyle = "#fff", l2.fillRect(0, 0, h3.width, h3.height);
    var f2 = { ignoreMouse: true, ignoreAnimation: true, ignoreDimensions: true }, d2 = this;
    return e().then(function(e2) {
      return e2.fromString(l2, t3, f2);
    }, function() {
      return Promise.reject(new Error("Could not load canvg."));
    }).then(function(t4) {
      return t4.render(f2);
    }).then(function() {
      d2.addImage(h3.toDataURL("image/jpeg", 1), r, n2, i2, o2, c2, u2);
    });
  };
}(), E.API.putTotalPages = function(t2) {
  var e, r = 0;
  parseInt(this.internal.getFont().id.substr(1), 10) < 15 ? (e = new RegExp(t2, "g"), r = this.internal.getNumberOfPages()) : (e = new RegExp(this.pdfEscape16(t2, this.internal.getFont()), "g"), r = this.pdfEscape16(this.internal.getNumberOfPages() + "", this.internal.getFont()));
  for (var n2 = 1; n2 <= this.internal.getNumberOfPages(); n2++)
    for (var i2 = 0; i2 < this.internal.pages[n2].length; i2++)
      this.internal.pages[n2][i2] = this.internal.pages[n2][i2].replace(e, r);
  return this;
}, E.API.viewerPreferences = function(e, r) {
  var n2;
  e = e || {}, r = r || false;
  var i2, a2, o2, s2 = { HideToolbar: { defaultValue: false, value: false, type: "boolean", explicitSet: false, valueSet: [true, false], pdfVersion: 1.3 }, HideMenubar: { defaultValue: false, value: false, type: "boolean", explicitSet: false, valueSet: [true, false], pdfVersion: 1.3 }, HideWindowUI: { defaultValue: false, value: false, type: "boolean", explicitSet: false, valueSet: [true, false], pdfVersion: 1.3 }, FitWindow: { defaultValue: false, value: false, type: "boolean", explicitSet: false, valueSet: [true, false], pdfVersion: 1.3 }, CenterWindow: { defaultValue: false, value: false, type: "boolean", explicitSet: false, valueSet: [true, false], pdfVersion: 1.3 }, DisplayDocTitle: { defaultValue: false, value: false, type: "boolean", explicitSet: false, valueSet: [true, false], pdfVersion: 1.4 }, NonFullScreenPageMode: { defaultValue: "UseNone", value: "UseNone", type: "name", explicitSet: false, valueSet: ["UseNone", "UseOutlines", "UseThumbs", "UseOC"], pdfVersion: 1.3 }, Direction: { defaultValue: "L2R", value: "L2R", type: "name", explicitSet: false, valueSet: ["L2R", "R2L"], pdfVersion: 1.3 }, ViewArea: { defaultValue: "CropBox", value: "CropBox", type: "name", explicitSet: false, valueSet: ["MediaBox", "CropBox", "TrimBox", "BleedBox", "ArtBox"], pdfVersion: 1.4 }, ViewClip: { defaultValue: "CropBox", value: "CropBox", type: "name", explicitSet: false, valueSet: ["MediaBox", "CropBox", "TrimBox", "BleedBox", "ArtBox"], pdfVersion: 1.4 }, PrintArea: { defaultValue: "CropBox", value: "CropBox", type: "name", explicitSet: false, valueSet: ["MediaBox", "CropBox", "TrimBox", "BleedBox", "ArtBox"], pdfVersion: 1.4 }, PrintClip: { defaultValue: "CropBox", value: "CropBox", type: "name", explicitSet: false, valueSet: ["MediaBox", "CropBox", "TrimBox", "BleedBox", "ArtBox"], pdfVersion: 1.4 }, PrintScaling: { defaultValue: "AppDefault", value: "AppDefault", type: "name", explicitSet: false, valueSet: ["AppDefault", "None"], pdfVersion: 1.6 }, Duplex: { defaultValue: "", value: "none", type: "name", explicitSet: false, valueSet: ["Simplex", "DuplexFlipShortEdge", "DuplexFlipLongEdge", "none"], pdfVersion: 1.7 }, PickTrayByPDFSize: { defaultValue: false, value: false, type: "boolean", explicitSet: false, valueSet: [true, false], pdfVersion: 1.7 }, PrintPageRange: { defaultValue: "", value: "", type: "array", explicitSet: false, valueSet: null, pdfVersion: 1.7 }, NumCopies: { defaultValue: 1, value: 1, type: "integer", explicitSet: false, valueSet: null, pdfVersion: 1.7 } }, c2 = Object.keys(s2), u2 = [], h3 = 0, l2 = 0, f2 = 0;
  function d2(t2, e2) {
    var r2, n3 = false;
    for (r2 = 0; r2 < t2.length; r2 += 1)
      t2[r2] === e2 && (n3 = true);
    return n3;
  }
  __name(d2, "d");
  if (void 0 === this.internal.viewerpreferences && (this.internal.viewerpreferences = {}, this.internal.viewerpreferences.configuration = JSON.parse(JSON.stringify(s2)), this.internal.viewerpreferences.isSubscribed = false), n2 = this.internal.viewerpreferences.configuration, "reset" === e || true === r) {
    var p2 = c2.length;
    for (f2 = 0; f2 < p2; f2 += 1)
      n2[c2[f2]].value = n2[c2[f2]].defaultValue, n2[c2[f2]].explicitSet = false;
  }
  if ("object" === _typeof(e)) {
    for (a2 in e)
      if (o2 = e[a2], d2(c2, a2) && void 0 !== o2) {
        if ("boolean" === n2[a2].type && "boolean" == typeof o2)
          n2[a2].value = o2;
        else if ("name" === n2[a2].type && d2(n2[a2].valueSet, o2))
          n2[a2].value = o2;
        else if ("integer" === n2[a2].type && Number.isInteger(o2))
          n2[a2].value = o2;
        else if ("array" === n2[a2].type) {
          for (h3 = 0; h3 < o2.length; h3 += 1)
            if (i2 = true, 1 === o2[h3].length && "number" == typeof o2[h3][0])
              u2.push(String(o2[h3] - 1));
            else if (o2[h3].length > 1) {
              for (l2 = 0; l2 < o2[h3].length; l2 += 1)
                "number" != typeof o2[h3][l2] && (i2 = false);
              true === i2 && u2.push([o2[h3][0] - 1, o2[h3][1] - 1].join(" "));
            }
          n2[a2].value = "[" + u2.join(" ") + "]";
        } else
          n2[a2].value = n2[a2].defaultValue;
        n2[a2].explicitSet = true;
      }
  }
  return false === this.internal.viewerpreferences.isSubscribed && (this.internal.events.subscribe("putCatalog", function() {
    var t2, e2 = [];
    for (t2 in n2)
      true === n2[t2].explicitSet && ("name" === n2[t2].type ? e2.push("/" + t2 + " /" + n2[t2].value) : e2.push("/" + t2 + " " + n2[t2].value));
    0 !== e2.length && this.internal.write("/ViewerPreferences\n<<\n" + e2.join("\n") + "\n>>");
  }), this.internal.viewerpreferences.isSubscribed = true), this.internal.viewerpreferences.configuration = n2, this;
}, /** ====================================================================
 * @license
 * jsPDF XMP metadata plugin
 * Copyright (c) 2016 Jussi Utunen, u-jussi@suomi24.fi
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
 * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 * ====================================================================
 */
function(t2) {
  var e = /* @__PURE__ */ __name(function() {
    var t3 = '<rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"><rdf:Description rdf:about="" xmlns:jspdf="' + this.internal.__metadata__.namespaceuri + '"><jspdf:metadata>', e2 = unescape(encodeURIComponent('<x:xmpmeta xmlns:x="adobe:ns:meta/">')), r2 = unescape(encodeURIComponent(t3)), n2 = unescape(encodeURIComponent(this.internal.__metadata__.metadata)), i2 = unescape(encodeURIComponent("</jspdf:metadata></rdf:Description></rdf:RDF>")), a2 = unescape(encodeURIComponent("</x:xmpmeta>")), o2 = r2.length + n2.length + i2.length + e2.length + a2.length;
    this.internal.__metadata__.metadata_object_number = this.internal.newObject(), this.internal.write("<< /Type /Metadata /Subtype /XML /Length " + o2 + " >>"), this.internal.write("stream"), this.internal.write(e2 + r2 + n2 + i2 + a2), this.internal.write("endstream"), this.internal.write("endobj");
  }, "e"), r = /* @__PURE__ */ __name(function() {
    this.internal.__metadata__.metadata_object_number && this.internal.write("/Metadata " + this.internal.__metadata__.metadata_object_number + " 0 R");
  }, "r");
  t2.addMetadata = function(t3, n2) {
    return void 0 === this.internal.__metadata__ && (this.internal.__metadata__ = { metadata: t3, namespaceuri: n2 || "http://jspdf.default.namespaceuri/" }, this.internal.events.subscribe("putCatalog", r), this.internal.events.subscribe("postPutResources", e)), this;
  };
}(E.API), function(t2) {
  var e = t2.API, r = e.pdfEscape16 = function(t3, e2) {
    for (var r2, n3 = e2.metadata.Unicode.widths, i3 = ["", "0", "00", "000", "0000"], a2 = [""], o2 = 0, s2 = t3.length; o2 < s2; ++o2) {
      if (r2 = e2.metadata.characterToGlyph(t3.charCodeAt(o2)), e2.metadata.glyIdsUsed.push(r2), e2.metadata.toUnicode[r2] = t3.charCodeAt(o2), -1 == n3.indexOf(r2) && (n3.push(r2), n3.push([parseInt(e2.metadata.widthOfGlyph(r2), 10)])), "0" == r2)
        return a2.join("");
      r2 = r2.toString(16), a2.push(i3[4 - r2.length], r2);
    }
    return a2.join("");
  }, n2 = /* @__PURE__ */ __name(function(t3) {
    var e2, r2, n3, i3, a2, o2, s2;
    for (a2 = "/CIDInit /ProcSet findresource begin\n12 dict begin\nbegincmap\n/CIDSystemInfo <<\n  /Registry (Adobe)\n  /Ordering (UCS)\n  /Supplement 0\n>> def\n/CMapName /Adobe-Identity-UCS def\n/CMapType 2 def\n1 begincodespacerange\n<0000><ffff>\nendcodespacerange", n3 = [], o2 = 0, s2 = (r2 = Object.keys(t3).sort(function(t4, e3) {
      return t4 - e3;
    })).length; o2 < s2; o2++)
      e2 = r2[o2], n3.length >= 100 && (a2 += "\n" + n3.length + " beginbfchar\n" + n3.join("\n") + "\nendbfchar", n3 = []), void 0 !== t3[e2] && null !== t3[e2] && "function" == typeof t3[e2].toString && (i3 = ("0000" + t3[e2].toString(16)).slice(-4), e2 = ("0000" + (+e2).toString(16)).slice(-4), n3.push("<" + e2 + "><" + i3 + ">"));
    return n3.length && (a2 += "\n" + n3.length + " beginbfchar\n" + n3.join("\n") + "\nendbfchar\n"), a2 += "endcmap\nCMapName currentdict /CMap defineresource pop\nend\nend";
  }, "n");
  e.events.push(["putFont", function(e2) {
    !function(e3) {
      var r2 = e3.font, i3 = e3.out, a2 = e3.newObject, o2 = e3.putStream;
      if (r2.metadata instanceof t2.API.TTFFont && "Identity-H" === r2.encoding) {
        for (var s2 = r2.metadata.Unicode.widths, c2 = r2.metadata.subset.encode(r2.metadata.glyIdsUsed, 1), u2 = "", h3 = 0; h3 < c2.length; h3++)
          u2 += String.fromCharCode(c2[h3]);
        var l2 = a2();
        o2({ data: u2, addLength1: true, objectId: l2 }), i3("endobj");
        var f2 = a2();
        o2({ data: n2(r2.metadata.toUnicode), addLength1: true, objectId: f2 }), i3("endobj");
        var d2 = a2();
        i3("<<"), i3("/Type /FontDescriptor"), i3("/FontName /" + F(r2.fontName)), i3("/FontFile2 " + l2 + " 0 R"), i3("/FontBBox " + t2.API.PDFObject.convert(r2.metadata.bbox)), i3("/Flags " + r2.metadata.flags), i3("/StemV " + r2.metadata.stemV), i3("/ItalicAngle " + r2.metadata.italicAngle), i3("/Ascent " + r2.metadata.ascender), i3("/Descent " + r2.metadata.decender), i3("/CapHeight " + r2.metadata.capHeight), i3(">>"), i3("endobj");
        var p2 = a2();
        i3("<<"), i3("/Type /Font"), i3("/BaseFont /" + F(r2.fontName)), i3("/FontDescriptor " + d2 + " 0 R"), i3("/W " + t2.API.PDFObject.convert(s2)), i3("/CIDToGIDMap /Identity"), i3("/DW 1000"), i3("/Subtype /CIDFontType2"), i3("/CIDSystemInfo"), i3("<<"), i3("/Supplement 0"), i3("/Registry (Adobe)"), i3("/Ordering (" + r2.encoding + ")"), i3(">>"), i3(">>"), i3("endobj"), r2.objectNumber = a2(), i3("<<"), i3("/Type /Font"), i3("/Subtype /Type0"), i3("/ToUnicode " + f2 + " 0 R"), i3("/BaseFont /" + F(r2.fontName)), i3("/Encoding /" + r2.encoding), i3("/DescendantFonts [" + p2 + " 0 R]"), i3(">>"), i3("endobj"), r2.isAlreadyPutted = true;
      }
    }(e2);
  }]);
  e.events.push(["putFont", function(e2) {
    !function(e3) {
      var r2 = e3.font, i3 = e3.out, a2 = e3.newObject, o2 = e3.putStream;
      if (r2.metadata instanceof t2.API.TTFFont && "WinAnsiEncoding" === r2.encoding) {
        for (var s2 = r2.metadata.rawData, c2 = "", u2 = 0; u2 < s2.length; u2++)
          c2 += String.fromCharCode(s2[u2]);
        var h3 = a2();
        o2({ data: c2, addLength1: true, objectId: h3 }), i3("endobj");
        var l2 = a2();
        o2({ data: n2(r2.metadata.toUnicode), addLength1: true, objectId: l2 }), i3("endobj");
        var f2 = a2();
        i3("<<"), i3("/Descent " + r2.metadata.decender), i3("/CapHeight " + r2.metadata.capHeight), i3("/StemV " + r2.metadata.stemV), i3("/Type /FontDescriptor"), i3("/FontFile2 " + h3 + " 0 R"), i3("/Flags 96"), i3("/FontBBox " + t2.API.PDFObject.convert(r2.metadata.bbox)), i3("/FontName /" + F(r2.fontName)), i3("/ItalicAngle " + r2.metadata.italicAngle), i3("/Ascent " + r2.metadata.ascender), i3(">>"), i3("endobj"), r2.objectNumber = a2();
        for (var d2 = 0; d2 < r2.metadata.hmtx.widths.length; d2++)
          r2.metadata.hmtx.widths[d2] = parseInt(r2.metadata.hmtx.widths[d2] * (1e3 / r2.metadata.head.unitsPerEm));
        i3("<</Subtype/TrueType/Type/Font/ToUnicode " + l2 + " 0 R/BaseFont/" + F(r2.fontName) + "/FontDescriptor " + f2 + " 0 R/Encoding/" + r2.encoding + " /FirstChar 29 /LastChar 255 /Widths " + t2.API.PDFObject.convert(r2.metadata.hmtx.widths) + ">>"), i3("endobj"), r2.isAlreadyPutted = true;
      }
    }(e2);
  }]);
  var i2 = /* @__PURE__ */ __name(function(t3) {
    var e2, n3 = t3.text || "", i3 = t3.x, a2 = t3.y, o2 = t3.options || {}, s2 = t3.mutex || {}, c2 = s2.pdfEscape, u2 = s2.activeFontKey, h3 = s2.fonts, l2 = u2, f2 = "", d2 = 0, p2 = "", g2 = h3[l2].encoding;
    if ("Identity-H" !== h3[l2].encoding)
      return { text: n3, x: i3, y: a2, options: o2, mutex: s2 };
    for (p2 = n3, l2 = u2, Array.isArray(n3) && (p2 = n3[0]), d2 = 0; d2 < p2.length; d2 += 1)
      h3[l2].metadata.hasOwnProperty("cmap") && (e2 = h3[l2].metadata.cmap.unicode.codeMap[p2[d2].charCodeAt(0)]), e2 || p2[d2].charCodeAt(0) < 256 && h3[l2].metadata.hasOwnProperty("Unicode") ? f2 += p2[d2] : f2 += "";
    var m2 = "";
    return parseInt(l2.slice(1)) < 14 || "WinAnsiEncoding" === g2 ? m2 = c2(f2, l2).split("").map(function(t4) {
      return t4.charCodeAt(0).toString(16);
    }).join("") : "Identity-H" === g2 && (m2 = r(f2, h3[l2])), s2.isHex = true, { text: m2, x: i3, y: a2, options: o2, mutex: s2 };
  }, "i");
  e.events.push(["postProcessText", function(t3) {
    var e2 = t3.text || "", r2 = [], n3 = { text: e2, x: t3.x, y: t3.y, options: t3.options, mutex: t3.mutex };
    if (Array.isArray(e2)) {
      var a2 = 0;
      for (a2 = 0; a2 < e2.length; a2 += 1)
        Array.isArray(e2[a2]) && 3 === e2[a2].length ? r2.push([i2(Object.assign({}, n3, { text: e2[a2][0] })).text, e2[a2][1], e2[a2][2]]) : r2.push(i2(Object.assign({}, n3, { text: e2[a2] })).text);
      t3.text = r2;
    } else
      t3.text = i2(Object.assign({}, n3, { text: e2 })).text;
  }]);
}(E), /**
 * @license
 * jsPDF virtual FileSystem functionality
 *
 * Licensed under the MIT License.
 * http://opensource.org/licenses/mit-license
 */
function(t2) {
  var e = /* @__PURE__ */ __name(function() {
    return void 0 === this.internal.vFS && (this.internal.vFS = {}), true;
  }, "e");
  t2.existsFileInVFS = function(t3) {
    return e.call(this), void 0 !== this.internal.vFS[t3];
  }, t2.addFileToVFS = function(t3, r) {
    return e.call(this), this.internal.vFS[t3] = r, this;
  }, t2.getFileFromVFS = function(t3) {
    return e.call(this), void 0 !== this.internal.vFS[t3] ? this.internal.vFS[t3] : null;
  };
}(E.API), /**
 * @license
 * Unicode Bidi Engine based on the work of Alex Shensis (@asthensis)
 * MIT License
 */
function(t2) {
  t2.__bidiEngine__ = t2.prototype.__bidiEngine__ = function(t3) {
    var r2, n2, i2, a2, o2, s2, c2, u2 = e, h3 = [[0, 3, 0, 1, 0, 0, 0], [0, 3, 0, 1, 2, 2, 0], [0, 3, 0, 17, 2, 0, 1], [0, 3, 5, 5, 4, 1, 0], [0, 3, 21, 21, 4, 0, 1], [0, 3, 5, 5, 4, 2, 0]], l2 = [[2, 0, 1, 1, 0, 1, 0], [2, 0, 1, 1, 0, 2, 0], [2, 0, 2, 1, 3, 2, 0], [2, 0, 2, 33, 3, 1, 1]], f2 = { L: 0, R: 1, EN: 2, AN: 3, N: 4, B: 5, S: 6 }, d2 = { 0: 0, 5: 1, 6: 2, 7: 3, 32: 4, 251: 5, 254: 6, 255: 7 }, p2 = ["(", ")", "(", "<", ">", "<", "[", "]", "[", "{", "}", "{", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], g2 = new RegExp(/^([1-4|9]|1[0-9]|2[0-9]|3[0168]|4[04589]|5[012]|7[78]|159|16[0-9]|17[0-2]|21[569]|22[03489]|250)$/), m2 = false, v2 = 0;
    this.__bidiEngine__ = {};
    var b2 = /* @__PURE__ */ __name(function(t4) {
      var e2 = t4.charCodeAt(), r3 = e2 >> 8, n3 = d2[r3];
      return void 0 !== n3 ? u2[256 * n3 + (255 & e2)] : 252 === r3 || 253 === r3 ? "AL" : g2.test(r3) ? "L" : 8 === r3 ? "R" : "N";
    }, "b"), y2 = /* @__PURE__ */ __name(function(t4) {
      for (var e2, r3 = 0; r3 < t4.length; r3++) {
        if ("L" === (e2 = b2(t4.charAt(r3))))
          return false;
        if ("R" === e2)
          return true;
      }
      return false;
    }, "y"), w2 = /* @__PURE__ */ __name(function(t4, e2, o3, s3) {
      var c3, u3, h4, l3, f3 = e2[s3];
      switch (f3) {
        case "L":
        case "R":
          m2 = false;
          break;
        case "N":
        case "AN":
          break;
        case "EN":
          m2 && (f3 = "AN");
          break;
        case "AL":
          m2 = true, f3 = "R";
          break;
        case "WS":
          f3 = "N";
          break;
        case "CS":
          s3 < 1 || s3 + 1 >= e2.length || "EN" !== (c3 = o3[s3 - 1]) && "AN" !== c3 || "EN" !== (u3 = e2[s3 + 1]) && "AN" !== u3 ? f3 = "N" : m2 && (u3 = "AN"), f3 = u3 === c3 ? u3 : "N";
          break;
        case "ES":
          f3 = "EN" === (c3 = s3 > 0 ? o3[s3 - 1] : "B") && s3 + 1 < e2.length && "EN" === e2[s3 + 1] ? "EN" : "N";
          break;
        case "ET":
          if (s3 > 0 && "EN" === o3[s3 - 1]) {
            f3 = "EN";
            break;
          }
          if (m2) {
            f3 = "N";
            break;
          }
          for (h4 = s3 + 1, l3 = e2.length; h4 < l3 && "ET" === e2[h4]; )
            h4++;
          f3 = h4 < l3 && "EN" === e2[h4] ? "EN" : "N";
          break;
        case "NSM":
          if (i2 && !a2) {
            for (l3 = e2.length, h4 = s3 + 1; h4 < l3 && "NSM" === e2[h4]; )
              h4++;
            if (h4 < l3) {
              var d3 = t4[s3], p3 = d3 >= 1425 && d3 <= 2303 || 64286 === d3;
              if (c3 = e2[h4], p3 && ("R" === c3 || "AL" === c3)) {
                f3 = "R";
                break;
              }
            }
          }
          f3 = s3 < 1 || "B" === (c3 = e2[s3 - 1]) ? "N" : o3[s3 - 1];
          break;
        case "B":
          m2 = false, r2 = true, f3 = v2;
          break;
        case "S":
          n2 = true, f3 = "N";
          break;
        case "LRE":
        case "RLE":
        case "LRO":
        case "RLO":
        case "PDF":
          m2 = false;
          break;
        case "BN":
          f3 = "N";
      }
      return f3;
    }, "w"), N2 = /* @__PURE__ */ __name(function(t4, e2, r3) {
      var n3 = t4.split("");
      return r3 && L2(n3, r3, { hiLevel: v2 }), n3.reverse(), e2 && e2.reverse(), n3.join("");
    }, "N"), L2 = /* @__PURE__ */ __name(function(t4, e2, i3) {
      var a3, o3, s3, c3, u3, d3 = -1, p3 = t4.length, g3 = 0, y3 = [], N3 = v2 ? l2 : h3, L3 = [];
      for (m2 = false, r2 = false, n2 = false, o3 = 0; o3 < p3; o3++)
        L3[o3] = b2(t4[o3]);
      for (s3 = 0; s3 < p3; s3++) {
        if (u3 = g3, y3[s3] = w2(t4, L3, y3, s3), a3 = 240 & (g3 = N3[u3][f2[y3[s3]]]), g3 &= 15, e2[s3] = c3 = N3[g3][5], a3 > 0)
          if (16 === a3) {
            for (o3 = d3; o3 < s3; o3++)
              e2[o3] = 1;
            d3 = -1;
          } else
            d3 = -1;
        if (N3[g3][6])
          -1 === d3 && (d3 = s3);
        else if (d3 > -1) {
          for (o3 = d3; o3 < s3; o3++)
            e2[o3] = c3;
          d3 = -1;
        }
        "B" === L3[s3] && (e2[s3] = 0), i3.hiLevel |= c3;
      }
      n2 && function(t5, e3, r3) {
        for (var n3 = 0; n3 < r3; n3++)
          if ("S" === t5[n3]) {
            e3[n3] = v2;
            for (var i4 = n3 - 1; i4 >= 0 && "WS" === t5[i4]; i4--)
              e3[i4] = v2;
          }
      }(L3, e2, p3);
    }, "L"), A2 = /* @__PURE__ */ __name(function(t4, e2, n3, i3, a3) {
      if (!(a3.hiLevel < t4)) {
        if (1 === t4 && 1 === v2 && !r2)
          return e2.reverse(), void (n3 && n3.reverse());
        for (var o3, s3, c3, u3, h4 = e2.length, l3 = 0; l3 < h4; ) {
          if (i3[l3] >= t4) {
            for (c3 = l3 + 1; c3 < h4 && i3[c3] >= t4; )
              c3++;
            for (u3 = l3, s3 = c3 - 1; u3 < s3; u3++, s3--)
              o3 = e2[u3], e2[u3] = e2[s3], e2[s3] = o3, n3 && (o3 = n3[u3], n3[u3] = n3[s3], n3[s3] = o3);
            l3 = c3;
          }
          l3++;
        }
      }
    }, "A"), x2 = /* @__PURE__ */ __name(function(t4, e2, r3) {
      var n3 = t4.split(""), i3 = { hiLevel: v2 };
      return r3 || (r3 = []), L2(n3, r3, i3), function(t5, e3, r4) {
        if (0 !== r4.hiLevel && c2)
          for (var n4, i4 = 0; i4 < t5.length; i4++)
            1 === e3[i4] && (n4 = p2.indexOf(t5[i4])) >= 0 && (t5[i4] = p2[n4 + 1]);
      }(n3, r3, i3), A2(2, n3, e2, r3, i3), A2(1, n3, e2, r3, i3), n3.join("");
    }, "x");
    return this.__bidiEngine__.doBidiReorder = function(t4, e2, r3) {
      if (function(t5, e3) {
        if (e3)
          for (var r4 = 0; r4 < t5.length; r4++)
            e3[r4] = r4;
        void 0 === a2 && (a2 = y2(t5)), void 0 === s2 && (s2 = y2(t5));
      }(t4, e2), i2 || !o2 || s2)
        if (i2 && o2 && a2 ^ s2)
          v2 = a2 ? 1 : 0, t4 = N2(t4, e2, r3);
        else if (!i2 && o2 && s2)
          v2 = a2 ? 1 : 0, t4 = x2(t4, e2, r3), t4 = N2(t4, e2);
        else if (!i2 || a2 || o2 || s2) {
          if (i2 && !o2 && a2 ^ s2)
            t4 = N2(t4, e2), a2 ? (v2 = 0, t4 = x2(t4, e2, r3)) : (v2 = 1, t4 = x2(t4, e2, r3), t4 = N2(t4, e2));
          else if (i2 && a2 && !o2 && s2)
            v2 = 1, t4 = x2(t4, e2, r3), t4 = N2(t4, e2);
          else if (!i2 && !o2 && a2 ^ s2) {
            var n3 = c2;
            a2 ? (v2 = 1, t4 = x2(t4, e2, r3), v2 = 0, c2 = false, t4 = x2(t4, e2, r3), c2 = n3) : (v2 = 0, t4 = x2(t4, e2, r3), t4 = N2(t4, e2), v2 = 1, c2 = false, t4 = x2(t4, e2, r3), c2 = n3, t4 = N2(t4, e2));
          }
        } else
          v2 = 0, t4 = x2(t4, e2, r3);
      else
        v2 = a2 ? 1 : 0, t4 = x2(t4, e2, r3);
      return t4;
    }, this.__bidiEngine__.setOptions = function(t4) {
      t4 && (i2 = t4.isInputVisual, o2 = t4.isOutputVisual, a2 = t4.isInputRtl, s2 = t4.isOutputRtl, c2 = t4.isSymmetricSwapping);
    }, this.__bidiEngine__.setOptions(t3), this.__bidiEngine__;
  };
  var e = ["BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "S", "B", "S", "WS", "B", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "B", "B", "B", "S", "WS", "N", "N", "ET", "ET", "ET", "N", "N", "N", "N", "N", "ES", "CS", "ES", "CS", "CS", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "CS", "N", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "N", "N", "N", "BN", "BN", "BN", "BN", "BN", "BN", "B", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "CS", "N", "ET", "ET", "ET", "ET", "N", "N", "N", "N", "L", "N", "N", "BN", "N", "N", "ET", "ET", "EN", "EN", "N", "L", "N", "N", "N", "EN", "L", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "N", "L", "L", "L", "L", "L", "L", "L", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "L", "N", "N", "N", "N", "N", "ET", "N", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "R", "NSM", "R", "NSM", "NSM", "R", "NSM", "NSM", "R", "NSM", "N", "N", "N", "N", "N", "N", "N", "N", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "N", "N", "N", "N", "N", "R", "R", "R", "R", "R", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "AN", "AN", "AN", "AN", "AN", "AN", "N", "N", "AL", "ET", "ET", "AL", "CS", "AL", "N", "N", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AL", "AL", "N", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AN", "AN", "AN", "AN", "AN", "AN", "AN", "AN", "AN", "AN", "ET", "AN", "AN", "AL", "AL", "AL", "NSM", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AN", "N", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AL", "AL", "NSM", "NSM", "N", "NSM", "NSM", "NSM", "NSM", "AL", "AL", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "N", "AL", "AL", "NSM", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "N", "N", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AL", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "R", "R", "N", "N", "N", "N", "R", "N", "N", "N", "N", "N", "WS", "WS", "WS", "WS", "WS", "WS", "WS", "WS", "WS", "WS", "WS", "BN", "BN", "BN", "L", "R", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "WS", "B", "LRE", "RLE", "PDF", "LRO", "RLO", "CS", "ET", "ET", "ET", "ET", "ET", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "CS", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "WS", "BN", "BN", "BN", "BN", "BN", "N", "LRI", "RLI", "FSI", "PDI", "BN", "BN", "BN", "BN", "BN", "BN", "EN", "L", "N", "N", "EN", "EN", "EN", "EN", "EN", "EN", "ES", "ES", "N", "N", "N", "L", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "ES", "ES", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "N", "N", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "N", "N", "N", "N", "N", "R", "NSM", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "ES", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "N", "R", "R", "R", "R", "R", "N", "R", "N", "R", "R", "N", "R", "R", "N", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "CS", "N", "CS", "N", "N", "CS", "N", "N", "N", "N", "N", "N", "N", "N", "N", "ET", "N", "N", "ES", "ES", "N", "N", "N", "N", "N", "ET", "ET", "N", "N", "N", "N", "N", "AL", "AL", "AL", "AL", "AL", "N", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "N", "N", "BN", "N", "N", "N", "ET", "ET", "ET", "N", "N", "N", "N", "N", "ES", "CS", "ES", "CS", "CS", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "CS", "N", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "N", "N", "L", "L", "L", "L", "L", "L", "N", "N", "L", "L", "L", "L", "L", "L", "N", "N", "L", "L", "L", "L", "L", "L", "N", "N", "L", "L", "L", "N", "N", "N", "ET", "ET", "N", "N", "N", "ET", "ET", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N"], r = new t2.__bidiEngine__({ isInputVisual: true });
  t2.API.events.push(["postProcessText", function(t3) {
    var e2 = t3.text, n2 = (t3.x, t3.y, t3.options || {}), i2 = (t3.mutex, n2.lang, []);
    if (n2.isInputVisual = "boolean" != typeof n2.isInputVisual || n2.isInputVisual, r.setOptions(n2), "[object Array]" === Object.prototype.toString.call(e2)) {
      var a2 = 0;
      for (i2 = [], a2 = 0; a2 < e2.length; a2 += 1)
        "[object Array]" === Object.prototype.toString.call(e2[a2]) ? i2.push([r.doBidiReorder(e2[a2][0]), e2[a2][1], e2[a2][2]]) : i2.push([r.doBidiReorder(e2[a2])]);
      t3.text = i2;
    } else
      t3.text = r.doBidiReorder(e2);
    r.setOptions({ isInputVisual: true });
  }]);
}(E), E.API.TTFFont = function() {
  function t2(t3) {
    var e;
    if (this.rawData = t3, e = this.contents = new ne(t3), this.contents.pos = 4, "ttcf" === e.readString(4))
      throw new Error("TTCF not supported.");
    e.pos = 0, this.parse(), this.subset = new Le(this), this.registerTTF();
  }
  __name(t2, "t");
  return t2.open = function(e) {
    return new t2(e);
  }, t2.prototype.parse = function() {
    return this.directory = new ie(this.contents), this.head = new se(this), this.name = new pe(this), this.cmap = new ue(this), this.toUnicode = {}, this.hhea = new he(this), this.maxp = new ge(this), this.hmtx = new me(this), this.post = new fe(this), this.os2 = new le(this), this.loca = new Ne(this), this.glyf = new be(this), this.ascender = this.os2.exists && this.os2.ascender || this.hhea.ascender, this.decender = this.os2.exists && this.os2.decender || this.hhea.decender, this.lineGap = this.os2.exists && this.os2.lineGap || this.hhea.lineGap, this.bbox = [this.head.xMin, this.head.yMin, this.head.xMax, this.head.yMax];
  }, t2.prototype.registerTTF = function() {
    var t3, e, r, n2, i2;
    if (this.scaleFactor = 1e3 / this.head.unitsPerEm, this.bbox = (function() {
      var e2, r2, n3, i3;
      for (i3 = [], e2 = 0, r2 = (n3 = this.bbox).length; e2 < r2; e2++)
        t3 = n3[e2], i3.push(Math.round(t3 * this.scaleFactor));
      return i3;
    }).call(this), this.stemV = 0, this.post.exists ? (r = 255 & (n2 = this.post.italic_angle), 0 != (32768 & (e = n2 >> 16)) && (e = -(1 + (65535 ^ e))), this.italicAngle = +(e + "." + r)) : this.italicAngle = 0, this.ascender = Math.round(this.ascender * this.scaleFactor), this.decender = Math.round(this.decender * this.scaleFactor), this.lineGap = Math.round(this.lineGap * this.scaleFactor), this.capHeight = this.os2.exists && this.os2.capHeight || this.ascender, this.xHeight = this.os2.exists && this.os2.xHeight || 0, this.familyClass = (this.os2.exists && this.os2.familyClass || 0) >> 8, this.isSerif = 1 === (i2 = this.familyClass) || 2 === i2 || 3 === i2 || 4 === i2 || 5 === i2 || 7 === i2, this.isScript = 10 === this.familyClass, this.flags = 0, this.post.isFixedPitch && (this.flags |= 1), this.isSerif && (this.flags |= 2), this.isScript && (this.flags |= 8), 0 !== this.italicAngle && (this.flags |= 64), this.flags |= 32, !this.cmap.unicode)
      throw new Error("No unicode cmap for font");
  }, t2.prototype.characterToGlyph = function(t3) {
    var e;
    return (null != (e = this.cmap.unicode) ? e.codeMap[t3] : void 0) || 0;
  }, t2.prototype.widthOfGlyph = function(t3) {
    var e;
    return e = 1e3 / this.head.unitsPerEm, this.hmtx.forGlyph(t3).advance * e;
  }, t2.prototype.widthOfString = function(t3, e, r) {
    var n2, i2, a2, o2;
    for (a2 = 0, i2 = 0, o2 = (t3 = "" + t3).length; 0 <= o2 ? i2 < o2 : i2 > o2; i2 = 0 <= o2 ? ++i2 : --i2)
      n2 = t3.charCodeAt(i2), a2 += this.widthOfGlyph(this.characterToGlyph(n2)) + r * (1e3 / e) || 0;
    return a2 * (e / 1e3);
  }, t2.prototype.lineHeight = function(t3, e) {
    var r;
    return null == e && (e = false), r = e ? this.lineGap : 0, (this.ascender + r - this.decender) / 1e3 * t3;
  }, t2;
}();
var re, ne = function() {
  function t2(t3) {
    this.data = null != t3 ? t3 : [], this.pos = 0, this.length = this.data.length;
  }
  __name(t2, "t");
  return t2.prototype.readByte = function() {
    return this.data[this.pos++];
  }, t2.prototype.writeByte = function(t3) {
    return this.data[this.pos++] = t3;
  }, t2.prototype.readUInt32 = function() {
    return 16777216 * this.readByte() + (this.readByte() << 16) + (this.readByte() << 8) + this.readByte();
  }, t2.prototype.writeUInt32 = function(t3) {
    return this.writeByte(t3 >>> 24 & 255), this.writeByte(t3 >> 16 & 255), this.writeByte(t3 >> 8 & 255), this.writeByte(255 & t3);
  }, t2.prototype.readInt32 = function() {
    var t3;
    return (t3 = this.readUInt32()) >= 2147483648 ? t3 - 4294967296 : t3;
  }, t2.prototype.writeInt32 = function(t3) {
    return t3 < 0 && (t3 += 4294967296), this.writeUInt32(t3);
  }, t2.prototype.readUInt16 = function() {
    return this.readByte() << 8 | this.readByte();
  }, t2.prototype.writeUInt16 = function(t3) {
    return this.writeByte(t3 >> 8 & 255), this.writeByte(255 & t3);
  }, t2.prototype.readInt16 = function() {
    var t3;
    return (t3 = this.readUInt16()) >= 32768 ? t3 - 65536 : t3;
  }, t2.prototype.writeInt16 = function(t3) {
    return t3 < 0 && (t3 += 65536), this.writeUInt16(t3);
  }, t2.prototype.readString = function(t3) {
    var e, r;
    for (r = [], e = 0; 0 <= t3 ? e < t3 : e > t3; e = 0 <= t3 ? ++e : --e)
      r[e] = String.fromCharCode(this.readByte());
    return r.join("");
  }, t2.prototype.writeString = function(t3) {
    var e, r, n2;
    for (n2 = [], e = 0, r = t3.length; 0 <= r ? e < r : e > r; e = 0 <= r ? ++e : --e)
      n2.push(this.writeByte(t3.charCodeAt(e)));
    return n2;
  }, t2.prototype.readShort = function() {
    return this.readInt16();
  }, t2.prototype.writeShort = function(t3) {
    return this.writeInt16(t3);
  }, t2.prototype.readLongLong = function() {
    var t3, e, r, n2, i2, a2, o2, s2;
    return t3 = this.readByte(), e = this.readByte(), r = this.readByte(), n2 = this.readByte(), i2 = this.readByte(), a2 = this.readByte(), o2 = this.readByte(), s2 = this.readByte(), 128 & t3 ? -1 * (72057594037927940 * (255 ^ t3) + 281474976710656 * (255 ^ e) + 1099511627776 * (255 ^ r) + 4294967296 * (255 ^ n2) + 16777216 * (255 ^ i2) + 65536 * (255 ^ a2) + 256 * (255 ^ o2) + (255 ^ s2) + 1) : 72057594037927940 * t3 + 281474976710656 * e + 1099511627776 * r + 4294967296 * n2 + 16777216 * i2 + 65536 * a2 + 256 * o2 + s2;
  }, t2.prototype.writeLongLong = function(t3) {
    var e, r;
    return e = Math.floor(t3 / 4294967296), r = 4294967295 & t3, this.writeByte(e >> 24 & 255), this.writeByte(e >> 16 & 255), this.writeByte(e >> 8 & 255), this.writeByte(255 & e), this.writeByte(r >> 24 & 255), this.writeByte(r >> 16 & 255), this.writeByte(r >> 8 & 255), this.writeByte(255 & r);
  }, t2.prototype.readInt = function() {
    return this.readInt32();
  }, t2.prototype.writeInt = function(t3) {
    return this.writeInt32(t3);
  }, t2.prototype.read = function(t3) {
    var e, r;
    for (e = [], r = 0; 0 <= t3 ? r < t3 : r > t3; r = 0 <= t3 ? ++r : --r)
      e.push(this.readByte());
    return e;
  }, t2.prototype.write = function(t3) {
    var e, r, n2, i2;
    for (i2 = [], r = 0, n2 = t3.length; r < n2; r++)
      e = t3[r], i2.push(this.writeByte(e));
    return i2;
  }, t2;
}(), ie = function() {
  var t2;
  function e(t3) {
    var e2, r, n2;
    for (this.scalarType = t3.readInt(), this.tableCount = t3.readShort(), this.searchRange = t3.readShort(), this.entrySelector = t3.readShort(), this.rangeShift = t3.readShort(), this.tables = {}, r = 0, n2 = this.tableCount; 0 <= n2 ? r < n2 : r > n2; r = 0 <= n2 ? ++r : --r)
      e2 = { tag: t3.readString(4), checksum: t3.readInt(), offset: t3.readInt(), length: t3.readInt() }, this.tables[e2.tag] = e2;
  }
  __name(e, "e");
  return e.prototype.encode = function(e2) {
    var r, n2, i2, a2, o2, s2, c2, u2, h3, l2, f2, d2, p2;
    for (p2 in f2 = Object.keys(e2).length, s2 = Math.log(2), h3 = 16 * Math.floor(Math.log(f2) / s2), a2 = Math.floor(h3 / s2), u2 = 16 * f2 - h3, (n2 = new ne()).writeInt(this.scalarType), n2.writeShort(f2), n2.writeShort(h3), n2.writeShort(a2), n2.writeShort(u2), i2 = 16 * f2, c2 = n2.pos + i2, o2 = null, d2 = [], e2)
      for (l2 = e2[p2], n2.writeString(p2), n2.writeInt(t2(l2)), n2.writeInt(c2), n2.writeInt(l2.length), d2 = d2.concat(l2), "head" === p2 && (o2 = c2), c2 += l2.length; c2 % 4; )
        d2.push(0), c2++;
    return n2.write(d2), r = 2981146554 - t2(n2.data), n2.pos = o2 + 8, n2.writeUInt32(r), n2.data;
  }, t2 = /* @__PURE__ */ __name(function(t3) {
    var e2, r, n2, i2;
    for (t3 = ve.call(t3); t3.length % 4; )
      t3.push(0);
    for (n2 = new ne(t3), r = 0, e2 = 0, i2 = t3.length; e2 < i2; e2 = e2 += 4)
      r += n2.readUInt32();
    return 4294967295 & r;
  }, "t"), e;
}(), ae = {}.hasOwnProperty, oe = /* @__PURE__ */ __name(function(t2, e) {
  for (var r in e)
    ae.call(e, r) && (t2[r] = e[r]);
  function n2() {
    this.constructor = t2;
  }
  __name(n2, "n");
  return n2.prototype = e.prototype, t2.prototype = new n2(), t2.__super__ = e.prototype, t2;
}, "oe");
re = function() {
  function t2(t3) {
    var e;
    this.file = t3, e = this.file.directory.tables[this.tag], this.exists = !!e, e && (this.offset = e.offset, this.length = e.length, this.parse(this.file.contents));
  }
  __name(t2, "t");
  return t2.prototype.parse = function() {
  }, t2.prototype.encode = function() {
  }, t2.prototype.raw = function() {
    return this.exists ? (this.file.contents.pos = this.offset, this.file.contents.read(this.length)) : null;
  }, t2;
}();
var se = function(t2) {
  function e() {
    return e.__super__.constructor.apply(this, arguments);
  }
  __name(e, "e");
  return oe(e, re), e.prototype.tag = "head", e.prototype.parse = function(t3) {
    return t3.pos = this.offset, this.version = t3.readInt(), this.revision = t3.readInt(), this.checkSumAdjustment = t3.readInt(), this.magicNumber = t3.readInt(), this.flags = t3.readShort(), this.unitsPerEm = t3.readShort(), this.created = t3.readLongLong(), this.modified = t3.readLongLong(), this.xMin = t3.readShort(), this.yMin = t3.readShort(), this.xMax = t3.readShort(), this.yMax = t3.readShort(), this.macStyle = t3.readShort(), this.lowestRecPPEM = t3.readShort(), this.fontDirectionHint = t3.readShort(), this.indexToLocFormat = t3.readShort(), this.glyphDataFormat = t3.readShort();
  }, e.prototype.encode = function(t3) {
    var e2;
    return (e2 = new ne()).writeInt(this.version), e2.writeInt(this.revision), e2.writeInt(this.checkSumAdjustment), e2.writeInt(this.magicNumber), e2.writeShort(this.flags), e2.writeShort(this.unitsPerEm), e2.writeLongLong(this.created), e2.writeLongLong(this.modified), e2.writeShort(this.xMin), e2.writeShort(this.yMin), e2.writeShort(this.xMax), e2.writeShort(this.yMax), e2.writeShort(this.macStyle), e2.writeShort(this.lowestRecPPEM), e2.writeShort(this.fontDirectionHint), e2.writeShort(t3), e2.writeShort(this.glyphDataFormat), e2.data;
  }, e;
}(), ce = function() {
  function t2(t3, e) {
    var r, n2, i2, a2, o2, s2, c2, u2, h3, l2, f2, d2, p2, g2, m2, v2, b2;
    switch (this.platformID = t3.readUInt16(), this.encodingID = t3.readShort(), this.offset = e + t3.readInt(), h3 = t3.pos, t3.pos = this.offset, this.format = t3.readUInt16(), this.length = t3.readUInt16(), this.language = t3.readUInt16(), this.isUnicode = 3 === this.platformID && 1 === this.encodingID && 4 === this.format || 0 === this.platformID && 4 === this.format, this.codeMap = {}, this.format) {
      case 0:
        for (s2 = 0; s2 < 256; ++s2)
          this.codeMap[s2] = t3.readByte();
        break;
      case 4:
        for (f2 = t3.readUInt16(), l2 = f2 / 2, t3.pos += 6, i2 = function() {
          var e2, r2;
          for (r2 = [], s2 = e2 = 0; 0 <= l2 ? e2 < l2 : e2 > l2; s2 = 0 <= l2 ? ++e2 : --e2)
            r2.push(t3.readUInt16());
          return r2;
        }(), t3.pos += 2, p2 = function() {
          var e2, r2;
          for (r2 = [], s2 = e2 = 0; 0 <= l2 ? e2 < l2 : e2 > l2; s2 = 0 <= l2 ? ++e2 : --e2)
            r2.push(t3.readUInt16());
          return r2;
        }(), c2 = function() {
          var e2, r2;
          for (r2 = [], s2 = e2 = 0; 0 <= l2 ? e2 < l2 : e2 > l2; s2 = 0 <= l2 ? ++e2 : --e2)
            r2.push(t3.readUInt16());
          return r2;
        }(), u2 = function() {
          var e2, r2;
          for (r2 = [], s2 = e2 = 0; 0 <= l2 ? e2 < l2 : e2 > l2; s2 = 0 <= l2 ? ++e2 : --e2)
            r2.push(t3.readUInt16());
          return r2;
        }(), n2 = (this.length - t3.pos + this.offset) / 2, o2 = function() {
          var e2, r2;
          for (r2 = [], s2 = e2 = 0; 0 <= n2 ? e2 < n2 : e2 > n2; s2 = 0 <= n2 ? ++e2 : --e2)
            r2.push(t3.readUInt16());
          return r2;
        }(), s2 = m2 = 0, b2 = i2.length; m2 < b2; s2 = ++m2)
          for (g2 = i2[s2], r = v2 = d2 = p2[s2]; d2 <= g2 ? v2 <= g2 : v2 >= g2; r = d2 <= g2 ? ++v2 : --v2)
            0 === u2[s2] ? a2 = r + c2[s2] : 0 !== (a2 = o2[u2[s2] / 2 + (r - d2) - (l2 - s2)] || 0) && (a2 += c2[s2]), this.codeMap[r] = 65535 & a2;
    }
    t3.pos = h3;
  }
  __name(t2, "t");
  return t2.encode = function(t3, e) {
    var r, n2, i2, a2, o2, s2, c2, u2, h3, l2, f2, d2, p2, g2, m2, v2, b2, y2, w2, N2, L2, A2, x2, S2, _2, P2, k2, I2, F2, C2, j2, O2, B2, M2, E2, q2, D2, R2, T2, U2, z2, H2, W2, V2, G2, Y2;
    switch (I2 = new ne(), a2 = Object.keys(t3).sort(function(t4, e2) {
      return t4 - e2;
    }), e) {
      case "macroman":
        for (p2 = 0, g2 = function() {
          var t4 = [];
          for (d2 = 0; d2 < 256; ++d2)
            t4.push(0);
          return t4;
        }(), v2 = { 0: 0 }, i2 = {}, F2 = 0, B2 = a2.length; F2 < B2; F2++)
          null == v2[W2 = t3[n2 = a2[F2]]] && (v2[W2] = ++p2), i2[n2] = { old: t3[n2], new: v2[t3[n2]] }, g2[n2] = v2[t3[n2]];
        return I2.writeUInt16(1), I2.writeUInt16(0), I2.writeUInt32(12), I2.writeUInt16(0), I2.writeUInt16(262), I2.writeUInt16(0), I2.write(g2), { charMap: i2, subtable: I2.data, maxGlyphID: p2 + 1 };
      case "unicode":
        for (P2 = [], h3 = [], b2 = 0, v2 = {}, r = {}, m2 = c2 = null, C2 = 0, M2 = a2.length; C2 < M2; C2++)
          null == v2[w2 = t3[n2 = a2[C2]]] && (v2[w2] = ++b2), r[n2] = { old: w2, new: v2[w2] }, o2 = v2[w2] - n2, null != m2 && o2 === c2 || (m2 && h3.push(m2), P2.push(n2), c2 = o2), m2 = n2;
        for (m2 && h3.push(m2), h3.push(65535), P2.push(65535), S2 = 2 * (x2 = P2.length), A2 = 2 * Math.pow(Math.log(x2) / Math.LN2, 2), l2 = Math.log(A2 / 2) / Math.LN2, L2 = 2 * x2 - A2, s2 = [], N2 = [], f2 = [], d2 = j2 = 0, E2 = P2.length; j2 < E2; d2 = ++j2) {
          if (_2 = P2[d2], u2 = h3[d2], 65535 === _2) {
            s2.push(0), N2.push(0);
            break;
          }
          if (_2 - (k2 = r[_2].new) >= 32768)
            for (s2.push(0), N2.push(2 * (f2.length + x2 - d2)), n2 = O2 = _2; _2 <= u2 ? O2 <= u2 : O2 >= u2; n2 = _2 <= u2 ? ++O2 : --O2)
              f2.push(r[n2].new);
          else
            s2.push(k2 - _2), N2.push(0);
        }
        for (I2.writeUInt16(3), I2.writeUInt16(1), I2.writeUInt32(12), I2.writeUInt16(4), I2.writeUInt16(16 + 8 * x2 + 2 * f2.length), I2.writeUInt16(0), I2.writeUInt16(S2), I2.writeUInt16(A2), I2.writeUInt16(l2), I2.writeUInt16(L2), z2 = 0, q2 = h3.length; z2 < q2; z2++)
          n2 = h3[z2], I2.writeUInt16(n2);
        for (I2.writeUInt16(0), H2 = 0, D2 = P2.length; H2 < D2; H2++)
          n2 = P2[H2], I2.writeUInt16(n2);
        for (V2 = 0, R2 = s2.length; V2 < R2; V2++)
          o2 = s2[V2], I2.writeUInt16(o2);
        for (G2 = 0, T2 = N2.length; G2 < T2; G2++)
          y2 = N2[G2], I2.writeUInt16(y2);
        for (Y2 = 0, U2 = f2.length; Y2 < U2; Y2++)
          p2 = f2[Y2], I2.writeUInt16(p2);
        return { charMap: r, subtable: I2.data, maxGlyphID: b2 + 1 };
    }
  }, t2;
}(), ue = function(t2) {
  function e() {
    return e.__super__.constructor.apply(this, arguments);
  }
  __name(e, "e");
  return oe(e, re), e.prototype.tag = "cmap", e.prototype.parse = function(t3) {
    var e2, r, n2;
    for (t3.pos = this.offset, this.version = t3.readUInt16(), n2 = t3.readUInt16(), this.tables = [], this.unicode = null, r = 0; 0 <= n2 ? r < n2 : r > n2; r = 0 <= n2 ? ++r : --r)
      e2 = new ce(t3, this.offset), this.tables.push(e2), e2.isUnicode && null == this.unicode && (this.unicode = e2);
    return true;
  }, e.encode = function(t3, e2) {
    var r, n2;
    return null == e2 && (e2 = "macroman"), r = ce.encode(t3, e2), (n2 = new ne()).writeUInt16(0), n2.writeUInt16(1), r.table = n2.data.concat(r.subtable), r;
  }, e;
}(), he = function(t2) {
  function e() {
    return e.__super__.constructor.apply(this, arguments);
  }
  __name(e, "e");
  return oe(e, re), e.prototype.tag = "hhea", e.prototype.parse = function(t3) {
    return t3.pos = this.offset, this.version = t3.readInt(), this.ascender = t3.readShort(), this.decender = t3.readShort(), this.lineGap = t3.readShort(), this.advanceWidthMax = t3.readShort(), this.minLeftSideBearing = t3.readShort(), this.minRightSideBearing = t3.readShort(), this.xMaxExtent = t3.readShort(), this.caretSlopeRise = t3.readShort(), this.caretSlopeRun = t3.readShort(), this.caretOffset = t3.readShort(), t3.pos += 8, this.metricDataFormat = t3.readShort(), this.numberOfMetrics = t3.readUInt16();
  }, e;
}(), le = function(t2) {
  function e() {
    return e.__super__.constructor.apply(this, arguments);
  }
  __name(e, "e");
  return oe(e, re), e.prototype.tag = "OS/2", e.prototype.parse = function(t3) {
    if (t3.pos = this.offset, this.version = t3.readUInt16(), this.averageCharWidth = t3.readShort(), this.weightClass = t3.readUInt16(), this.widthClass = t3.readUInt16(), this.type = t3.readShort(), this.ySubscriptXSize = t3.readShort(), this.ySubscriptYSize = t3.readShort(), this.ySubscriptXOffset = t3.readShort(), this.ySubscriptYOffset = t3.readShort(), this.ySuperscriptXSize = t3.readShort(), this.ySuperscriptYSize = t3.readShort(), this.ySuperscriptXOffset = t3.readShort(), this.ySuperscriptYOffset = t3.readShort(), this.yStrikeoutSize = t3.readShort(), this.yStrikeoutPosition = t3.readShort(), this.familyClass = t3.readShort(), this.panose = function() {
      var e2, r;
      for (r = [], e2 = 0; e2 < 10; ++e2)
        r.push(t3.readByte());
      return r;
    }(), this.charRange = function() {
      var e2, r;
      for (r = [], e2 = 0; e2 < 4; ++e2)
        r.push(t3.readInt());
      return r;
    }(), this.vendorID = t3.readString(4), this.selection = t3.readShort(), this.firstCharIndex = t3.readShort(), this.lastCharIndex = t3.readShort(), this.version > 0 && (this.ascent = t3.readShort(), this.descent = t3.readShort(), this.lineGap = t3.readShort(), this.winAscent = t3.readShort(), this.winDescent = t3.readShort(), this.codePageRange = function() {
      var e2, r;
      for (r = [], e2 = 0; e2 < 2; e2 = ++e2)
        r.push(t3.readInt());
      return r;
    }(), this.version > 1))
      return this.xHeight = t3.readShort(), this.capHeight = t3.readShort(), this.defaultChar = t3.readShort(), this.breakChar = t3.readShort(), this.maxContext = t3.readShort();
  }, e;
}(), fe = function(t2) {
  function e() {
    return e.__super__.constructor.apply(this, arguments);
  }
  __name(e, "e");
  return oe(e, re), e.prototype.tag = "post", e.prototype.parse = function(t3) {
    var e2, r, n2;
    switch (t3.pos = this.offset, this.format = t3.readInt(), this.italicAngle = t3.readInt(), this.underlinePosition = t3.readShort(), this.underlineThickness = t3.readShort(), this.isFixedPitch = t3.readInt(), this.minMemType42 = t3.readInt(), this.maxMemType42 = t3.readInt(), this.minMemType1 = t3.readInt(), this.maxMemType1 = t3.readInt(), this.format) {
      case 65536:
        break;
      case 131072:
        var i2;
        for (r = t3.readUInt16(), this.glyphNameIndex = [], i2 = 0; 0 <= r ? i2 < r : i2 > r; i2 = 0 <= r ? ++i2 : --i2)
          this.glyphNameIndex.push(t3.readUInt16());
        for (this.names = [], n2 = []; t3.pos < this.offset + this.length; )
          e2 = t3.readByte(), n2.push(this.names.push(t3.readString(e2)));
        return n2;
      case 151552:
        return r = t3.readUInt16(), this.offsets = t3.read(r);
      case 196608:
        break;
      case 262144:
        return this.map = (function() {
          var e3, r2, n3;
          for (n3 = [], i2 = e3 = 0, r2 = this.file.maxp.numGlyphs; 0 <= r2 ? e3 < r2 : e3 > r2; i2 = 0 <= r2 ? ++e3 : --e3)
            n3.push(t3.readUInt32());
          return n3;
        }).call(this);
    }
  }, e;
}(), de = /* @__PURE__ */ __name(function(t2, e) {
  this.raw = t2, this.length = t2.length, this.platformID = e.platformID, this.encodingID = e.encodingID, this.languageID = e.languageID;
}, "de"), pe = function(t2) {
  function e() {
    return e.__super__.constructor.apply(this, arguments);
  }
  __name(e, "e");
  return oe(e, re), e.prototype.tag = "name", e.prototype.parse = function(t3) {
    var e2, r, n2, i2, a2, o2, s2, c2, u2, h3, l2;
    for (t3.pos = this.offset, t3.readShort(), e2 = t3.readShort(), o2 = t3.readShort(), r = [], i2 = 0; 0 <= e2 ? i2 < e2 : i2 > e2; i2 = 0 <= e2 ? ++i2 : --i2)
      r.push({ platformID: t3.readShort(), encodingID: t3.readShort(), languageID: t3.readShort(), nameID: t3.readShort(), length: t3.readShort(), offset: this.offset + o2 + t3.readShort() });
    for (s2 = {}, i2 = u2 = 0, h3 = r.length; u2 < h3; i2 = ++u2)
      n2 = r[i2], t3.pos = n2.offset, c2 = t3.readString(n2.length), a2 = new de(c2, n2), null == s2[l2 = n2.nameID] && (s2[l2] = []), s2[n2.nameID].push(a2);
    this.strings = s2, this.copyright = s2[0], this.fontFamily = s2[1], this.fontSubfamily = s2[2], this.uniqueSubfamily = s2[3], this.fontName = s2[4], this.version = s2[5];
    try {
      this.postscriptName = s2[6][0].raw.replace(/[\x00-\x19\x80-\xff]/g, "");
    } catch (t4) {
      this.postscriptName = s2[4][0].raw.replace(/[\x00-\x19\x80-\xff]/g, "");
    }
    return this.trademark = s2[7], this.manufacturer = s2[8], this.designer = s2[9], this.description = s2[10], this.vendorUrl = s2[11], this.designerUrl = s2[12], this.license = s2[13], this.licenseUrl = s2[14], this.preferredFamily = s2[15], this.preferredSubfamily = s2[17], this.compatibleFull = s2[18], this.sampleText = s2[19];
  }, e;
}(), ge = function(t2) {
  function e() {
    return e.__super__.constructor.apply(this, arguments);
  }
  __name(e, "e");
  return oe(e, re), e.prototype.tag = "maxp", e.prototype.parse = function(t3) {
    return t3.pos = this.offset, this.version = t3.readInt(), this.numGlyphs = t3.readUInt16(), this.maxPoints = t3.readUInt16(), this.maxContours = t3.readUInt16(), this.maxCompositePoints = t3.readUInt16(), this.maxComponentContours = t3.readUInt16(), this.maxZones = t3.readUInt16(), this.maxTwilightPoints = t3.readUInt16(), this.maxStorage = t3.readUInt16(), this.maxFunctionDefs = t3.readUInt16(), this.maxInstructionDefs = t3.readUInt16(), this.maxStackElements = t3.readUInt16(), this.maxSizeOfInstructions = t3.readUInt16(), this.maxComponentElements = t3.readUInt16(), this.maxComponentDepth = t3.readUInt16();
  }, e;
}(), me = function(t2) {
  function e() {
    return e.__super__.constructor.apply(this, arguments);
  }
  __name(e, "e");
  return oe(e, re), e.prototype.tag = "hmtx", e.prototype.parse = function(t3) {
    var e2, r, n2, i2, a2, o2, s2;
    for (t3.pos = this.offset, this.metrics = [], e2 = 0, o2 = this.file.hhea.numberOfMetrics; 0 <= o2 ? e2 < o2 : e2 > o2; e2 = 0 <= o2 ? ++e2 : --e2)
      this.metrics.push({ advance: t3.readUInt16(), lsb: t3.readInt16() });
    for (n2 = this.file.maxp.numGlyphs - this.file.hhea.numberOfMetrics, this.leftSideBearings = function() {
      var r2, i3;
      for (i3 = [], e2 = r2 = 0; 0 <= n2 ? r2 < n2 : r2 > n2; e2 = 0 <= n2 ? ++r2 : --r2)
        i3.push(t3.readInt16());
      return i3;
    }(), this.widths = (function() {
      var t4, e3, r2, n3;
      for (n3 = [], t4 = 0, e3 = (r2 = this.metrics).length; t4 < e3; t4++)
        i2 = r2[t4], n3.push(i2.advance);
      return n3;
    }).call(this), r = this.widths[this.widths.length - 1], s2 = [], e2 = a2 = 0; 0 <= n2 ? a2 < n2 : a2 > n2; e2 = 0 <= n2 ? ++a2 : --a2)
      s2.push(this.widths.push(r));
    return s2;
  }, e.prototype.forGlyph = function(t3) {
    return t3 in this.metrics ? this.metrics[t3] : { advance: this.metrics[this.metrics.length - 1].advance, lsb: this.leftSideBearings[t3 - this.metrics.length] };
  }, e;
}(), ve = [].slice, be = function(t2) {
  function e() {
    return e.__super__.constructor.apply(this, arguments);
  }
  __name(e, "e");
  return oe(e, re), e.prototype.tag = "glyf", e.prototype.parse = function() {
    return this.cache = {};
  }, e.prototype.glyphFor = function(t3) {
    var e2, r, n2, i2, a2, o2, s2, c2, u2, h3;
    return t3 in this.cache ? this.cache[t3] : (i2 = this.file.loca, e2 = this.file.contents, r = i2.indexOf(t3), 0 === (n2 = i2.lengthOf(t3)) ? this.cache[t3] = null : (e2.pos = this.offset + r, a2 = (o2 = new ne(e2.read(n2))).readShort(), c2 = o2.readShort(), h3 = o2.readShort(), s2 = o2.readShort(), u2 = o2.readShort(), this.cache[t3] = -1 === a2 ? new we(o2, c2, h3, s2, u2) : new ye(o2, a2, c2, h3, s2, u2), this.cache[t3]));
  }, e.prototype.encode = function(t3, e2, r) {
    var n2, i2, a2, o2, s2;
    for (a2 = [], i2 = [], o2 = 0, s2 = e2.length; o2 < s2; o2++)
      n2 = t3[e2[o2]], i2.push(a2.length), n2 && (a2 = a2.concat(n2.encode(r)));
    return i2.push(a2.length), { table: a2, offsets: i2 };
  }, e;
}(), ye = function() {
  function t2(t3, e, r, n2, i2, a2) {
    this.raw = t3, this.numberOfContours = e, this.xMin = r, this.yMin = n2, this.xMax = i2, this.yMax = a2, this.compound = false;
  }
  __name(t2, "t");
  return t2.prototype.encode = function() {
    return this.raw.data;
  }, t2;
}(), we = function() {
  function t2(t3, e, r, n2, i2) {
    var a2, o2;
    for (this.raw = t3, this.xMin = e, this.yMin = r, this.xMax = n2, this.yMax = i2, this.compound = true, this.glyphIDs = [], this.glyphOffsets = [], a2 = this.raw; o2 = a2.readShort(), this.glyphOffsets.push(a2.pos), this.glyphIDs.push(a2.readUInt16()), 32 & o2; )
      a2.pos += 1 & o2 ? 4 : 2, 128 & o2 ? a2.pos += 8 : 64 & o2 ? a2.pos += 4 : 8 & o2 && (a2.pos += 2);
  }
  __name(t2, "t");
  return t2.prototype.encode = function() {
    var t3, e, r;
    for (e = new ne(ve.call(this.raw.data)), t3 = 0, r = this.glyphIDs.length; t3 < r; ++t3)
      e.pos = this.glyphOffsets[t3];
    return e.data;
  }, t2;
}(), Ne = function(t2) {
  function e() {
    return e.__super__.constructor.apply(this, arguments);
  }
  __name(e, "e");
  return oe(e, re), e.prototype.tag = "loca", e.prototype.parse = function(t3) {
    var e2, r;
    return t3.pos = this.offset, e2 = this.file.head.indexToLocFormat, this.offsets = 0 === e2 ? (function() {
      var e3, n2;
      for (n2 = [], r = 0, e3 = this.length; r < e3; r += 2)
        n2.push(2 * t3.readUInt16());
      return n2;
    }).call(this) : (function() {
      var e3, n2;
      for (n2 = [], r = 0, e3 = this.length; r < e3; r += 4)
        n2.push(t3.readUInt32());
      return n2;
    }).call(this);
  }, e.prototype.indexOf = function(t3) {
    return this.offsets[t3];
  }, e.prototype.lengthOf = function(t3) {
    return this.offsets[t3 + 1] - this.offsets[t3];
  }, e.prototype.encode = function(t3, e2) {
    for (var r = new Uint32Array(this.offsets.length), n2 = 0, i2 = 0, a2 = 0; a2 < r.length; ++a2)
      if (r[a2] = n2, i2 < e2.length && e2[i2] == a2) {
        ++i2, r[a2] = n2;
        var o2 = this.offsets[a2], s2 = this.offsets[a2 + 1] - o2;
        s2 > 0 && (n2 += s2);
      }
    for (var c2 = new Array(4 * r.length), u2 = 0; u2 < r.length; ++u2)
      c2[4 * u2 + 3] = 255 & r[u2], c2[4 * u2 + 2] = (65280 & r[u2]) >> 8, c2[4 * u2 + 1] = (16711680 & r[u2]) >> 16, c2[4 * u2] = (4278190080 & r[u2]) >> 24;
    return c2;
  }, e;
}(), Le = function() {
  function t2(t3) {
    this.font = t3, this.subset = {}, this.unicodes = {}, this.next = 33;
  }
  __name(t2, "t");
  return t2.prototype.generateCmap = function() {
    var t3, e, r, n2, i2;
    for (e in n2 = this.font.cmap.tables[0].codeMap, t3 = {}, i2 = this.subset)
      r = i2[e], t3[e] = n2[r];
    return t3;
  }, t2.prototype.glyphsFor = function(t3) {
    var e, r, n2, i2, a2, o2, s2;
    for (n2 = {}, a2 = 0, o2 = t3.length; a2 < o2; a2++)
      n2[i2 = t3[a2]] = this.font.glyf.glyphFor(i2);
    for (i2 in e = [], n2)
      (null != (r = n2[i2]) ? r.compound : void 0) && e.push.apply(e, r.glyphIDs);
    if (e.length > 0)
      for (i2 in s2 = this.glyphsFor(e))
        r = s2[i2], n2[i2] = r;
    return n2;
  }, t2.prototype.encode = function(t3, e) {
    var r, n2, i2, a2, o2, s2, c2, u2, h3, l2, f2, d2, p2, g2, m2;
    for (n2 in r = ue.encode(this.generateCmap(), "unicode"), a2 = this.glyphsFor(t3), f2 = { 0: 0 }, m2 = r.charMap)
      f2[(s2 = m2[n2]).old] = s2.new;
    for (d2 in l2 = r.maxGlyphID, a2)
      d2 in f2 || (f2[d2] = l2++);
    return u2 = function(t4) {
      var e2, r2;
      for (e2 in r2 = {}, t4)
        r2[t4[e2]] = e2;
      return r2;
    }(f2), h3 = Object.keys(u2).sort(function(t4, e2) {
      return t4 - e2;
    }), p2 = function() {
      var t4, e2, r2;
      for (r2 = [], t4 = 0, e2 = h3.length; t4 < e2; t4++)
        o2 = h3[t4], r2.push(u2[o2]);
      return r2;
    }(), i2 = this.font.glyf.encode(a2, p2, f2), c2 = this.font.loca.encode(i2.offsets, p2), g2 = { cmap: this.font.cmap.raw(), glyf: i2.table, loca: c2, hmtx: this.font.hmtx.raw(), hhea: this.font.hhea.raw(), maxp: this.font.maxp.raw(), post: this.font.post.raw(), name: this.font.name.raw(), head: this.font.head.encode(e) }, this.font.os2.exists && (g2["OS/2"] = this.font.os2.raw()), this.font.directory.encode(g2);
  }, t2;
}();
E.API.PDFObject = function() {
  var t2;
  function e() {
  }
  __name(e, "e");
  return t2 = /* @__PURE__ */ __name(function(t3, e2) {
    return (Array(e2 + 1).join("0") + t3).slice(-e2);
  }, "t"), e.convert = function(r) {
    var n2, i2, a2, o2;
    if (Array.isArray(r))
      return "[" + function() {
        var t3, i3, a3;
        for (a3 = [], t3 = 0, i3 = r.length; t3 < i3; t3++)
          n2 = r[t3], a3.push(e.convert(n2));
        return a3;
      }().join(" ") + "]";
    if ("string" == typeof r)
      return "/" + r;
    if (null != r ? r.isString : void 0)
      return "(" + r + ")";
    if (r instanceof Date)
      return "(D:" + t2(r.getUTCFullYear(), 4) + t2(r.getUTCMonth(), 2) + t2(r.getUTCDate(), 2) + t2(r.getUTCHours(), 2) + t2(r.getUTCMinutes(), 2) + t2(r.getUTCSeconds(), 2) + "Z)";
    if ("[object Object]" === {}.toString.call(r)) {
      for (i2 in a2 = ["<<"], r)
        o2 = r[i2], a2.push("/" + i2 + " " + e.convert(o2));
      return a2.push(">>"), a2.join("\n");
    }
    return "" + r;
  }, e;
}();
const jspdf_es_min = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  AcroForm: St,
  AcroFormAppearance: At,
  AcroFormButton: mt,
  AcroFormCheckBox: wt,
  AcroFormChoiceField: ft,
  AcroFormComboBox: pt,
  AcroFormEditBox: gt,
  AcroFormListBox: dt,
  AcroFormPasswordField: Lt,
  AcroFormPushButton: vt,
  AcroFormRadioButton: bt,
  AcroFormTextField: Nt,
  GState: j,
  ShadingPattern: B,
  TilingPattern: M,
  default: E,
  jsPDF: E
}, Symbol.toStringTag, { value: "Module" }));
var jspdf_plugin_autotable = { exports: {} };
const require$$0 = /* @__PURE__ */ getAugmentedNamespace(jspdf_es_min);
/*!
 * 
 *               jsPDF AutoTable plugin v3.8.4
 *
 *               Copyright (c) 2024 Simon Bengtsson, https://github.com/simonbengtsson/jsPDF-AutoTable
 *               Licensed under the MIT License.
 *               http://opensource.org/licenses/mit-license
 *
 */
(function(module2, exports2) {
  (/* @__PURE__ */ __name(function webpackUniversalModuleDefinition(root, factory) {
    module2.exports = factory((/* @__PURE__ */ __name(function webpackLoadOptionalExternalModule() {
      try {
        return require$$0;
      } catch (e) {
      }
    }, "webpackLoadOptionalExternalModule"))());
  }, "webpackUniversalModuleDefinition"))(typeof globalThis !== "undefined" ? globalThis : typeof commonjsGlobal !== "undefined" ? commonjsGlobal : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : commonjsGlobal, function(__WEBPACK_EXTERNAL_MODULE__964__) {
    return (
      /******/
      function() {
        var __webpack_modules__2 = {
          /***/
          172: (
            /***/
            function(__unused_webpack_module2, exports3) {
              var __extends = this && this.__extends || function() {
                var extendStatics = /* @__PURE__ */ __name(function(d2, b2) {
                  extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
                    d3.__proto__ = b3;
                  } || function(d3, b3) {
                    for (var p2 in b3)
                      if (Object.prototype.hasOwnProperty.call(b3, p2))
                        d3[p2] = b3[p2];
                  };
                  return extendStatics(d2, b2);
                }, "extendStatics");
                return function(d2, b2) {
                  if (typeof b2 !== "function" && b2 !== null)
                    throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
                  extendStatics(d2, b2);
                  function __() {
                    this.constructor = d2;
                  }
                  __name(__, "__");
                  d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
                };
              }();
              Object.defineProperty(exports3, "__esModule", { value: true });
              exports3.CellHookData = exports3.HookData = void 0;
              var HookData = (
                /** @class */
                function() {
                  function HookData2(doc, table, cursor) {
                    this.table = table;
                    this.pageNumber = table.pageNumber;
                    this.pageCount = this.pageNumber;
                    this.settings = table.settings;
                    this.cursor = cursor;
                    this.doc = doc.getDocument();
                  }
                  __name(HookData2, "HookData");
                  return HookData2;
                }()
              );
              exports3.HookData = HookData;
              var CellHookData = (
                /** @class */
                function(_super) {
                  __extends(CellHookData2, _super);
                  function CellHookData2(doc, table, cell, row, column, cursor) {
                    var _this = _super.call(this, doc, table, cursor) || this;
                    _this.cell = cell;
                    _this.row = row;
                    _this.column = column;
                    _this.section = row.section;
                    return _this;
                  }
                  __name(CellHookData2, "CellHookData");
                  return CellHookData2;
                }(HookData)
              );
              exports3.CellHookData = CellHookData;
            }
          ),
          /***/
          340: (
            /***/
            function(__unused_webpack_module2, exports3, __webpack_require__2) {
              Object.defineProperty(exports3, "__esModule", { value: true });
              var htmlParser_1 = __webpack_require__2(4);
              var autoTableText_1 = __webpack_require__2(136);
              var documentHandler_1 = __webpack_require__2(744);
              var inputParser_1 = __webpack_require__2(776);
              var tableDrawer_1 = __webpack_require__2(664);
              var tableCalculator_1 = __webpack_require__2(972);
              function default_1(jsPDF) {
                jsPDF.API.autoTable = function() {
                  var args = [];
                  for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                  }
                  var options;
                  if (args.length === 1) {
                    options = args[0];
                  } else {
                    console.error("Use of deprecated autoTable initiation");
                    options = args[2] || {};
                    options.columns = args[0];
                    options.body = args[1];
                  }
                  var input = (0, inputParser_1.parseInput)(this, options);
                  var table = (0, tableCalculator_1.createTable)(this, input);
                  (0, tableDrawer_1.drawTable)(this, table);
                  return this;
                };
                jsPDF.API.lastAutoTable = false;
                jsPDF.API.previousAutoTable = false;
                jsPDF.API.autoTable.previous = false;
                jsPDF.API.autoTableText = function(text, x2, y2, styles) {
                  (0, autoTableText_1.default)(text, x2, y2, styles, this);
                };
                jsPDF.API.autoTableSetDefaults = function(defaults2) {
                  documentHandler_1.DocHandler.setDefaults(defaults2, this);
                  return this;
                };
                jsPDF.autoTableSetDefaults = function(defaults2, doc) {
                  documentHandler_1.DocHandler.setDefaults(defaults2, doc);
                };
                jsPDF.API.autoTableHtmlToJson = function(tableElem, includeHiddenElements) {
                  var _a3;
                  if (includeHiddenElements === void 0) {
                    includeHiddenElements = false;
                  }
                  if (typeof window === "undefined") {
                    console.error("Cannot run autoTableHtmlToJson in non browser environment");
                    return null;
                  }
                  var doc = new documentHandler_1.DocHandler(this);
                  var _b2 = (0, htmlParser_1.parseHtml)(doc, tableElem, window, includeHiddenElements, false), head = _b2.head, body = _b2.body;
                  var columns = ((_a3 = head[0]) === null || _a3 === void 0 ? void 0 : _a3.map(function(c2) {
                    return c2.content;
                  })) || [];
                  return { columns, rows: body, data: body };
                };
                jsPDF.API.autoTableEndPosY = function() {
                  console.error("Use of deprecated function: autoTableEndPosY. Use doc.lastAutoTable.finalY instead.");
                  var prev = this.lastAutoTable;
                  if (prev && prev.finalY) {
                    return prev.finalY;
                  } else {
                    return 0;
                  }
                };
                jsPDF.API.autoTableAddPageContent = function(hook) {
                  console.error("Use of deprecated function: autoTableAddPageContent. Use jsPDF.autoTableSetDefaults({didDrawPage: () => {}}) instead.");
                  if (!jsPDF.API.autoTable.globalDefaults) {
                    jsPDF.API.autoTable.globalDefaults = {};
                  }
                  jsPDF.API.autoTable.globalDefaults.addPageContent = hook;
                  return this;
                };
                jsPDF.API.autoTableAddPage = function() {
                  console.error("Use of deprecated function: autoTableAddPage. Use doc.addPage()");
                  this.addPage();
                  return this;
                };
              }
              __name(default_1, "default_1");
              exports3["default"] = default_1;
            }
          ),
          /***/
          136: (
            /***/
            function(__unused_webpack_module2, exports3) {
              Object.defineProperty(exports3, "__esModule", { value: true });
              function default_1(text, x2, y2, styles, doc) {
                styles = styles || {};
                var PHYSICAL_LINE_HEIGHT = 1.15;
                var k2 = doc.internal.scaleFactor;
                var fontSize = doc.internal.getFontSize() / k2;
                var lineHeightFactor = doc.getLineHeightFactor ? doc.getLineHeightFactor() : PHYSICAL_LINE_HEIGHT;
                var lineHeight = fontSize * lineHeightFactor;
                var splitRegex = /\r\n|\r|\n/g;
                var splitText = "";
                var lineCount = 1;
                if (styles.valign === "middle" || styles.valign === "bottom" || styles.halign === "center" || styles.halign === "right") {
                  splitText = typeof text === "string" ? text.split(splitRegex) : text;
                  lineCount = splitText.length || 1;
                }
                y2 += fontSize * (2 - PHYSICAL_LINE_HEIGHT);
                if (styles.valign === "middle")
                  y2 -= lineCount / 2 * lineHeight;
                else if (styles.valign === "bottom")
                  y2 -= lineCount * lineHeight;
                if (styles.halign === "center" || styles.halign === "right") {
                  var alignSize = fontSize;
                  if (styles.halign === "center")
                    alignSize *= 0.5;
                  if (splitText && lineCount >= 1) {
                    for (var iLine = 0; iLine < splitText.length; iLine++) {
                      doc.text(splitText[iLine], x2 - doc.getStringUnitWidth(splitText[iLine]) * alignSize, y2);
                      y2 += lineHeight;
                    }
                    return doc;
                  }
                  x2 -= doc.getStringUnitWidth(text) * alignSize;
                }
                if (styles.halign === "justify") {
                  doc.text(text, x2, y2, {
                    maxWidth: styles.maxWidth || 100,
                    align: "justify"
                  });
                } else {
                  doc.text(text, x2, y2);
                }
                return doc;
              }
              __name(default_1, "default_1");
              exports3["default"] = default_1;
            }
          ),
          /***/
          420: (
            /***/
            function(__unused_webpack_module2, exports3) {
              Object.defineProperty(exports3, "__esModule", { value: true });
              exports3.getPageAvailableWidth = exports3.parseSpacing = exports3.getFillStyle = exports3.addTableBorder = exports3.getStringWidth = void 0;
              function getStringWidth(text, styles, doc) {
                doc.applyStyles(styles, true);
                var textArr = Array.isArray(text) ? text : [text];
                var widestLineWidth = textArr.map(function(text2) {
                  return doc.getTextWidth(text2);
                }).reduce(function(a2, b2) {
                  return Math.max(a2, b2);
                }, 0);
                return widestLineWidth;
              }
              __name(getStringWidth, "getStringWidth");
              exports3.getStringWidth = getStringWidth;
              function addTableBorder(doc, table, startPos, cursor) {
                var lineWidth = table.settings.tableLineWidth;
                var lineColor = table.settings.tableLineColor;
                doc.applyStyles({ lineWidth, lineColor });
                var fillStyle = getFillStyle(lineWidth, false);
                if (fillStyle) {
                  doc.rect(startPos.x, startPos.y, table.getWidth(doc.pageSize().width), cursor.y - startPos.y, fillStyle);
                }
              }
              __name(addTableBorder, "addTableBorder");
              exports3.addTableBorder = addTableBorder;
              function getFillStyle(lineWidth, fillColor) {
                var drawLine = lineWidth > 0;
                var drawBackground = fillColor || fillColor === 0;
                if (drawLine && drawBackground) {
                  return "DF";
                } else if (drawLine) {
                  return "S";
                } else if (drawBackground) {
                  return "F";
                } else {
                  return null;
                }
              }
              __name(getFillStyle, "getFillStyle");
              exports3.getFillStyle = getFillStyle;
              function parseSpacing(value, defaultValue) {
                var _a3, _b2, _c, _d;
                value = value || defaultValue;
                if (Array.isArray(value)) {
                  if (value.length >= 4) {
                    return {
                      top: value[0],
                      right: value[1],
                      bottom: value[2],
                      left: value[3]
                    };
                  } else if (value.length === 3) {
                    return {
                      top: value[0],
                      right: value[1],
                      bottom: value[2],
                      left: value[1]
                    };
                  } else if (value.length === 2) {
                    return {
                      top: value[0],
                      right: value[1],
                      bottom: value[0],
                      left: value[1]
                    };
                  } else if (value.length === 1) {
                    value = value[0];
                  } else {
                    value = defaultValue;
                  }
                }
                if (typeof value === "object") {
                  if (typeof value.vertical === "number") {
                    value.top = value.vertical;
                    value.bottom = value.vertical;
                  }
                  if (typeof value.horizontal === "number") {
                    value.right = value.horizontal;
                    value.left = value.horizontal;
                  }
                  return {
                    left: (_a3 = value.left) !== null && _a3 !== void 0 ? _a3 : defaultValue,
                    top: (_b2 = value.top) !== null && _b2 !== void 0 ? _b2 : defaultValue,
                    right: (_c = value.right) !== null && _c !== void 0 ? _c : defaultValue,
                    bottom: (_d = value.bottom) !== null && _d !== void 0 ? _d : defaultValue
                  };
                }
                if (typeof value !== "number") {
                  value = defaultValue;
                }
                return { top: value, right: value, bottom: value, left: value };
              }
              __name(parseSpacing, "parseSpacing");
              exports3.parseSpacing = parseSpacing;
              function getPageAvailableWidth(doc, table) {
                var margins = parseSpacing(table.settings.margin, 0);
                return doc.pageSize().width - (margins.left + margins.right);
              }
              __name(getPageAvailableWidth, "getPageAvailableWidth");
              exports3.getPageAvailableWidth = getPageAvailableWidth;
            }
          ),
          /***/
          796: (
            /***/
            function(__unused_webpack_module2, exports3) {
              var __extends = this && this.__extends || function() {
                var extendStatics = /* @__PURE__ */ __name(function(d2, b2) {
                  extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
                    d3.__proto__ = b3;
                  } || function(d3, b3) {
                    for (var p2 in b3)
                      if (Object.prototype.hasOwnProperty.call(b3, p2))
                        d3[p2] = b3[p2];
                  };
                  return extendStatics(d2, b2);
                }, "extendStatics");
                return function(d2, b2) {
                  if (typeof b2 !== "function" && b2 !== null)
                    throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
                  extendStatics(d2, b2);
                  function __() {
                    this.constructor = d2;
                  }
                  __name(__, "__");
                  d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
                };
              }();
              Object.defineProperty(exports3, "__esModule", { value: true });
              exports3.getTheme = exports3.defaultStyles = exports3.HtmlRowInput = void 0;
              var HtmlRowInput = (
                /** @class */
                function(_super) {
                  __extends(HtmlRowInput2, _super);
                  function HtmlRowInput2(element) {
                    var _this = _super.call(this) || this;
                    _this._element = element;
                    return _this;
                  }
                  __name(HtmlRowInput2, "HtmlRowInput");
                  return HtmlRowInput2;
                }(Array)
              );
              exports3.HtmlRowInput = HtmlRowInput;
              function defaultStyles(scaleFactor) {
                return {
                  font: "helvetica",
                  // helvetica, times, courier
                  fontStyle: "normal",
                  // normal, bold, italic, bolditalic
                  overflow: "linebreak",
                  // linebreak, ellipsize, visible or hidden
                  fillColor: false,
                  // Either false for transparent, rbg array e.g. [255, 255, 255] or gray level e.g 200
                  textColor: 20,
                  halign: "left",
                  // left, center, right, justify
                  valign: "top",
                  // top, middle, bottom
                  fontSize: 10,
                  cellPadding: 5 / scaleFactor,
                  // number or {top,left,right,left,vertical,horizontal}
                  lineColor: 200,
                  lineWidth: 0,
                  cellWidth: "auto",
                  // 'auto'|'wrap'|number
                  minCellHeight: 0,
                  minCellWidth: 0
                };
              }
              __name(defaultStyles, "defaultStyles");
              exports3.defaultStyles = defaultStyles;
              function getTheme(name) {
                var themes = {
                  striped: {
                    table: { fillColor: 255, textColor: 80, fontStyle: "normal" },
                    head: { textColor: 255, fillColor: [41, 128, 185], fontStyle: "bold" },
                    body: {},
                    foot: { textColor: 255, fillColor: [41, 128, 185], fontStyle: "bold" },
                    alternateRow: { fillColor: 245 }
                  },
                  grid: {
                    table: {
                      fillColor: 255,
                      textColor: 80,
                      fontStyle: "normal",
                      lineWidth: 0.1
                    },
                    head: {
                      textColor: 255,
                      fillColor: [26, 188, 156],
                      fontStyle: "bold",
                      lineWidth: 0
                    },
                    body: {},
                    foot: {
                      textColor: 255,
                      fillColor: [26, 188, 156],
                      fontStyle: "bold",
                      lineWidth: 0
                    },
                    alternateRow: {}
                  },
                  plain: {
                    head: { fontStyle: "bold" },
                    foot: { fontStyle: "bold" }
                  }
                };
                return themes[name];
              }
              __name(getTheme, "getTheme");
              exports3.getTheme = getTheme;
            }
          ),
          /***/
          903: (
            /***/
            function(__unused_webpack_module2, exports3, __webpack_require__2) {
              Object.defineProperty(exports3, "__esModule", { value: true });
              exports3.parseCss = void 0;
              var common_1 = __webpack_require__2(420);
              function parseCss(supportedFonts, element, scaleFactor, style, window2) {
                var result = {};
                var pxScaleFactor = 96 / 72;
                var backgroundColor = parseColor(element, function(elem) {
                  return window2.getComputedStyle(elem)["backgroundColor"];
                });
                if (backgroundColor != null)
                  result.fillColor = backgroundColor;
                var textColor = parseColor(element, function(elem) {
                  return window2.getComputedStyle(elem)["color"];
                });
                if (textColor != null)
                  result.textColor = textColor;
                var padding = parsePadding(style, scaleFactor);
                if (padding)
                  result.cellPadding = padding;
                var borderColorSide = "borderTopColor";
                var finalScaleFactor = pxScaleFactor * scaleFactor;
                var btw = style.borderTopWidth;
                if (style.borderBottomWidth === btw && style.borderRightWidth === btw && style.borderLeftWidth === btw) {
                  var borderWidth = (parseFloat(btw) || 0) / finalScaleFactor;
                  if (borderWidth)
                    result.lineWidth = borderWidth;
                } else {
                  result.lineWidth = {
                    top: (parseFloat(style.borderTopWidth) || 0) / finalScaleFactor,
                    right: (parseFloat(style.borderRightWidth) || 0) / finalScaleFactor,
                    bottom: (parseFloat(style.borderBottomWidth) || 0) / finalScaleFactor,
                    left: (parseFloat(style.borderLeftWidth) || 0) / finalScaleFactor
                  };
                  if (!result.lineWidth.top) {
                    if (result.lineWidth.right) {
                      borderColorSide = "borderRightColor";
                    } else if (result.lineWidth.bottom) {
                      borderColorSide = "borderBottomColor";
                    } else if (result.lineWidth.left) {
                      borderColorSide = "borderLeftColor";
                    }
                  }
                }
                var borderColor = parseColor(element, function(elem) {
                  return window2.getComputedStyle(elem)[borderColorSide];
                });
                if (borderColor != null)
                  result.lineColor = borderColor;
                var accepted = ["left", "right", "center", "justify"];
                if (accepted.indexOf(style.textAlign) !== -1) {
                  result.halign = style.textAlign;
                }
                accepted = ["middle", "bottom", "top"];
                if (accepted.indexOf(style.verticalAlign) !== -1) {
                  result.valign = style.verticalAlign;
                }
                var res = parseInt(style.fontSize || "");
                if (!isNaN(res))
                  result.fontSize = res / pxScaleFactor;
                var fontStyle = parseFontStyle(style);
                if (fontStyle)
                  result.fontStyle = fontStyle;
                var font = (style.fontFamily || "").toLowerCase();
                if (supportedFonts.indexOf(font) !== -1) {
                  result.font = font;
                }
                return result;
              }
              __name(parseCss, "parseCss");
              exports3.parseCss = parseCss;
              function parseFontStyle(style) {
                var res = "";
                if (style.fontWeight === "bold" || style.fontWeight === "bolder" || parseInt(style.fontWeight) >= 700) {
                  res = "bold";
                }
                if (style.fontStyle === "italic" || style.fontStyle === "oblique") {
                  res += "italic";
                }
                return res;
              }
              __name(parseFontStyle, "parseFontStyle");
              function parseColor(element, styleGetter) {
                var cssColor = realColor(element, styleGetter);
                if (!cssColor)
                  return null;
                var rgba = cssColor.match(/^rgba?\((\d+),\s*(\d+),\s*(\d+)(?:,\s*(\d*\.?\d*))?\)$/);
                if (!rgba || !Array.isArray(rgba)) {
                  return null;
                }
                var color2 = [
                  parseInt(rgba[1]),
                  parseInt(rgba[2]),
                  parseInt(rgba[3])
                ];
                var alpha2 = parseInt(rgba[4]);
                if (alpha2 === 0 || isNaN(color2[0]) || isNaN(color2[1]) || isNaN(color2[2])) {
                  return null;
                }
                return color2;
              }
              __name(parseColor, "parseColor");
              function realColor(elem, styleGetter) {
                var bg = styleGetter(elem);
                if (bg === "rgba(0, 0, 0, 0)" || bg === "transparent" || bg === "initial" || bg === "inherit") {
                  if (elem.parentElement == null) {
                    return null;
                  }
                  return realColor(elem.parentElement, styleGetter);
                } else {
                  return bg;
                }
              }
              __name(realColor, "realColor");
              function parsePadding(style, scaleFactor) {
                var val = [
                  style.paddingTop,
                  style.paddingRight,
                  style.paddingBottom,
                  style.paddingLeft
                ];
                var pxScaleFactor = 96 / (72 / scaleFactor);
                var linePadding = (parseInt(style.lineHeight) - parseInt(style.fontSize)) / scaleFactor / 2;
                var inputPadding = val.map(function(n2) {
                  return parseInt(n2 || "0") / pxScaleFactor;
                });
                var padding = (0, common_1.parseSpacing)(inputPadding, 0);
                if (linePadding > padding.top) {
                  padding.top = linePadding;
                }
                if (linePadding > padding.bottom) {
                  padding.bottom = linePadding;
                }
                return padding;
              }
              __name(parsePadding, "parsePadding");
            }
          ),
          /***/
          744: (
            /***/
            function(__unused_webpack_module2, exports3) {
              Object.defineProperty(exports3, "__esModule", { value: true });
              exports3.DocHandler = void 0;
              var globalDefaults = {};
              var DocHandler = (
                /** @class */
                function() {
                  function DocHandler2(jsPDFDocument) {
                    this.jsPDFDocument = jsPDFDocument;
                    this.userStyles = {
                      // Black for versions of jspdf without getTextColor
                      textColor: jsPDFDocument.getTextColor ? this.jsPDFDocument.getTextColor() : 0,
                      fontSize: jsPDFDocument.internal.getFontSize(),
                      fontStyle: jsPDFDocument.internal.getFont().fontStyle,
                      font: jsPDFDocument.internal.getFont().fontName,
                      // 0 for versions of jspdf without getLineWidth
                      lineWidth: jsPDFDocument.getLineWidth ? this.jsPDFDocument.getLineWidth() : 0,
                      // Black for versions of jspdf without getDrawColor
                      lineColor: jsPDFDocument.getDrawColor ? this.jsPDFDocument.getDrawColor() : 0
                    };
                  }
                  __name(DocHandler2, "DocHandler");
                  DocHandler2.setDefaults = function(defaults2, doc) {
                    if (doc === void 0) {
                      doc = null;
                    }
                    if (doc) {
                      doc.__autoTableDocumentDefaults = defaults2;
                    } else {
                      globalDefaults = defaults2;
                    }
                  };
                  DocHandler2.unifyColor = function(c2) {
                    if (Array.isArray(c2)) {
                      return c2;
                    } else if (typeof c2 === "number") {
                      return [c2, c2, c2];
                    } else if (typeof c2 === "string") {
                      return [c2];
                    } else {
                      return null;
                    }
                  };
                  DocHandler2.prototype.applyStyles = function(styles, fontOnly) {
                    var _a3, _b2, _c;
                    if (fontOnly === void 0) {
                      fontOnly = false;
                    }
                    if (styles.fontStyle)
                      this.jsPDFDocument.setFontStyle && this.jsPDFDocument.setFontStyle(styles.fontStyle);
                    var _d = this.jsPDFDocument.internal.getFont(), fontStyle = _d.fontStyle, fontName = _d.fontName;
                    if (styles.font)
                      fontName = styles.font;
                    if (styles.fontStyle) {
                      fontStyle = styles.fontStyle;
                      var availableFontStyles = this.getFontList()[fontName];
                      if (availableFontStyles && availableFontStyles.indexOf(fontStyle) === -1) {
                        this.jsPDFDocument.setFontStyle && this.jsPDFDocument.setFontStyle(availableFontStyles[0]);
                        fontStyle = availableFontStyles[0];
                      }
                    }
                    this.jsPDFDocument.setFont(fontName, fontStyle);
                    if (styles.fontSize)
                      this.jsPDFDocument.setFontSize(styles.fontSize);
                    if (fontOnly) {
                      return;
                    }
                    var color2 = DocHandler2.unifyColor(styles.fillColor);
                    if (color2)
                      (_a3 = this.jsPDFDocument).setFillColor.apply(_a3, color2);
                    color2 = DocHandler2.unifyColor(styles.textColor);
                    if (color2)
                      (_b2 = this.jsPDFDocument).setTextColor.apply(_b2, color2);
                    color2 = DocHandler2.unifyColor(styles.lineColor);
                    if (color2)
                      (_c = this.jsPDFDocument).setDrawColor.apply(_c, color2);
                    if (typeof styles.lineWidth === "number") {
                      this.jsPDFDocument.setLineWidth(styles.lineWidth);
                    }
                  };
                  DocHandler2.prototype.splitTextToSize = function(text, size, opts) {
                    return this.jsPDFDocument.splitTextToSize(text, size, opts);
                  };
                  DocHandler2.prototype.rect = function(x2, y2, width, height, fillStyle) {
                    return this.jsPDFDocument.rect(x2, y2, width, height, fillStyle);
                  };
                  DocHandler2.prototype.getLastAutoTable = function() {
                    return this.jsPDFDocument.lastAutoTable || null;
                  };
                  DocHandler2.prototype.getTextWidth = function(text) {
                    return this.jsPDFDocument.getTextWidth(text);
                  };
                  DocHandler2.prototype.getDocument = function() {
                    return this.jsPDFDocument;
                  };
                  DocHandler2.prototype.setPage = function(page) {
                    this.jsPDFDocument.setPage(page);
                  };
                  DocHandler2.prototype.addPage = function() {
                    return this.jsPDFDocument.addPage();
                  };
                  DocHandler2.prototype.getFontList = function() {
                    return this.jsPDFDocument.getFontList();
                  };
                  DocHandler2.prototype.getGlobalOptions = function() {
                    return globalDefaults || {};
                  };
                  DocHandler2.prototype.getDocumentOptions = function() {
                    return this.jsPDFDocument.__autoTableDocumentDefaults || {};
                  };
                  DocHandler2.prototype.pageSize = function() {
                    var pageSize = this.jsPDFDocument.internal.pageSize;
                    if (pageSize.width == null) {
                      pageSize = {
                        width: pageSize.getWidth(),
                        height: pageSize.getHeight()
                      };
                    }
                    return pageSize;
                  };
                  DocHandler2.prototype.scaleFactor = function() {
                    return this.jsPDFDocument.internal.scaleFactor;
                  };
                  DocHandler2.prototype.getLineHeightFactor = function() {
                    var doc = this.jsPDFDocument;
                    return doc.getLineHeightFactor ? doc.getLineHeightFactor() : 1.15;
                  };
                  DocHandler2.prototype.getLineHeight = function(fontSize) {
                    return fontSize / this.scaleFactor() * this.getLineHeightFactor();
                  };
                  DocHandler2.prototype.pageNumber = function() {
                    var pageInfo = this.jsPDFDocument.internal.getCurrentPageInfo();
                    if (!pageInfo) {
                      return this.jsPDFDocument.internal.getNumberOfPages();
                    }
                    return pageInfo.pageNumber;
                  };
                  return DocHandler2;
                }()
              );
              exports3.DocHandler = DocHandler;
            }
          ),
          /***/
          4: (
            /***/
            function(__unused_webpack_module2, exports3, __webpack_require__2) {
              Object.defineProperty(exports3, "__esModule", { value: true });
              exports3.parseHtml = void 0;
              var cssParser_1 = __webpack_require__2(903);
              var config_1 = __webpack_require__2(796);
              function parseHtml(doc, input, window2, includeHiddenHtml, useCss) {
                var _a3, _b2;
                if (includeHiddenHtml === void 0) {
                  includeHiddenHtml = false;
                }
                if (useCss === void 0) {
                  useCss = false;
                }
                var tableElement;
                if (typeof input === "string") {
                  tableElement = window2.document.querySelector(input);
                } else {
                  tableElement = input;
                }
                var supportedFonts = Object.keys(doc.getFontList());
                var scaleFactor = doc.scaleFactor();
                var head = [], body = [], foot = [];
                if (!tableElement) {
                  console.error("Html table could not be found with input: ", input);
                  return { head, body, foot };
                }
                for (var i2 = 0; i2 < tableElement.rows.length; i2++) {
                  var element = tableElement.rows[i2];
                  var tagName = (_b2 = (_a3 = element === null || element === void 0 ? void 0 : element.parentElement) === null || _a3 === void 0 ? void 0 : _a3.tagName) === null || _b2 === void 0 ? void 0 : _b2.toLowerCase();
                  var row = parseRowContent(supportedFonts, scaleFactor, window2, element, includeHiddenHtml, useCss);
                  if (!row)
                    continue;
                  if (tagName === "thead") {
                    head.push(row);
                  } else if (tagName === "tfoot") {
                    foot.push(row);
                  } else {
                    body.push(row);
                  }
                }
                return { head, body, foot };
              }
              __name(parseHtml, "parseHtml");
              exports3.parseHtml = parseHtml;
              function parseRowContent(supportedFonts, scaleFactor, window2, row, includeHidden, useCss) {
                var resultRow = new config_1.HtmlRowInput(row);
                for (var i2 = 0; i2 < row.cells.length; i2++) {
                  var cell = row.cells[i2];
                  var style_1 = window2.getComputedStyle(cell);
                  if (includeHidden || style_1.display !== "none") {
                    var cellStyles = void 0;
                    if (useCss) {
                      cellStyles = (0, cssParser_1.parseCss)(supportedFonts, cell, scaleFactor, style_1, window2);
                    }
                    resultRow.push({
                      rowSpan: cell.rowSpan,
                      colSpan: cell.colSpan,
                      styles: cellStyles,
                      _element: cell,
                      content: parseCellContent(cell)
                    });
                  }
                }
                var style = window2.getComputedStyle(row);
                if (resultRow.length > 0 && (includeHidden || style.display !== "none")) {
                  return resultRow;
                }
              }
              __name(parseRowContent, "parseRowContent");
              function parseCellContent(orgCell) {
                var cell = orgCell.cloneNode(true);
                cell.innerHTML = cell.innerHTML.replace(/\n/g, "").replace(/ +/g, " ");
                cell.innerHTML = cell.innerHTML.split(/<br.*?>/).map(function(part) {
                  return part.trim();
                }).join("\n");
                return cell.innerText || cell.textContent || "";
              }
              __name(parseCellContent, "parseCellContent");
            }
          ),
          /***/
          776: (
            /***/
            function(__unused_webpack_module2, exports3, __webpack_require__2) {
              Object.defineProperty(exports3, "__esModule", { value: true });
              exports3.parseInput = void 0;
              var htmlParser_1 = __webpack_require__2(4);
              var polyfills_1 = __webpack_require__2(356);
              var common_1 = __webpack_require__2(420);
              var documentHandler_1 = __webpack_require__2(744);
              var inputValidator_1 = __webpack_require__2(792);
              function parseInput(d2, current) {
                var doc = new documentHandler_1.DocHandler(d2);
                var document2 = doc.getDocumentOptions();
                var global2 = doc.getGlobalOptions();
                (0, inputValidator_1.default)(doc, global2, document2, current);
                var options = (0, polyfills_1.assign)({}, global2, document2, current);
                var win;
                if (typeof window !== "undefined") {
                  win = window;
                }
                var styles = parseStyles(global2, document2, current);
                var hooks = parseHooks(global2, document2, current);
                var settings = parseSettings(doc, options);
                var content = parseContent(doc, options, win);
                return {
                  id: current.tableId,
                  content,
                  hooks,
                  styles,
                  settings
                };
              }
              __name(parseInput, "parseInput");
              exports3.parseInput = parseInput;
              function parseStyles(gInput, dInput, cInput) {
                var styleOptions = {
                  styles: {},
                  headStyles: {},
                  bodyStyles: {},
                  footStyles: {},
                  alternateRowStyles: {},
                  columnStyles: {}
                };
                var _loop_1 = /* @__PURE__ */ __name(function(prop2) {
                  if (prop2 === "columnStyles") {
                    var global_1 = gInput[prop2];
                    var document_1 = dInput[prop2];
                    var current = cInput[prop2];
                    styleOptions.columnStyles = (0, polyfills_1.assign)({}, global_1, document_1, current);
                  } else {
                    var allOptions = [gInput, dInput, cInput];
                    var styles = allOptions.map(function(opts) {
                      return opts[prop2] || {};
                    });
                    styleOptions[prop2] = (0, polyfills_1.assign)({}, styles[0], styles[1], styles[2]);
                  }
                }, "_loop_1");
                for (var _i = 0, _a3 = Object.keys(styleOptions); _i < _a3.length; _i++) {
                  var prop = _a3[_i];
                  _loop_1(prop);
                }
                return styleOptions;
              }
              __name(parseStyles, "parseStyles");
              function parseHooks(global2, document2, current) {
                var allOptions = [global2, document2, current];
                var result = {
                  didParseCell: [],
                  willDrawCell: [],
                  didDrawCell: [],
                  willDrawPage: [],
                  didDrawPage: []
                };
                for (var _i = 0, allOptions_1 = allOptions; _i < allOptions_1.length; _i++) {
                  var options = allOptions_1[_i];
                  if (options.didParseCell)
                    result.didParseCell.push(options.didParseCell);
                  if (options.willDrawCell)
                    result.willDrawCell.push(options.willDrawCell);
                  if (options.didDrawCell)
                    result.didDrawCell.push(options.didDrawCell);
                  if (options.willDrawPage)
                    result.willDrawPage.push(options.willDrawPage);
                  if (options.didDrawPage)
                    result.didDrawPage.push(options.didDrawPage);
                }
                return result;
              }
              __name(parseHooks, "parseHooks");
              function parseSettings(doc, options) {
                var _a3, _b2, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;
                var margin = (0, common_1.parseSpacing)(options.margin, 40 / doc.scaleFactor());
                var startY = (_a3 = getStartY(doc, options.startY)) !== null && _a3 !== void 0 ? _a3 : margin.top;
                var showFoot;
                if (options.showFoot === true) {
                  showFoot = "everyPage";
                } else if (options.showFoot === false) {
                  showFoot = "never";
                } else {
                  showFoot = (_b2 = options.showFoot) !== null && _b2 !== void 0 ? _b2 : "everyPage";
                }
                var showHead;
                if (options.showHead === true) {
                  showHead = "everyPage";
                } else if (options.showHead === false) {
                  showHead = "never";
                } else {
                  showHead = (_c = options.showHead) !== null && _c !== void 0 ? _c : "everyPage";
                }
                var useCss = (_d = options.useCss) !== null && _d !== void 0 ? _d : false;
                var theme = options.theme || (useCss ? "plain" : "striped");
                var horizontalPageBreak = !!options.horizontalPageBreak;
                var horizontalPageBreakRepeat = (_e = options.horizontalPageBreakRepeat) !== null && _e !== void 0 ? _e : null;
                return {
                  includeHiddenHtml: (_f = options.includeHiddenHtml) !== null && _f !== void 0 ? _f : false,
                  useCss,
                  theme,
                  startY,
                  margin,
                  pageBreak: (_g = options.pageBreak) !== null && _g !== void 0 ? _g : "auto",
                  rowPageBreak: (_h = options.rowPageBreak) !== null && _h !== void 0 ? _h : "auto",
                  tableWidth: (_j = options.tableWidth) !== null && _j !== void 0 ? _j : "auto",
                  showHead,
                  showFoot,
                  tableLineWidth: (_k = options.tableLineWidth) !== null && _k !== void 0 ? _k : 0,
                  tableLineColor: (_l = options.tableLineColor) !== null && _l !== void 0 ? _l : 200,
                  horizontalPageBreak,
                  horizontalPageBreakRepeat,
                  horizontalPageBreakBehaviour: (_m = options.horizontalPageBreakBehaviour) !== null && _m !== void 0 ? _m : "afterAllRows"
                };
              }
              __name(parseSettings, "parseSettings");
              function getStartY(doc, userStartY) {
                var previous = doc.getLastAutoTable();
                var sf = doc.scaleFactor();
                var currentPage = doc.pageNumber();
                var isSamePageAsPreviousTable = false;
                if (previous && previous.startPageNumber) {
                  var endingPage = previous.startPageNumber + previous.pageNumber - 1;
                  isSamePageAsPreviousTable = endingPage === currentPage;
                }
                if (typeof userStartY === "number") {
                  return userStartY;
                } else if (userStartY == null || userStartY === false) {
                  if (isSamePageAsPreviousTable && (previous === null || previous === void 0 ? void 0 : previous.finalY) != null) {
                    return previous.finalY + 20 / sf;
                  }
                }
                return null;
              }
              __name(getStartY, "getStartY");
              function parseContent(doc, options, window2) {
                var head = options.head || [];
                var body = options.body || [];
                var foot = options.foot || [];
                if (options.html) {
                  var hidden = options.includeHiddenHtml;
                  if (window2) {
                    var htmlContent = (0, htmlParser_1.parseHtml)(doc, options.html, window2, hidden, options.useCss) || {};
                    head = htmlContent.head || head;
                    body = htmlContent.body || head;
                    foot = htmlContent.foot || head;
                  } else {
                    console.error("Cannot parse html in non browser environment");
                  }
                }
                var columns = options.columns || parseColumns(head, body, foot);
                return {
                  columns,
                  head,
                  body,
                  foot
                };
              }
              __name(parseContent, "parseContent");
              function parseColumns(head, body, foot) {
                var firstRow = head[0] || body[0] || foot[0] || [];
                var result = [];
                Object.keys(firstRow).filter(function(key) {
                  return key !== "_element";
                }).forEach(function(key) {
                  var colSpan = 1;
                  var input;
                  if (Array.isArray(firstRow)) {
                    input = firstRow[parseInt(key)];
                  } else {
                    input = firstRow[key];
                  }
                  if (typeof input === "object" && !Array.isArray(input)) {
                    colSpan = (input === null || input === void 0 ? void 0 : input.colSpan) || 1;
                  }
                  for (var i2 = 0; i2 < colSpan; i2++) {
                    var id = void 0;
                    if (Array.isArray(firstRow)) {
                      id = result.length;
                    } else {
                      id = key + (i2 > 0 ? "_".concat(i2) : "");
                    }
                    var rowResult = { dataKey: id };
                    result.push(rowResult);
                  }
                });
                return result;
              }
              __name(parseColumns, "parseColumns");
            }
          ),
          /***/
          792: (
            /***/
            function(__unused_webpack_module2, exports3) {
              Object.defineProperty(exports3, "__esModule", { value: true });
              function default_1(doc, global2, document2, current) {
                var _loop_1 = /* @__PURE__ */ __name(function(options2) {
                  if (options2 && typeof options2 !== "object") {
                    console.error("The options parameter should be of type object, is: " + typeof options2);
                  }
                  if (typeof options2.extendWidth !== "undefined") {
                    options2.tableWidth = options2.extendWidth ? "auto" : "wrap";
                    console.error("Use of deprecated option: extendWidth, use tableWidth instead.");
                  }
                  if (typeof options2.margins !== "undefined") {
                    if (typeof options2.margin === "undefined")
                      options2.margin = options2.margins;
                    console.error("Use of deprecated option: margins, use margin instead.");
                  }
                  if (options2.startY && typeof options2.startY !== "number") {
                    console.error("Invalid value for startY option", options2.startY);
                    delete options2.startY;
                  }
                  if (!options2.didDrawPage && (options2.afterPageContent || options2.beforePageContent || options2.afterPageAdd)) {
                    console.error("The afterPageContent, beforePageContent and afterPageAdd hooks are deprecated. Use didDrawPage instead");
                    options2.didDrawPage = function(data) {
                      doc.applyStyles(doc.userStyles);
                      if (options2.beforePageContent)
                        options2.beforePageContent(data);
                      doc.applyStyles(doc.userStyles);
                      if (options2.afterPageContent)
                        options2.afterPageContent(data);
                      doc.applyStyles(doc.userStyles);
                      if (options2.afterPageAdd && data.pageNumber > 1) {
                        data.afterPageAdd(data);
                      }
                      doc.applyStyles(doc.userStyles);
                    };
                  }
                  [
                    "createdHeaderCell",
                    "drawHeaderRow",
                    "drawRow",
                    "drawHeaderCell"
                  ].forEach(function(name) {
                    if (options2[name]) {
                      console.error('The "'.concat(name, '" hook has changed in version 3.0, check the changelog for how to migrate.'));
                    }
                  });
                  [
                    ["showFoot", "showFooter"],
                    ["showHead", "showHeader"],
                    ["didDrawPage", "addPageContent"],
                    ["didParseCell", "createdCell"],
                    ["headStyles", "headerStyles"]
                  ].forEach(function(_a4) {
                    var current2 = _a4[0], deprecated = _a4[1];
                    if (options2[deprecated]) {
                      console.error("Use of deprecated option ".concat(deprecated, ". Use ").concat(current2, " instead"));
                      options2[current2] = options2[deprecated];
                    }
                  });
                  [
                    ["padding", "cellPadding"],
                    ["lineHeight", "rowHeight"],
                    "fontSize",
                    "overflow"
                  ].forEach(function(o2) {
                    var deprecatedOption = typeof o2 === "string" ? o2 : o2[0];
                    var style = typeof o2 === "string" ? o2 : o2[1];
                    if (typeof options2[deprecatedOption] !== "undefined") {
                      if (typeof options2.styles[style] === "undefined") {
                        options2.styles[style] = options2[deprecatedOption];
                      }
                      console.error("Use of deprecated option: " + deprecatedOption + ", use the style " + style + " instead.");
                    }
                  });
                  for (var _b2 = 0, _c = [
                    "styles",
                    "bodyStyles",
                    "headStyles",
                    "footStyles"
                  ]; _b2 < _c.length; _b2++) {
                    var styleProp = _c[_b2];
                    checkStyles(options2[styleProp] || {});
                  }
                  var columnStyles = options2["columnStyles"] || {};
                  for (var _d = 0, _e = Object.keys(columnStyles); _d < _e.length; _d++) {
                    var key = _e[_d];
                    checkStyles(columnStyles[key] || {});
                  }
                }, "_loop_1");
                for (var _i = 0, _a3 = [global2, document2, current]; _i < _a3.length; _i++) {
                  var options = _a3[_i];
                  _loop_1(options);
                }
              }
              __name(default_1, "default_1");
              exports3["default"] = default_1;
              function checkStyles(styles) {
                if (styles.rowHeight) {
                  console.error("Use of deprecated style rowHeight. It is renamed to minCellHeight.");
                  if (!styles.minCellHeight) {
                    styles.minCellHeight = styles.rowHeight;
                  }
                } else if (styles.columnWidth) {
                  console.error("Use of deprecated style columnWidth. It is renamed to cellWidth.");
                  if (!styles.cellWidth) {
                    styles.cellWidth = styles.columnWidth;
                  }
                }
              }
              __name(checkStyles, "checkStyles");
            }
          ),
          /***/
          260: (
            /***/
            function(__unused_webpack_module2, exports3, __webpack_require__2) {
              Object.defineProperty(exports3, "__esModule", { value: true });
              exports3.Column = exports3.Cell = exports3.Row = exports3.Table = void 0;
              var config_1 = __webpack_require__2(796);
              var HookData_1 = __webpack_require__2(172);
              var common_1 = __webpack_require__2(420);
              var Table = (
                /** @class */
                function() {
                  function Table2(input, content) {
                    this.pageNumber = 1;
                    this.pageCount = 1;
                    this.id = input.id;
                    this.settings = input.settings;
                    this.styles = input.styles;
                    this.hooks = input.hooks;
                    this.columns = content.columns;
                    this.head = content.head;
                    this.body = content.body;
                    this.foot = content.foot;
                  }
                  __name(Table2, "Table");
                  Table2.prototype.getHeadHeight = function(columns) {
                    return this.head.reduce(function(acc, row) {
                      return acc + row.getMaxCellHeight(columns);
                    }, 0);
                  };
                  Table2.prototype.getFootHeight = function(columns) {
                    return this.foot.reduce(function(acc, row) {
                      return acc + row.getMaxCellHeight(columns);
                    }, 0);
                  };
                  Table2.prototype.allRows = function() {
                    return this.head.concat(this.body).concat(this.foot);
                  };
                  Table2.prototype.callCellHooks = function(doc, handlers, cell, row, column, cursor) {
                    for (var _i = 0, handlers_1 = handlers; _i < handlers_1.length; _i++) {
                      var handler = handlers_1[_i];
                      var data = new HookData_1.CellHookData(doc, this, cell, row, column, cursor);
                      var result = handler(data) === false;
                      cell.text = Array.isArray(cell.text) ? cell.text : [cell.text];
                      if (result) {
                        return false;
                      }
                    }
                    return true;
                  };
                  Table2.prototype.callEndPageHooks = function(doc, cursor) {
                    doc.applyStyles(doc.userStyles);
                    for (var _i = 0, _a3 = this.hooks.didDrawPage; _i < _a3.length; _i++) {
                      var handler = _a3[_i];
                      handler(new HookData_1.HookData(doc, this, cursor));
                    }
                  };
                  Table2.prototype.callWillDrawPageHooks = function(doc, cursor) {
                    for (var _i = 0, _a3 = this.hooks.willDrawPage; _i < _a3.length; _i++) {
                      var handler = _a3[_i];
                      handler(new HookData_1.HookData(doc, this, cursor));
                    }
                  };
                  Table2.prototype.getWidth = function(pageWidth) {
                    if (typeof this.settings.tableWidth === "number") {
                      return this.settings.tableWidth;
                    } else if (this.settings.tableWidth === "wrap") {
                      var wrappedWidth = this.columns.reduce(function(total, col) {
                        return total + col.wrappedWidth;
                      }, 0);
                      return wrappedWidth;
                    } else {
                      var margin = this.settings.margin;
                      return pageWidth - margin.left - margin.right;
                    }
                  };
                  return Table2;
                }()
              );
              exports3.Table = Table;
              var Row = (
                /** @class */
                function() {
                  function Row2(raw, index2, section, cells, spansMultiplePages) {
                    if (spansMultiplePages === void 0) {
                      spansMultiplePages = false;
                    }
                    this.height = 0;
                    this.raw = raw;
                    if (raw instanceof config_1.HtmlRowInput) {
                      this.raw = raw._element;
                      this.element = raw._element;
                    }
                    this.index = index2;
                    this.section = section;
                    this.cells = cells;
                    this.spansMultiplePages = spansMultiplePages;
                  }
                  __name(Row2, "Row");
                  Row2.prototype.getMaxCellHeight = function(columns) {
                    var _this = this;
                    return columns.reduce(function(acc, column) {
                      var _a3;
                      return Math.max(acc, ((_a3 = _this.cells[column.index]) === null || _a3 === void 0 ? void 0 : _a3.height) || 0);
                    }, 0);
                  };
                  Row2.prototype.hasRowSpan = function(columns) {
                    var _this = this;
                    return columns.filter(function(column) {
                      var cell = _this.cells[column.index];
                      if (!cell)
                        return false;
                      return cell.rowSpan > 1;
                    }).length > 0;
                  };
                  Row2.prototype.canEntireRowFit = function(height, columns) {
                    return this.getMaxCellHeight(columns) <= height;
                  };
                  Row2.prototype.getMinimumRowHeight = function(columns, doc) {
                    var _this = this;
                    return columns.reduce(function(acc, column) {
                      var cell = _this.cells[column.index];
                      if (!cell)
                        return 0;
                      var lineHeight = doc.getLineHeight(cell.styles.fontSize);
                      var vPadding = cell.padding("vertical");
                      var oneRowHeight = vPadding + lineHeight;
                      return oneRowHeight > acc ? oneRowHeight : acc;
                    }, 0);
                  };
                  return Row2;
                }()
              );
              exports3.Row = Row;
              var Cell = (
                /** @class */
                function() {
                  function Cell2(raw, styles, section) {
                    var _a3, _b2;
                    this.contentHeight = 0;
                    this.contentWidth = 0;
                    this.wrappedWidth = 0;
                    this.minReadableWidth = 0;
                    this.minWidth = 0;
                    this.width = 0;
                    this.height = 0;
                    this.x = 0;
                    this.y = 0;
                    this.styles = styles;
                    this.section = section;
                    this.raw = raw;
                    var content = raw;
                    if (raw != null && typeof raw === "object" && !Array.isArray(raw)) {
                      this.rowSpan = raw.rowSpan || 1;
                      this.colSpan = raw.colSpan || 1;
                      content = (_b2 = (_a3 = raw.content) !== null && _a3 !== void 0 ? _a3 : raw.title) !== null && _b2 !== void 0 ? _b2 : raw;
                      if (raw._element) {
                        this.raw = raw._element;
                      }
                    } else {
                      this.rowSpan = 1;
                      this.colSpan = 1;
                    }
                    var text = content != null ? "" + content : "";
                    var splitRegex = /\r\n|\r|\n/g;
                    this.text = text.split(splitRegex);
                  }
                  __name(Cell2, "Cell");
                  Cell2.prototype.getTextPos = function() {
                    var y2;
                    if (this.styles.valign === "top") {
                      y2 = this.y + this.padding("top");
                    } else if (this.styles.valign === "bottom") {
                      y2 = this.y + this.height - this.padding("bottom");
                    } else {
                      var netHeight = this.height - this.padding("vertical");
                      y2 = this.y + netHeight / 2 + this.padding("top");
                    }
                    var x2;
                    if (this.styles.halign === "right") {
                      x2 = this.x + this.width - this.padding("right");
                    } else if (this.styles.halign === "center") {
                      var netWidth = this.width - this.padding("horizontal");
                      x2 = this.x + netWidth / 2 + this.padding("left");
                    } else {
                      x2 = this.x + this.padding("left");
                    }
                    return { x: x2, y: y2 };
                  };
                  Cell2.prototype.getContentHeight = function(scaleFactor, lineHeightFactor) {
                    if (lineHeightFactor === void 0) {
                      lineHeightFactor = 1.15;
                    }
                    var lineCount = Array.isArray(this.text) ? this.text.length : 1;
                    var lineHeight = this.styles.fontSize / scaleFactor * lineHeightFactor;
                    var height = lineCount * lineHeight + this.padding("vertical");
                    return Math.max(height, this.styles.minCellHeight);
                  };
                  Cell2.prototype.padding = function(name) {
                    var padding = (0, common_1.parseSpacing)(this.styles.cellPadding, 0);
                    if (name === "vertical") {
                      return padding.top + padding.bottom;
                    } else if (name === "horizontal") {
                      return padding.left + padding.right;
                    } else {
                      return padding[name];
                    }
                  };
                  return Cell2;
                }()
              );
              exports3.Cell = Cell;
              var Column = (
                /** @class */
                function() {
                  function Column2(dataKey, raw, index2) {
                    this.wrappedWidth = 0;
                    this.minReadableWidth = 0;
                    this.minWidth = 0;
                    this.width = 0;
                    this.dataKey = dataKey;
                    this.raw = raw;
                    this.index = index2;
                  }
                  __name(Column2, "Column");
                  Column2.prototype.getMaxCustomCellWidth = function(table) {
                    var max2 = 0;
                    for (var _i = 0, _a3 = table.allRows(); _i < _a3.length; _i++) {
                      var row = _a3[_i];
                      var cell = row.cells[this.index];
                      if (cell && typeof cell.styles.cellWidth === "number") {
                        max2 = Math.max(max2, cell.styles.cellWidth);
                      }
                    }
                    return max2;
                  };
                  return Column2;
                }()
              );
              exports3.Column = Column;
            }
          ),
          /***/
          356: (
            /***/
            function(__unused_webpack_module2, exports3) {
              Object.defineProperty(exports3, "__esModule", { value: true });
              exports3.assign = void 0;
              function assign(target, s2, s1, s22, s3) {
                if (target == null) {
                  throw new TypeError("Cannot convert undefined or null to object");
                }
                var to2 = Object(target);
                for (var index2 = 1; index2 < arguments.length; index2++) {
                  var nextSource = arguments[index2];
                  if (nextSource != null) {
                    for (var nextKey in nextSource) {
                      if (Object.prototype.hasOwnProperty.call(nextSource, nextKey)) {
                        to2[nextKey] = nextSource[nextKey];
                      }
                    }
                  }
                }
                return to2;
              }
              __name(assign, "assign");
              exports3.assign = assign;
            }
          ),
          /***/
          972: (
            /***/
            function(__unused_webpack_module2, exports3, __webpack_require__2) {
              Object.defineProperty(exports3, "__esModule", { value: true });
              exports3.createTable = void 0;
              var documentHandler_1 = __webpack_require__2(744);
              var models_1 = __webpack_require__2(260);
              var widthCalculator_1 = __webpack_require__2(324);
              var config_1 = __webpack_require__2(796);
              var polyfills_1 = __webpack_require__2(356);
              function createTable(jsPDFDoc, input) {
                var doc = new documentHandler_1.DocHandler(jsPDFDoc);
                var content = parseContent(input, doc.scaleFactor());
                var table = new models_1.Table(input, content);
                (0, widthCalculator_1.calculateWidths)(doc, table);
                doc.applyStyles(doc.userStyles);
                return table;
              }
              __name(createTable, "createTable");
              exports3.createTable = createTable;
              function parseContent(input, sf) {
                var content = input.content;
                var columns = createColumns(content.columns);
                if (content.head.length === 0) {
                  var sectionRow = generateSectionRow(columns, "head");
                  if (sectionRow)
                    content.head.push(sectionRow);
                }
                if (content.foot.length === 0) {
                  var sectionRow = generateSectionRow(columns, "foot");
                  if (sectionRow)
                    content.foot.push(sectionRow);
                }
                var theme = input.settings.theme;
                var styles = input.styles;
                return {
                  columns,
                  head: parseSection("head", content.head, columns, styles, theme, sf),
                  body: parseSection("body", content.body, columns, styles, theme, sf),
                  foot: parseSection("foot", content.foot, columns, styles, theme, sf)
                };
              }
              __name(parseContent, "parseContent");
              function parseSection(sectionName, sectionRows, columns, styleProps, theme, scaleFactor) {
                var rowSpansLeftForColumn = {};
                var result = sectionRows.map(function(rawRow, rowIndex) {
                  var skippedRowForRowSpans = 0;
                  var cells = {};
                  var colSpansAdded = 0;
                  var columnSpansLeft = 0;
                  for (var _i = 0, columns_1 = columns; _i < columns_1.length; _i++) {
                    var column = columns_1[_i];
                    if (rowSpansLeftForColumn[column.index] == null || rowSpansLeftForColumn[column.index].left === 0) {
                      if (columnSpansLeft === 0) {
                        var rawCell = void 0;
                        if (Array.isArray(rawRow)) {
                          rawCell = rawRow[column.index - colSpansAdded - skippedRowForRowSpans];
                        } else {
                          rawCell = rawRow[column.dataKey];
                        }
                        var cellInputStyles = {};
                        if (typeof rawCell === "object" && !Array.isArray(rawCell)) {
                          cellInputStyles = (rawCell === null || rawCell === void 0 ? void 0 : rawCell.styles) || {};
                        }
                        var styles = cellStyles(sectionName, column, rowIndex, theme, styleProps, scaleFactor, cellInputStyles);
                        var cell = new models_1.Cell(rawCell, styles, sectionName);
                        cells[column.dataKey] = cell;
                        cells[column.index] = cell;
                        columnSpansLeft = cell.colSpan - 1;
                        rowSpansLeftForColumn[column.index] = {
                          left: cell.rowSpan - 1,
                          times: columnSpansLeft
                        };
                      } else {
                        columnSpansLeft--;
                        colSpansAdded++;
                      }
                    } else {
                      rowSpansLeftForColumn[column.index].left--;
                      columnSpansLeft = rowSpansLeftForColumn[column.index].times;
                      skippedRowForRowSpans++;
                    }
                  }
                  return new models_1.Row(rawRow, rowIndex, sectionName, cells);
                });
                return result;
              }
              __name(parseSection, "parseSection");
              function generateSectionRow(columns, section) {
                var sectionRow = {};
                columns.forEach(function(col) {
                  if (col.raw != null) {
                    var title = getSectionTitle(section, col.raw);
                    if (title != null)
                      sectionRow[col.dataKey] = title;
                  }
                });
                return Object.keys(sectionRow).length > 0 ? sectionRow : null;
              }
              __name(generateSectionRow, "generateSectionRow");
              function getSectionTitle(section, column) {
                if (section === "head") {
                  if (typeof column === "object") {
                    return column.header || column.title || null;
                  } else if (typeof column === "string" || typeof column === "number") {
                    return column;
                  }
                } else if (section === "foot" && typeof column === "object") {
                  return column.footer;
                }
                return null;
              }
              __name(getSectionTitle, "getSectionTitle");
              function createColumns(columns) {
                return columns.map(function(input, index2) {
                  var _a3, _b2;
                  var key;
                  if (typeof input === "object") {
                    key = (_b2 = (_a3 = input.dataKey) !== null && _a3 !== void 0 ? _a3 : input.key) !== null && _b2 !== void 0 ? _b2 : index2;
                  } else {
                    key = index2;
                  }
                  return new models_1.Column(key, input, index2);
                });
              }
              __name(createColumns, "createColumns");
              function cellStyles(sectionName, column, rowIndex, themeName, styles, scaleFactor, cellInputStyles) {
                var theme = (0, config_1.getTheme)(themeName);
                var sectionStyles;
                if (sectionName === "head") {
                  sectionStyles = styles.headStyles;
                } else if (sectionName === "body") {
                  sectionStyles = styles.bodyStyles;
                } else if (sectionName === "foot") {
                  sectionStyles = styles.footStyles;
                }
                var otherStyles = (0, polyfills_1.assign)({}, theme.table, theme[sectionName], styles.styles, sectionStyles);
                var columnStyles = styles.columnStyles[column.dataKey] || styles.columnStyles[column.index] || {};
                var colStyles = sectionName === "body" ? columnStyles : {};
                var rowStyles = sectionName === "body" && rowIndex % 2 === 0 ? (0, polyfills_1.assign)({}, theme.alternateRow, styles.alternateRowStyles) : {};
                var defaultStyle = (0, config_1.defaultStyles)(scaleFactor);
                var themeStyles = (0, polyfills_1.assign)({}, defaultStyle, otherStyles, rowStyles, colStyles);
                return (0, polyfills_1.assign)(themeStyles, cellInputStyles);
              }
              __name(cellStyles, "cellStyles");
            }
          ),
          /***/
          664: (
            /***/
            function(__unused_webpack_module2, exports3, __webpack_require__2) {
              Object.defineProperty(exports3, "__esModule", { value: true });
              exports3.addPage = exports3.drawTable = void 0;
              var common_1 = __webpack_require__2(420);
              var models_1 = __webpack_require__2(260);
              var documentHandler_1 = __webpack_require__2(744);
              var polyfills_1 = __webpack_require__2(356);
              var autoTableText_1 = __webpack_require__2(136);
              var tablePrinter_1 = __webpack_require__2(224);
              function drawTable(jsPDFDoc, table) {
                var settings = table.settings;
                var startY = settings.startY;
                var margin = settings.margin;
                var cursor = {
                  x: margin.left,
                  y: startY
                };
                var sectionsHeight = table.getHeadHeight(table.columns) + table.getFootHeight(table.columns);
                var minTableBottomPos = startY + margin.bottom + sectionsHeight;
                if (settings.pageBreak === "avoid") {
                  var rows = table.body;
                  var tableHeight = rows.reduce(function(acc, row) {
                    return acc + row.height;
                  }, 0);
                  minTableBottomPos += tableHeight;
                }
                var doc = new documentHandler_1.DocHandler(jsPDFDoc);
                if (settings.pageBreak === "always" || settings.startY != null && minTableBottomPos > doc.pageSize().height) {
                  nextPage(doc);
                  cursor.y = margin.top;
                }
                table.callWillDrawPageHooks(doc, cursor);
                var startPos = (0, polyfills_1.assign)({}, cursor);
                table.startPageNumber = doc.pageNumber();
                if (settings.horizontalPageBreak) {
                  printTableWithHorizontalPageBreak(doc, table, startPos, cursor);
                } else {
                  doc.applyStyles(doc.userStyles);
                  if (settings.showHead === "firstPage" || settings.showHead === "everyPage") {
                    table.head.forEach(function(row) {
                      return printRow(doc, table, row, cursor, table.columns);
                    });
                  }
                  doc.applyStyles(doc.userStyles);
                  table.body.forEach(function(row, index2) {
                    var isLastRow = index2 === table.body.length - 1;
                    printFullRow(doc, table, row, isLastRow, startPos, cursor, table.columns);
                  });
                  doc.applyStyles(doc.userStyles);
                  if (settings.showFoot === "lastPage" || settings.showFoot === "everyPage") {
                    table.foot.forEach(function(row) {
                      return printRow(doc, table, row, cursor, table.columns);
                    });
                  }
                }
                (0, common_1.addTableBorder)(doc, table, startPos, cursor);
                table.callEndPageHooks(doc, cursor);
                table.finalY = cursor.y;
                jsPDFDoc.lastAutoTable = table;
                jsPDFDoc.previousAutoTable = table;
                if (jsPDFDoc.autoTable)
                  jsPDFDoc.autoTable.previous = table;
                doc.applyStyles(doc.userStyles);
              }
              __name(drawTable, "drawTable");
              exports3.drawTable = drawTable;
              function printTableWithHorizontalPageBreak(doc, table, startPos, cursor) {
                var allColumnsCanFitResult = (0, tablePrinter_1.calculateAllColumnsCanFitInPage)(doc, table);
                var settings = table.settings;
                if (settings.horizontalPageBreakBehaviour === "afterAllRows") {
                  allColumnsCanFitResult.forEach(function(colsAndIndexes, index2) {
                    doc.applyStyles(doc.userStyles);
                    if (index2 > 0) {
                      addPage(doc, table, startPos, cursor, colsAndIndexes.columns, true);
                    } else {
                      printHead(doc, table, cursor, colsAndIndexes.columns);
                    }
                    printBody(doc, table, startPos, cursor, colsAndIndexes.columns);
                    printFoot(doc, table, cursor, colsAndIndexes.columns);
                  });
                } else {
                  var lastRowIndexOfLastPage_1 = -1;
                  var firstColumnsToFitResult = allColumnsCanFitResult[0];
                  var _loop_1 = /* @__PURE__ */ __name(function() {
                    var lastPrintedRowIndex = lastRowIndexOfLastPage_1;
                    if (firstColumnsToFitResult) {
                      doc.applyStyles(doc.userStyles);
                      var firstColumnsToFit = firstColumnsToFitResult.columns;
                      if (lastRowIndexOfLastPage_1 >= 0) {
                        addPage(doc, table, startPos, cursor, firstColumnsToFit, true);
                      } else {
                        printHead(doc, table, cursor, firstColumnsToFit);
                      }
                      lastPrintedRowIndex = printBodyWithoutPageBreaks(doc, table, lastRowIndexOfLastPage_1 + 1, cursor, firstColumnsToFit);
                      printFoot(doc, table, cursor, firstColumnsToFit);
                    }
                    var maxNumberOfRows = lastPrintedRowIndex - lastRowIndexOfLastPage_1;
                    allColumnsCanFitResult.slice(1).forEach(function(colsAndIndexes) {
                      doc.applyStyles(doc.userStyles);
                      addPage(doc, table, startPos, cursor, colsAndIndexes.columns, true);
                      printBodyWithoutPageBreaks(doc, table, lastRowIndexOfLastPage_1 + 1, cursor, colsAndIndexes.columns, maxNumberOfRows);
                      printFoot(doc, table, cursor, colsAndIndexes.columns);
                    });
                    lastRowIndexOfLastPage_1 = lastPrintedRowIndex;
                  }, "_loop_1");
                  while (lastRowIndexOfLastPage_1 < table.body.length - 1) {
                    _loop_1();
                  }
                }
              }
              __name(printTableWithHorizontalPageBreak, "printTableWithHorizontalPageBreak");
              function printHead(doc, table, cursor, columns) {
                var settings = table.settings;
                doc.applyStyles(doc.userStyles);
                if (settings.showHead === "firstPage" || settings.showHead === "everyPage") {
                  table.head.forEach(function(row) {
                    return printRow(doc, table, row, cursor, columns);
                  });
                }
              }
              __name(printHead, "printHead");
              function printBody(doc, table, startPos, cursor, columns) {
                doc.applyStyles(doc.userStyles);
                table.body.forEach(function(row, index2) {
                  var isLastRow = index2 === table.body.length - 1;
                  printFullRow(doc, table, row, isLastRow, startPos, cursor, columns);
                });
              }
              __name(printBody, "printBody");
              function printBodyWithoutPageBreaks(doc, table, startRowIndex, cursor, columns, maxNumberOfRows) {
                doc.applyStyles(doc.userStyles);
                maxNumberOfRows = maxNumberOfRows !== null && maxNumberOfRows !== void 0 ? maxNumberOfRows : table.body.length;
                var endRowIndex = Math.min(startRowIndex + maxNumberOfRows, table.body.length);
                var lastPrintedRowIndex = -1;
                table.body.slice(startRowIndex, endRowIndex).forEach(function(row, index2) {
                  var isLastRow = startRowIndex + index2 === table.body.length - 1;
                  var remainingSpace = getRemainingPageSpace(doc, table, isLastRow, cursor);
                  if (row.canEntireRowFit(remainingSpace, columns)) {
                    printRow(doc, table, row, cursor, columns);
                    lastPrintedRowIndex = startRowIndex + index2;
                  }
                });
                return lastPrintedRowIndex;
              }
              __name(printBodyWithoutPageBreaks, "printBodyWithoutPageBreaks");
              function printFoot(doc, table, cursor, columns) {
                var settings = table.settings;
                doc.applyStyles(doc.userStyles);
                if (settings.showFoot === "lastPage" || settings.showFoot === "everyPage") {
                  table.foot.forEach(function(row) {
                    return printRow(doc, table, row, cursor, columns);
                  });
                }
              }
              __name(printFoot, "printFoot");
              function getRemainingLineCount(cell, remainingPageSpace, doc) {
                var lineHeight = doc.getLineHeight(cell.styles.fontSize);
                var vPadding = cell.padding("vertical");
                var remainingLines = Math.floor((remainingPageSpace - vPadding) / lineHeight);
                return Math.max(0, remainingLines);
              }
              __name(getRemainingLineCount, "getRemainingLineCount");
              function modifyRowToFit(row, remainingPageSpace, table, doc) {
                var cells = {};
                row.spansMultiplePages = true;
                row.height = 0;
                var rowHeight = 0;
                for (var _i = 0, _a3 = table.columns; _i < _a3.length; _i++) {
                  var column = _a3[_i];
                  var cell = row.cells[column.index];
                  if (!cell)
                    continue;
                  if (!Array.isArray(cell.text)) {
                    cell.text = [cell.text];
                  }
                  var remainderCell = new models_1.Cell(cell.raw, cell.styles, cell.section);
                  remainderCell = (0, polyfills_1.assign)(remainderCell, cell);
                  remainderCell.text = [];
                  var remainingLineCount = getRemainingLineCount(cell, remainingPageSpace, doc);
                  if (cell.text.length > remainingLineCount) {
                    remainderCell.text = cell.text.splice(remainingLineCount, cell.text.length);
                  }
                  var scaleFactor = doc.scaleFactor();
                  var lineHeightFactor = doc.getLineHeightFactor();
                  cell.contentHeight = cell.getContentHeight(scaleFactor, lineHeightFactor);
                  if (cell.contentHeight >= remainingPageSpace) {
                    cell.contentHeight = remainingPageSpace;
                    remainderCell.styles.minCellHeight -= remainingPageSpace;
                  }
                  if (cell.contentHeight > row.height) {
                    row.height = cell.contentHeight;
                  }
                  remainderCell.contentHeight = remainderCell.getContentHeight(scaleFactor, lineHeightFactor);
                  if (remainderCell.contentHeight > rowHeight) {
                    rowHeight = remainderCell.contentHeight;
                  }
                  cells[column.index] = remainderCell;
                }
                var remainderRow = new models_1.Row(row.raw, -1, row.section, cells, true);
                remainderRow.height = rowHeight;
                for (var _b2 = 0, _c = table.columns; _b2 < _c.length; _b2++) {
                  var column = _c[_b2];
                  var remainderCell = remainderRow.cells[column.index];
                  if (remainderCell) {
                    remainderCell.height = remainderRow.height;
                  }
                  var cell = row.cells[column.index];
                  if (cell) {
                    cell.height = row.height;
                  }
                }
                return remainderRow;
              }
              __name(modifyRowToFit, "modifyRowToFit");
              function shouldPrintOnCurrentPage(doc, row, remainingPageSpace, table) {
                var pageHeight = doc.pageSize().height;
                var margin = table.settings.margin;
                var marginHeight = margin.top + margin.bottom;
                var maxRowHeight = pageHeight - marginHeight;
                if (row.section === "body") {
                  maxRowHeight -= table.getHeadHeight(table.columns) + table.getFootHeight(table.columns);
                }
                var minRowHeight = row.getMinimumRowHeight(table.columns, doc);
                var minRowFits = minRowHeight < remainingPageSpace;
                if (minRowHeight > maxRowHeight) {
                  console.error("Will not be able to print row ".concat(row.index, " correctly since it's minimum height is larger than page height"));
                  return true;
                }
                if (!minRowFits) {
                  return false;
                }
                var rowHasRowSpanCell = row.hasRowSpan(table.columns);
                var rowHigherThanPage = row.getMaxCellHeight(table.columns) > maxRowHeight;
                if (rowHigherThanPage) {
                  if (rowHasRowSpanCell) {
                    console.error("The content of row ".concat(row.index, " will not be drawn correctly since drawing rows with a height larger than the page height and has cells with rowspans is not supported."));
                  }
                  return true;
                }
                if (rowHasRowSpanCell) {
                  return false;
                }
                if (table.settings.rowPageBreak === "avoid") {
                  return false;
                }
                return true;
              }
              __name(shouldPrintOnCurrentPage, "shouldPrintOnCurrentPage");
              function printFullRow(doc, table, row, isLastRow, startPos, cursor, columns) {
                var remainingSpace = getRemainingPageSpace(doc, table, isLastRow, cursor);
                if (row.canEntireRowFit(remainingSpace, columns)) {
                  printRow(doc, table, row, cursor, columns);
                } else if (shouldPrintOnCurrentPage(doc, row, remainingSpace, table)) {
                  var remainderRow = modifyRowToFit(row, remainingSpace, table, doc);
                  printRow(doc, table, row, cursor, columns);
                  addPage(doc, table, startPos, cursor, columns);
                  printFullRow(doc, table, remainderRow, isLastRow, startPos, cursor, columns);
                } else {
                  addPage(doc, table, startPos, cursor, columns);
                  printFullRow(doc, table, row, isLastRow, startPos, cursor, columns);
                }
              }
              __name(printFullRow, "printFullRow");
              function printRow(doc, table, row, cursor, columns) {
                cursor.x = table.settings.margin.left;
                for (var _i = 0, columns_1 = columns; _i < columns_1.length; _i++) {
                  var column = columns_1[_i];
                  var cell = row.cells[column.index];
                  if (!cell) {
                    cursor.x += column.width;
                    continue;
                  }
                  doc.applyStyles(cell.styles);
                  cell.x = cursor.x;
                  cell.y = cursor.y;
                  var result = table.callCellHooks(doc, table.hooks.willDrawCell, cell, row, column, cursor);
                  if (result === false) {
                    cursor.x += column.width;
                    continue;
                  }
                  drawCellRect(doc, cell, cursor);
                  var textPos = cell.getTextPos();
                  (0, autoTableText_1.default)(cell.text, textPos.x, textPos.y, {
                    halign: cell.styles.halign,
                    valign: cell.styles.valign,
                    maxWidth: Math.ceil(cell.width - cell.padding("left") - cell.padding("right"))
                  }, doc.getDocument());
                  table.callCellHooks(doc, table.hooks.didDrawCell, cell, row, column, cursor);
                  cursor.x += column.width;
                }
                cursor.y += row.height;
              }
              __name(printRow, "printRow");
              function drawCellRect(doc, cell, cursor) {
                var cellStyles = cell.styles;
                doc.getDocument().setFillColor(doc.getDocument().getFillColor());
                if (typeof cellStyles.lineWidth === "number") {
                  var fillStyle = (0, common_1.getFillStyle)(cellStyles.lineWidth, cellStyles.fillColor);
                  if (fillStyle) {
                    doc.rect(cell.x, cursor.y, cell.width, cell.height, fillStyle);
                  }
                } else if (typeof cellStyles.lineWidth === "object") {
                  if (cellStyles.fillColor) {
                    doc.rect(cell.x, cursor.y, cell.width, cell.height, "F");
                  }
                  drawCellBorders(doc, cell, cursor, cellStyles.lineWidth);
                }
              }
              __name(drawCellRect, "drawCellRect");
              function drawCellBorders(doc, cell, cursor, lineWidth) {
                var x1, y1, x2, y2;
                if (lineWidth.top) {
                  x1 = cursor.x;
                  y1 = cursor.y;
                  x2 = cursor.x + cell.width;
                  y2 = cursor.y;
                  if (lineWidth.right) {
                    x2 += 0.5 * lineWidth.right;
                  }
                  if (lineWidth.left) {
                    x1 -= 0.5 * lineWidth.left;
                  }
                  drawLine(lineWidth.top, x1, y1, x2, y2);
                }
                if (lineWidth.bottom) {
                  x1 = cursor.x;
                  y1 = cursor.y + cell.height;
                  x2 = cursor.x + cell.width;
                  y2 = cursor.y + cell.height;
                  if (lineWidth.right) {
                    x2 += 0.5 * lineWidth.right;
                  }
                  if (lineWidth.left) {
                    x1 -= 0.5 * lineWidth.left;
                  }
                  drawLine(lineWidth.bottom, x1, y1, x2, y2);
                }
                if (lineWidth.left) {
                  x1 = cursor.x;
                  y1 = cursor.y;
                  x2 = cursor.x;
                  y2 = cursor.y + cell.height;
                  if (lineWidth.top) {
                    y1 -= 0.5 * lineWidth.top;
                  }
                  if (lineWidth.bottom) {
                    y2 += 0.5 * lineWidth.bottom;
                  }
                  drawLine(lineWidth.left, x1, y1, x2, y2);
                }
                if (lineWidth.right) {
                  x1 = cursor.x + cell.width;
                  y1 = cursor.y;
                  x2 = cursor.x + cell.width;
                  y2 = cursor.y + cell.height;
                  if (lineWidth.top) {
                    y1 -= 0.5 * lineWidth.top;
                  }
                  if (lineWidth.bottom) {
                    y2 += 0.5 * lineWidth.bottom;
                  }
                  drawLine(lineWidth.right, x1, y1, x2, y2);
                }
                function drawLine(width, x12, y12, x22, y22) {
                  doc.getDocument().setLineWidth(width);
                  doc.getDocument().line(x12, y12, x22, y22, "S");
                }
                __name(drawLine, "drawLine");
              }
              __name(drawCellBorders, "drawCellBorders");
              function getRemainingPageSpace(doc, table, isLastRow, cursor) {
                var bottomContentHeight = table.settings.margin.bottom;
                var showFoot = table.settings.showFoot;
                if (showFoot === "everyPage" || showFoot === "lastPage" && isLastRow) {
                  bottomContentHeight += table.getFootHeight(table.columns);
                }
                return doc.pageSize().height - cursor.y - bottomContentHeight;
              }
              __name(getRemainingPageSpace, "getRemainingPageSpace");
              function addPage(doc, table, startPos, cursor, columns, suppressFooter) {
                if (columns === void 0) {
                  columns = [];
                }
                if (suppressFooter === void 0) {
                  suppressFooter = false;
                }
                doc.applyStyles(doc.userStyles);
                if (table.settings.showFoot === "everyPage" && !suppressFooter) {
                  table.foot.forEach(function(row) {
                    return printRow(doc, table, row, cursor, columns);
                  });
                }
                table.callEndPageHooks(doc, cursor);
                var margin = table.settings.margin;
                (0, common_1.addTableBorder)(doc, table, startPos, cursor);
                nextPage(doc);
                table.pageNumber++;
                table.pageCount++;
                cursor.x = margin.left;
                cursor.y = margin.top;
                startPos.y = margin.top;
                table.callWillDrawPageHooks(doc, cursor);
                if (table.settings.showHead === "everyPage") {
                  table.head.forEach(function(row) {
                    return printRow(doc, table, row, cursor, columns);
                  });
                  doc.applyStyles(doc.userStyles);
                }
              }
              __name(addPage, "addPage");
              exports3.addPage = addPage;
              function nextPage(doc) {
                var current = doc.pageNumber();
                doc.setPage(current + 1);
                var newCurrent = doc.pageNumber();
                if (newCurrent === current) {
                  doc.addPage();
                  return true;
                }
                return false;
              }
              __name(nextPage, "nextPage");
            }
          ),
          /***/
          224: (
            /***/
            function(__unused_webpack_module2, exports3, __webpack_require__2) {
              Object.defineProperty(exports3, "__esModule", { value: true });
              exports3.calculateAllColumnsCanFitInPage = void 0;
              var common_1 = __webpack_require__2(420);
              function getColumnsCanFitInPage(doc, table, config) {
                var _a3;
                if (config === void 0) {
                  config = {};
                }
                var remainingWidth = (0, common_1.getPageAvailableWidth)(doc, table);
                var repeatColumnsMap = /* @__PURE__ */ new Map();
                var colIndexes = [];
                var columns = [];
                var horizontalPageBreakRepeat = [];
                table.settings.horizontalPageBreakRepeat;
                if (Array.isArray(table.settings.horizontalPageBreakRepeat)) {
                  horizontalPageBreakRepeat = table.settings.horizontalPageBreakRepeat;
                } else if (typeof table.settings.horizontalPageBreakRepeat === "string" || typeof table.settings.horizontalPageBreakRepeat === "number") {
                  horizontalPageBreakRepeat = [table.settings.horizontalPageBreakRepeat];
                }
                horizontalPageBreakRepeat.forEach(function(field) {
                  var col = table.columns.find(function(item) {
                    return item.dataKey === field || item.index === field;
                  });
                  if (col && !repeatColumnsMap.has(col.index)) {
                    repeatColumnsMap.set(col.index, true);
                    colIndexes.push(col.index);
                    columns.push(table.columns[col.index]);
                    remainingWidth -= col.wrappedWidth;
                  }
                });
                var first = true;
                var i2 = (_a3 = config === null || config === void 0 ? void 0 : config.start) !== null && _a3 !== void 0 ? _a3 : 0;
                while (i2 < table.columns.length) {
                  if (repeatColumnsMap.has(i2)) {
                    i2++;
                    continue;
                  }
                  var colWidth = table.columns[i2].wrappedWidth;
                  if (first || remainingWidth >= colWidth) {
                    first = false;
                    colIndexes.push(i2);
                    columns.push(table.columns[i2]);
                    remainingWidth -= colWidth;
                  } else {
                    break;
                  }
                  i2++;
                }
                return { colIndexes, columns, lastIndex: i2 - 1 };
              }
              __name(getColumnsCanFitInPage, "getColumnsCanFitInPage");
              function calculateAllColumnsCanFitInPage(doc, table) {
                var allResults = [];
                for (var i2 = 0; i2 < table.columns.length; i2++) {
                  var result = getColumnsCanFitInPage(doc, table, { start: i2 });
                  if (result.columns.length) {
                    allResults.push(result);
                    i2 = result.lastIndex;
                  }
                }
                return allResults;
              }
              __name(calculateAllColumnsCanFitInPage, "calculateAllColumnsCanFitInPage");
              exports3.calculateAllColumnsCanFitInPage = calculateAllColumnsCanFitInPage;
            }
          ),
          /***/
          324: (
            /***/
            function(__unused_webpack_module2, exports3, __webpack_require__2) {
              Object.defineProperty(exports3, "__esModule", { value: true });
              exports3.ellipsize = exports3.resizeColumns = exports3.calculateWidths = void 0;
              var common_1 = __webpack_require__2(420);
              function calculateWidths(doc, table) {
                calculate(doc, table);
                var resizableColumns = [];
                var initialTableWidth = 0;
                table.columns.forEach(function(column) {
                  var customWidth = column.getMaxCustomCellWidth(table);
                  if (customWidth) {
                    column.width = customWidth;
                  } else {
                    column.width = column.wrappedWidth;
                    resizableColumns.push(column);
                  }
                  initialTableWidth += column.width;
                });
                var resizeWidth = table.getWidth(doc.pageSize().width) - initialTableWidth;
                if (resizeWidth) {
                  resizeWidth = resizeColumns(resizableColumns, resizeWidth, function(column) {
                    return Math.max(column.minReadableWidth, column.minWidth);
                  });
                }
                if (resizeWidth) {
                  resizeWidth = resizeColumns(resizableColumns, resizeWidth, function(column) {
                    return column.minWidth;
                  });
                }
                resizeWidth = Math.abs(resizeWidth);
                if (!table.settings.horizontalPageBreak && resizeWidth > 0.1 / doc.scaleFactor()) {
                  resizeWidth = resizeWidth < 1 ? resizeWidth : Math.round(resizeWidth);
                  console.warn("Of the table content, ".concat(resizeWidth, " units width could not fit page"));
                }
                applyColSpans(table);
                fitContent(table, doc);
                applyRowSpans(table);
              }
              __name(calculateWidths, "calculateWidths");
              exports3.calculateWidths = calculateWidths;
              function calculate(doc, table) {
                var sf = doc.scaleFactor();
                var horizontalPageBreak = table.settings.horizontalPageBreak;
                var availablePageWidth = (0, common_1.getPageAvailableWidth)(doc, table);
                table.allRows().forEach(function(row) {
                  for (var _i = 0, _a3 = table.columns; _i < _a3.length; _i++) {
                    var column = _a3[_i];
                    var cell = row.cells[column.index];
                    if (!cell)
                      continue;
                    var hooks = table.hooks.didParseCell;
                    table.callCellHooks(doc, hooks, cell, row, column, null);
                    var padding = cell.padding("horizontal");
                    cell.contentWidth = (0, common_1.getStringWidth)(cell.text, cell.styles, doc) + padding;
                    var longestWordWidth = (0, common_1.getStringWidth)(cell.text.join(" ").split(/[^\S\u00A0]+/), cell.styles, doc);
                    cell.minReadableWidth = longestWordWidth + cell.padding("horizontal");
                    if (typeof cell.styles.cellWidth === "number") {
                      cell.minWidth = cell.styles.cellWidth;
                      cell.wrappedWidth = cell.styles.cellWidth;
                    } else if (cell.styles.cellWidth === "wrap" || horizontalPageBreak === true) {
                      if (cell.contentWidth > availablePageWidth) {
                        cell.minWidth = availablePageWidth;
                        cell.wrappedWidth = availablePageWidth;
                      } else {
                        cell.minWidth = cell.contentWidth;
                        cell.wrappedWidth = cell.contentWidth;
                      }
                    } else {
                      var defaultMinWidth = 10 / sf;
                      cell.minWidth = cell.styles.minCellWidth || defaultMinWidth;
                      cell.wrappedWidth = cell.contentWidth;
                      if (cell.minWidth > cell.wrappedWidth) {
                        cell.wrappedWidth = cell.minWidth;
                      }
                    }
                  }
                });
                table.allRows().forEach(function(row) {
                  for (var _i = 0, _a3 = table.columns; _i < _a3.length; _i++) {
                    var column = _a3[_i];
                    var cell = row.cells[column.index];
                    if (cell && cell.colSpan === 1) {
                      column.wrappedWidth = Math.max(column.wrappedWidth, cell.wrappedWidth);
                      column.minWidth = Math.max(column.minWidth, cell.minWidth);
                      column.minReadableWidth = Math.max(column.minReadableWidth, cell.minReadableWidth);
                    } else {
                      var columnStyles = table.styles.columnStyles[column.dataKey] || table.styles.columnStyles[column.index] || {};
                      var cellWidth = columnStyles.cellWidth || columnStyles.minCellWidth;
                      if (cellWidth && typeof cellWidth === "number") {
                        column.minWidth = cellWidth;
                        column.wrappedWidth = cellWidth;
                      }
                    }
                    if (cell) {
                      if (cell.colSpan > 1 && !column.minWidth) {
                        column.minWidth = cell.minWidth;
                      }
                      if (cell.colSpan > 1 && !column.wrappedWidth) {
                        column.wrappedWidth = cell.minWidth;
                      }
                    }
                  }
                });
              }
              __name(calculate, "calculate");
              function resizeColumns(columns, resizeWidth, getMinWidth) {
                var initialResizeWidth = resizeWidth;
                var sumWrappedWidth = columns.reduce(function(acc, column2) {
                  return acc + column2.wrappedWidth;
                }, 0);
                for (var i2 = 0; i2 < columns.length; i2++) {
                  var column = columns[i2];
                  var ratio = column.wrappedWidth / sumWrappedWidth;
                  var suggestedChange = initialResizeWidth * ratio;
                  var suggestedWidth = column.width + suggestedChange;
                  var minWidth = getMinWidth(column);
                  var newWidth = suggestedWidth < minWidth ? minWidth : suggestedWidth;
                  resizeWidth -= newWidth - column.width;
                  column.width = newWidth;
                }
                resizeWidth = Math.round(resizeWidth * 1e10) / 1e10;
                if (resizeWidth) {
                  var resizableColumns = columns.filter(function(column2) {
                    return resizeWidth < 0 ? column2.width > getMinWidth(column2) : true;
                  });
                  if (resizableColumns.length) {
                    resizeWidth = resizeColumns(resizableColumns, resizeWidth, getMinWidth);
                  }
                }
                return resizeWidth;
              }
              __name(resizeColumns, "resizeColumns");
              exports3.resizeColumns = resizeColumns;
              function applyRowSpans(table) {
                var rowSpanCells = {};
                var colRowSpansLeft = 1;
                var all = table.allRows();
                for (var rowIndex = 0; rowIndex < all.length; rowIndex++) {
                  var row = all[rowIndex];
                  for (var _i = 0, _a3 = table.columns; _i < _a3.length; _i++) {
                    var column = _a3[_i];
                    var data = rowSpanCells[column.index];
                    if (colRowSpansLeft > 1) {
                      colRowSpansLeft--;
                      delete row.cells[column.index];
                    } else if (data) {
                      data.cell.height += row.height;
                      colRowSpansLeft = data.cell.colSpan;
                      delete row.cells[column.index];
                      data.left--;
                      if (data.left <= 1) {
                        delete rowSpanCells[column.index];
                      }
                    } else {
                      var cell = row.cells[column.index];
                      if (!cell) {
                        continue;
                      }
                      cell.height = row.height;
                      if (cell.rowSpan > 1) {
                        var remaining = all.length - rowIndex;
                        var left = cell.rowSpan > remaining ? remaining : cell.rowSpan;
                        rowSpanCells[column.index] = { cell, left, row };
                      }
                    }
                  }
                }
              }
              __name(applyRowSpans, "applyRowSpans");
              function applyColSpans(table) {
                var all = table.allRows();
                for (var rowIndex = 0; rowIndex < all.length; rowIndex++) {
                  var row = all[rowIndex];
                  var colSpanCell = null;
                  var combinedColSpanWidth = 0;
                  var colSpansLeft = 0;
                  for (var columnIndex = 0; columnIndex < table.columns.length; columnIndex++) {
                    var column = table.columns[columnIndex];
                    colSpansLeft -= 1;
                    if (colSpansLeft > 1 && table.columns[columnIndex + 1]) {
                      combinedColSpanWidth += column.width;
                      delete row.cells[column.index];
                    } else if (colSpanCell) {
                      var cell = colSpanCell;
                      delete row.cells[column.index];
                      colSpanCell = null;
                      cell.width = column.width + combinedColSpanWidth;
                    } else {
                      var cell = row.cells[column.index];
                      if (!cell)
                        continue;
                      colSpansLeft = cell.colSpan;
                      combinedColSpanWidth = 0;
                      if (cell.colSpan > 1) {
                        colSpanCell = cell;
                        combinedColSpanWidth += column.width;
                        continue;
                      }
                      cell.width = column.width + combinedColSpanWidth;
                    }
                  }
                }
              }
              __name(applyColSpans, "applyColSpans");
              function fitContent(table, doc) {
                var rowSpanHeight = { count: 0, height: 0 };
                for (var _i = 0, _a3 = table.allRows(); _i < _a3.length; _i++) {
                  var row = _a3[_i];
                  for (var _b2 = 0, _c = table.columns; _b2 < _c.length; _b2++) {
                    var column = _c[_b2];
                    var cell = row.cells[column.index];
                    if (!cell)
                      continue;
                    doc.applyStyles(cell.styles, true);
                    var textSpace = cell.width - cell.padding("horizontal");
                    if (cell.styles.overflow === "linebreak") {
                      cell.text = doc.splitTextToSize(cell.text, textSpace + 1 / doc.scaleFactor(), { fontSize: cell.styles.fontSize });
                    } else if (cell.styles.overflow === "ellipsize") {
                      cell.text = ellipsize(cell.text, textSpace, cell.styles, doc, "...");
                    } else if (cell.styles.overflow === "hidden") {
                      cell.text = ellipsize(cell.text, textSpace, cell.styles, doc, "");
                    } else if (typeof cell.styles.overflow === "function") {
                      var result = cell.styles.overflow(cell.text, textSpace);
                      if (typeof result === "string") {
                        cell.text = [result];
                      } else {
                        cell.text = result;
                      }
                    }
                    cell.contentHeight = cell.getContentHeight(doc.scaleFactor(), doc.getLineHeightFactor());
                    var realContentHeight = cell.contentHeight / cell.rowSpan;
                    if (cell.rowSpan > 1 && rowSpanHeight.count * rowSpanHeight.height < realContentHeight * cell.rowSpan) {
                      rowSpanHeight = { height: realContentHeight, count: cell.rowSpan };
                    } else if (rowSpanHeight && rowSpanHeight.count > 0) {
                      if (rowSpanHeight.height > realContentHeight) {
                        realContentHeight = rowSpanHeight.height;
                      }
                    }
                    if (realContentHeight > row.height) {
                      row.height = realContentHeight;
                    }
                  }
                  rowSpanHeight.count--;
                }
              }
              __name(fitContent, "fitContent");
              function ellipsize(text, width, styles, doc, overflow) {
                return text.map(function(str) {
                  return ellipsizeStr(str, width, styles, doc, overflow);
                });
              }
              __name(ellipsize, "ellipsize");
              exports3.ellipsize = ellipsize;
              function ellipsizeStr(text, width, styles, doc, overflow) {
                var precision = 1e4 * doc.scaleFactor();
                width = Math.ceil(width * precision) / precision;
                if (width >= (0, common_1.getStringWidth)(text, styles, doc)) {
                  return text;
                }
                while (width < (0, common_1.getStringWidth)(text + overflow, styles, doc)) {
                  if (text.length <= 1) {
                    break;
                  }
                  text = text.substring(0, text.length - 1);
                }
                return text.trim() + overflow;
              }
              __name(ellipsizeStr, "ellipsizeStr");
            }
          ),
          /***/
          964: (
            /***/
            function(module3) {
              if (typeof __WEBPACK_EXTERNAL_MODULE__964__ === "undefined") {
                var e = new Error("Cannot find module 'undefined'");
                e.code = "MODULE_NOT_FOUND";
                throw e;
              }
              module3.exports = __WEBPACK_EXTERNAL_MODULE__964__;
            }
          )
          /******/
        };
        var __webpack_module_cache__2 = {};
        function __webpack_require__(moduleId) {
          var cachedModule = __webpack_module_cache__2[moduleId];
          if (cachedModule !== void 0) {
            return cachedModule.exports;
          }
          var module3 = __webpack_module_cache__2[moduleId] = {
            /******/
            // no module.id needed
            /******/
            // no module.loaded needed
            /******/
            exports: {}
            /******/
          };
          __webpack_modules__2[moduleId].call(module3.exports, module3, module3.exports, __webpack_require__);
          return module3.exports;
        }
        __name(__webpack_require__, "__webpack_require__");
        var __webpack_exports__2 = {};
        !function() {
          var exports3 = __webpack_exports__2;
          Object.defineProperty(exports3, "__esModule", { value: true });
          exports3.Cell = exports3.Column = exports3.Row = exports3.Table = exports3.CellHookData = exports3.__drawTable = exports3.__createTable = exports3.applyPlugin = void 0;
          var applyPlugin_1 = __webpack_require__(340);
          var inputParser_1 = __webpack_require__(776);
          var tableDrawer_1 = __webpack_require__(664);
          var tableCalculator_1 = __webpack_require__(972);
          var models_1 = __webpack_require__(260);
          Object.defineProperty(exports3, "Table", { enumerable: true, get: function() {
            return models_1.Table;
          } });
          var HookData_1 = __webpack_require__(172);
          Object.defineProperty(exports3, "CellHookData", { enumerable: true, get: function() {
            return HookData_1.CellHookData;
          } });
          var models_2 = __webpack_require__(260);
          Object.defineProperty(exports3, "Cell", { enumerable: true, get: function() {
            return models_2.Cell;
          } });
          Object.defineProperty(exports3, "Column", { enumerable: true, get: function() {
            return models_2.Column;
          } });
          Object.defineProperty(exports3, "Row", { enumerable: true, get: function() {
            return models_2.Row;
          } });
          function applyPlugin(jsPDF2) {
            (0, applyPlugin_1.default)(jsPDF2);
          }
          __name(applyPlugin, "applyPlugin");
          exports3.applyPlugin = applyPlugin;
          function autoTable(d2, options) {
            var input = (0, inputParser_1.parseInput)(d2, options);
            var table = (0, tableCalculator_1.createTable)(d2, input);
            (0, tableDrawer_1.drawTable)(d2, table);
          }
          __name(autoTable, "autoTable");
          function __createTable(d2, options) {
            var input = (0, inputParser_1.parseInput)(d2, options);
            return (0, tableCalculator_1.createTable)(d2, input);
          }
          __name(__createTable, "__createTable");
          exports3.__createTable = __createTable;
          function __drawTable(d2, table) {
            (0, tableDrawer_1.drawTable)(d2, table);
          }
          __name(__drawTable, "__drawTable");
          exports3.__drawTable = __drawTable;
          try {
            var jsPDF = __webpack_require__(964);
            if (jsPDF.jsPDF)
              jsPDF = jsPDF.jsPDF;
            applyPlugin(jsPDF);
          } catch (error) {
          }
          exports3["default"] = autoTable;
        }();
        return __webpack_exports__2;
      }()
    );
  });
})(jspdf_plugin_autotable);
function Reports() {
  const { query } = useDatabase();
  const { user } = useAuth();
  const [reports, setReports] = reactExports.useState([]);
  const [companies, setCompanies] = reactExports.useState([]);
  const [loading, setLoading] = reactExports.useState(true);
  const [generating, setGenerating] = reactExports.useState(false);
  const [searchTerm, setSearchTerm] = reactExports.useState("");
  const [showCreateModal, setShowCreateModal] = reactExports.useState(false);
  const [formData, setFormData] = reactExports.useState({
    name: "",
    type: "company_analysis",
    company_ids: [],
    date_range: "all",
    include_inconsistencies: true,
    format: "excel"
  });
  reactExports.useEffect(() => {
    loadReports();
    loadCompanies();
  }, []);
  const loadReports = /* @__PURE__ */ __name(async () => {
    try {
      const result = await query(`
        SELECT r.*, u.email as created_by_email
        FROM reports r
        LEFT JOIN users u ON r.created_by = u.id
        ORDER BY r.created_at DESC
      `);
      setReports(result.data || []);
    } catch (error) {
      console.error("Error loading reports:", error);
    } finally {
      setLoading(false);
    }
  }, "loadReports");
  const loadCompanies = /* @__PURE__ */ __name(async () => {
    try {
      const result = await query("SELECT id, name FROM companies ORDER BY name");
      setCompanies(result.data || []);
    } catch (error) {
      console.error("Error loading companies:", error);
    }
  }, "loadCompanies");
  const generateReport = /* @__PURE__ */ __name(async (reportConfig) => {
    setGenerating(true);
    try {
      const reportData = await fetchReportData(reportConfig);
      if (reportConfig.format === "excel") {
        generateExcelReport(reportData, reportConfig);
      } else if (reportConfig.format === "pdf") {
        generatePDFReport(reportData, reportConfig);
      } else if (reportConfig.format === "csv") {
        generateCSVReport(reportData, reportConfig);
      }
      await query(`
        INSERT INTO reports (name, type, parameters, created_by)
        VALUES ($1, $2, $3, $4)
      `, [
        reportConfig.name,
        reportConfig.type,
        JSON.stringify(reportConfig),
        user == null ? void 0 : user.id
      ]);
      loadReports();
    } catch (error) {
      console.error("Error generating report:", error);
      alert("Error generating report: " + error.message);
    } finally {
      setGenerating(false);
    }
  }, "generateReport");
  const fetchReportData = /* @__PURE__ */ __name(async (config) => {
    const data = {};
    if (config.company_ids.length > 0) {
      const companiesResult = await query(`
        SELECT * FROM companies WHERE id = ANY($1)
      `, [config.company_ids]);
      data.companies = companiesResult.data || [];
      const statementsResult = await query(`
        SELECT fs.*, c.name as company_name
        FROM financial_statements fs
        JOIN companies c ON fs.company_id = c.id
        WHERE fs.company_id = ANY($1)
        ORDER BY fs.year DESC, fs.quarter DESC
      `, [config.company_ids]);
      data.statements = statementsResult.data || [];
      const metricsResult = await query(`
        SELECT fm.*, fs.year, fs.quarter, c.name as company_name
        FROM financial_metrics fm
        JOIN financial_statements fs ON fm.statement_id = fs.id
        JOIN companies c ON fs.company_id = c.id
        WHERE fs.company_id = ANY($1)
        ORDER BY c.name, fs.year DESC, fs.quarter DESC
      `, [config.company_ids]);
      data.metrics = metricsResult.data || [];
      if (config.include_inconsistencies) {
        const inconsistenciesResult = await query(`
          SELECT i.*, fs.year, fs.quarter, c.name as company_name
          FROM inconsistencies i
          JOIN financial_statements fs ON i.statement_id = fs.id
          JOIN companies c ON fs.company_id = c.id
          WHERE fs.company_id = ANY($1)
          ORDER BY i.severity DESC, i.detected_at DESC
        `, [config.company_ids]);
        data.inconsistencies = inconsistenciesResult.data || [];
      }
    }
    return data;
  }, "fetchReportData");
  const generateExcelReport = /* @__PURE__ */ __name((data, config) => {
    const wb = utils.book_new();
    if (data.companies) {
      const companiesWS = utils.json_to_sheet(data.companies);
      utils.book_append_sheet(wb, companiesWS, "Companies");
    }
    if (data.metrics) {
      const metricsWS = utils.json_to_sheet(data.metrics);
      utils.book_append_sheet(wb, metricsWS, "Financial Metrics");
    }
    if (data.inconsistencies) {
      const inconsistenciesWS = utils.json_to_sheet(data.inconsistencies);
      utils.book_append_sheet(wb, inconsistenciesWS, "Inconsistencies");
    }
    writeFileSync(wb, `${config.name}.xlsx`);
  }, "generateExcelReport");
  const generatePDFReport = /* @__PURE__ */ __name((data, config) => {
    const doc = new E();
    doc.setFontSize(20);
    doc.text(config.name, 20, 20);
    doc.setFontSize(12);
    doc.text(`Generated on: ${(/* @__PURE__ */ new Date()).toLocaleDateString()}`, 20, 30);
    doc.text(`Created by: ${user == null ? void 0 : user.email}`, 20, 40);
    let yPosition = 60;
    if (data.companies) {
      doc.setFontSize(16);
      doc.text("Companies Overview", 20, yPosition);
      yPosition += 10;
      const companyData = data.companies.map((c2) => [c2.name, c2.industry || "N/A"]);
      doc.autoTable({
        head: [["Company", "Industry"]],
        body: companyData,
        startY: yPosition,
        margin: { left: 20 }
      });
      yPosition = doc.lastAutoTable.finalY + 20;
    }
    if (data.metrics) {
      doc.setFontSize(16);
      doc.text("Key Financial Metrics", 20, yPosition);
      yPosition += 10;
      const revenueMetrics = data.metrics.filter((m2) => m2.metric_name === "total_revenue");
      const metricsData = revenueMetrics.map((m2) => [
        m2.company_name,
        m2.year,
        m2.quarter || "Annual",
        `$${(parseFloat(m2.metric_value) / 1e6).toFixed(1)}M`
      ]);
      doc.autoTable({
        head: [["Company", "Year", "Period", "Revenue"]],
        body: metricsData,
        startY: yPosition,
        margin: { left: 20 }
      });
      yPosition = doc.lastAutoTable.finalY + 20;
    }
    if (data.inconsistencies && data.inconsistencies.length > 0) {
      doc.setFontSize(16);
      doc.text("Data Quality Issues", 20, yPosition);
      yPosition += 10;
      const inconsistencyData = data.inconsistencies.slice(0, 10).map((i2) => [
        i2.company_name,
        i2.inconsistency_type,
        i2.severity,
        i2.description.substring(0, 50) + "..."
      ]);
      doc.autoTable({
        head: [["Company", "Type", "Severity", "Description"]],
        body: inconsistencyData,
        startY: yPosition,
        margin: { left: 20 }
      });
    }
    doc.save(`${config.name}.pdf`);
  }, "generatePDFReport");
  const generateCSVReport = /* @__PURE__ */ __name((data, config) => {
    if (data.metrics) {
      const csvContent = [
        ["Company", "Year", "Quarter", "Metric Name", "Metric Value", "Category"],
        ...data.metrics.map((m2) => [
          m2.company_name,
          m2.year,
          m2.quarter || "",
          m2.metric_name,
          m2.metric_value,
          m2.metric_category
        ])
      ].map((row) => row.join(",")).join("\n");
      const blob = new Blob([csvContent], { type: "text/csv" });
      const url = window.URL.createObjectURL(blob);
      const a2 = document.createElement("a");
      a2.href = url;
      a2.download = `${config.name}.csv`;
      a2.click();
      window.URL.revokeObjectURL(url);
    }
  }, "generateCSVReport");
  const handleSubmit = /* @__PURE__ */ __name(async (e) => {
    e.preventDefault();
    await generateReport(formData);
    setShowCreateModal(false);
    setFormData({
      name: "",
      type: "company_analysis",
      company_ids: [],
      date_range: "all",
      include_inconsistencies: true,
      format: "excel"
    });
  }, "handleSubmit");
  const filteredReports = reports.filter(
    (report) => report.name.toLowerCase().includes(searchTerm.toLowerCase()) || report.type.toLowerCase().includes(searchTerm.toLowerCase())
  );
  if (loading) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex items-center justify-center h-64", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "animate-spin rounded-full h-32 w-32 border-b-2 border-primary-600" }) });
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-6", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex justify-between items-center", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h1", { className: "text-3xl font-bold text-gray-900 dark:text-white", children: "Reports" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "mt-2 text-gray-600 dark:text-gray-400", children: "Generate and download financial analysis reports" })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(
        "button",
        {
          onClick: () => setShowCreateModal(true),
          className: "btn-primary flex items-center space-x-2",
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(Plus, { className: "h-4 w-4" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "Create Report" })
          ]
        }
      )
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "relative", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Search, { className: "absolute left-3 top-1/2 transform -translate-y-1/2 h-4 w-4 text-gray-400" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "input",
        {
          type: "text",
          placeholder: "Search reports...",
          value: searchTerm,
          onChange: (e) => setSearchTerm(e.target.value),
          className: "input-field pl-10"
        }
      )
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "space-y-4", children: filteredReports.map((report) => /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "card p-6", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center justify-between", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center space-x-3", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "p-2 bg-primary-100 dark:bg-primary-900/20 rounded-lg", children: /* @__PURE__ */ jsxRuntimeExports.jsx(FileBarChart, { className: "h-6 w-6 text-primary-600" }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "text-lg font-semibold text-gray-900 dark:text-white", children: report.name }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: "text-sm text-gray-600 dark:text-gray-400", children: [
            report.type.replace("_", " ").replace(/\b\w/g, (l2) => l2.toUpperCase()),
            "  Created by ",
            report.created_by_email,
            " ",
            new Date(report.created_at).toLocaleDateString()
          ] })
        ] })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(
        "button",
        {
          onClick: () => generateReport(JSON.parse(report.parameters)),
          className: "btn-secondary flex items-center space-x-2",
          disabled: generating,
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(Download, { className: "h-4 w-4" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "Download" })
          ]
        }
      )
    ] }) }, report.id)) }),
    filteredReports.length === 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "text-center py-12", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(FileBarChart, { className: "mx-auto h-12 w-12 text-gray-400" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "mt-2 text-sm font-medium text-gray-900 dark:text-white", children: "No reports" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "mt-1 text-sm text-gray-500 dark:text-gray-400", children: "Create your first financial analysis report." })
    ] }),
    showCreateModal && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center p-4 z-50", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-white dark:bg-gray-800 rounded-lg p-6 w-full max-w-md max-h-[90vh] overflow-y-auto", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: "text-lg font-semibold text-gray-900 dark:text-white mb-4", children: "Create New Report" }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("form", { onSubmit: handleSubmit, className: "space-y-4", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1", children: "Report Name" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "input",
            {
              type: "text",
              required: true,
              value: formData.name,
              onChange: (e) => setFormData({ ...formData, name: e.target.value }),
              className: "input-field",
              placeholder: "Enter report name"
            }
          )
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1", children: "Report Type" }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(
            "select",
            {
              value: formData.type,
              onChange: (e) => setFormData({ ...formData, type: e.target.value }),
              className: "input-field",
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "company_analysis", children: "Company Analysis" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "comparative_analysis", children: "Comparative Analysis" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "inconsistency_report", children: "Data Quality Report" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "financial_summary", children: "Financial Summary" })
              ]
            }
          )
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1", children: "Companies" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "max-h-32 overflow-y-auto border border-gray-300 dark:border-gray-600 rounded-lg p-2", children: companies.map((company) => /* @__PURE__ */ jsxRuntimeExports.jsxs("label", { className: "flex items-center space-x-2 py-1 cursor-pointer", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "input",
              {
                type: "checkbox",
                checked: formData.company_ids.includes(company.id),
                onChange: (e) => {
                  if (e.target.checked) {
                    setFormData({
                      ...formData,
                      company_ids: [...formData.company_ids, company.id]
                    });
                  } else {
                    setFormData({
                      ...formData,
                      company_ids: formData.company_ids.filter((id) => id !== company.id)
                    });
                  }
                },
                className: "rounded border-gray-300 text-primary-600 focus:ring-primary-500"
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-sm text-gray-900 dark:text-white", children: company.name })
          ] }, company.id)) })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1", children: "Export Format" }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(
            "select",
            {
              value: formData.format,
              onChange: (e) => setFormData({ ...formData, format: e.target.value }),
              className: "input-field",
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "excel", children: "Excel (.xlsx)" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "pdf", children: "PDF Report" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "csv", children: "CSV Data" })
              ]
            }
          )
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center space-x-2", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "input",
            {
              type: "checkbox",
              id: "include_inconsistencies",
              checked: formData.include_inconsistencies,
              onChange: (e) => setFormData({ ...formData, include_inconsistencies: e.target.checked }),
              className: "rounded border-gray-300 text-primary-600 focus:ring-primary-500"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx("label", { htmlFor: "include_inconsistencies", className: "text-sm text-gray-700 dark:text-gray-300", children: "Include data quality issues" })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex space-x-3 pt-4", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "button",
            {
              type: "button",
              onClick: () => setShowCreateModal(false),
              className: "btn-secondary flex-1",
              disabled: generating,
              children: "Cancel"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "button",
            {
              type: "submit",
              className: "btn-primary flex-1 disabled:opacity-50",
              disabled: generating || formData.company_ids.length === 0,
              children: generating ? "Generating..." : "Generate Report"
            }
          )
        ] })
      ] })
    ] }) })
  ] });
}
__name(Reports, "Reports");
function AppContent() {
  const { user, loading } = useAuth();
  if (loading) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "min-h-screen flex items-center justify-center", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "animate-spin rounded-full h-32 w-32 border-b-2 border-primary-600" }) });
  }
  if (!user) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Login, {});
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "min-h-screen bg-gray-50 dark:bg-gray-900", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(Navbar, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx("main", { className: "container mx-auto px-4 py-8", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Routes, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "/", element: /* @__PURE__ */ jsxRuntimeExports.jsx(Dashboard, {}) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "/companies", element: /* @__PURE__ */ jsxRuntimeExports.jsx(Companies, {}) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "/statements", element: /* @__PURE__ */ jsxRuntimeExports.jsx(Statements, {}) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "/analytics", element: /* @__PURE__ */ jsxRuntimeExports.jsx(Analytics, {}) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "/reports", element: /* @__PURE__ */ jsxRuntimeExports.jsx(Reports, {}) }),
      user.role === "admin" && /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "/users", element: /* @__PURE__ */ jsxRuntimeExports.jsx(UserManagement, {}) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "*", element: /* @__PURE__ */ jsxRuntimeExports.jsx(Navigate, { to: "/", replace: true }) })
    ] }) })
  ] });
}
__name(AppContent, "AppContent");
function App() {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(BrowserRouter, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(AuthProvider, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(DatabaseProvider, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(AppContent, {}) }) }) });
}
__name(App, "App");
const index = "";
client.createRoot(document.getElementById("root")).render(
  /* @__PURE__ */ jsxRuntimeExports.jsx(React$1.StrictMode, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(App, {}) })
);
export {
  _typeof as _
};
